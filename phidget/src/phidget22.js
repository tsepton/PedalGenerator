/*!
 * Phidget22 JavaScript Library v3.12.3 (https://phidgets.com)
 *  phidget22 release 1.12.20221205
 * Copyright 2017-2022 Phidgets Inc.
 * Licensed under ISC
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.phidget22 = {}));
})(this, (function (exports) { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	var check = function (it) {
	  return it && it.Math == Math && it;
	};
	var global$D =
	  check(typeof globalThis == 'object' && globalThis) ||
	  check(typeof window == 'object' && window) ||
	  check(typeof self == 'object' && self) ||
	  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
	  (function () { return this; })() || Function('return this')();

	var fails$f = function (exec) {
	  try {
	    return !!exec();
	  } catch (error) {
	    return true;
	  }
	};

	var fails$e = fails$f;
	var functionBindNative = !fails$e(function () {
	  var test = (function () {  }).bind();
	  return typeof test != 'function' || test.hasOwnProperty('prototype');
	});

	var NATIVE_BIND$3 = functionBindNative;
	var FunctionPrototype$2 = Function.prototype;
	var apply$2 = FunctionPrototype$2.apply;
	var call$c = FunctionPrototype$2.call;
	var functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND$3 ? call$c.bind(apply$2) : function () {
	  return call$c.apply(apply$2, arguments);
	});

	var NATIVE_BIND$2 = functionBindNative;
	var FunctionPrototype$1 = Function.prototype;
	var bind$6 = FunctionPrototype$1.bind;
	var call$b = FunctionPrototype$1.call;
	var uncurryThis$j = NATIVE_BIND$2 && bind$6.bind(call$b, call$b);
	var functionUncurryThis = NATIVE_BIND$2 ? function (fn) {
	  return fn && uncurryThis$j(fn);
	} : function (fn) {
	  return fn && function () {
	    return call$b.apply(fn, arguments);
	  };
	};

	var isCallable$h = function (argument) {
	  return typeof argument == 'function';
	};

	var objectGetOwnPropertyDescriptor = {};

	var fails$d = fails$f;
	var descriptors = !fails$d(function () {
	  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
	});

	var NATIVE_BIND$1 = functionBindNative;
	var call$a = Function.prototype.call;
	var functionCall = NATIVE_BIND$1 ? call$a.bind(call$a) : function () {
	  return call$a.apply(call$a, arguments);
	};

	var objectPropertyIsEnumerable = {};

	var $propertyIsEnumerable = {}.propertyIsEnumerable;
	var getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;
	var NASHORN_BUG = getOwnPropertyDescriptor$2 && !$propertyIsEnumerable.call({ 1: 2 }, 1);
	objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
	  var descriptor = getOwnPropertyDescriptor$2(this, V);
	  return !!descriptor && descriptor.enumerable;
	} : $propertyIsEnumerable;

	var createPropertyDescriptor$5 = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var uncurryThis$i = functionUncurryThis;
	var toString$7 = uncurryThis$i({}.toString);
	var stringSlice$1 = uncurryThis$i(''.slice);
	var classofRaw$1 = function (it) {
	  return stringSlice$1(toString$7(it), 8, -1);
	};

	var global$C = global$D;
	var uncurryThis$h = functionUncurryThis;
	var fails$c = fails$f;
	var classof$9 = classofRaw$1;
	var Object$5 = global$C.Object;
	var split = uncurryThis$h(''.split);
	var indexedObject = fails$c(function () {
	  return !Object$5('z').propertyIsEnumerable(0);
	}) ? function (it) {
	  return classof$9(it) == 'String' ? split(it, '') : Object$5(it);
	} : Object$5;

	var global$B = global$D;
	var TypeError$f = global$B.TypeError;
	var requireObjectCoercible$4 = function (it) {
	  if (it == undefined) throw TypeError$f("Can't call method on " + it);
	  return it;
	};

	var IndexedObject$1 = indexedObject;
	var requireObjectCoercible$3 = requireObjectCoercible$4;
	var toIndexedObject$5 = function (it) {
	  return IndexedObject$1(requireObjectCoercible$3(it));
	};

	var isCallable$g = isCallable$h;
	var isObject$8 = function (it) {
	  return typeof it == 'object' ? it !== null : isCallable$g(it);
	};

	var path$4 = {};

	var path$3 = path$4;
	var global$A = global$D;
	var isCallable$f = isCallable$h;
	var aFunction = function (variable) {
	  return isCallable$f(variable) ? variable : undefined;
	};
	var getBuiltIn$9 = function (namespace, method) {
	  return arguments.length < 2 ? aFunction(path$3[namespace]) || aFunction(global$A[namespace])
	    : path$3[namespace] && path$3[namespace][method] || global$A[namespace] && global$A[namespace][method];
	};

	var uncurryThis$g = functionUncurryThis;
	var objectIsPrototypeOf = uncurryThis$g({}.isPrototypeOf);

	var getBuiltIn$8 = getBuiltIn$9;
	var engineUserAgent = getBuiltIn$8('navigator', 'userAgent') || '';

	var global$z = global$D;
	var userAgent$3 = engineUserAgent;
	var process$3 = global$z.process;
	var Deno = global$z.Deno;
	var versions = process$3 && process$3.versions || Deno && Deno.version;
	var v8 = versions && versions.v8;
	var match, version;
	if (v8) {
	  match = v8.split('.');
	  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
	}
	if (!version && userAgent$3) {
	  match = userAgent$3.match(/Edge\/(\d+)/);
	  if (!match || match[1] >= 74) {
	    match = userAgent$3.match(/Chrome\/(\d+)/);
	    if (match) version = +match[1];
	  }
	}
	var engineV8Version = version;

	var V8_VERSION$1 = engineV8Version;
	var fails$b = fails$f;
	var nativeSymbol = !!Object.getOwnPropertySymbols && !fails$b(function () {
	  var symbol = Symbol();
	  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
	    !Symbol.sham && V8_VERSION$1 && V8_VERSION$1 < 41;
	});

	var NATIVE_SYMBOL$1 = nativeSymbol;
	var useSymbolAsUid = NATIVE_SYMBOL$1
	  && !Symbol.sham
	  && typeof Symbol.iterator == 'symbol';

	var global$y = global$D;
	var getBuiltIn$7 = getBuiltIn$9;
	var isCallable$e = isCallable$h;
	var isPrototypeOf$8 = objectIsPrototypeOf;
	var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
	var Object$4 = global$y.Object;
	var isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function (it) {
	  return typeof it == 'symbol';
	} : function (it) {
	  var $Symbol = getBuiltIn$7('Symbol');
	  return isCallable$e($Symbol) && isPrototypeOf$8($Symbol.prototype, Object$4(it));
	};

	var global$x = global$D;
	var String$5 = global$x.String;
	var tryToString$4 = function (argument) {
	  try {
	    return String$5(argument);
	  } catch (error) {
	    return 'Object';
	  }
	};

	var global$w = global$D;
	var isCallable$d = isCallable$h;
	var tryToString$3 = tryToString$4;
	var TypeError$e = global$w.TypeError;
	var aCallable$8 = function (argument) {
	  if (isCallable$d(argument)) return argument;
	  throw TypeError$e(tryToString$3(argument) + ' is not a function');
	};

	var aCallable$7 = aCallable$8;
	var getMethod$3 = function (V, P) {
	  var func = V[P];
	  return func == null ? undefined : aCallable$7(func);
	};

	var global$v = global$D;
	var call$9 = functionCall;
	var isCallable$c = isCallable$h;
	var isObject$7 = isObject$8;
	var TypeError$d = global$v.TypeError;
	var ordinaryToPrimitive$1 = function (input, pref) {
	  var fn, val;
	  if (pref === 'string' && isCallable$c(fn = input.toString) && !isObject$7(val = call$9(fn, input))) return val;
	  if (isCallable$c(fn = input.valueOf) && !isObject$7(val = call$9(fn, input))) return val;
	  if (pref !== 'string' && isCallable$c(fn = input.toString) && !isObject$7(val = call$9(fn, input))) return val;
	  throw TypeError$d("Can't convert object to primitive value");
	};

	var shared$3 = {exports: {}};

	var isPure = true;

	var global$u = global$D;
	var defineProperty$1 = Object.defineProperty;
	var setGlobal$1 = function (key, value) {
	  try {
	    defineProperty$1(global$u, key, { value: value, configurable: true, writable: true });
	  } catch (error) {
	    global$u[key] = value;
	  } return value;
	};

	var global$t = global$D;
	var setGlobal = setGlobal$1;
	var SHARED = '__core-js_shared__';
	var store$3 = global$t[SHARED] || setGlobal(SHARED, {});
	var sharedStore = store$3;

	var store$2 = sharedStore;
	(shared$3.exports = function (key, value) {
	  return store$2[key] || (store$2[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: '3.21.1',
	  mode: 'pure' ,
	  copyright: 'Â© 2014-2022 Denis Pushkarev (zloirock.ru)',
	  license: 'https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE',
	  source: 'https://github.com/zloirock/core-js'
	});

	var global$s = global$D;
	var requireObjectCoercible$2 = requireObjectCoercible$4;
	var Object$3 = global$s.Object;
	var toObject$3 = function (argument) {
	  return Object$3(requireObjectCoercible$2(argument));
	};

	var uncurryThis$f = functionUncurryThis;
	var toObject$2 = toObject$3;
	var hasOwnProperty = uncurryThis$f({}.hasOwnProperty);
	var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
	  return hasOwnProperty(toObject$2(it), key);
	};

	var uncurryThis$e = functionUncurryThis;
	var id = 0;
	var postfix = Math.random();
	var toString$6 = uncurryThis$e(1.0.toString);
	var uid$2 = function (key) {
	  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$6(++id + postfix, 36);
	};

	var global$r = global$D;
	var shared$2 = shared$3.exports;
	var hasOwn$a = hasOwnProperty_1;
	var uid$1 = uid$2;
	var NATIVE_SYMBOL = nativeSymbol;
	var USE_SYMBOL_AS_UID = useSymbolAsUid;
	var WellKnownSymbolsStore = shared$2('wks');
	var Symbol$1 = global$r.Symbol;
	var symbolFor = Symbol$1 && Symbol$1['for'];
	var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;
	var wellKnownSymbol$e = function (name) {
	  if (!hasOwn$a(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
	    var description = 'Symbol.' + name;
	    if (NATIVE_SYMBOL && hasOwn$a(Symbol$1, name)) {
	      WellKnownSymbolsStore[name] = Symbol$1[name];
	    } else if (USE_SYMBOL_AS_UID && symbolFor) {
	      WellKnownSymbolsStore[name] = symbolFor(description);
	    } else {
	      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
	    }
	  } return WellKnownSymbolsStore[name];
	};

	var global$q = global$D;
	var call$8 = functionCall;
	var isObject$6 = isObject$8;
	var isSymbol$1 = isSymbol$2;
	var getMethod$2 = getMethod$3;
	var ordinaryToPrimitive = ordinaryToPrimitive$1;
	var wellKnownSymbol$d = wellKnownSymbol$e;
	var TypeError$c = global$q.TypeError;
	var TO_PRIMITIVE = wellKnownSymbol$d('toPrimitive');
	var toPrimitive$1 = function (input, pref) {
	  if (!isObject$6(input) || isSymbol$1(input)) return input;
	  var exoticToPrim = getMethod$2(input, TO_PRIMITIVE);
	  var result;
	  if (exoticToPrim) {
	    if (pref === undefined) pref = 'default';
	    result = call$8(exoticToPrim, input, pref);
	    if (!isObject$6(result) || isSymbol$1(result)) return result;
	    throw TypeError$c("Can't convert object to primitive value");
	  }
	  if (pref === undefined) pref = 'number';
	  return ordinaryToPrimitive(input, pref);
	};

	var toPrimitive = toPrimitive$1;
	var isSymbol = isSymbol$2;
	var toPropertyKey$2 = function (argument) {
	  var key = toPrimitive(argument, 'string');
	  return isSymbol(key) ? key : key + '';
	};

	var global$p = global$D;
	var isObject$5 = isObject$8;
	var document$3 = global$p.document;
	var EXISTS$1 = isObject$5(document$3) && isObject$5(document$3.createElement);
	var documentCreateElement$1 = function (it) {
	  return EXISTS$1 ? document$3.createElement(it) : {};
	};

	var DESCRIPTORS$7 = descriptors;
	var fails$a = fails$f;
	var createElement$1 = documentCreateElement$1;
	var ie8DomDefine = !DESCRIPTORS$7 && !fails$a(function () {
	  return Object.defineProperty(createElement$1('div'), 'a', {
	    get: function () { return 7; }
	  }).a != 7;
	});

	var DESCRIPTORS$6 = descriptors;
	var call$7 = functionCall;
	var propertyIsEnumerableModule = objectPropertyIsEnumerable;
	var createPropertyDescriptor$4 = createPropertyDescriptor$5;
	var toIndexedObject$4 = toIndexedObject$5;
	var toPropertyKey$1 = toPropertyKey$2;
	var hasOwn$9 = hasOwnProperty_1;
	var IE8_DOM_DEFINE$1 = ie8DomDefine;
	var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
	objectGetOwnPropertyDescriptor.f = DESCRIPTORS$6 ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {
	  O = toIndexedObject$4(O);
	  P = toPropertyKey$1(P);
	  if (IE8_DOM_DEFINE$1) try {
	    return $getOwnPropertyDescriptor$1(O, P);
	  } catch (error) {  }
	  if (hasOwn$9(O, P)) return createPropertyDescriptor$4(!call$7(propertyIsEnumerableModule.f, O, P), O[P]);
	};

	var fails$9 = fails$f;
	var isCallable$b = isCallable$h;
	var replacement = /#|\.prototype\./;
	var isForced$2 = function (feature, detection) {
	  var value = data[normalize(feature)];
	  return value == POLYFILL ? true
	    : value == NATIVE ? false
	    : isCallable$b(detection) ? fails$9(detection)
	    : !!detection;
	};
	var normalize = isForced$2.normalize = function (string) {
	  return String(string).replace(replacement, '.').toLowerCase();
	};
	var data = isForced$2.data = {};
	var NATIVE = isForced$2.NATIVE = 'N';
	var POLYFILL = isForced$2.POLYFILL = 'P';
	var isForced_1 = isForced$2;

	var uncurryThis$d = functionUncurryThis;
	var aCallable$6 = aCallable$8;
	var NATIVE_BIND = functionBindNative;
	var bind$5 = uncurryThis$d(uncurryThis$d.bind);
	var functionBindContext = function (fn, that) {
	  aCallable$6(fn);
	  return that === undefined ? fn : NATIVE_BIND ? bind$5(fn, that) : function () {
	    return fn.apply(that, arguments);
	  };
	};

	var objectDefineProperty = {};

	var DESCRIPTORS$5 = descriptors;
	var fails$8 = fails$f;
	var v8PrototypeDefineBug = DESCRIPTORS$5 && fails$8(function () {
	  return Object.defineProperty(function () {  }, 'prototype', {
	    value: 42,
	    writable: false
	  }).prototype != 42;
	});

	var global$o = global$D;
	var isObject$4 = isObject$8;
	var String$4 = global$o.String;
	var TypeError$b = global$o.TypeError;
	var anObject$b = function (argument) {
	  if (isObject$4(argument)) return argument;
	  throw TypeError$b(String$4(argument) + ' is not an object');
	};

	var global$n = global$D;
	var DESCRIPTORS$4 = descriptors;
	var IE8_DOM_DEFINE = ie8DomDefine;
	var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
	var anObject$a = anObject$b;
	var toPropertyKey = toPropertyKey$2;
	var TypeError$a = global$n.TypeError;
	var $defineProperty = Object.defineProperty;
	var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
	var ENUMERABLE = 'enumerable';
	var CONFIGURABLE$1 = 'configurable';
	var WRITABLE = 'writable';
	objectDefineProperty.f = DESCRIPTORS$4 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {
	  anObject$a(O);
	  P = toPropertyKey(P);
	  anObject$a(Attributes);
	  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
	    var current = $getOwnPropertyDescriptor(O, P);
	    if (current && current[WRITABLE]) {
	      O[P] = Attributes.value;
	      Attributes = {
	        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
	        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
	        writable: false
	      };
	    }
	  } return $defineProperty(O, P, Attributes);
	} : $defineProperty : function defineProperty(O, P, Attributes) {
	  anObject$a(O);
	  P = toPropertyKey(P);
	  anObject$a(Attributes);
	  if (IE8_DOM_DEFINE) try {
	    return $defineProperty(O, P, Attributes);
	  } catch (error) {  }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError$a('Accessors not supported');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};

	var DESCRIPTORS$3 = descriptors;
	var definePropertyModule$3 = objectDefineProperty;
	var createPropertyDescriptor$3 = createPropertyDescriptor$5;
	var createNonEnumerableProperty$7 = DESCRIPTORS$3 ? function (object, key, value) {
	  return definePropertyModule$3.f(object, key, createPropertyDescriptor$3(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var global$m = global$D;
	var apply$1 = functionApply;
	var uncurryThis$c = functionUncurryThis;
	var isCallable$a = isCallable$h;
	var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
	var isForced$1 = isForced_1;
	var path$2 = path$4;
	var bind$4 = functionBindContext;
	var createNonEnumerableProperty$6 = createNonEnumerableProperty$7;
	var hasOwn$8 = hasOwnProperty_1;
	var wrapConstructor = function (NativeConstructor) {
	  var Wrapper = function (a, b, c) {
	    if (this instanceof Wrapper) {
	      switch (arguments.length) {
	        case 0: return new NativeConstructor();
	        case 1: return new NativeConstructor(a);
	        case 2: return new NativeConstructor(a, b);
	      } return new NativeConstructor(a, b, c);
	    } return apply$1(NativeConstructor, this, arguments);
	  };
	  Wrapper.prototype = NativeConstructor.prototype;
	  return Wrapper;
	};
	var _export = function (options, source) {
	  var TARGET = options.target;
	  var GLOBAL = options.global;
	  var STATIC = options.stat;
	  var PROTO = options.proto;
	  var nativeSource = GLOBAL ? global$m : STATIC ? global$m[TARGET] : (global$m[TARGET] || {}).prototype;
	  var target = GLOBAL ? path$2 : path$2[TARGET] || createNonEnumerableProperty$6(path$2, TARGET, {})[TARGET];
	  var targetPrototype = target.prototype;
	  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
	  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;
	  for (key in source) {
	    FORCED = isForced$1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
	    USE_NATIVE = !FORCED && nativeSource && hasOwn$8(nativeSource, key);
	    targetProperty = target[key];
	    if (USE_NATIVE) if (options.noTargetGet) {
	      descriptor = getOwnPropertyDescriptor$1(nativeSource, key);
	      nativeProperty = descriptor && descriptor.value;
	    } else nativeProperty = nativeSource[key];
	    sourceProperty = (USE_NATIVE && nativeProperty) ? nativeProperty : source[key];
	    if (USE_NATIVE && typeof targetProperty == typeof sourceProperty) continue;
	    if (options.bind && USE_NATIVE) resultProperty = bind$4(sourceProperty, global$m);
	    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);
	    else if (PROTO && isCallable$a(sourceProperty)) resultProperty = uncurryThis$c(sourceProperty);
	    else resultProperty = sourceProperty;
	    if (options.sham || (sourceProperty && sourceProperty.sham) || (targetProperty && targetProperty.sham)) {
	      createNonEnumerableProperty$6(resultProperty, 'sham', true);
	    }
	    createNonEnumerableProperty$6(target, key, resultProperty);
	    if (PROTO) {
	      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';
	      if (!hasOwn$8(path$2, VIRTUAL_PROTOTYPE)) {
	        createNonEnumerableProperty$6(path$2, VIRTUAL_PROTOTYPE, {});
	      }
	      createNonEnumerableProperty$6(path$2[VIRTUAL_PROTOTYPE], key, sourceProperty);
	      if (options.real && targetPrototype && !targetPrototype[key]) {
	        createNonEnumerableProperty$6(targetPrototype, key, sourceProperty);
	      }
	    }
	  }
	};

	var shared$1 = shared$3.exports;
	var uid = uid$2;
	var keys = shared$1('keys');
	var sharedKey$3 = function (key) {
	  return keys[key] || (keys[key] = uid(key));
	};

	var fails$7 = fails$f;
	var correctPrototypeGetter = !fails$7(function () {
	  function F() {  }
	  F.prototype.constructor = null;
	  return Object.getPrototypeOf(new F()) !== F.prototype;
	});

	var global$l = global$D;
	var hasOwn$7 = hasOwnProperty_1;
	var isCallable$9 = isCallable$h;
	var toObject$1 = toObject$3;
	var sharedKey$2 = sharedKey$3;
	var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
	var IE_PROTO$1 = sharedKey$2('IE_PROTO');
	var Object$2 = global$l.Object;
	var ObjectPrototype = Object$2.prototype;
	var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? Object$2.getPrototypeOf : function (O) {
	  var object = toObject$1(O);
	  if (hasOwn$7(object, IE_PROTO$1)) return object[IE_PROTO$1];
	  var constructor = object.constructor;
	  if (isCallable$9(constructor) && object instanceof constructor) {
	    return constructor.prototype;
	  } return object instanceof Object$2 ? ObjectPrototype : null;
	};

	var global$k = global$D;
	var isCallable$8 = isCallable$h;
	var String$3 = global$k.String;
	var TypeError$9 = global$k.TypeError;
	var aPossiblePrototype$1 = function (argument) {
	  if (typeof argument == 'object' || isCallable$8(argument)) return argument;
	  throw TypeError$9("Can't set " + String$3(argument) + ' as a prototype');
	};

	var uncurryThis$b = functionUncurryThis;
	var anObject$9 = anObject$b;
	var aPossiblePrototype = aPossiblePrototype$1;
	var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
	  var CORRECT_SETTER = false;
	  var test = {};
	  var setter;
	  try {
	    setter = uncurryThis$b(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
	    setter(test, []);
	    CORRECT_SETTER = test instanceof Array;
	  } catch (error) {  }
	  return function setPrototypeOf(O, proto) {
	    anObject$9(O);
	    aPossiblePrototype(proto);
	    if (CORRECT_SETTER) setter(O, proto);
	    else O.__proto__ = proto;
	    return O;
	  };
	}() : undefined);

	var objectGetOwnPropertyNames = {};

	var ceil = Math.ceil;
	var floor = Math.floor;
	var toIntegerOrInfinity$3 = function (argument) {
	  var number = +argument;
	  return number !== number || number === 0 ? 0 : (number > 0 ? floor : ceil)(number);
	};

	var toIntegerOrInfinity$2 = toIntegerOrInfinity$3;
	var max = Math.max;
	var min$1 = Math.min;
	var toAbsoluteIndex$1 = function (index, length) {
	  var integer = toIntegerOrInfinity$2(index);
	  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
	};

	var toIntegerOrInfinity$1 = toIntegerOrInfinity$3;
	var min = Math.min;
	var toLength$1 = function (argument) {
	  return argument > 0 ? min(toIntegerOrInfinity$1(argument), 0x1FFFFFFFFFFFFF) : 0;
	};

	var toLength = toLength$1;
	var lengthOfArrayLike$3 = function (obj) {
	  return toLength(obj.length);
	};

	var toIndexedObject$3 = toIndexedObject$5;
	var toAbsoluteIndex = toAbsoluteIndex$1;
	var lengthOfArrayLike$2 = lengthOfArrayLike$3;
	var createMethod$3 = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIndexedObject$3($this);
	    var length = lengthOfArrayLike$2(O);
	    var index = toAbsoluteIndex(fromIndex, length);
	    var value;
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      if (value != value) return true;
	    } else for (;length > index; index++) {
	      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};
	var arrayIncludes = {
	  includes: createMethod$3(true),
	  indexOf: createMethod$3(false)
	};

	var hiddenKeys$4 = {};

	var uncurryThis$a = functionUncurryThis;
	var hasOwn$6 = hasOwnProperty_1;
	var toIndexedObject$2 = toIndexedObject$5;
	var indexOf = arrayIncludes.indexOf;
	var hiddenKeys$3 = hiddenKeys$4;
	var push$1 = uncurryThis$a([].push);
	var objectKeysInternal = function (object, names) {
	  var O = toIndexedObject$2(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) !hasOwn$6(hiddenKeys$3, key) && hasOwn$6(O, key) && push$1(result, key);
	  while (names.length > i) if (hasOwn$6(O, key = names[i++])) {
	    ~indexOf(result, key) || push$1(result, key);
	  }
	  return result;
	};

	var enumBugKeys$3 = [
	  'constructor',
	  'hasOwnProperty',
	  'isPrototypeOf',
	  'propertyIsEnumerable',
	  'toLocaleString',
	  'toString',
	  'valueOf'
	];

	var internalObjectKeys$1 = objectKeysInternal;
	var enumBugKeys$2 = enumBugKeys$3;
	var hiddenKeys$2 = enumBugKeys$2.concat('length', 'prototype');
	objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return internalObjectKeys$1(O, hiddenKeys$2);
	};

	var objectGetOwnPropertySymbols = {};

	objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;

	var getBuiltIn$6 = getBuiltIn$9;
	var uncurryThis$9 = functionUncurryThis;
	var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
	var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
	var anObject$8 = anObject$b;
	var concat = uncurryThis$9([].concat);
	var ownKeys$1 = getBuiltIn$6('Reflect', 'ownKeys') || function ownKeys(it) {
	  var keys = getOwnPropertyNamesModule.f(anObject$8(it));
	  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
	  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
	};

	var hasOwn$5 = hasOwnProperty_1;
	var ownKeys = ownKeys$1;
	var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
	var definePropertyModule$2 = objectDefineProperty;
	var copyConstructorProperties$1 = function (target, source, exceptions) {
	  var keys = ownKeys(source);
	  var defineProperty = definePropertyModule$2.f;
	  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    if (!hasOwn$5(target, key) && !(exceptions && hasOwn$5(exceptions, key))) {
	      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
	    }
	  }
	};

	var objectDefineProperties = {};

	var internalObjectKeys = objectKeysInternal;
	var enumBugKeys$1 = enumBugKeys$3;
	var objectKeys$1 = Object.keys || function keys(O) {
	  return internalObjectKeys(O, enumBugKeys$1);
	};

	var DESCRIPTORS$2 = descriptors;
	var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
	var definePropertyModule$1 = objectDefineProperty;
	var anObject$7 = anObject$b;
	var toIndexedObject$1 = toIndexedObject$5;
	var objectKeys = objectKeys$1;
	objectDefineProperties.f = DESCRIPTORS$2 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject$7(O);
	  var props = toIndexedObject$1(Properties);
	  var keys = objectKeys(Properties);
	  var length = keys.length;
	  var index = 0;
	  var key;
	  while (length > index) definePropertyModule$1.f(O, key = keys[index++], props[key]);
	  return O;
	};

	var getBuiltIn$5 = getBuiltIn$9;
	var html$2 = getBuiltIn$5('document', 'documentElement');

	var anObject$6 = anObject$b;
	var definePropertiesModule = objectDefineProperties;
	var enumBugKeys = enumBugKeys$3;
	var hiddenKeys$1 = hiddenKeys$4;
	var html$1 = html$2;
	var documentCreateElement = documentCreateElement$1;
	var sharedKey$1 = sharedKey$3;
	var GT = '>';
	var LT = '<';
	var PROTOTYPE = 'prototype';
	var SCRIPT = 'script';
	var IE_PROTO = sharedKey$1('IE_PROTO');
	var EmptyConstructor = function () {  };
	var scriptTag = function (content) {
	  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
	};
	var NullProtoObjectViaActiveX = function (activeXDocument) {
	  activeXDocument.write(scriptTag(''));
	  activeXDocument.close();
	  var temp = activeXDocument.parentWindow.Object;
	  activeXDocument = null;
	  return temp;
	};
	var NullProtoObjectViaIFrame = function () {
	  var iframe = documentCreateElement('iframe');
	  var JS = 'java' + SCRIPT + ':';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  html$1.appendChild(iframe);
	  iframe.src = String(JS);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(scriptTag('document.F=Object'));
	  iframeDocument.close();
	  return iframeDocument.F;
	};
	var activeXDocument;
	var NullProtoObject = function () {
	  try {
	    activeXDocument = new ActiveXObject('htmlfile');
	  } catch (error) {  }
	  NullProtoObject = typeof document != 'undefined'
	    ? document.domain && activeXDocument
	      ? NullProtoObjectViaActiveX(activeXDocument)
	      : NullProtoObjectViaIFrame()
	    : NullProtoObjectViaActiveX(activeXDocument);
	  var length = enumBugKeys.length;
	  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
	  return NullProtoObject();
	};
	hiddenKeys$1[IE_PROTO] = true;
	var objectCreate = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    EmptyConstructor[PROTOTYPE] = anObject$6(O);
	    result = new EmptyConstructor();
	    EmptyConstructor[PROTOTYPE] = null;
	    result[IE_PROTO] = O;
	  } else result = NullProtoObject();
	  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
	};

	var uncurryThis$8 = functionUncurryThis;
	var replace$1 = uncurryThis$8(''.replace);
	var TEST = (function (arg) { return String(Error(arg).stack); })('zxcasd');
	var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
	var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
	var clearErrorStack$1 = function (stack, dropEntries) {
	  if (IS_V8_OR_CHAKRA_STACK && typeof stack == 'string') {
	    while (dropEntries--) stack = replace$1(stack, V8_OR_CHAKRA_STACK_ENTRY, '');
	  } return stack;
	};

	var isObject$3 = isObject$8;
	var createNonEnumerableProperty$5 = createNonEnumerableProperty$7;
	var installErrorCause$1 = function (O, options) {
	  if (isObject$3(options) && 'cause' in options) {
	    createNonEnumerableProperty$5(O, 'cause', options.cause);
	  }
	};

	var iterators = {};

	var wellKnownSymbol$c = wellKnownSymbol$e;
	var Iterators$5 = iterators;
	var ITERATOR$4 = wellKnownSymbol$c('iterator');
	var ArrayPrototype$3 = Array.prototype;
	var isArrayIteratorMethod$1 = function (it) {
	  return it !== undefined && (Iterators$5.Array === it || ArrayPrototype$3[ITERATOR$4] === it);
	};

	var wellKnownSymbol$b = wellKnownSymbol$e;
	var TO_STRING_TAG$4 = wellKnownSymbol$b('toStringTag');
	var test$1 = {};
	test$1[TO_STRING_TAG$4] = 'z';
	var toStringTagSupport = String(test$1) === '[object z]';

	var global$j = global$D;
	var TO_STRING_TAG_SUPPORT$2 = toStringTagSupport;
	var isCallable$7 = isCallable$h;
	var classofRaw = classofRaw$1;
	var wellKnownSymbol$a = wellKnownSymbol$e;
	var TO_STRING_TAG$3 = wellKnownSymbol$a('toStringTag');
	var Object$1 = global$j.Object;
	var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (error) {  }
	};
	var classof$8 = TO_STRING_TAG_SUPPORT$2 ? classofRaw : function (it) {
	  var O, tag, result;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    : typeof (tag = tryGet(O = Object$1(it), TO_STRING_TAG$3)) == 'string' ? tag
	    : CORRECT_ARGUMENTS ? classofRaw(O)
	    : (result = classofRaw(O)) == 'Object' && isCallable$7(O.callee) ? 'Arguments' : result;
	};

	var classof$7 = classof$8;
	var getMethod$1 = getMethod$3;
	var Iterators$4 = iterators;
	var wellKnownSymbol$9 = wellKnownSymbol$e;
	var ITERATOR$3 = wellKnownSymbol$9('iterator');
	var getIteratorMethod$2 = function (it) {
	  if (it != undefined) return getMethod$1(it, ITERATOR$3)
	    || getMethod$1(it, '@@iterator')
	    || Iterators$4[classof$7(it)];
	};

	var global$i = global$D;
	var call$6 = functionCall;
	var aCallable$5 = aCallable$8;
	var anObject$5 = anObject$b;
	var tryToString$2 = tryToString$4;
	var getIteratorMethod$1 = getIteratorMethod$2;
	var TypeError$8 = global$i.TypeError;
	var getIterator$1 = function (argument, usingIterator) {
	  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$1(argument) : usingIterator;
	  if (aCallable$5(iteratorMethod)) return anObject$5(call$6(iteratorMethod, argument));
	  throw TypeError$8(tryToString$2(argument) + ' is not iterable');
	};

	var call$5 = functionCall;
	var anObject$4 = anObject$b;
	var getMethod = getMethod$3;
	var iteratorClose$1 = function (iterator, kind, value) {
	  var innerResult, innerError;
	  anObject$4(iterator);
	  try {
	    innerResult = getMethod(iterator, 'return');
	    if (!innerResult) {
	      if (kind === 'throw') throw value;
	      return value;
	    }
	    innerResult = call$5(innerResult, iterator);
	  } catch (error) {
	    innerError = true;
	    innerResult = error;
	  }
	  if (kind === 'throw') throw value;
	  if (innerError) throw innerResult;
	  anObject$4(innerResult);
	  return value;
	};

	var global$h = global$D;
	var bind$3 = functionBindContext;
	var call$4 = functionCall;
	var anObject$3 = anObject$b;
	var tryToString$1 = tryToString$4;
	var isArrayIteratorMethod = isArrayIteratorMethod$1;
	var lengthOfArrayLike$1 = lengthOfArrayLike$3;
	var isPrototypeOf$7 = objectIsPrototypeOf;
	var getIterator = getIterator$1;
	var getIteratorMethod = getIteratorMethod$2;
	var iteratorClose = iteratorClose$1;
	var TypeError$7 = global$h.TypeError;
	var Result = function (stopped, result) {
	  this.stopped = stopped;
	  this.result = result;
	};
	var ResultPrototype = Result.prototype;
	var iterate$4 = function (iterable, unboundFunction, options) {
	  var that = options && options.that;
	  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
	  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
	  var INTERRUPTED = !!(options && options.INTERRUPTED);
	  var fn = bind$3(unboundFunction, that);
	  var iterator, iterFn, index, length, result, next, step;
	  var stop = function (condition) {
	    if (iterator) iteratorClose(iterator, 'normal', condition);
	    return new Result(true, condition);
	  };
	  var callFn = function (value) {
	    if (AS_ENTRIES) {
	      anObject$3(value);
	      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
	    } return INTERRUPTED ? fn(value, stop) : fn(value);
	  };
	  if (IS_ITERATOR) {
	    iterator = iterable;
	  } else {
	    iterFn = getIteratorMethod(iterable);
	    if (!iterFn) throw TypeError$7(tryToString$1(iterable) + ' is not iterable');
	    if (isArrayIteratorMethod(iterFn)) {
	      for (index = 0, length = lengthOfArrayLike$1(iterable); length > index; index++) {
	        result = callFn(iterable[index]);
	        if (result && isPrototypeOf$7(ResultPrototype, result)) return result;
	      } return new Result(false);
	    }
	    iterator = getIterator(iterable, iterFn);
	  }
	  next = iterator.next;
	  while (!(step = call$4(next, iterator)).done) {
	    try {
	      result = callFn(step.value);
	    } catch (error) {
	      iteratorClose(iterator, 'throw', error);
	    }
	    if (typeof result == 'object' && result && isPrototypeOf$7(ResultPrototype, result)) return result;
	  } return new Result(false);
	};

	var global$g = global$D;
	var classof$6 = classof$8;
	var String$2 = global$g.String;
	var toString$5 = function (argument) {
	  if (classof$6(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
	  return String$2(argument);
	};

	var toString$4 = toString$5;
	var normalizeStringArgument$1 = function (argument, $default) {
	  return argument === undefined ? arguments.length < 2 ? '' : $default : toString$4(argument);
	};

	var fails$6 = fails$f;
	var createPropertyDescriptor$2 = createPropertyDescriptor$5;
	var errorStackInstallable = !fails$6(function () {
	  var error = Error('a');
	  if (!('stack' in error)) return true;
	  Object.defineProperty(error, 'stack', createPropertyDescriptor$2(1, 7));
	  return error.stack !== 7;
	});

	var $$8 = _export;
	var global$f = global$D;
	var isPrototypeOf$6 = objectIsPrototypeOf;
	var getPrototypeOf$2 = objectGetPrototypeOf;
	var setPrototypeOf = objectSetPrototypeOf;
	var copyConstructorProperties = copyConstructorProperties$1;
	var create$2 = objectCreate;
	var createNonEnumerableProperty$4 = createNonEnumerableProperty$7;
	var createPropertyDescriptor$1 = createPropertyDescriptor$5;
	var clearErrorStack = clearErrorStack$1;
	var installErrorCause = installErrorCause$1;
	var iterate$3 = iterate$4;
	var normalizeStringArgument = normalizeStringArgument$1;
	var wellKnownSymbol$8 = wellKnownSymbol$e;
	var ERROR_STACK_INSTALLABLE = errorStackInstallable;
	var TO_STRING_TAG$2 = wellKnownSymbol$8('toStringTag');
	var Error$1 = global$f.Error;
	var push = [].push;
	var $AggregateError = function AggregateError(errors, message ) {
	  var options = arguments.length > 2 ? arguments[2] : undefined;
	  var isInstance = isPrototypeOf$6(AggregateErrorPrototype, this);
	  var that;
	  if (setPrototypeOf) {
	    that = setPrototypeOf(new Error$1(), isInstance ? getPrototypeOf$2(this) : AggregateErrorPrototype);
	  } else {
	    that = isInstance ? this : create$2(AggregateErrorPrototype);
	    createNonEnumerableProperty$4(that, TO_STRING_TAG$2, 'Error');
	  }
	  if (message !== undefined) createNonEnumerableProperty$4(that, 'message', normalizeStringArgument(message));
	  if (ERROR_STACK_INSTALLABLE) createNonEnumerableProperty$4(that, 'stack', clearErrorStack(that.stack, 1));
	  installErrorCause(that, options);
	  var errorsArray = [];
	  iterate$3(errors, push, { that: errorsArray });
	  createNonEnumerableProperty$4(that, 'errors', errorsArray);
	  return that;
	};
	if (setPrototypeOf) setPrototypeOf($AggregateError, Error$1);
	else copyConstructorProperties($AggregateError, Error$1, { name: true });
	var AggregateErrorPrototype = $AggregateError.prototype = create$2(Error$1.prototype, {
	  constructor: createPropertyDescriptor$1(1, $AggregateError),
	  message: createPropertyDescriptor$1(1, ''),
	  name: createPropertyDescriptor$1(1, 'AggregateError')
	});
	$$8({ global: true }, {
	  AggregateError: $AggregateError
	});

	var uncurryThis$7 = functionUncurryThis;
	var isCallable$6 = isCallable$h;
	var store$1 = sharedStore;
	var functionToString = uncurryThis$7(Function.toString);
	if (!isCallable$6(store$1.inspectSource)) {
	  store$1.inspectSource = function (it) {
	    return functionToString(it);
	  };
	}
	var inspectSource$3 = store$1.inspectSource;

	var global$e = global$D;
	var isCallable$5 = isCallable$h;
	var inspectSource$2 = inspectSource$3;
	var WeakMap$1 = global$e.WeakMap;
	var nativeWeakMap = isCallable$5(WeakMap$1) && /native code/.test(inspectSource$2(WeakMap$1));

	var NATIVE_WEAK_MAP = nativeWeakMap;
	var global$d = global$D;
	var uncurryThis$6 = functionUncurryThis;
	var isObject$2 = isObject$8;
	var createNonEnumerableProperty$3 = createNonEnumerableProperty$7;
	var hasOwn$4 = hasOwnProperty_1;
	var shared = sharedStore;
	var sharedKey = sharedKey$3;
	var hiddenKeys = hiddenKeys$4;
	var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
	var TypeError$6 = global$d.TypeError;
	var WeakMap = global$d.WeakMap;
	var set$1, get, has;
	var enforce = function (it) {
	  return has(it) ? get(it) : set$1(it, {});
	};
	var getterFor = function (TYPE) {
	  return function (it) {
	    var state;
	    if (!isObject$2(it) || (state = get(it)).type !== TYPE) {
	      throw TypeError$6('Incompatible receiver, ' + TYPE + ' required');
	    } return state;
	  };
	};
	if (NATIVE_WEAK_MAP || shared.state) {
	  var store = shared.state || (shared.state = new WeakMap());
	  var wmget = uncurryThis$6(store.get);
	  var wmhas = uncurryThis$6(store.has);
	  var wmset = uncurryThis$6(store.set);
	  set$1 = function (it, metadata) {
	    if (wmhas(store, it)) throw new TypeError$6(OBJECT_ALREADY_INITIALIZED);
	    metadata.facade = it;
	    wmset(store, it, metadata);
	    return metadata;
	  };
	  get = function (it) {
	    return wmget(store, it) || {};
	  };
	  has = function (it) {
	    return wmhas(store, it);
	  };
	} else {
	  var STATE = sharedKey('state');
	  hiddenKeys[STATE] = true;
	  set$1 = function (it, metadata) {
	    if (hasOwn$4(it, STATE)) throw new TypeError$6(OBJECT_ALREADY_INITIALIZED);
	    metadata.facade = it;
	    createNonEnumerableProperty$3(it, STATE, metadata);
	    return metadata;
	  };
	  get = function (it) {
	    return hasOwn$4(it, STATE) ? it[STATE] : {};
	  };
	  has = function (it) {
	    return hasOwn$4(it, STATE);
	  };
	}
	var internalState = {
	  set: set$1,
	  get: get,
	  has: has,
	  enforce: enforce,
	  getterFor: getterFor
	};

	var DESCRIPTORS$1 = descriptors;
	var hasOwn$3 = hasOwnProperty_1;
	var FunctionPrototype = Function.prototype;
	var getDescriptor = DESCRIPTORS$1 && Object.getOwnPropertyDescriptor;
	var EXISTS = hasOwn$3(FunctionPrototype, 'name');
	var PROPER = EXISTS && (function something() {  }).name === 'something';
	var CONFIGURABLE = EXISTS && (!DESCRIPTORS$1 || (DESCRIPTORS$1 && getDescriptor(FunctionPrototype, 'name').configurable));
	var functionName = {
	  EXISTS: EXISTS,
	  PROPER: PROPER,
	  CONFIGURABLE: CONFIGURABLE
	};

	var createNonEnumerableProperty$2 = createNonEnumerableProperty$7;
	var redefine$3 = function (target, key, value, options) {
	  if (options && options.enumerable) target[key] = value;
	  else createNonEnumerableProperty$2(target, key, value);
	};

	var fails$5 = fails$f;
	var isCallable$4 = isCallable$h;
	var create$1 = objectCreate;
	var getPrototypeOf$1 = objectGetPrototypeOf;
	var redefine$2 = redefine$3;
	var wellKnownSymbol$7 = wellKnownSymbol$e;
	var ITERATOR$2 = wellKnownSymbol$7('iterator');
	var BUGGY_SAFARI_ITERATORS$1 = false;
	var IteratorPrototype$1, PrototypeOfArrayIteratorPrototype, arrayIterator;
	if ([].keys) {
	  arrayIterator = [].keys();
	  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;
	  else {
	    PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));
	    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$1 = PrototypeOfArrayIteratorPrototype;
	  }
	}
	var NEW_ITERATOR_PROTOTYPE = IteratorPrototype$1 == undefined || fails$5(function () {
	  var test = {};
	  return IteratorPrototype$1[ITERATOR$2].call(test) !== test;
	});
	if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$1 = {};
	else IteratorPrototype$1 = create$1(IteratorPrototype$1);
	if (!isCallable$4(IteratorPrototype$1[ITERATOR$2])) {
	  redefine$2(IteratorPrototype$1, ITERATOR$2, function () {
	    return this;
	  });
	}
	var iteratorsCore = {
	  IteratorPrototype: IteratorPrototype$1,
	  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
	};

	var TO_STRING_TAG_SUPPORT$1 = toStringTagSupport;
	var classof$5 = classof$8;
	var objectToString = TO_STRING_TAG_SUPPORT$1 ? {}.toString : function toString() {
	  return '[object ' + classof$5(this) + ']';
	};

	var TO_STRING_TAG_SUPPORT = toStringTagSupport;
	var defineProperty = objectDefineProperty.f;
	var createNonEnumerableProperty$1 = createNonEnumerableProperty$7;
	var hasOwn$2 = hasOwnProperty_1;
	var toString$3 = objectToString;
	var wellKnownSymbol$6 = wellKnownSymbol$e;
	var TO_STRING_TAG$1 = wellKnownSymbol$6('toStringTag');
	var setToStringTag$3 = function (it, TAG, STATIC, SET_METHOD) {
	  if (it) {
	    var target = STATIC ? it : it.prototype;
	    if (!hasOwn$2(target, TO_STRING_TAG$1)) {
	      defineProperty(target, TO_STRING_TAG$1, { configurable: true, value: TAG });
	    }
	    if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {
	      createNonEnumerableProperty$1(target, 'toString', toString$3);
	    }
	  }
	};

	var IteratorPrototype = iteratorsCore.IteratorPrototype;
	var create = objectCreate;
	var createPropertyDescriptor = createPropertyDescriptor$5;
	var setToStringTag$2 = setToStringTag$3;
	var Iterators$3 = iterators;
	var returnThis$1 = function () { return this; };
	var createIteratorConstructor$1 = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
	  var TO_STRING_TAG = NAME + ' Iterator';
	  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
	  setToStringTag$2(IteratorConstructor, TO_STRING_TAG, false, true);
	  Iterators$3[TO_STRING_TAG] = returnThis$1;
	  return IteratorConstructor;
	};

	var $$7 = _export;
	var call$3 = functionCall;
	var FunctionName = functionName;
	var createIteratorConstructor = createIteratorConstructor$1;
	var getPrototypeOf = objectGetPrototypeOf;
	var setToStringTag$1 = setToStringTag$3;
	var redefine$1 = redefine$3;
	var wellKnownSymbol$5 = wellKnownSymbol$e;
	var Iterators$2 = iterators;
	var IteratorsCore = iteratorsCore;
	var PROPER_FUNCTION_NAME$1 = FunctionName.PROPER;
	var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
	var ITERATOR$1 = wellKnownSymbol$5('iterator');
	var KEYS = 'keys';
	var VALUES = 'values';
	var ENTRIES = 'entries';
	var returnThis = function () { return this; };
	var defineIterator$2 = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
	  createIteratorConstructor(IteratorConstructor, NAME, next);
	  var getIterationMethod = function (KIND) {
	    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
	    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
	    switch (KIND) {
	      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
	      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
	      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
	    } return function () { return new IteratorConstructor(this); };
	  };
	  var TO_STRING_TAG = NAME + ' Iterator';
	  var INCORRECT_VALUES_NAME = false;
	  var IterablePrototype = Iterable.prototype;
	  var nativeIterator = IterablePrototype[ITERATOR$1]
	    || IterablePrototype['@@iterator']
	    || DEFAULT && IterablePrototype[DEFAULT];
	  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
	  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
	  var CurrentIteratorPrototype, methods, KEY;
	  if (anyNativeIterator) {
	    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
	    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
	      setToStringTag$1(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
	      Iterators$2[TO_STRING_TAG] = returnThis;
	    }
	  }
	  if (PROPER_FUNCTION_NAME$1 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
	    {
	      INCORRECT_VALUES_NAME = true;
	      defaultIterator = function values() { return call$3(nativeIterator, this); };
	    }
	  }
	  if (DEFAULT) {
	    methods = {
	      values: getIterationMethod(VALUES),
	      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
	      entries: getIterationMethod(ENTRIES)
	    };
	    if (FORCED) for (KEY in methods) {
	      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
	        redefine$1(IterablePrototype, KEY, methods[KEY]);
	      }
	    } else $$7({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
	  }
	  if ((FORCED) && IterablePrototype[ITERATOR$1] !== defaultIterator) {
	    redefine$1(IterablePrototype, ITERATOR$1, defaultIterator, { name: DEFAULT });
	  }
	  Iterators$2[NAME] = defaultIterator;
	  return methods;
	};

	var toIndexedObject = toIndexedObject$5;
	var Iterators$1 = iterators;
	var InternalStateModule$2 = internalState;
	objectDefineProperty.f;
	var defineIterator$1 = defineIterator$2;
	var ARRAY_ITERATOR = 'Array Iterator';
	var setInternalState$2 = InternalStateModule$2.set;
	var getInternalState$2 = InternalStateModule$2.getterFor(ARRAY_ITERATOR);
	defineIterator$1(Array, 'Array', function (iterated, kind) {
	  setInternalState$2(this, {
	    type: ARRAY_ITERATOR,
	    target: toIndexedObject(iterated),
	    index: 0,
	    kind: kind
	  });
	}, function () {
	  var state = getInternalState$2(this);
	  var target = state.target;
	  var kind = state.kind;
	  var index = state.index++;
	  if (!target || index >= target.length) {
	    state.target = undefined;
	    return { value: undefined, done: true };
	  }
	  if (kind == 'keys') return { value: index, done: false };
	  if (kind == 'values') return { value: target[index], done: false };
	  return { value: [index, target[index]], done: false };
	}, 'values');
	Iterators$1.Arguments = Iterators$1.Array;

	var global$c = global$D;
	var nativePromiseConstructor = global$c.Promise;

	var redefine = redefine$3;
	var redefineAll$1 = function (target, src, options) {
	  for (var key in src) {
	    if (options && options.unsafe && target[key]) target[key] = src[key];
	    else redefine(target, key, src[key], options);
	  } return target;
	};

	var getBuiltIn$4 = getBuiltIn$9;
	var definePropertyModule = objectDefineProperty;
	var wellKnownSymbol$4 = wellKnownSymbol$e;
	var DESCRIPTORS = descriptors;
	var SPECIES$2 = wellKnownSymbol$4('species');
	var setSpecies$1 = function (CONSTRUCTOR_NAME) {
	  var Constructor = getBuiltIn$4(CONSTRUCTOR_NAME);
	  var defineProperty = definePropertyModule.f;
	  if (DESCRIPTORS && Constructor && !Constructor[SPECIES$2]) {
	    defineProperty(Constructor, SPECIES$2, {
	      configurable: true,
	      get: function () { return this; }
	    });
	  }
	};

	var global$b = global$D;
	var isPrototypeOf$5 = objectIsPrototypeOf;
	var TypeError$5 = global$b.TypeError;
	var anInstance$1 = function (it, Prototype) {
	  if (isPrototypeOf$5(Prototype, it)) return it;
	  throw TypeError$5('Incorrect invocation');
	};

	var wellKnownSymbol$3 = wellKnownSymbol$e;
	var ITERATOR = wellKnownSymbol$3('iterator');
	var SAFE_CLOSING = false;
	try {
	  var called = 0;
	  var iteratorWithReturn = {
	    next: function () {
	      return { done: !!called++ };
	    },
	    'return': function () {
	      SAFE_CLOSING = true;
	    }
	  };
	  iteratorWithReturn[ITERATOR] = function () {
	    return this;
	  };
	  Array.from(iteratorWithReturn, function () { throw 2; });
	} catch (error) {  }
	var checkCorrectnessOfIteration$1 = function (exec, SKIP_CLOSING) {
	  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
	  var ITERATION_SUPPORT = false;
	  try {
	    var object = {};
	    object[ITERATOR] = function () {
	      return {
	        next: function () {
	          return { done: ITERATION_SUPPORT = true };
	        }
	      };
	    };
	    exec(object);
	  } catch (error) {  }
	  return ITERATION_SUPPORT;
	};

	var uncurryThis$5 = functionUncurryThis;
	var fails$4 = fails$f;
	var isCallable$3 = isCallable$h;
	var classof$4 = classof$8;
	var getBuiltIn$3 = getBuiltIn$9;
	var inspectSource$1 = inspectSource$3;
	var noop = function () {  };
	var empty = [];
	var construct = getBuiltIn$3('Reflect', 'construct');
	var constructorRegExp = /^\s*(?:class|function)\b/;
	var exec = uncurryThis$5(constructorRegExp.exec);
	var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);
	var isConstructorModern = function isConstructor(argument) {
	  if (!isCallable$3(argument)) return false;
	  try {
	    construct(noop, empty, argument);
	    return true;
	  } catch (error) {
	    return false;
	  }
	};
	var isConstructorLegacy = function isConstructor(argument) {
	  if (!isCallable$3(argument)) return false;
	  switch (classof$4(argument)) {
	    case 'AsyncFunction':
	    case 'GeneratorFunction':
	    case 'AsyncGeneratorFunction': return false;
	  }
	  try {
	    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource$1(argument));
	  } catch (error) {
	    return true;
	  }
	};
	isConstructorLegacy.sham = true;
	var isConstructor$1 = !construct || fails$4(function () {
	  var called;
	  return isConstructorModern(isConstructorModern.call)
	    || !isConstructorModern(Object)
	    || !isConstructorModern(function () { called = true; })
	    || called;
	}) ? isConstructorLegacy : isConstructorModern;

	var global$a = global$D;
	var isConstructor = isConstructor$1;
	var tryToString = tryToString$4;
	var TypeError$4 = global$a.TypeError;
	var aConstructor$1 = function (argument) {
	  if (isConstructor(argument)) return argument;
	  throw TypeError$4(tryToString(argument) + ' is not a constructor');
	};

	var anObject$2 = anObject$b;
	var aConstructor = aConstructor$1;
	var wellKnownSymbol$2 = wellKnownSymbol$e;
	var SPECIES$1 = wellKnownSymbol$2('species');
	var speciesConstructor$2 = function (O, defaultConstructor) {
	  var C = anObject$2(O).constructor;
	  var S;
	  return C === undefined || (S = anObject$2(C)[SPECIES$1]) == undefined ? defaultConstructor : aConstructor(S);
	};

	var uncurryThis$4 = functionUncurryThis;
	var arraySlice$1 = uncurryThis$4([].slice);

	var global$9 = global$D;
	var TypeError$3 = global$9.TypeError;
	var validateArgumentsLength$1 = function (passed, required) {
	  if (passed < required) throw TypeError$3('Not enough arguments');
	  return passed;
	};

	var userAgent$2 = engineUserAgent;
	var engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$2);

	var classof$3 = classofRaw$1;
	var global$8 = global$D;
	var engineIsNode = classof$3(global$8.process) == 'process';

	var global$7 = global$D;
	var apply = functionApply;
	var bind$2 = functionBindContext;
	var isCallable$2 = isCallable$h;
	var hasOwn$1 = hasOwnProperty_1;
	var fails$3 = fails$f;
	var html = html$2;
	var arraySlice = arraySlice$1;
	var createElement = documentCreateElement$1;
	var validateArgumentsLength = validateArgumentsLength$1;
	var IS_IOS$1 = engineIsIos;
	var IS_NODE$3 = engineIsNode;
	var set = global$7.setImmediate;
	var clear = global$7.clearImmediate;
	var process$2 = global$7.process;
	var Dispatch = global$7.Dispatch;
	var Function$1 = global$7.Function;
	var MessageChannel = global$7.MessageChannel;
	var String$1 = global$7.String;
	var counter = 0;
	var queue$1 = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var location, defer, channel, port;
	try {
	  location = global$7.location;
	} catch (error) {  }
	var run = function (id) {
	  if (hasOwn$1(queue$1, id)) {
	    var fn = queue$1[id];
	    delete queue$1[id];
	    fn();
	  }
	};
	var runner = function (id) {
	  return function () {
	    run(id);
	  };
	};
	var listener = function (event) {
	  run(event.data);
	};
	var post = function (id) {
	  global$7.postMessage(String$1(id), location.protocol + '//' + location.host);
	};
	if (!set || !clear) {
	  set = function setImmediate(handler) {
	    validateArgumentsLength(arguments.length, 1);
	    var fn = isCallable$2(handler) ? handler : Function$1(handler);
	    var args = arraySlice(arguments, 1);
	    queue$1[++counter] = function () {
	      apply(fn, undefined, args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clear = function clearImmediate(id) {
	    delete queue$1[id];
	  };
	  if (IS_NODE$3) {
	    defer = function (id) {
	      process$2.nextTick(runner(id));
	    };
	  } else if (Dispatch && Dispatch.now) {
	    defer = function (id) {
	      Dispatch.now(runner(id));
	    };
	  } else if (MessageChannel && !IS_IOS$1) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = bind$2(port.postMessage, port);
	  } else if (
	    global$7.addEventListener &&
	    isCallable$2(global$7.postMessage) &&
	    !global$7.importScripts &&
	    location && location.protocol !== 'file:' &&
	    !fails$3(post)
	  ) {
	    defer = post;
	    global$7.addEventListener('message', listener, false);
	  } else if (ONREADYSTATECHANGE in createElement('script')) {
	    defer = function (id) {
	      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
	        html.removeChild(this);
	        run(id);
	      };
	    };
	  } else {
	    defer = function (id) {
	      setTimeout(runner(id), 0);
	    };
	  }
	}
	var task$1 = {
	  set: set,
	  clear: clear
	};

	var userAgent$1 = engineUserAgent;
	var global$6 = global$D;
	var engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$1) && global$6.Pebble !== undefined;

	var userAgent = engineUserAgent;
	var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent);

	var global$5 = global$D;
	var bind$1 = functionBindContext;
	var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	var macrotask = task$1.set;
	var IS_IOS = engineIsIos;
	var IS_IOS_PEBBLE = engineIsIosPebble;
	var IS_WEBOS_WEBKIT = engineIsWebosWebkit;
	var IS_NODE$2 = engineIsNode;
	var MutationObserver = global$5.MutationObserver || global$5.WebKitMutationObserver;
	var document$2 = global$5.document;
	var process$1 = global$5.process;
	var Promise$1 = global$5.Promise;
	var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global$5, 'queueMicrotask');
	var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
	var flush, head, last, notify$1, toggle, node, promise$3, then;
	if (!queueMicrotask) {
	  flush = function () {
	    var parent, fn;
	    if (IS_NODE$2 && (parent = process$1.domain)) parent.exit();
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (error) {
	        if (head) notify$1();
	        else last = undefined;
	        throw error;
	      }
	    } last = undefined;
	    if (parent) parent.enter();
	  };
	  if (!IS_IOS && !IS_NODE$2 && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {
	    toggle = true;
	    node = document$2.createTextNode('');
	    new MutationObserver(flush).observe(node, { characterData: true });
	    notify$1 = function () {
	      node.data = toggle = !toggle;
	    };
	  } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {
	    promise$3 = Promise$1.resolve(undefined);
	    promise$3.constructor = Promise$1;
	    then = bind$1(promise$3.then, promise$3);
	    notify$1 = function () {
	      then(flush);
	    };
	  } else if (IS_NODE$2) {
	    notify$1 = function () {
	      process$1.nextTick(flush);
	    };
	  } else {
	    macrotask = bind$1(macrotask, global$5);
	    notify$1 = function () {
	      macrotask(flush);
	    };
	  }
	}
	var microtask$1 = queueMicrotask || function (fn) {
	  var task = { fn: fn, next: undefined };
	  if (last) last.next = task;
	  if (!head) {
	    head = task;
	    notify$1();
	  } last = task;
	};

	var newPromiseCapability$2 = {};

	var aCallable$4 = aCallable$8;
	var PromiseCapability = function (C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = aCallable$4(resolve);
	  this.reject = aCallable$4(reject);
	};
	newPromiseCapability$2.f = function (C) {
	  return new PromiseCapability(C);
	};

	var anObject$1 = anObject$b;
	var isObject$1 = isObject$8;
	var newPromiseCapability$1 = newPromiseCapability$2;
	var promiseResolve$2 = function (C, x) {
	  anObject$1(C);
	  if (isObject$1(x) && x.constructor === C) return x;
	  var promiseCapability = newPromiseCapability$1.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};

	var global$4 = global$D;
	var hostReportErrors$1 = function (a, b) {
	  var console = global$4.console;
	  if (console && console.error) {
	    arguments.length == 1 ? console.error(a) : console.error(a, b);
	  }
	};

	var perform$3 = function (exec) {
	  try {
	    return { error: false, value: exec() };
	  } catch (error) {
	    return { error: true, value: error };
	  }
	};

	var Queue$1 = function () {
	  this.head = null;
	  this.tail = null;
	};
	Queue$1.prototype = {
	  add: function (item) {
	    var entry = { item: item, next: null };
	    if (this.head) this.tail.next = entry;
	    else this.head = entry;
	    this.tail = entry;
	  },
	  get: function () {
	    var entry = this.head;
	    if (entry) {
	      this.head = entry.next;
	      if (this.tail === entry) this.tail = null;
	      return entry.item;
	    }
	  }
	};
	var queue = Queue$1;

	var engineIsBrowser = typeof window == 'object';

	var $$6 = _export;
	var IS_PURE = isPure;
	var global$3 = global$D;
	var getBuiltIn$2 = getBuiltIn$9;
	var call$2 = functionCall;
	var NativePromise$1 = nativePromiseConstructor;
	var redefineAll = redefineAll$1;
	var setToStringTag = setToStringTag$3;
	var setSpecies = setSpecies$1;
	var aCallable$3 = aCallable$8;
	var isCallable$1 = isCallable$h;
	var isObject = isObject$8;
	var anInstance = anInstance$1;
	var inspectSource = inspectSource$3;
	var iterate$2 = iterate$4;
	var checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;
	var speciesConstructor$1 = speciesConstructor$2;
	var task = task$1.set;
	var microtask = microtask$1;
	var promiseResolve$1 = promiseResolve$2;
	var hostReportErrors = hostReportErrors$1;
	var newPromiseCapabilityModule$2 = newPromiseCapability$2;
	var perform$2 = perform$3;
	var Queue = queue;
	var InternalStateModule$1 = internalState;
	var isForced = isForced_1;
	var wellKnownSymbol$1 = wellKnownSymbol$e;
	var IS_BROWSER = engineIsBrowser;
	var IS_NODE$1 = engineIsNode;
	var V8_VERSION = engineV8Version;
	var SPECIES = wellKnownSymbol$1('species');
	var PROMISE = 'Promise';
	var getInternalState$1 = InternalStateModule$1.getterFor(PROMISE);
	var setInternalState$1 = InternalStateModule$1.set;
	var getInternalPromiseState = InternalStateModule$1.getterFor(PROMISE);
	var NativePromisePrototype = NativePromise$1 && NativePromise$1.prototype;
	var PromiseConstructor = NativePromise$1;
	var PromisePrototype = NativePromisePrototype;
	var TypeError$2 = global$3.TypeError;
	var document$1 = global$3.document;
	var process = global$3.process;
	var newPromiseCapability = newPromiseCapabilityModule$2.f;
	var newGenericPromiseCapability = newPromiseCapability;
	var DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$3.dispatchEvent);
	var NATIVE_REJECTION_EVENT = isCallable$1(global$3.PromiseRejectionEvent);
	var UNHANDLED_REJECTION = 'unhandledrejection';
	var REJECTION_HANDLED = 'rejectionhandled';
	var PENDING = 0;
	var FULFILLED = 1;
	var REJECTED = 2;
	var HANDLED = 1;
	var UNHANDLED = 2;
	var SUBCLASSING = false;
	var Internal, OwnPromiseCapability, PromiseWrapper;
	var FORCED = isForced(PROMISE, function () {
	  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(PromiseConstructor);
	  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(PromiseConstructor);
	  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
	  if (!PromisePrototype['finally']) return true;
	  if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;
	  var promise = new PromiseConstructor(function (resolve) { resolve(1); });
	  var FakePromise = function (exec) {
	    exec(function () {  }, function () {  });
	  };
	  var constructor = promise.constructor = {};
	  constructor[SPECIES] = FakePromise;
	  SUBCLASSING = promise.then(function () {  }) instanceof FakePromise;
	  if (!SUBCLASSING) return true;
	  return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_REJECTION_EVENT;
	});
	var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
	  PromiseConstructor.all(iterable)['catch'](function () {  });
	});
	var isThenable = function (it) {
	  var then;
	  return isObject(it) && isCallable$1(then = it.then) ? then : false;
	};
	var callReaction = function (reaction, state) {
	  var value = state.value;
	  var ok = state.state == FULFILLED;
	  var handler = ok ? reaction.ok : reaction.fail;
	  var resolve = reaction.resolve;
	  var reject = reaction.reject;
	  var domain = reaction.domain;
	  var result, then, exited;
	  try {
	    if (handler) {
	      if (!ok) {
	        if (state.rejection === UNHANDLED) onHandleUnhandled(state);
	        state.rejection = HANDLED;
	      }
	      if (handler === true) result = value;
	      else {
	        if (domain) domain.enter();
	        result = handler(value);
	        if (domain) {
	          domain.exit();
	          exited = true;
	        }
	      }
	      if (result === reaction.promise) {
	        reject(TypeError$2('Promise-chain cycle'));
	      } else if (then = isThenable(result)) {
	        call$2(then, result, resolve, reject);
	      } else resolve(result);
	    } else reject(value);
	  } catch (error) {
	    if (domain && !exited) domain.exit();
	    reject(error);
	  }
	};
	var notify = function (state, isReject) {
	  if (state.notified) return;
	  state.notified = true;
	  microtask(function () {
	    var reactions = state.reactions;
	    var reaction;
	    while (reaction = reactions.get()) {
	      callReaction(reaction, state);
	    }
	    state.notified = false;
	    if (isReject && !state.rejection) onUnhandled(state);
	  });
	};
	var dispatchEvent = function (name, promise, reason) {
	  var event, handler;
	  if (DISPATCH_EVENT) {
	    event = document$1.createEvent('Event');
	    event.promise = promise;
	    event.reason = reason;
	    event.initEvent(name, false, true);
	    global$3.dispatchEvent(event);
	  } else event = { promise: promise, reason: reason };
	  if (!NATIVE_REJECTION_EVENT && (handler = global$3['on' + name])) handler(event);
	  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
	};
	var onUnhandled = function (state) {
	  call$2(task, global$3, function () {
	    var promise = state.facade;
	    var value = state.value;
	    var IS_UNHANDLED = isUnhandled(state);
	    var result;
	    if (IS_UNHANDLED) {
	      result = perform$2(function () {
	        if (IS_NODE$1) {
	          process.emit('unhandledRejection', value, promise);
	        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
	      });
	      state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;
	      if (result.error) throw result.value;
	    }
	  });
	};
	var isUnhandled = function (state) {
	  return state.rejection !== HANDLED && !state.parent;
	};
	var onHandleUnhandled = function (state) {
	  call$2(task, global$3, function () {
	    var promise = state.facade;
	    if (IS_NODE$1) {
	      process.emit('rejectionHandled', promise);
	    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
	  });
	};
	var bind = function (fn, state, unwrap) {
	  return function (value) {
	    fn(state, value, unwrap);
	  };
	};
	var internalReject = function (state, value, unwrap) {
	  if (state.done) return;
	  state.done = true;
	  if (unwrap) state = unwrap;
	  state.value = value;
	  state.state = REJECTED;
	  notify(state, true);
	};
	var internalResolve = function (state, value, unwrap) {
	  if (state.done) return;
	  state.done = true;
	  if (unwrap) state = unwrap;
	  try {
	    if (state.facade === value) throw TypeError$2("Promise can't be resolved itself");
	    var then = isThenable(value);
	    if (then) {
	      microtask(function () {
	        var wrapper = { done: false };
	        try {
	          call$2(then, value,
	            bind(internalResolve, wrapper, state),
	            bind(internalReject, wrapper, state)
	          );
	        } catch (error) {
	          internalReject(wrapper, error, state);
	        }
	      });
	    } else {
	      state.value = value;
	      state.state = FULFILLED;
	      notify(state, false);
	    }
	  } catch (error) {
	    internalReject({ done: false }, error, state);
	  }
	};
	if (FORCED) {
	  PromiseConstructor = function Promise(executor) {
	    anInstance(this, PromisePrototype);
	    aCallable$3(executor);
	    call$2(Internal, this);
	    var state = getInternalState$1(this);
	    try {
	      executor(bind(internalResolve, state), bind(internalReject, state));
	    } catch (error) {
	      internalReject(state, error);
	    }
	  };
	  PromisePrototype = PromiseConstructor.prototype;
	  Internal = function Promise(executor) {
	    setInternalState$1(this, {
	      type: PROMISE,
	      done: false,
	      notified: false,
	      parent: false,
	      reactions: new Queue(),
	      rejection: false,
	      state: PENDING,
	      value: undefined
	    });
	  };
	  Internal.prototype = redefineAll(PromisePrototype, {
	    then: function then(onFulfilled, onRejected) {
	      var state = getInternalPromiseState(this);
	      var reaction = newPromiseCapability(speciesConstructor$1(this, PromiseConstructor));
	      state.parent = true;
	      reaction.ok = isCallable$1(onFulfilled) ? onFulfilled : true;
	      reaction.fail = isCallable$1(onRejected) && onRejected;
	      reaction.domain = IS_NODE$1 ? process.domain : undefined;
	      if (state.state == PENDING) state.reactions.add(reaction);
	      else microtask(function () {
	        callReaction(reaction, state);
	      });
	      return reaction.promise;
	    },
	    'catch': function (onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });
	  OwnPromiseCapability = function () {
	    var promise = new Internal();
	    var state = getInternalState$1(promise);
	    this.promise = promise;
	    this.resolve = bind(internalResolve, state);
	    this.reject = bind(internalReject, state);
	  };
	  newPromiseCapabilityModule$2.f = newPromiseCapability = function (C) {
	    return C === PromiseConstructor || C === PromiseWrapper
	      ? new OwnPromiseCapability(C)
	      : newGenericPromiseCapability(C);
	  };
	}
	$$6({ global: true, wrap: true, forced: FORCED }, {
	  Promise: PromiseConstructor
	});
	setToStringTag(PromiseConstructor, PROMISE, false, true);
	setSpecies(PROMISE);
	PromiseWrapper = getBuiltIn$2(PROMISE);
	$$6({ target: PROMISE, stat: true, forced: FORCED }, {
	  reject: function reject(r) {
	    var capability = newPromiseCapability(this);
	    call$2(capability.reject, undefined, r);
	    return capability.promise;
	  }
	});
	$$6({ target: PROMISE, stat: true, forced: IS_PURE  }, {
	  resolve: function resolve(x) {
	    return promiseResolve$1(this === PromiseWrapper ? PromiseConstructor : this, x);
	  }
	});
	$$6({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform$2(function () {
	      var $promiseResolve = aCallable$3(C.resolve);
	      var values = [];
	      var counter = 0;
	      var remaining = 1;
	      iterate$2(iterable, function (promise) {
	        var index = counter++;
	        var alreadyCalled = false;
	        remaining++;
	        call$2($promiseResolve, C, promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  },
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var reject = capability.reject;
	    var result = perform$2(function () {
	      var $promiseResolve = aCallable$3(C.resolve);
	      iterate$2(iterable, function (promise) {
	        call$2($promiseResolve, C, promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  }
	});

	var $$5 = _export;
	var call$1 = functionCall;
	var aCallable$2 = aCallable$8;
	var newPromiseCapabilityModule$1 = newPromiseCapability$2;
	var perform$1 = perform$3;
	var iterate$1 = iterate$4;
	$$5({ target: 'Promise', stat: true }, {
	  allSettled: function allSettled(iterable) {
	    var C = this;
	    var capability = newPromiseCapabilityModule$1.f(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform$1(function () {
	      var promiseResolve = aCallable$2(C.resolve);
	      var values = [];
	      var counter = 0;
	      var remaining = 1;
	      iterate$1(iterable, function (promise) {
	        var index = counter++;
	        var alreadyCalled = false;
	        remaining++;
	        call$1(promiseResolve, C, promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = { status: 'fulfilled', value: value };
	          --remaining || resolve(values);
	        }, function (error) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = { status: 'rejected', reason: error };
	          --remaining || resolve(values);
	        });
	      });
	      --remaining || resolve(values);
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  }
	});

	var $$4 = _export;
	var aCallable$1 = aCallable$8;
	var getBuiltIn$1 = getBuiltIn$9;
	var call = functionCall;
	var newPromiseCapabilityModule = newPromiseCapability$2;
	var perform = perform$3;
	var iterate = iterate$4;
	var PROMISE_ANY_ERROR = 'No one promise resolved';
	$$4({ target: 'Promise', stat: true }, {
	  any: function any(iterable) {
	    var C = this;
	    var AggregateError = getBuiltIn$1('AggregateError');
	    var capability = newPromiseCapabilityModule.f(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var promiseResolve = aCallable$1(C.resolve);
	      var errors = [];
	      var counter = 0;
	      var remaining = 1;
	      var alreadyResolved = false;
	      iterate(iterable, function (promise) {
	        var index = counter++;
	        var alreadyRejected = false;
	        remaining++;
	        call(promiseResolve, C, promise).then(function (value) {
	          if (alreadyRejected || alreadyResolved) return;
	          alreadyResolved = true;
	          resolve(value);
	        }, function (error) {
	          if (alreadyRejected || alreadyResolved) return;
	          alreadyRejected = true;
	          errors[index] = error;
	          --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
	        });
	      });
	      --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  }
	});

	var $$3 = _export;
	var NativePromise = nativePromiseConstructor;
	var fails$2 = fails$f;
	var getBuiltIn = getBuiltIn$9;
	var isCallable = isCallable$h;
	var speciesConstructor = speciesConstructor$2;
	var promiseResolve = promiseResolve$2;
	var NON_GENERIC = !!NativePromise && fails$2(function () {
	  NativePromise.prototype['finally'].call({ then: function () {  } }, function () {  });
	});
	$$3({ target: 'Promise', proto: true, real: true, forced: NON_GENERIC }, {
	  'finally': function (onFinally) {
	    var C = speciesConstructor(this, getBuiltIn('Promise'));
	    var isFunction = isCallable(onFinally);
	    return this.then(
	      isFunction ? function (x) {
	        return promiseResolve(C, onFinally()).then(function () { return x; });
	      } : onFinally,
	      isFunction ? function (e) {
	        return promiseResolve(C, onFinally()).then(function () { throw e; });
	      } : onFinally
	    );
	  }
	});

	var uncurryThis$3 = functionUncurryThis;
	var toIntegerOrInfinity = toIntegerOrInfinity$3;
	var toString$2 = toString$5;
	var requireObjectCoercible$1 = requireObjectCoercible$4;
	var charAt$1 = uncurryThis$3(''.charAt);
	var charCodeAt = uncurryThis$3(''.charCodeAt);
	var stringSlice = uncurryThis$3(''.slice);
	var createMethod$2 = function (CONVERT_TO_STRING) {
	  return function ($this, pos) {
	    var S = toString$2(requireObjectCoercible$1($this));
	    var position = toIntegerOrInfinity(pos);
	    var size = S.length;
	    var first, second;
	    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
	    first = charCodeAt(S, position);
	    return first < 0xD800 || first > 0xDBFF || position + 1 === size
	      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
	        ? CONVERT_TO_STRING
	          ? charAt$1(S, position)
	          : first
	        : CONVERT_TO_STRING
	          ? stringSlice(S, position, position + 2)
	          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
	  };
	};
	var stringMultibyte = {
	  codeAt: createMethod$2(false),
	  charAt: createMethod$2(true)
	};

	var charAt = stringMultibyte.charAt;
	var toString$1 = toString$5;
	var InternalStateModule = internalState;
	var defineIterator = defineIterator$2;
	var STRING_ITERATOR = 'String Iterator';
	var setInternalState = InternalStateModule.set;
	var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
	defineIterator(String, 'String', function (iterated) {
	  setInternalState(this, {
	    type: STRING_ITERATOR,
	    string: toString$1(iterated),
	    index: 0
	  });
	}, function next() {
	  var state = getInternalState(this);
	  var string = state.string;
	  var index = state.index;
	  var point;
	  if (index >= string.length) return { value: undefined, done: true };
	  point = charAt(string, index);
	  state.index += point.length;
	  return { value: point, done: false };
	});

	var path$1 = path$4;
	var promise$2 = path$1.Promise;

	var domIterables = {
	  CSSRuleList: 0,
	  CSSStyleDeclaration: 0,
	  CSSValueList: 0,
	  ClientRectList: 0,
	  DOMRectList: 0,
	  DOMStringList: 0,
	  DOMTokenList: 1,
	  DataTransferItemList: 0,
	  FileList: 0,
	  HTMLAllCollection: 0,
	  HTMLCollection: 0,
	  HTMLFormElement: 0,
	  HTMLSelectElement: 0,
	  MediaList: 0,
	  MimeTypeArray: 0,
	  NamedNodeMap: 0,
	  NodeList: 1,
	  PaintRequestList: 0,
	  Plugin: 0,
	  PluginArray: 0,
	  SVGLengthList: 0,
	  SVGNumberList: 0,
	  SVGPathSegList: 0,
	  SVGPointList: 0,
	  SVGStringList: 0,
	  SVGTransformList: 0,
	  SourceBufferList: 0,
	  StyleSheetList: 0,
	  TextTrackCueList: 0,
	  TextTrackList: 0,
	  TouchList: 0
	};

	var DOMIterables$1 = domIterables;
	var global$2 = global$D;
	var classof$2 = classof$8;
	var createNonEnumerableProperty = createNonEnumerableProperty$7;
	var Iterators = iterators;
	var wellKnownSymbol = wellKnownSymbol$e;
	var TO_STRING_TAG = wellKnownSymbol('toStringTag');
	for (var COLLECTION_NAME in DOMIterables$1) {
	  var Collection = global$2[COLLECTION_NAME];
	  var CollectionPrototype = Collection && Collection.prototype;
	  if (CollectionPrototype && classof$2(CollectionPrototype) !== TO_STRING_TAG) {
	    createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
	  }
	  Iterators[COLLECTION_NAME] = Iterators.Array;
	}

	var parent$5 = promise$2;
	var promise$1 = parent$5;

	var promise = promise$1;

	/**
	 * Generates SHA-256 hash of string.
	 *
	 * @param   {string} msg - String to be hashed
	 * @returns {string} Hash of msg as hex character string
	 */
	function sha256hash(msg) {
	  /**
	   * Rotates right (circular right shift) value x by n positions [3.2.4].
	   * @private
	   */
	  function ROTR(n, x) {
	    return x >>> n | x << 32 - n;
	  }
	  /**
	   * Logical functions [4.1.2].
	   * @private
	   */


	  function S0(x) {
	    return ROTR(2, x) ^ ROTR(13, x) ^ ROTR(22, x);
	  }

	  function S1(x) {
	    return ROTR(6, x) ^ ROTR(11, x) ^ ROTR(25, x);
	  }

	  function s0(x) {
	    return ROTR(7, x) ^ ROTR(18, x) ^ x >>> 3;
	  }

	  function s1(x) {
	    return ROTR(17, x) ^ ROTR(19, x) ^ x >>> 10;
	  }

	  function Ch(x, y, z) {
	    return x & y ^ ~x & z;
	  }

	  function Maj(x, y, z) {
	    return x & y ^ x & z ^ y & z;
	  }
	  /**
	   * Hexadecimal representation of a number.
	   * @private
	   */


	  function toHexStr(n) {
	    let s = "",
	        v;

	    for (let i = 7; i >= 0; i--) {
	      v = n >>> i * 4 & 0xf;
	      s += v.toString(16);
	    }

	    return s;
	  }

	  msg = unescape(encodeURIComponent(msg));
	  const K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];
	  const H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];
	  msg += String.fromCharCode(0x80);
	  const l = msg.length / 4 + 2;
	  const N = Math.ceil(l / 16);
	  const M = new Array(N);

	  for (let i = 0; i < N; i++) {
	    M[i] = new Array(16);

	    for (let j = 0; j < 16; j++) {
	      M[i][j] = msg.charCodeAt(i * 64 + j * 4) << 24 | msg.charCodeAt(i * 64 + j * 4 + 1) << 16 | msg.charCodeAt(i * 64 + j * 4 + 2) << 8 | msg.charCodeAt(i * 64 + j * 4 + 3);
	    }
	  }

	  M[N - 1][14] = (msg.length - 1) * 8 / Math.pow(2, 32);
	  M[N - 1][14] = Math.floor(M[N - 1][14]);
	  M[N - 1][15] = (msg.length - 1) * 8 & 0xffffffff;
	  const W = new Array(64);
	  let a, b, c, d, e, f, g, h;

	  for (let i = 0; i < N; i++) {
	    for (let t = 0; t < 16; t++) W[t] = M[i][t];

	    for (let t = 16; t < 64; t++) W[t] = s1(W[t - 2]) + W[t - 7] + s0(W[t - 15]) + W[t - 16] & 0xffffffff;

	    a = H[0];
	    b = H[1];
	    c = H[2];
	    d = H[3];
	    e = H[4];
	    f = H[5];
	    g = H[6];
	    h = H[7];

	    for (let t = 0; t < 64; t++) {
	      const T1 = h + S1(e) + Ch(e, f, g) + K[t] + W[t];
	      const T2 = S0(a) + Maj(a, b, c);
	      h = g;
	      g = f;
	      f = e;
	      e = d + T1 & 0xffffffff;
	      d = c;
	      c = b;
	      b = a;
	      a = T1 + T2 & 0xffffffff;
	    }

	    H[0] = H[0] + a & 0xffffffff;
	    H[1] = H[1] + b & 0xffffffff;
	    H[2] = H[2] + c & 0xffffffff;
	    H[3] = H[3] + d & 0xffffffff;
	    H[4] = H[4] + e & 0xffffffff;
	    H[5] = H[5] + f & 0xffffffff;
	    H[6] = H[6] + g & 0xffffffff;
	    H[7] = H[7] + h & 0xffffffff;
	  }

	  return toHexStr(H[0]) + toHexStr(H[1]) + toHexStr(H[2]) + toHexStr(H[3]) + toHexStr(H[4]) + toHexStr(H[5]) + toHexStr(H[6]) + toHexStr(H[7]);
	}

	var path = path$4;
	var entryVirtual$4 = function (CONSTRUCTOR) {
	  return path[CONSTRUCTOR + 'Prototype'];
	};

	var entryVirtual$3 = entryVirtual$4;
	var values$3 = entryVirtual$3('Array').values;

	var parent$4 = values$3;
	var values$2 = parent$4;

	var classof$1 = classof$8;
	var hasOwn = hasOwnProperty_1;
	var isPrototypeOf$4 = objectIsPrototypeOf;
	var method$3 = values$2;
	var ArrayPrototype$2 = Array.prototype;
	var DOMIterables = {
	  DOMTokenList: true,
	  NodeList: true
	};
	var values$1 = function (it) {
	  var own = it.values;
	  return it === ArrayPrototype$2 || (isPrototypeOf$4(ArrayPrototype$2, it) && own === ArrayPrototype$2.values)
	    || hasOwn(DOMIterables, classof$1(it)) ? method$3 : own;
	};

	var values = values$1;

	/**
	 * Encoder interface mode
	 * @public
	 */
	exports.EncoderIOMode = void 0;

	(function (EncoderIOMode) {
	  /**
	   * No additional pull-up or pull-down resistors will be applied to the input lines.
	   * @public
	   */
	  EncoderIOMode[EncoderIOMode["PUSH_PULL"] = 1] = "PUSH_PULL";
	  /**
	   * 2.2kÎ© pull-down resistors will be applied to the input lines.
	   * @public
	   */

	  EncoderIOMode[EncoderIOMode["LINE_DRIVER_2K2"] = 2] = "LINE_DRIVER_2K2";
	  /**
	   * 10kÎ© pull-down resistors will be applied to the input lines.
	   * @public
	   */

	  EncoderIOMode[EncoderIOMode["LINE_DRIVER_10K"] = 3] = "LINE_DRIVER_10K";
	  /**
	   * 2.2kÎ© pull-up resistors will be applied to the input lines.
	   * @public
	   */

	  EncoderIOMode[EncoderIOMode["OPEN_COLLECTOR_2K2"] = 4] = "OPEN_COLLECTOR_2K2";
	  /**
	   * 10kÎ© pull-up resistors will be applied to the input lines.
	   * @public
	   */

	  EncoderIOMode[EncoderIOMode["OPEN_COLLECTOR_10K"] = 5] = "OPEN_COLLECTOR_10K";
	})(exports.EncoderIOMode || (exports.EncoderIOMode = {}));
	/**
	 * Error codes returned from all API calls via Exceptions.
	 * @public
	 */


	exports.ErrorCode = void 0;

	(function (ErrorCode) {
	  /**
	   * Call succeeded.
	   * @public
	   */
	  ErrorCode[ErrorCode["SUCCESS"] = 0] = "SUCCESS";
	  /**
	   * Not Permitted
	   * @public
	   */

	  ErrorCode[ErrorCode["NOT_PERMITTED"] = 1] = "NOT_PERMITTED";
	  /**
	   * The specified entity does not exist. This is usually a result of Net or Log API calls.
	   * @public
	   */

	  ErrorCode[ErrorCode["NO_SUCH_ENTITY"] = 2] = "NO_SUCH_ENTITY";
	  /**
	   * Call has timed out. This can happen for a number of common reasons: Check that the Phidget you are trying to open is plugged in, and that the addressing parameters have been specified correctly. Check that the Phidget is not already open in another program, such as the Phidget Control Panel, or another program you are developing. If your Phidget has a plug or terminal block for external power, ensure it is plugged in and powered. If you are using remote Phidgets, ensure that your computer can access the remote Phidgets using the Phidget Control Panel. If you are using remote Phidgets, ensure you have enabled Server Discovery or added the server corresponding to the Phidget you are trying to open. If you are using Network Server Discovery, try extending the timeout to allow more time for the server to be discovered.
	   * @public
	   */

	  ErrorCode[ErrorCode["TIMEOUT"] = 3] = "TIMEOUT";
	  /**
	   * Keep Alive Failure
	   * @public
	   */

	  ErrorCode[ErrorCode["KEEP_ALIVE"] = 58] = "KEEP_ALIVE";
	  /**
	   * The operation was interrupted; either from an error, or because the device was closed.
	   * @public
	   */

	  ErrorCode[ErrorCode["INTERRUPTED"] = 4] = "INTERRUPTED";
	  /**
	   * IO Issue
	   * @public
	   */

	  ErrorCode[ErrorCode["IO"] = 5] = "IO";
	  /**
	   * Memory Issue
	   * @public
	   */

	  ErrorCode[ErrorCode["NO_MEMORY"] = 6] = "NO_MEMORY";
	  /**
	   * Access to the resource (file) is denied. This can happen when enabling logging.
	   * @public
	   */

	  ErrorCode[ErrorCode["ACCESS"] = 7] = "ACCESS";
	  /**
	   * Address Issue
	   * @public
	   */

	  ErrorCode[ErrorCode["FAULT"] = 8] = "FAULT";
	  /**
	   * Specified resource is in use. This error code is not normally used.
	   * @public
	   */

	  ErrorCode[ErrorCode["BUSY"] = 9] = "BUSY";
	  /**
	   * Object Exists
	   * @public
	   */

	  ErrorCode[ErrorCode["EXISTS"] = 10] = "EXISTS";
	  /**
	   * Object is not a directory
	   * @public
	   */

	  ErrorCode[ErrorCode["IS_NOT_DIRECTORY"] = 11] = "IS_NOT_DIRECTORY";
	  /**
	   * Object is a directory
	   * @public
	   */

	  ErrorCode[ErrorCode["IS_DIRECTORY"] = 12] = "IS_DIRECTORY";
	  /**
	   * Invalid or malformed command. This can be caused by sending a command to a device which is not supported in it's current configuration.
	   * @public
	   */

	  ErrorCode[ErrorCode["INVALID"] = 13] = "INVALID";
	  /**
	   * Too many open files in system
	   * @public
	   */

	  ErrorCode[ErrorCode["TOO_MANY_FILES_SYSTEM"] = 14] = "TOO_MANY_FILES_SYSTEM";
	  /**
	   * Too many open files
	   * @public
	   */

	  ErrorCode[ErrorCode["TOO_MANY_FILES"] = 15] = "TOO_MANY_FILES";
	  /**
	   * The provided buffer argument size is too small.
	   * @public
	   */

	  ErrorCode[ErrorCode["NO_SPACE"] = 16] = "NO_SPACE";
	  /**
	   * File too Big
	   * @public
	   */

	  ErrorCode[ErrorCode["FILE_TOO_BIG"] = 17] = "FILE_TOO_BIG";
	  /**
	   * Read Only Filesystem
	   * @public
	   */

	  ErrorCode[ErrorCode["READ_ONLY_FILESYSTEM"] = 18] = "READ_ONLY_FILESYSTEM";
	  /**
	   * Read Only Object
	   * @public
	   */

	  ErrorCode[ErrorCode["READ_ONLY"] = 19] = "READ_ONLY";
	  /**
	   * This API call is not supported. For Class APIs this means that this API is not supported by this device. This can also mean the API is not supported on this OS, or OS configuration.
	   * @public
	   */

	  ErrorCode[ErrorCode["UNSUPPORTED"] = 20] = "UNSUPPORTED";
	  /**
	   * One or more of the parameters passed to the function is not accepted by the channel in its current configuration.
	   * @public
	   */

	  ErrorCode[ErrorCode["INVALID_ARGUMENT"] = 21] = "INVALID_ARGUMENT";
	  /**
	   * Try again
	   * @public
	   */

	  ErrorCode[ErrorCode["TRY_AGAIN"] = 22] = "TRY_AGAIN";
	  /**
	   * Not Empty
	   * @public
	   */

	  ErrorCode[ErrorCode["NOT_EMPTY"] = 26] = "NOT_EMPTY";
	  /**
	   * Something unexpected has occured. Enable library logging and have a look at the log, or contact Phidgets support.
	   * @public
	   */

	  ErrorCode[ErrorCode["UNEXPECTED"] = 28] = "UNEXPECTED";
	  /**
	   * Duplicated request. Can happen with some Net API calls, such as trying to add the same server twice.
	   * @public
	   */

	  ErrorCode[ErrorCode["DUPLICATE"] = 27] = "DUPLICATE";
	  /**
	   * Bad Credential
	   * @public
	   */

	  ErrorCode[ErrorCode["BAD_PASSWORD"] = 37] = "BAD_PASSWORD";
	  /**
	   * Network Unavailable
	   * @public
	   */

	  ErrorCode[ErrorCode["NETWORK_UNAVAILABLE"] = 45] = "NETWORK_UNAVAILABLE";
	  /**
	   * Connection Refused
	   * @public
	   */

	  ErrorCode[ErrorCode["CONNECTION_REFUSED"] = 35] = "CONNECTION_REFUSED";
	  /**
	   * Connection Reset
	   * @public
	   */

	  ErrorCode[ErrorCode["CONNECTION_RESET"] = 46] = "CONNECTION_RESET";
	  /**
	   * No route to host
	   * @public
	   */

	  ErrorCode[ErrorCode["HOST_UNREACHABLE"] = 48] = "HOST_UNREACHABLE";
	  /**
	   * No Such Device
	   * @public
	   */

	  ErrorCode[ErrorCode["NO_SUCH_DEVICE"] = 40] = "NO_SUCH_DEVICE";
	  /**
	   * A Phidget channel object of the wrong channel class was passed into this API call.
	   * @public
	   */

	  ErrorCode[ErrorCode["WRONG_DEVICE"] = 50] = "WRONG_DEVICE";
	  /**
	   * Broken Pipe
	   * @public
	   */

	  ErrorCode[ErrorCode["BROKEN_PIPE"] = 41] = "BROKEN_PIPE";
	  /**
	   * Name Resolution Failure
	   * @public
	   */

	  ErrorCode[ErrorCode["NAME_RESOLUTION_FAILURE"] = 44] = "NAME_RESOLUTION_FAILURE";
	  /**
	   * The value is unknown. This can happen right after attach, when the value has not yet been recieved from the Phidget. This can also happen if a device has not yet been configured / enabled. Some properties can only be read back after being set.
	   * @public
	   */

	  ErrorCode[ErrorCode["UNKNOWN_VALUE"] = 51] = "UNKNOWN_VALUE";
	  /**
	   * This can happen for a number of common reasons. Be sure you are opening the channel before trying to use it. If you are opening the channel, the program may not be waiting for the channel to be attached. If possible use openWaitForAttachment. Otherwise, be sure to check the Attached property of the channel before trying to use it.
	   * @public
	   */

	  ErrorCode[ErrorCode["NOT_ATTACHED"] = 52] = "NOT_ATTACHED";
	  /**
	   * Invalid or Unexpected Packet
	   * @public
	   */

	  ErrorCode[ErrorCode["INVALID_PACKET"] = 53] = "INVALID_PACKET";
	  /**
	   * Argument List Too Long
	   * @public
	   */

	  ErrorCode[ErrorCode["TOO_BIG"] = 54] = "TOO_BIG";
	  /**
	   * Bad Version
	   * @public
	   */

	  ErrorCode[ErrorCode["BAD_VERSION"] = 55] = "BAD_VERSION";
	  /**
	   * Channel was closed. This can happen if a channel is closed while openWaitForAttachment is waiting.
	   * @public
	   */

	  ErrorCode[ErrorCode["CLOSED"] = 56] = "CLOSED";
	  /**
	   * Device is not configured enough for this API call. Have a look at the must-set properties for this device and make sure to configure them first.
	   * @public
	   */

	  ErrorCode[ErrorCode["NOT_CONFIGURED"] = 57] = "NOT_CONFIGURED";
	  /**
	   * End of File
	   * @public
	   */

	  ErrorCode[ErrorCode["END_OF_FILE"] = 31] = "END_OF_FILE";
	  /**
	   * Failsafe Triggered on this channel. Close and Re-open the channel to resume operation.
	   * @public
	   */

	  ErrorCode[ErrorCode["FAILSAFE"] = 59] = "FAILSAFE";
	  /**
	   * The value has been measured to be higher than the valid range of the sensor.
	   * @public
	   */

	  ErrorCode[ErrorCode["UNKNOWN_VALUE_HIGH"] = 60] = "UNKNOWN_VALUE_HIGH";
	  /**
	   * The value has been measured to be lower than the valid range of the sensor.
	   * @public
	   */

	  ErrorCode[ErrorCode["UNKNOWN_VALUE_LOW"] = 61] = "UNKNOWN_VALUE_LOW";
	})(exports.ErrorCode || (exports.ErrorCode = {}));
	/**
	 * The error code from an Error event
	 * @public
	 */


	exports.ErrorEventCode = void 0;

	(function (ErrorEventCode) {
	  /**
	   * Client and Server protocol versions don't match. Ensure that both sides are using the same release of phidget22.
	   * @public
	   */
	  ErrorEventCode[ErrorEventCode["BAD_VERSION"] = 1] = "BAD_VERSION";
	  /**
	   * Check that the Phidget is not already open in another program, such as the Phidget Control Panel, or another program you are developing.
	   * @public
	   */

	  ErrorEventCode[ErrorEventCode["BUSY"] = 2] = "BUSY";
	  /**
	   * This could be a network communication issue, an authentication issue (if server password is enabled), or a Device access / hardware issue.
	   * @public
	   */

	  ErrorEventCode[ErrorEventCode["NETWORK"] = 3] = "NETWORK";
	  /**
	   * An error occured dispatching a command or event.
	   * @public
	   */

	  ErrorEventCode[ErrorEventCode["DISPATCH"] = 4] = "DISPATCH";
	  /**
	   * A general failure occured - see description for details.
	   * @public
	   */

	  ErrorEventCode[ErrorEventCode["FAILURE"] = 5] = "FAILURE";
	  /**
	   * An error state has cleared.
	   * @public
	   */

	  ErrorEventCode[ErrorEventCode["SUCCESS"] = 4096] = "SUCCESS";
	  /**
	   * A sampling overrun happened in firmware.
	   * @public
	   */

	  ErrorEventCode[ErrorEventCode["OVERRUN"] = 4098] = "OVERRUN";
	  /**
	   * One or more packets were lost.
	   * @public
	   */

	  ErrorEventCode[ErrorEventCode["PACKET_LOST"] = 4099] = "PACKET_LOST";
	  /**
	   * Variable has wrapped around.
	   * @public
	   */

	  ErrorEventCode[ErrorEventCode["WRAP_AROUND"] = 4100] = "WRAP_AROUND";
	  /**
	   * Over-temperature condition detected.
	   * @public
	   */

	  ErrorEventCode[ErrorEventCode["OVER_TEMPERATURE"] = 4101] = "OVER_TEMPERATURE";
	  /**
	   * Over-current condition detected.
	   * @public
	   */

	  ErrorEventCode[ErrorEventCode["OVER_CURRENT"] = 4102] = "OVER_CURRENT";
	  /**
	   * Out of range condition detected.
	   * @public
	   */

	  ErrorEventCode[ErrorEventCode["OUT_OF_RANGE"] = 4103] = "OUT_OF_RANGE";
	  /**
	   * Power supply problem detected.
	   * @public
	   */

	  ErrorEventCode[ErrorEventCode["BAD_POWER"] = 4104] = "BAD_POWER";
	  /**
	   * Saturation condition detected.
	   * @public
	   */

	  ErrorEventCode[ErrorEventCode["SATURATION"] = 4105] = "SATURATION";
	  /**
	   * Over-voltage condition detected.
	   * @public
	   */

	  ErrorEventCode[ErrorEventCode["OVER_VOLTAGE"] = 4107] = "OVER_VOLTAGE";
	  /**
	   * Failsafe condition detected.
	   * @public
	   */

	  ErrorEventCode[ErrorEventCode["FAILSAFE_CONDITION"] = 4108] = "FAILSAFE_CONDITION";
	  /**
	   * Voltage error detected.
	   * @public
	   */

	  ErrorEventCode[ErrorEventCode["VOLTAGE_ERROR"] = 4109] = "VOLTAGE_ERROR";
	  /**
	   * Energy dump condition detected.
	   * @public
	   */

	  ErrorEventCode[ErrorEventCode["ENERGY_DUMP_CONDITION"] = 4110] = "ENERGY_DUMP_CONDITION";
	  /**
	   * Motor stall detected.
	   * @public
	   */

	  ErrorEventCode[ErrorEventCode["MOTOR_STALL_CONDITION"] = 4111] = "MOTOR_STALL_CONDITION";
	  /**
	   * Invalid state detected.
	   * @public
	   */

	  ErrorEventCode[ErrorEventCode["INVALID_STATE_CONDITION"] = 4112] = "INVALID_STATE_CONDITION";
	  /**
	   * Bad connection detected.
	   * @public
	   */

	  ErrorEventCode[ErrorEventCode["BAD_CONNECTION_CONDITION"] = 4113] = "BAD_CONNECTION_CONDITION";
	  /**
	   * Measurement is above the valid range.
	   * @public
	   */

	  ErrorEventCode[ErrorEventCode["OUT_OF_RANGE_HIGH_CONDITION"] = 4114] = "OUT_OF_RANGE_HIGH_CONDITION";
	  /**
	   * Measurement is below the valid range.
	   * @public
	   */

	  ErrorEventCode[ErrorEventCode["OUT_OF_RANGE_LOW_CONDITION"] = 4115] = "OUT_OF_RANGE_LOW_CONDITION";
	  /**
	   * Fault condition detected.
	   * @public
	   */

	  ErrorEventCode[ErrorEventCode["FAULT"] = 4116] = "FAULT";
	})(exports.ErrorEventCode || (exports.ErrorEventCode = {}));
	/**
	 * Phidget device ID
	 * @public
	 */


	exports.DeviceID = void 0;

	(function (DeviceID) {
	  /**
	   * Unknown device
	   * @internal
	   */
	  DeviceID[DeviceID["NONE"] = 0] = "NONE";
	  /**
	   * Unknown device
	   * @public
	   */

	  DeviceID[DeviceID["UNKNOWN"] = 125] = "UNKNOWN";
	  /**
	   * Hub Port in Digital Input mode
	   * @public
	   */

	  DeviceID[DeviceID["DIGITAL_INPUT_PORT"] = 95] = "DIGITAL_INPUT_PORT";
	  /**
	   * Hub Port in Digital Output mode
	   * @public
	   */

	  DeviceID[DeviceID["DIGITAL_OUTPUT_PORT"] = 96] = "DIGITAL_OUTPUT_PORT";
	  /**
	   * Hub Port in Voltage Input mode
	   * @public
	   */

	  DeviceID[DeviceID["VOLTAGE_INPUT_PORT"] = 97] = "VOLTAGE_INPUT_PORT";
	  /**
	   * Hub Port in Voltage Ratio Input mode
	   * @public
	   */

	  DeviceID[DeviceID["VOLTAGE_RATIO_INPUT_PORT"] = 98] = "VOLTAGE_RATIO_INPUT_PORT";
	  /**
	   * Dictionary
	   * @public
	   */

	  DeviceID[DeviceID["PN_DICTIONARY"] = 111] = "PN_DICTIONARY";
	  /**
	   * PhidgetServo 1-Motor (1000)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1000"] = 2] = "PN_1000";
	  /**
	   * PhidgetServo 4-Motor (1001)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1001"] = 3] = "PN_1001";
	  /**
	   * PhidgetAnalog 4-Output (1002)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1002"] = 4] = "PN_1002";
	  /**
	   * PhidgetAccelerometer 2-Axis (1008)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1008"] = 5] = "PN_1008";
	  /**
	   * PhidgetInterfaceKit 8/8/8 (1010, 1013, 1018, 1019)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1010_1013_1018_1019"] = 6] = "PN_1010_1013_1018_1019";
	  /**
	   * PhidgetInterfaceKit 2/2/2 (1011)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1011"] = 7] = "PN_1011";
	  /**
	   * PhidgetInterfaceKit 0/16/16 (1012)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1012"] = 8] = "PN_1012";
	  /**
	   * PhidgetInterfaceKit 0/0/4 (1014)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1014"] = 9] = "PN_1014";
	  /**
	   * PhidgetLinearTouch (1015)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1015"] = 10] = "PN_1015";
	  /**
	   * PhidgetCircularTouch (1016)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1016"] = 11] = "PN_1016";
	  /**
	   * PhidgetInterfaceKit 0/0/8 (1017)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1017"] = 12] = "PN_1017";
	  /**
	   * PhidgetRFID (1023)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1023"] = 13] = "PN_1023";
	  /**
	   * PhidgetRFID Read-Write (1024)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1024"] = 14] = "PN_1024";
	  /**
	   * PhidgetLED-64 (1030)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1030"] = 15] = "PN_1030";
	  /**
	   * PhidgetLED-64 Advanced (1031)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1031"] = 16] = "PN_1031";
	  /**
	   * PhidgetLED-64 Advanced (1032)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1032"] = 17] = "PN_1032";
	  /**
	   * PhidgetGPS (1040)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1040"] = 18] = "PN_1040";
	  /**
	   * PhidgetSpatial 0/0/3 Basic (1041)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1041"] = 19] = "PN_1041";
	  /**
	   * PhidgetSpatial 3/3/3 Basic (1042)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1042"] = 20] = "PN_1042";
	  /**
	   * PhidgetSpatial Precision 0/0/3 High Resolution (1043)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1043"] = 21] = "PN_1043";
	  /**
	   * PhidgetSpatial Precision 3/3/3 High Resolution (1044)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1044"] = 22] = "PN_1044";
	  /**
	   * PhidgetTemperatureSensor IR (1045)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1045"] = 23] = "PN_1045";
	  /**
	   * PhidgetBridge 4-Input (1046)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1046"] = 24] = "PN_1046";
	  /**
	   * PhidgetEncoder HighSpeed 4-Input (1047)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1047"] = 25] = "PN_1047";
	  /**
	   * PhidgetTemperatureSensor 4-input (1048)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1048"] = 26] = "PN_1048";
	  /**
	   * PhidgetSpatial 0/0/3 (1049)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1049"] = 27] = "PN_1049";
	  /**
	   * PhidgetTemperatureSensor 1-Input (1051)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1051"] = 28] = "PN_1051";
	  /**
	   * PhidgetEncoder Mechanical (1052)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1052"] = 29] = "PN_1052";
	  /**
	   * PhidgetAccelerometer 2-Axis (1053)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1053"] = 30] = "PN_1053";
	  /**
	   * PhidgetFrequencyCounter (1054)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1054"] = 31] = "PN_1054";
	  /**
	   * PhidgetIR (1055)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1055"] = 32] = "PN_1055";
	  /**
	   * PhidgetSpatial 3/3/3 (1056)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1056"] = 33] = "PN_1056";
	  /**
	   * PhidgetEncoder HighSpeed (1057)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1057"] = 34] = "PN_1057";
	  /**
	   * PhidgetPHSensor (1058)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1058"] = 35] = "PN_1058";
	  /**
	   * PhidgetAccelerometer 3-Axis (1059)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1059"] = 36] = "PN_1059";
	  /**
	   * PhidgetMotorControl LV (1060)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1060"] = 37] = "PN_1060";
	  /**
	   * PhidgetAdvancedServo 8-Motor (1061)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1061"] = 38] = "PN_1061";
	  /**
	   * PhidgetStepper Unipolar 4-Motor (1062)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1062"] = 39] = "PN_1062";
	  /**
	   * PhidgetStepper Bipolar 1-Motor (1063)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1063"] = 40] = "PN_1063";
	  /**
	   * PhidgetMotorControl HC (1064)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1064"] = 41] = "PN_1064";
	  /**
	   * PhidgetMotorControl 1-Motor (1065)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1065"] = 42] = "PN_1065";
	  /**
	   * PhidgetAdvancedServo 1-Motor (1066)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1066"] = 43] = "PN_1066";
	  /**
	   * PhidgetStepper Bipolar HC (1067)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1067"] = 44] = "PN_1067";
	  /**
	   * PhidgetTextLCD 20x2 with PhidgetInterfaceKit 8/8/8 (1202, 1203)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1202_1203"] = 45] = "PN_1202_1203";
	  /**
	   * PhidgetTextLCD Adapter (1204)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1204"] = 46] = "PN_1204";
	  /**
	   * PhidgetTextLCD 20x2 (1215, 1216, 1217, 1218)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1215__1218"] = 47] = "PN_1215__1218";
	  /**
	   * PhidgetTextLCD 20x2 with PhidgetInterfaceKit 0/8/8 (1219, 1220, 1221, 1222)
	   * @public
	   */

	  DeviceID[DeviceID["PN_1219__1222"] = 48] = "PN_1219__1222";
	  /**
	   * pH Adapter
	   * @public
	   */

	  DeviceID[DeviceID["PN_ADP1000"] = 49] = "PN_ADP1000";
	  /**
	   * Analog Input Module x8
	   * @public
	   */

	  DeviceID[DeviceID["PN_DAQ1000"] = 51] = "PN_DAQ1000";
	  /**
	   * Digital Input 4
	   * @public
	   */

	  DeviceID[DeviceID["PN_DAQ1200"] = 52] = "PN_DAQ1200";
	  /**
	   * Digital Input 4 Isolated
	   * @public
	   */

	  DeviceID[DeviceID["PN_DAQ1300"] = 53] = "PN_DAQ1300";
	  /**
	   * Digital Input 16
	   * @public
	   */

	  DeviceID[DeviceID["PN_DAQ1301"] = 54] = "PN_DAQ1301";
	  /**
	   * Versatile Input
	   * @public
	   */

	  DeviceID[DeviceID["PN_DAQ1400"] = 55] = "PN_DAQ1400";
	  /**
	   * Bridge
	   * @public
	   */

	  DeviceID[DeviceID["PN_DAQ1500"] = 56] = "PN_DAQ1500";
	  /**
	   * DC Motor Controller with PID
	   * @public
	   */

	  DeviceID[DeviceID["PN_DCC1000"] = 57] = "PN_DCC1000";
	  /**
	   * Small DC Motor Controller
	   * @public
	   */

	  DeviceID[DeviceID["PN_DCC1001"] = 110] = "PN_DCC1001";
	  /**
	   * 4A Small DC Motor Controller
	   * @public
	   */

	  DeviceID[DeviceID["PN_DCC1002"] = 117] = "PN_DCC1002";
	  /**
	   * 2 Channel DC Motor Controller
	   * @public
	   */

	  DeviceID[DeviceID["PN_DCC1003"] = 120] = "PN_DCC1003";
	  /**
	   * BLDC Motor Controller
	   * @public
	   */

	  DeviceID[DeviceID["PN_DCC1100"] = 108] = "PN_DCC1100";
	  /**
	   * 200mm Distance Sensor
	   * @public
	   */

	  DeviceID[DeviceID["PN_DST1000"] = 58] = "PN_DST1000";
	  /**
	   * 650mm distance sensor
	   * @public
	   */

	  DeviceID[DeviceID["PN_DST1001"] = 121] = "PN_DST1001";
	  /**
	   * 1200mm distance sensor
	   * @public
	   */

	  DeviceID[DeviceID["PN_DST1002"] = 126] = "PN_DST1002";
	  /**
	   * Sonar Distance Sensor
	   * @public
	   */

	  DeviceID[DeviceID["PN_DST1200"] = 59] = "PN_DST1200";
	  /**
	   * Encoder
	   * @public
	   */

	  DeviceID[DeviceID["PN_ENC1000"] = 60] = "PN_ENC1000";
	  /**
	   * Phidget SPI device under firmware upgrade
	   * @internal
	   */

	  DeviceID[DeviceID["FIRMWARE_UPGRADE_SPI"] = 104] = "FIRMWARE_UPGRADE_SPI";
	  /**
	   * VINT Device in firmware upgrade mode, STM32F0 Proc.
	   * @internal
	   */

	  DeviceID[DeviceID["FIRMWARE_UPGRADE_STM32F0"] = 102] = "FIRMWARE_UPGRADE_STM32F0";
	  /**
	   * VINT Device in firmware upgrade mode, STM32F3 Proc.
	   * @internal
	   */

	  DeviceID[DeviceID["FIRMWARE_UPGRADE_STM32F3"] = 145] = "FIRMWARE_UPGRADE_STM32F3";
	  /**
	   * VINT Device in firmware upgrade mode, STM32G0 Proc.
	   * @internal
	   */

	  DeviceID[DeviceID["FIRMWARE_UPGRADE_STM32G0"] = 143] = "FIRMWARE_UPGRADE_STM32G0";
	  /**
	   * VINT Device in firmware upgrade mode, STM8S Proc.
	   * @internal
	   */

	  DeviceID[DeviceID["FIRMWARE_UPGRADE_STM8S"] = 103] = "FIRMWARE_UPGRADE_STM8S";
	  /**
	   * USB device in firmware upgrade mode
	   * @internal
	   */

	  DeviceID[DeviceID["FIRMWARE_UPGRADE_USB"] = 101] = "FIRMWARE_UPGRADE_USB";
	  /**
	   * Capacitive Touch Sensor
	   * @public
	   */

	  DeviceID[DeviceID["PN_HIN1000"] = 61] = "PN_HIN1000";
	  /**
	   * Capacitive Scroll
	   * @public
	   */

	  DeviceID[DeviceID["PN_HIN1001"] = 62] = "PN_HIN1001";
	  /**
	   * Joystick
	   * @public
	   */

	  DeviceID[DeviceID["PN_HIN1100"] = 63] = "PN_HIN1100";
	  /**
	   * Dial Encoder
	   * @public
	   */

	  DeviceID[DeviceID["PN_HIN1101"] = 109] = "PN_HIN1101";
	  /**
	   * Phidget USB VINT Hub with 6 ports
	   * @public
	   */

	  DeviceID[DeviceID["PN_HUB0000"] = 64] = "PN_HUB0000";
	  /**
	   * Phidget USB VINT Hub with 6 ports
	   * @public
	   */

	  DeviceID[DeviceID["PN_HUB0001"] = 142] = "PN_HUB0001";
	  /**
	   * Phidget SPI VINT Hub with 6 ports
	   * @public
	   */

	  DeviceID[DeviceID["PN_HUB0004"] = 67] = "PN_HUB0004";
	  /**
	   * Phidget Network Hub with 6 ports
	   * @public
	   */

	  DeviceID[DeviceID["PN_HUB5000"] = 123] = "PN_HUB5000";
	  /**
	   * Humidity Sensor
	   * @public
	   */

	  DeviceID[DeviceID["PN_HUM1000"] = 69] = "PN_HUM1000";
	  /**
	   * Humidity Sensor
	   * @public
	   */

	  DeviceID[DeviceID["PN_HUM1001"] = 127] = "PN_HUM1001";
	  /**
	   * VINT Moisture Sensor
	   * @public
	   */

	  DeviceID[DeviceID["PN_HUM1100"] = 136] = "PN_HUM1100";
	  /**
	   * PhidgetInterfaceKit 4/8/8
	   * @internal
	   */

	  DeviceID[DeviceID["PN_INTERFACE_KIT488"] = 1] = "PN_INTERFACE_KIT488";
	  /**
	   * LCD
	   * @public
	   */

	  DeviceID[DeviceID["PN_LCD1100"] = 70] = "PN_LCD1100";
	  /**
	   * LED Driver 32
	   * @public
	   */

	  DeviceID[DeviceID["PN_LED1000"] = 71] = "PN_LED1000";
	  /**
	   * Light Sensor
	   * @public
	   */

	  DeviceID[DeviceID["PN_LUX1000"] = 72] = "PN_LUX1000";
	  /**
	   * Phidget Accelerometer
	   * @public
	   */

	  DeviceID[DeviceID["PN_MOT0100"] = 146] = "PN_MOT0100";
	  /**
	   * PhidgetSpatial Precision 3/3/3
	   * @public
	   */

	  DeviceID[DeviceID["PN_MOT0109"] = 140] = "PN_MOT0109";
	  /**
	   * PhidgetSpatial Precision 3/3/3
	   * @public
	   */

	  DeviceID[DeviceID["PN_MOT0110"] = 141] = "PN_MOT0110";
	  /**
	   * Accelerometer 0/0/3
	   * @public
	   */

	  DeviceID[DeviceID["PN_MOT1100"] = 73] = "PN_MOT1100";
	  /**
	   * Spatial 3/3/3
	   * @public
	   */

	  DeviceID[DeviceID["PN_MOT1101"] = 74] = "PN_MOT1101";
	  /**
	   * VINT Spatial Phidget AHRS
	   * @public
	   */

	  DeviceID[DeviceID["PN_MOT1102"] = 137] = "PN_MOT1102";
	  /**
	   * Analog Output 0-5V
	   * @public
	   */

	  DeviceID[DeviceID["PN_OUT1000"] = 75] = "PN_OUT1000";
	  /**
	   * Analog Output (+/-)10V
	   * @public
	   */

	  DeviceID[DeviceID["PN_OUT1001"] = 76] = "PN_OUT1001";
	  /**
	   * Analog Output (+/-)10V - 16 bit
	   * @public
	   */

	  DeviceID[DeviceID["PN_OUT1002"] = 77] = "PN_OUT1002";
	  /**
	   * Digital Output 4
	   * @public
	   */

	  DeviceID[DeviceID["PN_OUT1100"] = 78] = "PN_OUT1100";
	  /**
	   * Barometer
	   * @public
	   */

	  DeviceID[DeviceID["PN_PRE1000"] = 79] = "PN_PRE1000";
	  /**
	   * PhidgetAdvancedServo 8-Motor
	   * @public
	   */

	  DeviceID[DeviceID["PN_RCC0004"] = 124] = "PN_RCC0004";
	  /**
	   * 8-Servo Controller
	   * @public
	   */

	  DeviceID[DeviceID["PN_RCC1000"] = 80] = "PN_RCC1000";
	  /**
	   * Power Relay 4
	   * @public
	   */

	  DeviceID[DeviceID["PN_REL1000"] = 81] = "PN_REL1000";
	  /**
	   * Digital Output 4 Isolated
	   * @public
	   */

	  DeviceID[DeviceID["PN_REL1100"] = 82] = "PN_REL1100";
	  /**
	   * Digital Output 16 Isolated
	   * @public
	   */

	  DeviceID[DeviceID["PN_REL1101"] = 83] = "PN_REL1101";
	  /**
	   * Power Supply Protector
	   * @public
	   */

	  DeviceID[DeviceID["PN_SAF1000"] = 84] = "PN_SAF1000";
	  /**
	   * Sound Pressure Level Sensor
	   * @public
	   */

	  DeviceID[DeviceID["PN_SND1000"] = 85] = "PN_SND1000";
	  /**
	   * Bipolar Stepper Motor Controller
	   * @public
	   */

	  DeviceID[DeviceID["PN_STC1000"] = 86] = "PN_STC1000";
	  /**
	   * Bipolar Stepper Motor SmallController
	   * @public
	   */

	  DeviceID[DeviceID["PN_STC1001"] = 115] = "PN_STC1001";
	  /**
	   * 8A Bipolar Stepper Motor Controller
	   * @public
	   */

	  DeviceID[DeviceID["PN_STC1002"] = 118] = "PN_STC1002";
	  /**
	   * 4A Bipolar Stepper Motor SmallController
	   * @public
	   */

	  DeviceID[DeviceID["PN_STC1003"] = 119] = "PN_STC1003";
	  /**
	   * 4A Bipolar Stepper Motor SmallController
	   * @public
	   */

	  DeviceID[DeviceID["PN_STC1005"] = 149] = "PN_STC1005";
	  /**
	   * Integrated Temperature Sensor
	   * @public
	   */

	  DeviceID[DeviceID["PN_TMP1000"] = 87] = "PN_TMP1000";
	  /**
	   * Thermocouple 1
	   * @public
	   */

	  DeviceID[DeviceID["PN_TMP1100"] = 88] = "PN_TMP1100";
	  /**
	   * Thermocouple 4
	   * @public
	   */

	  DeviceID[DeviceID["PN_TMP1101"] = 89] = "PN_TMP1101";
	  /**
	   * RTD
	   * @public
	   */

	  DeviceID[DeviceID["PN_TMP1200"] = 90] = "PN_TMP1200";
	  /**
	   * Voltage Sensor High Precision
	   * @public
	   */

	  DeviceID[DeviceID["PN_VCP1000"] = 92] = "PN_VCP1000";
	  /**
	   * Voltage Sensor Large
	   * @public
	   */

	  DeviceID[DeviceID["PN_VCP1001"] = 93] = "PN_VCP1001";
	  /**
	   * Voltage Sensor Small
	   * @public
	   */

	  DeviceID[DeviceID["PN_VCP1002"] = 94] = "PN_VCP1002";
	  /**
	   * 30A Current Sensor
	   * @public
	   */

	  DeviceID[DeviceID["PN_VCP1100"] = 105] = "PN_VCP1100";
	})(exports.DeviceID || (exports.DeviceID = {}));
	/**
	 * Phidget logging level
	 * @public
	 */


	exports.LogLevel = void 0;

	(function (LogLevel) {
	  /**
	   * Critical
	   * @public
	   */
	  LogLevel[LogLevel["CRITICAL"] = 1] = "CRITICAL";
	  /**
	   * Error
	   * @public
	   */

	  LogLevel[LogLevel["ERROR"] = 2] = "ERROR";
	  /**
	   * Warning
	   * @public
	   */

	  LogLevel[LogLevel["WARNING"] = 3] = "WARNING";
	  /**
	   * Info
	   * @public
	   */

	  LogLevel[LogLevel["INFO"] = 4] = "INFO";
	  /**
	   * Debug
	   * @public
	   */

	  LogLevel[LogLevel["DEBUG"] = 5] = "DEBUG";
	  /**
	   * Verbose
	   * @public
	   */

	  LogLevel[LogLevel["VERBOSE"] = 6] = "VERBOSE";
	})(exports.LogLevel || (exports.LogLevel = {}));
	/**
	 * Phidget device class
	 * @public
	 */


	exports.DeviceClass = void 0;

	(function (DeviceClass) {
	  /**
	   * Any device
	   * @internal
	   */
	  DeviceClass[DeviceClass["NONE"] = 0] = "NONE";
	  /**
	   * PhidgetAccelerometer device
	   * @public
	   */

	  DeviceClass[DeviceClass["ACCELEROMETER"] = 1] = "ACCELEROMETER";
	  /**
	   * PhidgetAdvancedServo device
	   * @public
	   */

	  DeviceClass[DeviceClass["ADVANCED_SERVO"] = 2] = "ADVANCED_SERVO";
	  /**
	   * PhidgetAnalog device
	   * @public
	   */

	  DeviceClass[DeviceClass["ANALOG"] = 3] = "ANALOG";
	  /**
	   * PhidgetBridge device
	   * @public
	   */

	  DeviceClass[DeviceClass["BRIDGE"] = 4] = "BRIDGE";
	  /**
	   * PhidgetDataAdapter device
	   * @internal
	   */

	  DeviceClass[DeviceClass["DATA_ADAPTER"] = 25] = "DATA_ADAPTER";
	  /**
	   * Dictionary device
	   * @public
	   */

	  DeviceClass[DeviceClass["DICTIONARY"] = 24] = "DICTIONARY";
	  /**
	   * PhidgetEncoder device
	   * @public
	   */

	  DeviceClass[DeviceClass["ENCODER"] = 5] = "ENCODER";
	  /**
	   * Phidget device in Firmware Upgrade mode
	   * @internal
	   */

	  DeviceClass[DeviceClass["FIRMWARE_UPGRADE"] = 23] = "FIRMWARE_UPGRADE";
	  /**
	   * PhidgetFrequencyCounter device
	   * @public
	   */

	  DeviceClass[DeviceClass["FREQUENCY_COUNTER"] = 6] = "FREQUENCY_COUNTER";
	  /**
	   * Generic device
	   * @internal
	   */

	  DeviceClass[DeviceClass["GENERIC"] = 22] = "GENERIC";
	  /**
	   * PhidgetGPS device
	   * @public
	   */

	  DeviceClass[DeviceClass["GPS"] = 7] = "GPS";
	  /**
	   * Phidget VINT Hub device
	   * @public
	   */

	  DeviceClass[DeviceClass["HUB"] = 8] = "HUB";
	  /**
	   * PhidgetInterfaceKit device
	   * @public
	   */

	  DeviceClass[DeviceClass["INTERFACE_KIT"] = 9] = "INTERFACE_KIT";
	  /**
	   * PhidgetIR device
	   * @public
	   */

	  DeviceClass[DeviceClass["IR"] = 10] = "IR";
	  /**
	   * PhidgetLED device
	   * @public
	   */

	  DeviceClass[DeviceClass["LED"] = 11] = "LED";
	  /**
	   * Phidget Mesh Dongle
	   * @internal
	   */

	  DeviceClass[DeviceClass["MESH_DONGLE"] = 12] = "MESH_DONGLE";
	  /**
	   * PhidgetMotorControl device
	   * @public
	   */

	  DeviceClass[DeviceClass["MOTOR_CONTROL"] = 13] = "MOTOR_CONTROL";
	  /**
	   * PhidgetPHSensor device
	   * @public
	   */

	  DeviceClass[DeviceClass["PH_SENSOR"] = 14] = "PH_SENSOR";
	  /**
	   * PhidgetRFID device
	   * @public
	   */

	  DeviceClass[DeviceClass["RFID"] = 15] = "RFID";
	  /**
	   * PhidgetServo device
	   * @public
	   */

	  DeviceClass[DeviceClass["SERVO"] = 16] = "SERVO";
	  /**
	   * PhidgetSpatial device
	   * @public
	   */

	  DeviceClass[DeviceClass["SPATIAL"] = 17] = "SPATIAL";
	  /**
	   * PhidgetStepper device
	   * @public
	   */

	  DeviceClass[DeviceClass["STEPPER"] = 18] = "STEPPER";
	  /**
	   * PhidgetTemperatureSensor device
	   * @public
	   */

	  DeviceClass[DeviceClass["TEMPERATURE_SENSOR"] = 19] = "TEMPERATURE_SENSOR";
	  /**
	   * PhidgetTextLCD device
	   * @public
	   */

	  DeviceClass[DeviceClass["TEXT_LCD"] = 20] = "TEXT_LCD";
	  /**
	   * Phidget VINT device
	   * @public
	   */

	  DeviceClass[DeviceClass["VINT"] = 21] = "VINT";
	})(exports.DeviceClass || (exports.DeviceClass = {}));
	/**
	 * Phidget channel class
	 * @public
	 */


	exports.ChannelClass = void 0;

	(function (ChannelClass) {
	  /**
	   * Any channel
	   * @internal
	   */
	  ChannelClass[ChannelClass["NONE"] = 0] = "NONE";
	  /**
	   * Accelerometer channel
	   * @public
	   */

	  ChannelClass[ChannelClass["ACCELEROMETER"] = 1] = "ACCELEROMETER";
	  /**
	   * BLDC motor channel
	   * @public
	   */

	  ChannelClass[ChannelClass["BLDC_MOTOR"] = 35] = "BLDC_MOTOR";
	  /**
	   * Capacitive Touch channel
	   * @public
	   */

	  ChannelClass[ChannelClass["CAPACITIVE_TOUCH"] = 14] = "CAPACITIVE_TOUCH";
	  /**
	   * Current input channel
	   * @public
	   */

	  ChannelClass[ChannelClass["CURRENT_INPUT"] = 2] = "CURRENT_INPUT";
	  /**
	   * Current output channel
	   * @internal
	   */

	  ChannelClass[ChannelClass["CURRENT_OUTPUT"] = 38] = "CURRENT_OUTPUT";
	  /**
	   * Data adapter channel
	   * @internal
	   */

	  ChannelClass[ChannelClass["DATA_ADAPTER"] = 3] = "DATA_ADAPTER";
	  /**
	   * DC motor channel
	   * @public
	   */

	  ChannelClass[ChannelClass["DC_MOTOR"] = 4] = "DC_MOTOR";
	  /**
	   * Dictionary
	   * @public
	   */

	  ChannelClass[ChannelClass["DICTIONARY"] = 36] = "DICTIONARY";
	  /**
	   * Digital input channel
	   * @public
	   */

	  ChannelClass[ChannelClass["DIGITAL_INPUT"] = 5] = "DIGITAL_INPUT";
	  /**
	   * Digital output channel
	   * @public
	   */

	  ChannelClass[ChannelClass["DIGITAL_OUTPUT"] = 6] = "DIGITAL_OUTPUT";
	  /**
	   * Distance sensor channel
	   * @public
	   */

	  ChannelClass[ChannelClass["DISTANCE_SENSOR"] = 7] = "DISTANCE_SENSOR";
	  /**
	   * Encoder channel
	   * @public
	   */

	  ChannelClass[ChannelClass["ENCODER"] = 8] = "ENCODER";
	  /**
	   * Firmware upgrade channel
	   * @internal
	   */

	  ChannelClass[ChannelClass["FIRMWARE_UPGRADE"] = 32] = "FIRMWARE_UPGRADE";
	  /**
	   * Frequency counter channel
	   * @public
	   */

	  ChannelClass[ChannelClass["FREQUENCY_COUNTER"] = 9] = "FREQUENCY_COUNTER";
	  /**
	   * Generic channel
	   * @internal
	   */

	  ChannelClass[ChannelClass["GENERIC"] = 33] = "GENERIC";
	  /**
	   * GPS channel
	   * @public
	   */

	  ChannelClass[ChannelClass["GPS"] = 10] = "GPS";
	  /**
	   * Gyroscope channel
	   * @public
	   */

	  ChannelClass[ChannelClass["GYROSCOPE"] = 12] = "GYROSCOPE";
	  /**
	   * VINT Hub channel
	   * @public
	   */

	  ChannelClass[ChannelClass["HUB"] = 13] = "HUB";
	  /**
	   * Humidity sensor channel
	   * @public
	   */

	  ChannelClass[ChannelClass["HUMIDITY_SENSOR"] = 15] = "HUMIDITY_SENSOR";
	  /**
	   * IR channel
	   * @public
	   */

	  ChannelClass[ChannelClass["IR"] = 16] = "IR";
	  /**
	   * LCD channel
	   * @public
	   */

	  ChannelClass[ChannelClass["LCD"] = 11] = "LCD";
	  /**
	   * Light sensor channel
	   * @public
	   */

	  ChannelClass[ChannelClass["LIGHT_SENSOR"] = 17] = "LIGHT_SENSOR";
	  /**
	   * Magnetometer channel
	   * @public
	   */

	  ChannelClass[ChannelClass["MAGNETOMETER"] = 18] = "MAGNETOMETER";
	  /**
	   * Mesh dongle channel
	   * @internal
	   */

	  ChannelClass[ChannelClass["MESH_DONGLE"] = 19] = "MESH_DONGLE";
	  /**
	   * Motor position control channel.
	   * @public
	   */

	  ChannelClass[ChannelClass["MOTOR_POSITION_CONTROLLER"] = 34] = "MOTOR_POSITION_CONTROLLER";
	  /**
	   * pH sensor channel
	   * @public
	   */

	  ChannelClass[ChannelClass["PH_SENSOR"] = 37] = "PH_SENSOR";
	  /**
	   * Power guard channel
	   * @public
	   */

	  ChannelClass[ChannelClass["POWER_GUARD"] = 20] = "POWER_GUARD";
	  /**
	   * Pressure sensor channel
	   * @public
	   */

	  ChannelClass[ChannelClass["PRESSURE_SENSOR"] = 21] = "PRESSURE_SENSOR";
	  /**
	   * RC Servo channel
	   * @public
	   */

	  ChannelClass[ChannelClass["RC_SERVO"] = 22] = "RC_SERVO";
	  /**
	   * Resistance input channel
	   * @public
	   */

	  ChannelClass[ChannelClass["RESISTANCE_INPUT"] = 23] = "RESISTANCE_INPUT";
	  /**
	   * RFID channel
	   * @public
	   */

	  ChannelClass[ChannelClass["RFID"] = 24] = "RFID";
	  /**
	   * Sound sensor channel
	   * @public
	   */

	  ChannelClass[ChannelClass["SOUND_SENSOR"] = 25] = "SOUND_SENSOR";
	  /**
	   * Spatial channel
	   * @public
	   */

	  ChannelClass[ChannelClass["SPATIAL"] = 26] = "SPATIAL";
	  /**
	   * Stepper channel
	   * @public
	   */

	  ChannelClass[ChannelClass["STEPPER"] = 27] = "STEPPER";
	  /**
	   * Temperature sensor channel
	   * @public
	   */

	  ChannelClass[ChannelClass["TEMPERATURE_SENSOR"] = 28] = "TEMPERATURE_SENSOR";
	  /**
	   * Voltage input channel
	   * @public
	   */

	  ChannelClass[ChannelClass["VOLTAGE_INPUT"] = 29] = "VOLTAGE_INPUT";
	  /**
	   * Voltage output channel
	   * @public
	   */

	  ChannelClass[ChannelClass["VOLTAGE_OUTPUT"] = 30] = "VOLTAGE_OUTPUT";
	  /**
	   * Voltage ratio input channel
	   * @public
	   */

	  ChannelClass[ChannelClass["VOLTAGE_RATIO_INPUT"] = 31] = "VOLTAGE_RATIO_INPUT";
	})(exports.ChannelClass || (exports.ChannelClass = {}));
	/**
	 * Phidget channel sub class
	 * @public
	 */


	exports.ChannelSubclass = void 0;

	(function (ChannelSubclass) {
	  /**
	   * No subclass
	   * @public
	   */
	  ChannelSubclass[ChannelSubclass["NONE"] = 1] = "NONE";
	  /**
	   * Digital output duty cycle
	   * @public
	   */

	  ChannelSubclass[ChannelSubclass["DIGITAL_OUTPUT_DUTY_CYCLE"] = 16] = "DIGITAL_OUTPUT_DUTY_CYCLE";
	  /**
	   * Digital output frequency
	   * @public
	   */

	  ChannelSubclass[ChannelSubclass["DIGITAL_OUTPUT_FREQUENCY"] = 18] = "DIGITAL_OUTPUT_FREQUENCY";
	  /**
	   * Digital output LED driver
	   * @public
	   */

	  ChannelSubclass[ChannelSubclass["DIGITAL_OUTPUT_LEDDRIVER"] = 17] = "DIGITAL_OUTPUT_LEDDRIVER";
	  /**
	   * Encoder IO mode settable
	   * @public
	   */

	  ChannelSubclass[ChannelSubclass["ENCODER_MODE_SETTABLE"] = 96] = "ENCODER_MODE_SETTABLE";
	  /**
	   * Graphic LCD
	   * @public
	   */

	  ChannelSubclass[ChannelSubclass["LCD_GRAPHIC"] = 80] = "LCD_GRAPHIC";
	  /**
	   * Text LCD
	   * @public
	   */

	  ChannelSubclass[ChannelSubclass["LCD_TEXT"] = 81] = "LCD_TEXT";
	  /**
	   * Spatial AHRS/IMU
	   * @public
	   */

	  ChannelSubclass[ChannelSubclass["SPATIAL_AHRS"] = 112] = "SPATIAL_AHRS";
	  /**
	   * Temperature sensor RTD
	   * @public
	   */

	  ChannelSubclass[ChannelSubclass["TEMPERATURE_SENSOR_RTD"] = 32] = "TEMPERATURE_SENSOR_RTD";
	  /**
	   * Temperature sensor thermocouple
	   * @public
	   */

	  ChannelSubclass[ChannelSubclass["TEMPERATURE_SENSOR_THERMOCOUPLE"] = 33] = "TEMPERATURE_SENSOR_THERMOCOUPLE";
	  /**
	   * Voltage sensor port
	   * @public
	   */

	  ChannelSubclass[ChannelSubclass["VOLTAGE_INPUT_SENSOR_PORT"] = 48] = "VOLTAGE_INPUT_SENSOR_PORT";
	  /**
	   * Voltage ratio bridge input
	   * @public
	   */

	  ChannelSubclass[ChannelSubclass["VOLTAGE_RATIO_INPUT_BRIDGE"] = 65] = "VOLTAGE_RATIO_INPUT_BRIDGE";
	  /**
	   * Voltage ratio sensor port
	   * @public
	   */

	  ChannelSubclass[ChannelSubclass["VOLTAGE_RATIO_INPUT_SENSOR_PORT"] = 64] = "VOLTAGE_RATIO_INPUT_SENSOR_PORT";
	})(exports.ChannelSubclass || (exports.ChannelSubclass = {}));
	/**
	 * Phidget mesh mode
	 * @public
	 */


	exports.MeshMode = void 0;

	(function (MeshMode) {
	  /**
	   * Router mode
	   * @public
	   */
	  MeshMode[MeshMode["ROUTER"] = 1] = "ROUTER";
	  /**
	   * Sleepy end device mode
	   * @public
	   */

	  MeshMode[MeshMode["SLEEPY_END_DEVICE"] = 2] = "SLEEPY_END_DEVICE";
	})(exports.MeshMode || (exports.MeshMode = {}));
	/**
	 * The voltage level being provided to the sensor
	 * @public
	 */


	exports.PowerSupply = void 0;

	(function (PowerSupply) {
	  /**
	   * Switch the sensor power supply off
	   * @public
	   */
	  PowerSupply[PowerSupply["OFF"] = 1] = "OFF";
	  /**
	   * The sensor is provided with 12 volts
	   * @public
	   */

	  PowerSupply[PowerSupply["VOLTS_12"] = 2] = "VOLTS_12";
	  /**
	   * The sensor is provided with 24 volts
	   * @public
	   */

	  PowerSupply[PowerSupply["VOLTS_24"] = 3] = "VOLTS_24";
	})(exports.PowerSupply || (exports.PowerSupply = {}));
	/**
	 * RTD wiring configuration
	 * @public
	 */


	exports.RTDWireSetup = void 0;

	(function (RTDWireSetup) {
	  /**
	   * Configures the device to make resistance calculations based on a 2-wire RTD setup.
	   * @public
	   */
	  RTDWireSetup[RTDWireSetup["WIRES_2"] = 1] = "WIRES_2";
	  /**
	   * Configures the device to make resistance calculations based on a 3-wire RTD setup.
	   * @public
	   */

	  RTDWireSetup[RTDWireSetup["WIRES_3"] = 2] = "WIRES_3";
	  /**
	   * Configures the device to make resistance calculations based on a 4-wire RTD setup.
	   * @public
	   */

	  RTDWireSetup[RTDWireSetup["WIRES_4"] = 3] = "WIRES_4";
	})(exports.RTDWireSetup || (exports.RTDWireSetup = {}));
	/**
	 * The selected polarity mode for the digital input
	 * @public
	 */


	exports.InputMode = void 0;

	(function (InputMode) {
	  /**
	   * For interfacing NPN digital sensors
	   * @public
	   */
	  InputMode[InputMode["NPN"] = 1] = "NPN";
	  /**
	   * For interfacing PNP digital sensors
	   * @public
	   */

	  InputMode[InputMode["PNP"] = 2] = "PNP";
	})(exports.InputMode || (exports.InputMode = {}));
	/**
	 * The operating condition of the fan. Choose between on, off, or automatic (based on temperature).
	 * @public
	 */


	exports.FanMode = void 0;

	(function (FanMode) {
	  /**
	   * Turns the fan off.
	   * @public
	   */
	  FanMode[FanMode["OFF"] = 1] = "OFF";
	  /**
	   * Turns the fan on.
	   * @public
	   */

	  FanMode[FanMode["ON"] = 2] = "ON";
	  /**
	   * The fan will be automatically controlled based on temperature.
	   * @public
	   */

	  FanMode[FanMode["AUTO"] = 3] = "AUTO";
	})(exports.FanMode || (exports.FanMode = {}));
	/**
	 * Controls how data from primary and backup sptial sensing chips are used.
	 * @public
	 */


	exports.SpatialPrecision = void 0;

	(function (SpatialPrecision) {
	  /**
	   * High precision sensor is used when possible, fallback to low precision sensor.
	   * @public
	   */
	  SpatialPrecision[SpatialPrecision["HYBRID"] = 0] = "HYBRID";
	  /**
	   * High precision sensor is always used.
	   * @public
	   */

	  SpatialPrecision[SpatialPrecision["HIGH"] = 1] = "HIGH";
	  /**
	   * Low precision sensor is always used.
	   * @public
	   */

	  SpatialPrecision[SpatialPrecision["LOW"] = 2] = "LOW";
	})(exports.SpatialPrecision || (exports.SpatialPrecision = {}));
	/**
	 * Analog sensor units. These correspond to the types of quantities that can be measured by Phidget analog sensors.
	 * @public
	 */


	exports.Unit = void 0;

	(function (Unit) {
	  /**
	   * Unitless
	   * @public
	   */
	  Unit[Unit["NONE"] = 0] = "NONE";
	  /**
	   * Boolean
	   * @public
	   */

	  Unit[Unit["BOOLEAN"] = 1] = "BOOLEAN";
	  /**
	   * Percent
	   * @public
	   */

	  Unit[Unit["PERCENT"] = 2] = "PERCENT";
	  /**
	   * Decibel
	   * @public
	   */

	  Unit[Unit["DECIBEL"] = 3] = "DECIBEL";
	  /**
	   * Millimeter
	   * @public
	   */

	  Unit[Unit["MILLIMETER"] = 4] = "MILLIMETER";
	  /**
	   * Centimeter
	   * @public
	   */

	  Unit[Unit["CENTIMETER"] = 5] = "CENTIMETER";
	  /**
	   * Meter
	   * @public
	   */

	  Unit[Unit["METER"] = 6] = "METER";
	  /**
	   * Gram
	   * @public
	   */

	  Unit[Unit["GRAM"] = 7] = "GRAM";
	  /**
	   * Kilogram
	   * @public
	   */

	  Unit[Unit["KILOGRAM"] = 8] = "KILOGRAM";
	  /**
	   * Milliampere
	   * @public
	   */

	  Unit[Unit["MILLIAMPERE"] = 9] = "MILLIAMPERE";
	  /**
	   * Ampere
	   * @public
	   */

	  Unit[Unit["AMPERE"] = 10] = "AMPERE";
	  /**
	   * Kilopascal
	   * @public
	   */

	  Unit[Unit["KILOPASCAL"] = 11] = "KILOPASCAL";
	  /**
	   * Volt
	   * @public
	   */

	  Unit[Unit["VOLT"] = 12] = "VOLT";
	  /**
	   * Degree Celcius
	   * @public
	   */

	  Unit[Unit["DEGREE_CELCIUS"] = 13] = "DEGREE_CELCIUS";
	  /**
	   * Lux
	   * @public
	   */

	  Unit[Unit["LUX"] = 14] = "LUX";
	  /**
	   * Gauss
	   * @public
	   */

	  Unit[Unit["GAUSS"] = 15] = "GAUSS";
	  /**
	   * pH
	   * @public
	   */

	  Unit[Unit["PH"] = 16] = "PH";
	  /**
	   * Watt
	   * @public
	   */

	  Unit[Unit["WATT"] = 17] = "WATT";
	})(exports.Unit || (exports.Unit = {}));
	/**
	 * Bridge gain amplification setting. Higher gain results in better resolution, but narrower voltage range.
	 * @public
	 */


	exports.BridgeGain = void 0;

	(function (BridgeGain) {
	  /**
	   * 1x Amplificaion
	   * @public
	   */
	  BridgeGain[BridgeGain["GAIN_1X"] = 1] = "GAIN_1X";
	  /**
	   * 2x Amplification
	   * @public
	   */

	  BridgeGain[BridgeGain["GAIN_2X"] = 2] = "GAIN_2X";
	  /**
	   * 4x Amplification
	   * @public
	   */

	  BridgeGain[BridgeGain["GAIN_4X"] = 3] = "GAIN_4X";
	  /**
	   * 8x Amplification
	   * @public
	   */

	  BridgeGain[BridgeGain["GAIN_8X"] = 4] = "GAIN_8X";
	  /**
	   * 16x Amplification
	   * @public
	   */

	  BridgeGain[BridgeGain["GAIN_16X"] = 5] = "GAIN_16X";
	  /**
	   * 32x Amplification
	   * @public
	   */

	  BridgeGain[BridgeGain["GAIN_32X"] = 6] = "GAIN_32X";
	  /**
	   * 64x Amplification
	   * @public
	   */

	  BridgeGain[BridgeGain["GAIN_64X"] = 7] = "GAIN_64X";
	  /**
	   * 128x Amplification
	   * @public
	   */

	  BridgeGain[BridgeGain["GAIN_128X"] = 8] = "GAIN_128X";
	})(exports.BridgeGain || (exports.BridgeGain = {}));
	/**
	 * The type of sensor attached to the voltage ratio input
	 * @public
	 */


	exports.VoltageRatioSensorType = void 0;

	(function (VoltageRatioSensorType) {
	  /**
	   * Default. Configures the channel to be a generic ratiometric sensor. Unit is volts/volt.
	   * @public
	   */
	  VoltageRatioSensorType[VoltageRatioSensorType["VOLTAGE_RATIO"] = 0] = "VOLTAGE_RATIO";
	  /**
	   * 1101 - IR Distance Adapter, with Sharp Distance Sensor 2D120X (4-30cm)
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1101_SHARP2D120X"] = 11011] = "PN_1101_SHARP2D120X";
	  /**
	   * 1101 - IR Distance Adapter, with Sharp Distance Sensor 2Y0A21 (10-80cm)
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1101_SHARP2Y0A21"] = 11012] = "PN_1101_SHARP2Y0A21";
	  /**
	   * 1101 - IR Distance Adapter, with Sharp Distance Sensor 2Y0A02 (20-150cm)
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1101_SHARP2Y0A02"] = 11013] = "PN_1101_SHARP2Y0A02";
	  /**
	   * 1102 - IR Reflective Sensor 5mm
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1102"] = 11020] = "PN_1102";
	  /**
	   * 1103 - IR Reflective Sensor 10cm
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1103"] = 11030] = "PN_1103";
	  /**
	   * 1104 - Vibration Sensor
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1104"] = 11040] = "PN_1104";
	  /**
	   * 1105 - Light Sensor
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1105"] = 11050] = "PN_1105";
	  /**
	   * 1106 - Force Sensor
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1106"] = 11060] = "PN_1106";
	  /**
	   * 1107 - Humidity Sensor
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1107"] = 11070] = "PN_1107";
	  /**
	   * 1108 - Magnetic Sensor
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1108"] = 11080] = "PN_1108";
	  /**
	   * 1109 - Rotation Sensor
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1109"] = 11090] = "PN_1109";
	  /**
	   * 1110 - Touch Sensor
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1110"] = 11100] = "PN_1110";
	  /**
	   * 1111 - Motion Sensor
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1111"] = 11110] = "PN_1111";
	  /**
	   * 1112 - Slider 60
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1112"] = 11120] = "PN_1112";
	  /**
	   * 1113 - Mini Joy Stick Sensor
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1113"] = 11130] = "PN_1113";
	  /**
	   * 1115 - Pressure Sensor
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1115"] = 11150] = "PN_1115";
	  /**
	   * 1116 - Multi-turn Rotation Sensor
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1116"] = 11160] = "PN_1116";
	  /**
	   * 1118 - 50Amp Current Sensor AC
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1118_AC"] = 11181] = "PN_1118_AC";
	  /**
	   * 1118 - 50Amp Current Sensor DC
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1118_DC"] = 11182] = "PN_1118_DC";
	  /**
	   * 1119 - 20Amp Current Sensor AC
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1119_AC"] = 11191] = "PN_1119_AC";
	  /**
	   * 1119 - 20Amp Current Sensor DC
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1119_DC"] = 11192] = "PN_1119_DC";
	  /**
	   * 1120 - FlexiForce Adapter
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1120"] = 11200] = "PN_1120";
	  /**
	   * 1121 - Voltage Divider
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1121"] = 11210] = "PN_1121";
	  /**
	   * 1122 - 30 Amp Current Sensor AC
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1122_AC"] = 11221] = "PN_1122_AC";
	  /**
	   * 1122 - 30 Amp Current Sensor DC
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1122_DC"] = 11222] = "PN_1122_DC";
	  /**
	   * 1124 - Precision Temperature Sensor
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1124"] = 11240] = "PN_1124";
	  /**
	   * 1125 - Humidity Sensor
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1125_HUMIDITY"] = 11251] = "PN_1125_HUMIDITY";
	  /**
	   * 1125 - Temperature Sensor
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1125_TEMPERATURE"] = 11252] = "PN_1125_TEMPERATURE";
	  /**
	   * 1126 - Differential Air Pressure Sensor +- 25kPa
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1126"] = 11260] = "PN_1126";
	  /**
	   * 1128 - MaxBotix EZ-1 Sonar Sensor
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1128"] = 11280] = "PN_1128";
	  /**
	   * 1129 - Touch Sensor
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1129"] = 11290] = "PN_1129";
	  /**
	   * 1131 - Thin Force Sensor
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1131"] = 11310] = "PN_1131";
	  /**
	   * 1134 - Switchable Voltage Divider
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1134"] = 11340] = "PN_1134";
	  /**
	   * 1136 - Differential Air Pressure Sensor +-2 kPa
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1136"] = 11360] = "PN_1136";
	  /**
	   * 1137 - Differential Air Pressure Sensor +-7 kPa
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1137"] = 11370] = "PN_1137";
	  /**
	   * 1138 - Differential Air Pressure Sensor 50 kPa
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1138"] = 11380] = "PN_1138";
	  /**
	   * 1139 - Differential Air Pressure Sensor 100 kPa
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1139"] = 11390] = "PN_1139";
	  /**
	   * 1140 - Absolute Air Pressure Sensor 20-400 kPa
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1140"] = 11400] = "PN_1140";
	  /**
	   * 1141 - Absolute Air Pressure Sensor 15-115 kPa
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1141"] = 11410] = "PN_1141";
	  /**
	   * 1146 - IR Reflective Sensor 1-4mm
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_1146"] = 11460] = "PN_1146";
	  /**
	   * 3120 - Compression Load Cell (0-4.5 kg)
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_3120"] = 31200] = "PN_3120";
	  /**
	   * 3121 - Compression Load Cell (0-11.3 kg)
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_3121"] = 31210] = "PN_3121";
	  /**
	   * 3122 - Compression Load Cell (0-22.7 kg)
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_3122"] = 31220] = "PN_3122";
	  /**
	   * 3123 - Compression Load Cell (0-45.3 kg)
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_3123"] = 31230] = "PN_3123";
	  /**
	   * 3130 - Relative Humidity Sensor
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_3130"] = 31300] = "PN_3130";
	  /**
	   * 3520 - Sharp Distance Sensor (4-30cm)
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_3520"] = 35200] = "PN_3520";
	  /**
	   * 3521 - Sharp Distance Sensor (10-80cm)
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_3521"] = 35210] = "PN_3521";
	  /**
	   * 3522 - Sharp Distance Sensor (20-150cm)
	   * @public
	   */

	  VoltageRatioSensorType[VoltageRatioSensorType["PN_3522"] = 35220] = "PN_3522";
	})(exports.VoltageRatioSensorType || (exports.VoltageRatioSensorType = {}));
	/**
	 * The forward voltage setting of the LED
	 * @public
	 */


	exports.LEDForwardVoltage = void 0;

	(function (LEDForwardVoltage) {
	  /**
	   * 1.7 V
	   * @public
	   */
	  LEDForwardVoltage[LEDForwardVoltage["VOLTS_1_7"] = 1] = "VOLTS_1_7";
	  /**
	   * 2.75 V
	   * @public
	   */

	  LEDForwardVoltage[LEDForwardVoltage["VOLTS_2_75"] = 2] = "VOLTS_2_75";
	  /**
	   * 3.2 V
	   * @public
	   */

	  LEDForwardVoltage[LEDForwardVoltage["VOLTS_3_2"] = 3] = "VOLTS_3_2";
	  /**
	   * 3.9 V
	   * @public
	   */

	  LEDForwardVoltage[LEDForwardVoltage["VOLTS_3_9"] = 4] = "VOLTS_3_9";
	  /**
	   * 4.0 V
	   * @public
	   */

	  LEDForwardVoltage[LEDForwardVoltage["VOLTS_4_0"] = 5] = "VOLTS_4_0";
	  /**
	   * 4.8 V
	   * @public
	   */

	  LEDForwardVoltage[LEDForwardVoltage["VOLTS_4_8"] = 6] = "VOLTS_4_8";
	  /**
	   * 5.0 V
	   * @public
	   */

	  LEDForwardVoltage[LEDForwardVoltage["VOLTS_5_0"] = 7] = "VOLTS_5_0";
	  /**
	   * 5.6 V
	   * @public
	   */

	  LEDForwardVoltage[LEDForwardVoltage["VOLTS_5_6"] = 8] = "VOLTS_5_6";
	})(exports.LEDForwardVoltage || (exports.LEDForwardVoltage = {}));
	/**
	 * Voltage supplied to all attached servos
	 * @public
	 */


	exports.RCServoVoltage = void 0;

	(function (RCServoVoltage) {
	  /**
	   * Run all servos on 5V DC
	   * @public
	   */
	  RCServoVoltage[RCServoVoltage["VOLTS_5_0"] = 1] = "VOLTS_5_0";
	  /**
	   * Run all servos on 6V DC
	   * @public
	   */

	  RCServoVoltage[RCServoVoltage["VOLTS_6_0"] = 2] = "VOLTS_6_0";
	  /**
	   * Run all servos on 7.4V DC
	   * @public
	   */

	  RCServoVoltage[RCServoVoltage["VOLTS_7_4"] = 3] = "VOLTS_7_4";
	})(exports.RCServoVoltage || (exports.RCServoVoltage = {}));
	/**
	 * The selected output voltage range
	 * @public
	 */


	exports.VoltageOutputRange = void 0;

	(function (VoltageOutputRange) {
	  /**
	   * Â±10V DC
	   * @public
	   */
	  VoltageOutputRange[VoltageOutputRange["VOLTS_10"] = 1] = "VOLTS_10";
	  /**
	   * 0-5V DC
	   * @public
	   */

	  VoltageOutputRange[VoltageOutputRange["VOLTS_5"] = 2] = "VOLTS_5";
	})(exports.VoltageOutputRange || (exports.VoltageOutputRange = {}));
	/**
	 * Measurement range of the voltage input. Larger ranges have less resolution.
	 * @public
	 */


	exports.VoltageRange = void 0;

	(function (VoltageRange) {
	  /**
	   * Range Â±10mV DC
	   * @public
	   */
	  VoltageRange[VoltageRange["MILLIVOLTS_10"] = 1] = "MILLIVOLTS_10";
	  /**
	   * Range Â±40mV DC
	   * @public
	   */

	  VoltageRange[VoltageRange["MILLIVOLTS_40"] = 2] = "MILLIVOLTS_40";
	  /**
	   * Range Â±200mV DC
	   * @public
	   */

	  VoltageRange[VoltageRange["MILLIVOLTS_200"] = 3] = "MILLIVOLTS_200";
	  /**
	   * Range Â±312.5mV DC
	   * @public
	   */

	  VoltageRange[VoltageRange["MILLIVOLTS_312_5"] = 4] = "MILLIVOLTS_312_5";
	  /**
	   * Range Â±400mV DC
	   * @public
	   */

	  VoltageRange[VoltageRange["MILLIVOLTS_400"] = 5] = "MILLIVOLTS_400";
	  /**
	   * Range Â±1000mV DC
	   * @public
	   */

	  VoltageRange[VoltageRange["MILLIVOLTS_1000"] = 6] = "MILLIVOLTS_1000";
	  /**
	   * Range Â±2V DC
	   * @public
	   */

	  VoltageRange[VoltageRange["VOLTS_2"] = 7] = "VOLTS_2";
	  /**
	   * Range Â±5V DC
	   * @public
	   */

	  VoltageRange[VoltageRange["VOLTS_5"] = 8] = "VOLTS_5";
	  /**
	   * Range Â±15V DC
	   * @public
	   */

	  VoltageRange[VoltageRange["VOLTS_15"] = 9] = "VOLTS_15";
	  /**
	   * Range Â±40V DC
	   * @public
	   */

	  VoltageRange[VoltageRange["VOLTS_40"] = 10] = "VOLTS_40";
	  /**
	   * Auto-range mode changes based on the present voltage measurements.
	   * @public
	   */

	  VoltageRange[VoltageRange["AUTO"] = 11] = "AUTO";
	})(exports.VoltageRange || (exports.VoltageRange = {}));
	/**
	 * Type of sensor attached to the voltage input
	 * @public
	 */


	exports.VoltageSensorType = void 0;

	(function (VoltageSensorType) {
	  /**
	   * Default. Configures the channel to be a generic voltage sensor. Unit is volts.
	   * @public
	   */
	  VoltageSensorType[VoltageSensorType["VOLTAGE"] = 0] = "VOLTAGE";
	  /**
	   * 1114 - Temperature Sensor
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_1114"] = 11140] = "PN_1114";
	  /**
	   * 1117 - Voltage Sensor
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_1117"] = 11170] = "PN_1117";
	  /**
	   * 1123 - Precision Voltage Sensor
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_1123"] = 11230] = "PN_1123";
	  /**
	   * 1127 - Precision Light Sensor
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_1127"] = 11270] = "PN_1127";
	  /**
	   * 1130 - pH Adapter
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_1130_PH"] = 11301] = "PN_1130_PH";
	  /**
	   * 1130 - ORP Adapter
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_1130_ORP"] = 11302] = "PN_1130_ORP";
	  /**
	   * 1132 - 4-20mA Adapter
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_1132"] = 11320] = "PN_1132";
	  /**
	   * 1133 - Sound Sensor
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_1133"] = 11330] = "PN_1133";
	  /**
	   * 1135 - Precision Voltage Sensor
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_1135"] = 11350] = "PN_1135";
	  /**
	   * 1142 - Light Sensor 1000 lux
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_1142"] = 11420] = "PN_1142";
	  /**
	   * 1143 - Light Sensor 70000 lux
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_1143"] = 11430] = "PN_1143";
	  /**
	   * 3500 - AC Current Sensor 10Amp
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_3500"] = 35000] = "PN_3500";
	  /**
	   * 3501 - AC Current Sensor 25Amp
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_3501"] = 35010] = "PN_3501";
	  /**
	   * 3502 - AC Current Sensor 50Amp
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_3502"] = 35020] = "PN_3502";
	  /**
	   * 3503 - AC Current Sensor 100Amp
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_3503"] = 35030] = "PN_3503";
	  /**
	   * 3507 - AC Voltage Sensor 0-250V (50Hz)
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_3507"] = 35070] = "PN_3507";
	  /**
	   * 3508 - AC Voltage Sensor 0-250V (60Hz)
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_3508"] = 35080] = "PN_3508";
	  /**
	   * 3509 - DC Voltage Sensor 0-200V
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_3509"] = 35090] = "PN_3509";
	  /**
	   * 3510 - DC Voltage Sensor 0-75V
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_3510"] = 35100] = "PN_3510";
	  /**
	   * 3511 - DC Current Sensor 0-10mA
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_3511"] = 35110] = "PN_3511";
	  /**
	   * 3512 - DC Current Sensor 0-100mA
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_3512"] = 35120] = "PN_3512";
	  /**
	   * 3513 - DC Current Sensor 0-1A
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_3513"] = 35130] = "PN_3513";
	  /**
	   * 3514 - AC Active Power Sensor 0-250V*0-30A (50Hz)
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_3514"] = 35140] = "PN_3514";
	  /**
	   * 3515 - AC Active Power Sensor 0-250V*0-30A (60Hz)
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_3515"] = 35150] = "PN_3515";
	  /**
	   * 3516 - AC Active Power Sensor 0-250V*0-5A (50Hz)
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_3516"] = 35160] = "PN_3516";
	  /**
	   * 3517 - AC Active Power Sensor 0-250V*0-5A (60Hz)
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_3517"] = 35170] = "PN_3517";
	  /**
	   * 3518 - AC Active Power Sensor 0-110V*0-5A (60Hz)
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_3518"] = 35180] = "PN_3518";
	  /**
	   * 3519 - AC Active Power Sensor 0-110V*0-15A (60Hz)
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_3519"] = 35190] = "PN_3519";
	  /**
	   * 3584 - 0-50A DC Current Transducer
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_3584"] = 35840] = "PN_3584";
	  /**
	   * 3585 - 0-100A DC Current Transducer
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_3585"] = 35850] = "PN_3585";
	  /**
	   * 3586 - 0-250A DC Current Transducer
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_3586"] = 35860] = "PN_3586";
	  /**
	   * 3587 - +-50A DC Current Transducer
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_3587"] = 35870] = "PN_3587";
	  /**
	   * 3588 - +-100A DC Current Transducer
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_3588"] = 35880] = "PN_3588";
	  /**
	   * 3589 - +-250A DC Current Transducer
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_3589"] = 35890] = "PN_3589";
	  /**
	   * MOT2002 - Motion Sensor Low Sensitivity
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_MOT2002_LOW"] = 20020] = "PN_MOT2002_LOW";
	  /**
	   * MOT2002 - Motion Sensor Medium Sensitivity
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_MOT2002_MED"] = 20021] = "PN_MOT2002_MED";
	  /**
	   * MOT2002 - Motion Sensor High Sensitivity
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_MOT2002_HIGH"] = 20022] = "PN_MOT2002_HIGH";
	  /**
	   * VCP4114 - +-25A DC Current Transducer
	   * @public
	   */

	  VoltageSensorType[VoltageSensorType["PN_VCP4114"] = 41140] = "PN_VCP4114";
	})(exports.VoltageSensorType || (exports.VoltageSensorType = {}));
	/**
	 * The protocol used to communicate with the tags
	 * @public
	 */


	exports.RFIDProtocol = void 0;

	(function (RFIDProtocol) {
	  /**
	   * EM4100 Series
	   * @public
	   */
	  RFIDProtocol[RFIDProtocol["EM4100"] = 1] = "EM4100";
	  /**
	   * ISO11785 FDX B
	   * @public
	   */

	  RFIDProtocol[RFIDProtocol["ISO11785_FDX_B"] = 2] = "ISO11785_FDX_B";
	  /**
	   * PhidgetTAG
	   * @public
	   */

	  RFIDProtocol[RFIDProtocol["PHIDGET_TAG"] = 3] = "PHIDGET_TAG";
	})(exports.RFIDProtocol || (exports.RFIDProtocol = {}));
	/**
	 * Controls the AHRS algorithm.
	 * @public
	 */


	exports.SpatialAlgorithm = void 0;

	(function (SpatialAlgorithm) {
	  /**
	   * No AHRS algorithm is used.
	   * @public
	   */
	  SpatialAlgorithm[SpatialAlgorithm["NONE"] = 0] = "NONE";
	  /**
	   * AHRS algorithm, incorporating magnetometer data for yaw correction.
	   * @public
	   */

	  SpatialAlgorithm[SpatialAlgorithm["AHRS"] = 1] = "AHRS";
	  /**
	   * IMU algorithm, using gyro and accelerometer, but not magnetometer.
	   * @public
	   */

	  SpatialAlgorithm[SpatialAlgorithm["IMU"] = 2] = "IMU";
	})(exports.SpatialAlgorithm || (exports.SpatialAlgorithm = {}));
	/**
	 * RTD sensor type
	 * @public
	 */


	exports.RTDType = void 0;

	(function (RTDType) {
	  /**
	   * Configures the RTD type as a PT100 with a 3850ppm curve.
	   * @public
	   */
	  RTDType[RTDType["PT100_3850"] = 1] = "PT100_3850";
	  /**
	   * Configures the RTD type as a PT1000 with a 3850ppm curve.
	   * @public
	   */

	  RTDType[RTDType["PT1000_3850"] = 2] = "PT1000_3850";
	  /**
	   * Configures the RTD type as a PT100 with a 3920ppm curve.
	   * @public
	   */

	  RTDType[RTDType["PT100_3920"] = 3] = "PT100_3920";
	  /**
	   * Configures the RTD type as a PT1000 with a 3920ppm curve.
	   * @public
	   */

	  RTDType[RTDType["PT1000_3920"] = 4] = "PT1000_3920";
	})(exports.RTDType || (exports.RTDType = {}));
	/**
	 * The type of thermocouple being used
	 * @public
	 */


	exports.ThermocoupleType = void 0;

	(function (ThermocoupleType) {
	  /**
	   * Configures the thermocouple input as a J-Type thermocouple.
	   * @public
	   */
	  ThermocoupleType[ThermocoupleType["J"] = 1] = "J";
	  /**
	   * Configures the thermocouple input as a K-Type thermocouple.
	   * @public
	   */

	  ThermocoupleType[ThermocoupleType["K"] = 2] = "K";
	  /**
	   * Configures the thermocouple input as a E-Type thermocouple.
	   * @public
	   */

	  ThermocoupleType[ThermocoupleType["E"] = 3] = "E";
	  /**
	   * Configures the thermocouple input as a T-Type thermocouple.
	   * @public
	   */

	  ThermocoupleType[ThermocoupleType["T"] = 4] = "T";
	})(exports.ThermocoupleType || (exports.ThermocoupleType = {}));
	/**
	 * Type of filter used on the frequency input
	 * @public
	 */


	exports.FrequencyFilterType = void 0;

	(function (FrequencyFilterType) {
	  /**
	   * Frequency is calculated from the number of times the signal transitions from a negative voltage to a positive voltage and back again.
	   * @public
	   */
	  FrequencyFilterType[FrequencyFilterType["ZERO_CROSSING"] = 1] = "ZERO_CROSSING";
	  /**
	   * Frequency is calculated from the number of times the signal transitions from a logic false to a logic true and back again.
	   * @public
	   */

	  FrequencyFilterType[FrequencyFilterType["LOGIC_LEVEL"] = 2] = "LOGIC_LEVEL";
	})(exports.FrequencyFilterType || (exports.FrequencyFilterType = {}));
	/**
	 * Describes the encoding technique used for the code
	 * @public
	 */


	exports.IRCodeEncoding = void 0;

	(function (IRCodeEncoding) {
	  /**
	   * Unknown - the default value
	   * @public
	   */
	  IRCodeEncoding[IRCodeEncoding["UNKNOWN"] = 1] = "UNKNOWN";
	  /**
	   * Space encoding, or Pulse Distance Modulation
	   * @public
	   */

	  IRCodeEncoding[IRCodeEncoding["SPACE"] = 2] = "SPACE";
	  /**
	   * Pulse encoding, or Pulse Width Modulation
	   * @public
	   */

	  IRCodeEncoding[IRCodeEncoding["PULSE"] = 3] = "PULSE";
	  /**
	   * Bi-Phase, or Manchester encoding
	   * @public
	   */

	  IRCodeEncoding[IRCodeEncoding["BI_PHASE"] = 4] = "BI_PHASE";
	  /**
	   * RC5 - a type of Bi-Phase encoding
	   * @public
	   */

	  IRCodeEncoding[IRCodeEncoding["RC5"] = 5] = "RC5";
	  /**
	   * RC6 - a type of Bi-Phase encoding
	   * @public
	   */

	  IRCodeEncoding[IRCodeEncoding["RC6"] = 6] = "RC6";
	})(exports.IRCodeEncoding || (exports.IRCodeEncoding = {}));
	/**
	 * The length type of the bitstream and gaps
	 * @public
	 */


	exports.IRCodeLength = void 0;

	(function (IRCodeLength) {
	  /**
	   * Unknown - the default value
	   * @public
	   */
	  IRCodeLength[IRCodeLength["UNKNOWN"] = 1] = "UNKNOWN";
	  /**
	   * Constant - the bitstream and gap length is constant
	   * @public
	   */

	  IRCodeLength[IRCodeLength["CONSTANT"] = 2] = "CONSTANT";
	  /**
	   * Variable - the bitstream has a variable length with a constant gap
	   * @public
	   */

	  IRCodeLength[IRCodeLength["VARIABLE"] = 3] = "VARIABLE";
	})(exports.IRCodeLength || (exports.IRCodeLength = {}));
	/**
	 * Method of motor control
	 * @public
	 */


	exports.StepperControlMode = void 0;

	(function (StepperControlMode) {
	  /**
	   * Control the motor by setting a target position.
	   * @public
	   */
	  StepperControlMode[StepperControlMode["STEP"] = 0] = "STEP";
	  /**
	   * Control the motor by selecting a target velocity (sign indicates direction). The motor will rotate continuously in the chosen direction.
	   * @public
	   */

	  StepperControlMode[StepperControlMode["RUN"] = 1] = "RUN";
	})(exports.StepperControlMode || (exports.StepperControlMode = {}));
	/**
	 * The type of font being used
	 * @public
	 */


	exports.LCDFont = void 0;

	(function (LCDFont) {
	  /**
	   * User-defined font #1
	   * @public
	   */
	  LCDFont[LCDFont["USER1"] = 1] = "USER1";
	  /**
	   * User-defined font #2
	   * @public
	   */

	  LCDFont[LCDFont["USER2"] = 2] = "USER2";
	  /**
	   * 6px by 10px font
	   * @public
	   */

	  LCDFont[LCDFont["DIMENSIONS_6X10"] = 3] = "DIMENSIONS_6X10";
	  /**
	   * 5px by 8px font
	   * @public
	   */

	  LCDFont[LCDFont["DIMENSIONS_5X8"] = 4] = "DIMENSIONS_5X8";
	  /**
	   * 6px by 12px font
	   * @public
	   */

	  LCDFont[LCDFont["DIMENSIONS_6X12"] = 5] = "DIMENSIONS_6X12";
	})(exports.LCDFont || (exports.LCDFont = {}));
	/**
	 * Size of the attached LCD screen
	 * @public
	 */


	exports.LCDScreenSize = void 0;

	(function (LCDScreenSize) {
	  /**
	   * Screen size unknown
	   * @public
	   */
	  LCDScreenSize[LCDScreenSize["NO_SCREEN"] = 1] = "NO_SCREEN";
	  /**
	   * One row, eight column text screen
	   * @public
	   */

	  LCDScreenSize[LCDScreenSize["DIMENSIONS_1X8"] = 2] = "DIMENSIONS_1X8";
	  /**
	   * Two row, eight column text screen
	   * @public
	   */

	  LCDScreenSize[LCDScreenSize["DIMENSIONS_2X8"] = 3] = "DIMENSIONS_2X8";
	  /**
	   * One row, 16 column text screen
	   * @public
	   */

	  LCDScreenSize[LCDScreenSize["DIMENSIONS_1X16"] = 4] = "DIMENSIONS_1X16";
	  /**
	   * Two row, 16 column text screen
	   * @public
	   */

	  LCDScreenSize[LCDScreenSize["DIMENSIONS_2X16"] = 5] = "DIMENSIONS_2X16";
	  /**
	   * Four row, 16 column text screen
	   * @public
	   */

	  LCDScreenSize[LCDScreenSize["DIMENSIONS_4X16"] = 6] = "DIMENSIONS_4X16";
	  /**
	   * Two row, 20 column text screen
	   * @public
	   */

	  LCDScreenSize[LCDScreenSize["DIMENSIONS_2X20"] = 7] = "DIMENSIONS_2X20";
	  /**
	   * Four row, 20 column text screen.
	   * @public
	   */

	  LCDScreenSize[LCDScreenSize["DIMENSIONS_4X20"] = 8] = "DIMENSIONS_4X20";
	  /**
	   * Two row, 24 column text screen
	   * @public
	   */

	  LCDScreenSize[LCDScreenSize["DIMENSIONS_2X24"] = 9] = "DIMENSIONS_2X24";
	  /**
	   * One row, 40 column text screen
	   * @public
	   */

	  LCDScreenSize[LCDScreenSize["DIMENSIONS_1X40"] = 10] = "DIMENSIONS_1X40";
	  /**
	   * Two row, 40 column text screen
	   * @public
	   */

	  LCDScreenSize[LCDScreenSize["DIMENSIONS_2X40"] = 11] = "DIMENSIONS_2X40";
	  /**
	   * Four row, 40 column text screen
	   * @public
	   */

	  LCDScreenSize[LCDScreenSize["DIMENSIONS_4X40"] = 12] = "DIMENSIONS_4X40";
	  /**
	   * 64px by 128px graphic screen
	   * @public
	   */

	  LCDScreenSize[LCDScreenSize["DIMENSIONS_64X128"] = 13] = "DIMENSIONS_64X128";
	})(exports.LCDScreenSize || (exports.LCDScreenSize = {}));
	/**
	 * The on/off state of the pixel to be set
	 * @public
	 */


	exports.LCDPixelState = void 0;

	(function (LCDPixelState) {
	  /**
	   * Pixel off state
	   * @public
	   */
	  LCDPixelState[LCDPixelState["OFF"] = 0] = "OFF";
	  /**
	   * Pixel on state
	   * @public
	   */

	  LCDPixelState[LCDPixelState["ON"] = 1] = "ON";
	  /**
	   * Invert the pixel state
	   * @public
	   */

	  LCDPixelState[LCDPixelState["INVERT"] = 2] = "INVERT";
	})(exports.LCDPixelState || (exports.LCDPixelState = {}));
	/**
	 * The parity setting of the data adapter
	 * @public
	 */


	exports.DataAdapterParity = void 0;

	(function (DataAdapterParity) {
	  /**
	   * No Parity Bit
	   * @public
	   */
	  DataAdapterParity[DataAdapterParity["NONE"] = 1] = "NONE";
	  /**
	   * Even Parity
	   * @public
	   */

	  DataAdapterParity[DataAdapterParity["EVEN"] = 2] = "EVEN";
	  /**
	   * Odd Parity
	   * @public
	   */

	  DataAdapterParity[DataAdapterParity["ODD"] = 3] = "ODD";
	})(exports.DataAdapterParity || (exports.DataAdapterParity = {}));
	/**
	 * The number of stop bits used for communication
	 * @public
	 */


	exports.DataAdapterStopBits = void 0;

	(function (DataAdapterStopBits) {
	  /**
	   * One Stop Bit
	   * @public
	   */
	  DataAdapterStopBits[DataAdapterStopBits["ONE"] = 1] = "ONE";
	  /**
	   * Two Stop Bits
	   * @public
	   */

	  DataAdapterStopBits[DataAdapterStopBits["TWO"] = 2] = "TWO";
	})(exports.DataAdapterStopBits || (exports.DataAdapterStopBits = {}));
	/**
	 * The mothod of handshaking used for communication
	 * @public
	 */


	exports.DataAdapterHandshakeMode = void 0;

	(function (DataAdapterHandshakeMode) {
	  /**
	   * RTS is never set, and CTS is ignored.
	   * @public
	   */
	  DataAdapterHandshakeMode[DataAdapterHandshakeMode["NONE"] = 1] = "NONE";
	  /**
	   * RTS Pin requests to transmit data. CTS input confirms we can send data.
	   * @public
	   */

	  DataAdapterHandshakeMode[DataAdapterHandshakeMode["REQUEST_TO_SEND"] = 2] = "REQUEST_TO_SEND";
	  /**
	   * RTS signals this device can receive data. CTS confirms we can send data.
	   * @public
	   */

	  DataAdapterHandshakeMode[DataAdapterHandshakeMode["READY_TO_RECEIVE"] = 3] = "READY_TO_RECEIVE";
	})(exports.DataAdapterHandshakeMode || (exports.DataAdapterHandshakeMode = {}));
	/**
	 * The communication protocol
	 * @public
	 */


	exports.DataAdapterProtocol = void 0;

	(function (DataAdapterProtocol) {
	  /**
	   * Basic half-duplex RS485. Always receiving until you send data.
	   * @public
	   */
	  DataAdapterProtocol[DataAdapterProtocol["RS485"] = 1] = "RS485";
	  /**
	   * Uses full-duplex RS422 communication.
	   * @public
	   */

	  DataAdapterProtocol[DataAdapterProtocol["RS422"] = 2] = "RS422";
	  /**
	   * Allows communication with DMX512-compatible devices, such as stage lighting
	   * @public
	   */

	  DataAdapterProtocol[DataAdapterProtocol["DMX512"] = 3] = "DMX512";
	  /**
	   * Allows communication with MODBUS RTU compatible devices
	   * @public
	   */

	  DataAdapterProtocol[DataAdapterProtocol["MODBUS_RTU"] = 4] = "MODBUS_RTU";
	  /**
	   * Allows communication with SPI compatible devices
	   * @public
	   */

	  DataAdapterProtocol[DataAdapterProtocol["SPI"] = 5] = "SPI";
	  /**
	   * Allows communication with I2C compatible devices
	   * @public
	   */

	  DataAdapterProtocol[DataAdapterProtocol["I2C"] = 6] = "I2C";
	  /**
	   * Allows communication with UART compatible devices
	   * @public
	   */

	  DataAdapterProtocol[DataAdapterProtocol["UART"] = 7] = "UART";
	  /**
	   * Allows communication with RS232 compatible devices
	   * @public
	   */

	  DataAdapterProtocol[DataAdapterProtocol["RS232"] = 8] = "RS232";
	})(exports.DataAdapterProtocol || (exports.DataAdapterProtocol = {}));
	/**
	 * The SPI Mode
	 * @public
	 */


	exports.DataAdapterSPIMode = void 0;

	(function (DataAdapterSPIMode) {
	  /**
	   * CPOL = 0 CPHA = 0
	   * @public
	   */
	  DataAdapterSPIMode[DataAdapterSPIMode["MODE_0"] = 1] = "MODE_0";
	  /**
	   * CPOL = 0 CPHA = 1
	   * @public
	   */

	  DataAdapterSPIMode[DataAdapterSPIMode["MODE_1"] = 2] = "MODE_1";
	  /**
	   * CPOL = 1 CPHA = 0
	   * @public
	   */

	  DataAdapterSPIMode[DataAdapterSPIMode["MODE_2"] = 3] = "MODE_2";
	  /**
	   * CPOL = 1 CPHA = 1
	   * @public
	   */

	  DataAdapterSPIMode[DataAdapterSPIMode["MODE_3"] = 4] = "MODE_3";
	})(exports.DataAdapterSPIMode || (exports.DataAdapterSPIMode = {}));
	/**
	 * The SPI Mode
	 * @public
	 */


	exports.DataAdapterEndianness = void 0;

	(function (DataAdapterEndianness) {
	  /**
	   * MSB First
	   * @public
	   */
	  DataAdapterEndianness[DataAdapterEndianness["MSB_FIRST"] = 1] = "MSB_FIRST";
	  /**
	   * LSB First
	   * @public
	   */

	  DataAdapterEndianness[DataAdapterEndianness["LSB_FIRST"] = 2] = "LSB_FIRST";
	})(exports.DataAdapterEndianness || (exports.DataAdapterEndianness = {}));
	/**
	 * The IO Voltage
	 * @public
	 */


	exports.DataAdapterIOVoltage = void 0;

	(function (DataAdapterIOVoltage) {
	  /**
	   * Voltage supplied by external device
	   * @public
	   */
	  DataAdapterIOVoltage[DataAdapterIOVoltage["EXTERNAL"] = 1] = "EXTERNAL";
	  /**
	   * 1.8V
	   * @public
	   */

	  DataAdapterIOVoltage[DataAdapterIOVoltage["VOLTS_1_8"] = 2] = "VOLTS_1_8";
	  /**
	   * 2.5V
	   * @public
	   */

	  DataAdapterIOVoltage[DataAdapterIOVoltage["VOLTS_2_5"] = 3] = "VOLTS_2_5";
	  /**
	   * 3.3V
	   * @public
	   */

	  DataAdapterIOVoltage[DataAdapterIOVoltage["VOLTS_3_3"] = 4] = "VOLTS_3_3";
	  /**
	   * 5.0V
	   * @public
	   */

	  DataAdapterIOVoltage[DataAdapterIOVoltage["VOLTS_5"] = 5] = "VOLTS_5";
	})(exports.DataAdapterIOVoltage || (exports.DataAdapterIOVoltage = {}));
	/**
	 * The Type of Error on the Packet
	 * @public
	 */


	exports.PacketErrorCode = void 0;

	(function (PacketErrorCode) {
	  /**
	   * No error
	   * @public
	   */
	  PacketErrorCode[PacketErrorCode["OK"] = 0] = "OK";
	  /**
	   * Unknown Error
	   * @public
	   */

	  PacketErrorCode[PacketErrorCode["UNKNOWN"] = 1] = "UNKNOWN";
	  /**
	   * The response packet timed out
	   * @public
	   */

	  PacketErrorCode[PacketErrorCode["TIMEOUT"] = 2] = "TIMEOUT";
	  /**
	   * Something about the received transmission didn't match the expected format.
	   * @public
	   */

	  PacketErrorCode[PacketErrorCode["FORMAT"] = 3] = "FORMAT";
	  /**
	   * The input lines are invalid. This likely means a cable has been unplugged.
	   * @public
	   */

	  PacketErrorCode[PacketErrorCode["INVALID"] = 4] = "INVALID";
	  /**
	   * Data is being received fater than it can be processed. Some has been lost.
	   * @public
	   */

	  PacketErrorCode[PacketErrorCode["OVERRUN"] = 5] = "OVERRUN";
	  /**
	   * Something behind the scenes got out of sequence.
	   * @public
	   */

	  PacketErrorCode[PacketErrorCode["CORRUPT"] = 6] = "CORRUPT";
	})(exports.PacketErrorCode || (exports.PacketErrorCode = {}));
	/**
	 * The measurement range of the sound sensor
	 * @public
	 */


	exports.SPLRange = void 0;

	(function (SPLRange) {
	  /**
	   * Range 102dB
	   * @public
	   */
	  SPLRange[SPLRange["DB_102"] = 1] = "DB_102";
	  /**
	   * Range 82dB
	   * @public
	   */

	  SPLRange[SPLRange["DB_82"] = 2] = "DB_82";
	})(exports.SPLRange || (exports.SPLRange = {}));
	/**
	 * The mode of the VINT port
	 * @public
	 */


	exports.HubPortMode = void 0;

	(function (HubPortMode) {
	  /**
	   * Communicate with a smart VINT device
	   * @public
	   */
	  HubPortMode[HubPortMode["VINT"] = 0] = "VINT";
	  /**
	   * 5V Logic-level digital input
	   * @public
	   */

	  HubPortMode[HubPortMode["DIGITAL_INPUT"] = 1] = "DIGITAL_INPUT";
	  /**
	   * 3.3V digital output
	   * @public
	   */

	  HubPortMode[HubPortMode["DIGITAL_OUTPUT"] = 2] = "DIGITAL_OUTPUT";
	  /**
	   * 0-5V voltage input for non-ratiometric sensors
	   * @public
	   */

	  HubPortMode[HubPortMode["VOLTAGE_INPUT"] = 3] = "VOLTAGE_INPUT";
	  /**
	   * 0-5V voltage input for ratiometric sensors
	   * @public
	   */

	  HubPortMode[HubPortMode["VOLTAGE_RATIO_INPUT"] = 4] = "VOLTAGE_RATIO_INPUT";
	})(exports.HubPortMode || (exports.HubPortMode = {}));

	/** @internal */
	const PhidgetErrorDescription = {
	  0: 'Success',
	  1: 'Not Permitted',
	  2: 'No Such Entity',
	  3: 'Timed Out',
	  58: 'Keep Alive Failure',
	  4: 'Op Interrupted',
	  5: 'IO Issue',
	  6: 'Memory Issue',
	  7: 'Access (Permission) Issue',
	  8: 'Address Issue',
	  9: 'Resource Busy',
	  10: 'Object Exists',
	  11: 'Object is not a directory',
	  12: 'Object is a directory',
	  13: 'Invalid',
	  14: 'Too many open files in system',
	  15: 'Too many open files',
	  16: 'Not enough space',
	  17: 'File too Big',
	  18: 'Read Only Filesystem',
	  19: 'Read Only Object',
	  20: 'Operation Not Supported',
	  21: 'Invalid Argument',
	  22: 'Try again',
	  26: 'Not Empty',
	  28: 'Unexpected Error',
	  27: 'Duplicate',
	  37: 'Bad Credential',
	  45: 'Network Unavailable',
	  35: 'Connection Refused',
	  46: 'Connection Reset',
	  48: 'No route to host',
	  40: 'No Such Device',
	  50: 'Wrong Device',
	  41: 'Broken Pipe',
	  44: 'Name Resolution Failure',
	  51: 'Unknown or Invalid Value',
	  52: 'Device not Attached',
	  53: 'Invalid or Unexpected Packet',
	  54: 'Argument List Too Long',
	  55: 'Bad Version',
	  56: 'Closed',
	  57: 'Not Configured',
	  31: 'End of File',
	  59: 'Failsafe Triggered',
	  60: 'Invalid Value - Too High',
	  61: 'Invalid Value - Too Low'
	};

	/** @public */

	class PhidgetError extends Error {
	  constructor(code, message, innerException) {
	    let msg = message || PhidgetErrorDescription[code];

	    if (innerException != undefined) {
	      let innerMsg;

	      if (innerException instanceof Error) {
	        innerMsg = innerException.message;
	      } else if (typeof innerException === 'string') {
	        innerMsg = innerException;
	      } else {
	        innerMsg = JSON.stringify(innerException);
	      }

	      if (innerMsg.length > 0) msg += ' - ' + innerMsg;
	    }

	    super(msg);
	    if (innerException instanceof Error) this.innerException = innerException;
	    if (Error.captureStackTrace) Error.captureStackTrace(this, PhidgetError);
	    this.name = "PhidgetError";
	    this.errorCode = code;
	  }

	  get stacks() {
	    let _stacks = this.stack;
	    if (this.innerException && this.innerException.stack) _stacks += '\n<- ' + this.innerException.stack;
	    return _stacks;
	  }

	}

	let loglevel = exports.LogLevel.WARNING;
	let logsEnabled = true;
	/**
	 * The Logging API controls logs sent to the console. By default, warnings and errors are printed.
	 * Verbosity of logs can be changed, or logging can be disabled entirely.
	 * @public
	 */

	class Log {
	  static setLevel(level) {
	    loglevel = level;
	  }

	  static getLevel() {
	    return loglevel;
	  }
	  /**
	   * Enables logging within the Phidget library. Logs are sent to the console.
	   * @param level - The logging level
	   */


	  static enable(level) {
	    if (level !== undefined) loglevel = level;
	    logsEnabled = true;
	  }

	  static disable() {
	    logsEnabled = false;
	  }
	  /**
	   * Writes a message to the Phidget library log.
	   * @param level - The logging level
	   * @param message - The message
	   */


	  static log(level, message) {
	    switch (level) {
	      case exports.LogLevel.CRITICAL:
	        logcrit(message);
	        break;

	      case exports.LogLevel.ERROR:
	        logerr(message);
	        break;

	      case exports.LogLevel.WARNING:
	        logwarn(message);
	        break;

	      case exports.LogLevel.INFO:
	        loginfo(message);
	        break;

	      case exports.LogLevel.DEBUG:
	        logdebug(message);
	        break;

	      case exports.LogLevel.VERBOSE:
	        logverbose(message);
	        break;
	    }
	  }

	}
	let prevTime = null;

	function colouredText(txt, colour) {
	  return txt;
	}

	function log(logger, lvl, msg, obj) {
	  if (!logsEnabled) return;
	  let msDiffTxt = '';

	  {
	    const curr = Number(new Date());
	    const ms = curr - (prevTime || curr);
	    prevTime = curr;
	    msDiffTxt = colouredText(' +' + ms + 'ms');
	  }

	  const m = ('') + ('') + msg + msDiffTxt;
	  if (obj) logger(m + ' -', obj);else logger(m);
	}

	function logcrit(msg, obj) {
	  if (loglevel >= exports.LogLevel.CRITICAL) log(console.error, ' <' + colouredText('CRIT') + '>', msg, obj);
	}
	function logerr(msg, obj) {
	  if (loglevel >= exports.LogLevel.ERROR) log(console.error, '<' + colouredText('ERROR') + '>', msg, obj);
	}
	function logwarn(msg, obj) {
	  if (loglevel >= exports.LogLevel.WARNING) log(console.warn, ' <' + colouredText('Warn') + '>', msg, obj);
	}
	function loginfo(msg, obj) {
	  if (loglevel >= exports.LogLevel.INFO) log(console.log, ' <' + 'Info' + '>', msg, obj);
	}
	function logdebug(msg, obj) {
	  if (loglevel >= exports.LogLevel.DEBUG) log(console.debug, '<' + colouredText('Debug') + '>', msg, obj);
	}
	function logverbose(msg, obj) {
	  if (loglevel >= exports.LogLevel.VERBOSE) log(console.debug, ' <' + colouredText('Verb') + '>', msg, obj);
	}
	function logbuffer(message, buffer) {
	  if (loglevel < exports.LogLevel.VERBOSE) return;
	  let bytestring = " ";
	  let view;

	  if (ArrayBuffer.isView(buffer)) {
	    view = new DataView(buffer.buffer);
	  } else {
	    view = new DataView(buffer);
	  }

	  for (let i = 0; i < view.byteLength; i++) {
	    let by = view.getUint8(i).toString(16);
	    if (by.length === 1) by = "0" + by;
	    bytestring += "0x" + by + ", ";
	  }

	  bytestring = bytestring.slice(0, bytestring.length - 2);
	  logverbose(message + " - " + bytestring);
	}
	function logEventException(err) {
	  logwarn("Unhandled exception in event handler", err);
	}

	/** @internal */

	class PhidgetLock {
	  constructor() {
	    this._locked = false;
	    this.releaseEvents = [];
	  }

	  onRelease(listener) {
	    this.releaseEvents.push(listener);
	  }

	  removeReleaseListener(listener) {
	    const idx = this.releaseEvents.indexOf(listener);
	    if (idx > -1) this.releaseEvents.splice(idx, 1);
	  }

	  emitRelease() {
	    const listeners = this.releaseEvents.slice();
	    const length = listeners.length;

	    for (let i = 0; i < length; i++) listeners[i]();

	    logverbose('LOCK Released!');
	  }

	  acquire() {
	    logverbose('LOCK Aquiring..');
	    return new promise(resolve => {
	      if (!this._locked) {
	        this._locked = true;
	        return resolve();
	      }

	      const tryAcquire = () => {
	        if (!this._locked) {
	          this._locked = true;
	          this.removeReleaseListener(tryAcquire);
	          logverbose('LOCK Aquired!');
	          return resolve();
	        }
	      };

	      this.onRelease(tryAcquire);
	    });
	  }

	  release() {
	    this._locked = false;
	    setTimeout(() => this.emitRelease());
	  }

	  get locked() {
	    return this._locked;
	  }

	}

	const C_LIBRARY_VERSION = "1.12";
	/**
	 * The base Phidget22 library version for this release - corresponds to the C library version
	 * @public
	 */

	const LibraryVersion = "Phidget22 - Version " + C_LIBRARY_VERSION + " - Built December 5, 2022";
	/**
	 * The JavaScript library version
	 * @public
	 */

	const JSLibraryVersion = "3.12.3 - December 5, 2022";
	const Managers = [];
	const Connections = [];
	const UserPhidgets = [];
	let Epoch;
	function tm() {
	  if (Epoch == undefined) Epoch = Date.now();
	  return Date.now() - Epoch;
	}
	async function scanChannels(userphid) {
	  for (const conn of Connections) {
	    if (userphid._isLocal && conn._isRemote) continue;
	    if (userphid._isRemote && conn._isLocal) continue;
	    if (await conn._match(userphid)) return true;
	  }

	  return false;
	}
	async function scanUserPhidgets(ch) {
	  for (const userphid of UserPhidgets) {
	    if (await ch.tryMatchOpen(userphid)) return;
	  }
	}
	let scanningActive = false;
	let scanStopped;
	let scanLock;
	let scanTimeout;
	async function startScanningUserPhidgets() {
	  if (!scanLock) scanLock = new PhidgetLock();
	  await scanLock.acquire();

	  if (scanningActive) {
	    scanLock.release();
	    return;
	  }

	  const scan = () => {
	    scanTimeout = undefined;

	    const again = () => {
	      if (scanningActive) {
	        scanTimeout = setTimeout(scan, 1000);
	      } else {
	        if (scanStopped) {
	          scanStopped();
	          scanStopped = undefined;
	        }
	      }
	    };

	    promise.all(UserPhidgets.filter(userphid => !userphid._attaching && !userphid._isopen).map(userphid => {
	      return scanChannels(userphid);
	    })).then(() => {
	      again();
	    }).catch(err => {
	      logerr("Error during User Phidgets scan", err);
	      again();
	    });
	  };

	  scanningActive = true;
	  loginfo("Starting User Phidget scanning");
	  scan();
	  scanLock.release();
	}
	async function stopScanningUserPhidgets() {
	  if (!scanLock) scanLock = new PhidgetLock();
	  await scanLock.acquire();

	  if (!scanningActive) {
	    scanLock.release();
	    return;
	  }

	  scanningActive = false;

	  if (scanTimeout != undefined) {
	    clearTimeout(scanTimeout);
	  } else {
	    const scanStopPromise = new promise(resolve => {
	      scanStopped = resolve;
	    });
	    await scanStopPromise;
	  }

	  loginfo("User Phidget scanning Stopped");
	  scanLock.release();
	}
	function managerDeviceAttach(dev) {
	  for (const m of Managers) m._deviceAttach(dev);
	}
	function managerDeviceDetach(dev) {
	  for (const m of Managers) m._deviceDetach(dev);
	}
	function managerChannelAttach(ch) {
	  for (const m of Managers) m._channelAttach(ch);
	}
	function managerChannelDetach(ch) {
	  for (const m of Managers) m._channelDetach(ch);
	}

	let _onConnectionRemoved = null;
	let _onConnectionAdded = null;

	function onConnectionRemoved(conn) {
	  if (_onConnectionRemoved) _onConnectionRemoved(conn);
	}

	function onConnectionAdded(conn) {
	  if (_onConnectionAdded) _onConnectionAdded(conn);
	}

	let ConnectionID = 0;
	/** @public */

	class PhidgetConnection {
	  /** @internal */
	  constructor(opts) {
	    this.onError = null;
	    if (opts != undefined && typeof opts !== 'object') throw new Error('Options argument must be an object');
	    this._id = ConnectionID++;
	    this.connected = false;
	    this._channels = new Map();
	    this._devices = new Map();
	    this.name = '';

	    if (opts != undefined) {
	      if (opts.name != undefined && typeof opts.name === 'string') this.name = opts.name;
	      if (opts.onError != undefined && typeof opts.onError === 'function') this.onError = opts.onError;
	    }

	    if (this.onError === undefined) {
	      this.onError = function (code, msg) {
	        logerr("Connection error: " + msg + ':0x' + code.toString(16));
	      };
	    }

	    Connections.push(this);
	    onConnectionAdded(this);
	  }

	  static setOnConnectionRemoved(func) {
	    _onConnectionRemoved = func;
	  }

	  static setOnConnectionAdded(func) {
	    _onConnectionAdded = func;
	  }

	  delete() {
	    if (this.connected) throw new PhidgetError(exports.ErrorCode.BUSY, 'close connection before deleting');
	    onConnectionRemoved(this);
	    if (Connections.includes(this)) Connections.splice(Connections.indexOf(this), 1);
	  }

	  getKey() {
	    return this._id;
	  }

	  get key() {
	    return this._id;
	  }
	  /** @internal */


	  get _isLocal() {
	    return this._type === 0;
	  }
	  /** @internal */


	  get _isRemote() {
	    return this._type === 1;
	  }
	  /** @internal */


	  _getChannel(id) {
	    const ch = this._channels.get(id);

	    if (ch == undefined) throw new PhidgetError(exports.ErrorCode.UNEXPECTED, 'invalid channel id:' + id);
	    return ch;
	  }
	  /** @internal */


	  _getDevice(id) {
	    const dev = this._devices.get(id);

	    if (dev == undefined) return null;
	    return dev;
	  }
	  /** @internal */


	  _detachAllDevices() {
	    while (this._devices.size > 0) {
	      var _context;

	      const last = Array.from(values(_context = this._devices).call(_context))[this._devices.size - 1];

	      try {
	        this._deviceDetach(last);
	      } catch (err) {
	        logerr("Error while detaching all devices", err);
	      }
	    }
	  }
	  /** @internal */


	  _deviceAttach(dev) {
	    if (this._devices.has(dev.id)) throw new PhidgetError(exports.ErrorCode.DUPLICATE, 'duplicate device:' + dev);
	    (dev.isHubPort ? logverbose : loginfo)("Device Attach: " + dev);

	    this._devices.set(dev.id, dev);

	    managerDeviceAttach(dev);
	  }
	  /** @internal */


	  _deviceDetach(dev) {
	    if (!this._devices.has(dev.id)) throw new PhidgetError(exports.ErrorCode.NO_SUCH_ENTITY, 'no such device:' + dev);

	    for (const ch of this._channels.entries()) {
	      if (ch[1].parent === dev) {
	        logverbose("Channel Detach: " + ch[1]);
	        managerChannelDetach(ch[1]);
	        ch[1].detach();

	        this._channels.delete(ch[0]);
	      }
	    }

	    (dev.isHubPort ? logverbose : loginfo)("Device Detach: " + dev);
	    managerDeviceDetach(dev);

	    this._devices.delete(dev.id);
	  }
	  /** @internal */


	  _channelAttach(ch) {
	    if (this._channels.has(ch.id)) throw new PhidgetError(exports.ErrorCode.DUPLICATE, 'duplicate channel:' + ch);
	    logverbose("Channel Attach: " + ch);

	    this._channels.set(ch.id, ch);

	    managerChannelAttach(ch);
	    scanUserPhidgets(ch).catch(err => {
	      logerr("Error scanning user phidgets", err);
	    });
	  }
	  /** @internal */


	  async _match(userphid) {
	    for (const ch of values(_context2 = this._channels).call(_context2)) {
	      var _context2;

	      if (await ch.tryMatchOpen(userphid)) return true;
	    }

	    return false;
	  }

	}

	/** @internal */
	class Request {
	  constructor(dataOrLength, flgs, reqseq, repseq, type, stype) {
	    if (typeof dataOrLength === 'number') {
	      if (flgs === undefined || reqseq === undefined || repseq === undefined || type === undefined || stype === undefined) throw new Error("Invalid Input");
	      this.len = dataOrLength;
	      this.flgs = flgs;
	      this.reqseq = reqseq;
	      this.repseq = repseq;
	      this.type = type;
	      this.stype = stype;
	      this.hdrlen = 16;
	    } else {
	      this.hdrlen = this.parse(dataOrLength);
	    }
	  }

	  toString() {
	    return '{flags:0x' + this.flgs.toString(16) + ' len:' + this.len + ' reqseq:' + this.reqseq + ' repseq:' + this.repseq + ' type:' + this.type + ' subtype:' + this.stype + '}';
	  }

	  parse(buf) {
	    const magic = buf[3] << 24 | buf[2] << 16 | buf[1] << 8 | buf[0];
	    this.len = buf[7] << 24 | buf[6] << 16 | buf[5] << 8 | buf[4];
	    this.flgs = buf[9] << 8 | buf[8];
	    this.reqseq = buf[11] << 8 | buf[10];
	    this.repseq = buf[13] << 8 | buf[12];
	    this.type = buf[14];
	    this.stype = buf[15];
	    if (magic != 1346914608) throw new Error("Bad Request Magic");
	    return 16;
	  }

	  get buffer() {
	    const array = new Uint8Array(16);
	    array[3] = 1346914608 >> 24 & 0xff;
	    array[2] = 1346914608 >> 16 & 0xff;
	    array[1] = 1346914608 >> 8 & 0xff;
	    array[0] = 1346914608 & 0xff;
	    array[7] = this.len >> 24 & 0xff;
	    array[6] = this.len >> 16 & 0xff;
	    array[5] = this.len >> 8 & 0xff;
	    array[4] = this.len & 0xff;
	    array[9] = this.flgs >> 8 & 0xff;
	    array[8] = this.flgs & 0xff;
	    array[11] = this.reqseq >> 8 & 0xff;
	    array[10] = this.reqseq & 0xff;
	    array[13] = this.repseq >> 8 & 0xff;
	    array[12] = this.repseq & 0xff;
	    array[14] = this.type;
	    array[15] = this.stype;
	    return array;
	  }

	}

	var anObject = anObject$b;
	var regexpFlags = function () {
	  var that = anObject(this);
	  var result = '';
	  if (that.global) result += 'g';
	  if (that.ignoreCase) result += 'i';
	  if (that.multiline) result += 'm';
	  if (that.dotAll) result += 's';
	  if (that.unicode) result += 'u';
	  if (that.sticky) result += 'y';
	  return result;
	};

	var uncurryThis$2 = functionUncurryThis;
	var regExpFlags = regexpFlags;
	var flags$3 = uncurryThis$2(regExpFlags);

	var isPrototypeOf$3 = objectIsPrototypeOf;
	var flags$2 = flags$3;
	var RegExpPrototype = RegExp.prototype;
	var flags_1 = function (it) {
	  return (it === RegExpPrototype || isPrototypeOf$3(RegExpPrototype, it)) ? flags$2(it) : it.flags;
	};

	var parent$3 = flags_1;
	var flags$1 = parent$3;

	var flags = flags$1;

	/** @internal */

	const BPE_ISEVENT_FLAG = 0x01;
	/** @internal */

	class BridgePacket {
	  constructor(conn, data) {
	    if (conn != undefined && data != undefined) {
	      this.version = data.v;
	      this.source = data.s;
	      this.flags = data.f;
	      this.vpkt = data.p;
	      this.ch = conn._getChannel(data.O);
	      this.entryCount = data.c;
	      this.entries = data.e;
	      this.local = false;
	    } else {
	      this.version = 0;
	      this.source = 2;
	      this.flags = 0;
	      this.entryCount = 0;
	      this.entries = {};
	      this.local = true;
	    }
	  }

	  isEvent() {
	    if (flags(this) & BPE_ISEVENT_FLAG) return true;
	    return false;
	  }

	  entryType(type) {
	    switch (type) {
	      case 'c':
	      case 'h':
	      case 'uh':
	      case 'd':
	      case 'u':
	      case 'l':
	      case 'ul':
	        return 1;

	      case 'f':
	      case 'g':
	        return 2;

	      case 's':
	        return 3;

	      case 'R':
	      case 'I':
	      case 'G':
	      case 'U':
	      case 'H':
	        return 4;

	      case 'J':
	        return 5;

	      default:
	        return -1;
	    }
	  }

	  validate(e) {
	    switch (this.entryType(e.type)) {
	      case 1:
	      case 2:
	        if (typeof e.value !== 'number') {
	          const num = Number(e.value);
	          if (Number.isNaN(num)) throw new TypeError('Expected number but got ' + typeof e.value);
	          e.value = num;
	        }

	        return;

	      case 3:
	        if (typeof e.value == 'string') return;
	        throw new TypeError('Expected string but got ' + typeof e.value);

	      case 5:
	        if (typeof e.value === 'object') return;
	        throw new TypeError('Expected object but got ' + typeof e.value);

	      case 4:
	        if (Array.isArray(e.value)) return;
	        throw new TypeError('Expected an Array but got ' + typeof e.value);

	      default:
	        throw new Error('Invalid entry type: ' + e.type);
	    }
	  }

	  set(val) {
	    this.validate(val);
	    if (val.name in this.entries) throw new Error('value [' + val.name + '] already set');
	    const e = {
	      t: val.type,
	      v: val.value
	    };
	    this.entries[val.name] = e;
	    this.entryCount++;
	  }

	  remove(name) {
	    const entry = {
	      t: name,
	      v: ""
	    };
	    if (!(entry.t in this.entries)) return;
	    const filteredEntries = {};

	    for (const e in this.entries) {
	      if (e !== entry.t) {
	        filteredEntries[e] = this.entries[e];
	      }
	    }

	    this.entries = filteredEntries;
	    this.entryCount--;
	  }

	  add(val) {
	    val.name = this.entryCount.toString();
	    this.set(val);
	  }

	  getJsonOut(ch) {
	    if (this.vpkt == undefined) throw new Error('vpkt not set!');
	    const bp = {
	      v: this.version,
	      s: this.source,
	      f: flags(this),
	      p: this.vpkt,
	      I: ch.parent.id,
	      X: ch.uniqueIndex,
	      c: this.entryCount,
	      e: this.entries
	    };
	    return bp;
	  }

	  async send(ch, vpkt) {
	    let callBridgeInput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	    if (!ch || !ch.isopen) throw new PhidgetError(exports.ErrorCode.NOT_ATTACHED);
	    this.vpkt = vpkt;
	    const response = await ch.send(this);
	    if (callBridgeInput) ch.bridgeInput(this);
	    return response;
	  }

	  deliver() {
	    if (!this.ch) throw new PhidgetError(exports.ErrorCode.UNEXPECTED, 'Bridge packet missing channel');
	    if (this.ch.isopen === false) return;
	    this.ch.bridgeInput(this);
	  }

	  sendToChannel(ch, vpkt) {
	    this.vpkt = vpkt;
	    ch.clearErrorEvent();
	    ch.bridgeInput(this);
	  }

	  getNumber(name) {
	    if (!(name in this.entries)) throw new Error("BP entry '".concat(name, "' does not exist."));
	    const type = this.entryType(this.entries[name].t);
	    if (type != 2 && type != 1) throw new Error("BP entry '".concat(name, "' is not a number."));
	    if (typeof this.entries[name].v !== 'number') throw new Error("BP entry '".concat(name, "' has an unexpected value!"));
	    return this.entries[name].v;
	  }

	  getArray(name) {
	    if (!(name in this.entries)) throw new Error("BP entry '".concat(name, "' does not exist."));
	    const type = this.entryType(this.entries[name].t);
	    if (type != 4) throw new Error("BP entry '".concat(name, "' is not an array."));
	    if (!Array.isArray(this.entries[name].v)) throw new Error("BP entry '".concat(name, "' has an unexpected value!"));
	    return this.entries[name].v;
	  }

	  getObject(name) {
	    if (!(name in this.entries)) throw new Error("BP entry '".concat(name, "' does not exist."));
	    const type = this.entryType(this.entries[name].t);
	    if (type != 5) throw new Error("BP entry '".concat(name, "' is not an object."));
	    if (typeof this.entries[name].v !== 'object') throw new Error("BP entry '".concat(name, "' has an unexpected value!"));
	    return this.entries[name].v;
	  }

	  getString(name) {
	    if (!(name in this.entries)) throw new Error("BP entry '".concat(name, "' does not exist."));
	    const type = this.entryType(this.entries[name].t);
	    if (type != 3) throw new Error("BP entry '".concat(name, "' is not a string."));
	    if (this.entries[name].v === null) throw new Error("BP entry '".concat(name, "' is null."));
	    if (typeof this.entries[name].v !== 'string') throw new Error("BP entry '".concat(name, "' has an unexpected value!"));
	    return this.entries[name].v;
	  }

	  getBoolean(name) {
	    if (!(name in this.entries)) throw new Error("BP entry '".concat(name, "' does not exist."));
	    const type = this.entryType(this.entries[name].t);
	    if (type != 1) throw new Error("BP entry '".concat(name, "' is not a boolean."));
	    if (typeof this.entries[name].v !== 'number') throw new Error("BP entry '".concat(name, "' has an unexpected value!"));
	    if (this.entries[name].v === 0) return false;
	    if (this.entries[name].v === 1) return true;
	    if (this.entries[name].v === 2) return 2;
	    throw new Error("BP entry '".concat(name, "' has an unexpected value!"));
	  }

	}

	/** @internal */
	const ChannelClassName = {
	  0: 'PhidgetNone',
	  1: 'PhidgetAccelerometer',
	  35: 'PhidgetBLDCMotor',
	  14: 'PhidgetCapacitiveTouch',
	  2: 'PhidgetCurrentInput',
	  38: 'PhidgetCurrentOutput',
	  3: 'PhidgetDataAdapter',
	  4: 'PhidgetDCMotor',
	  36: 'PhidgetDictionary',
	  5: 'PhidgetDigitalInput',
	  6: 'PhidgetDigitalOutput',
	  7: 'PhidgetDistanceSensor',
	  8: 'PhidgetEncoder',
	  32: 'PhidgetFirmwareUpgrade',
	  9: 'PhidgetFrequencyCounter',
	  33: 'PhidgetGeneric',
	  10: 'PhidgetGPS',
	  12: 'PhidgetGyroscope',
	  13: 'PhidgetHub',
	  15: 'PhidgetHumiditySensor',
	  16: 'PhidgetIR',
	  11: 'PhidgetLCD',
	  17: 'PhidgetLightSensor',
	  18: 'PhidgetMagnetometer',
	  19: 'PhidgetMeshDongle',
	  34: 'PhidgetMotorPositionController',
	  37: 'PhidgetPHSensor',
	  20: 'PhidgetPowerGuard',
	  21: 'PhidgetPressureSensor',
	  22: 'PhidgetRCServo',
	  23: 'PhidgetResistanceInput',
	  24: 'PhidgetRFID',
	  25: 'PhidgetSoundSensor',
	  26: 'PhidgetSpatial',
	  27: 'PhidgetStepper',
	  28: 'PhidgetTemperatureSensor',
	  29: 'PhidgetVoltageInput',
	  30: 'PhidgetVoltageOutput',
	  31: 'PhidgetVoltageRatioInput'
	};

	/** @internal */
	const DeviceClassName = {
	  0: 'PhidgetNone',
	  1: 'PhidgetAccelerometer',
	  2: 'PhidgetAdvancedServo',
	  3: 'PhidgetAnalog',
	  4: 'PhidgetBridge',
	  25: 'PhidgetDataAdapter',
	  24: 'PhidgetDictionary',
	  5: 'PhidgetEncoder',
	  23: 'PhidgetFirmwareUpgrade',
	  6: 'PhidgetFrequencyCounter',
	  22: 'PhidgetGeneric',
	  7: 'PhidgetGPS',
	  8: 'PhidgetHub',
	  9: 'PhidgetInterfaceKit',
	  10: 'PhidgetIR',
	  11: 'PhidgetLED',
	  12: 'PhidgetMeshDongle',
	  13: 'PhidgetMotorControl',
	  14: 'PhidgetPHSensor',
	  15: 'PhidgetRFID',
	  16: 'PhidgetServo',
	  17: 'PhidgetSpatial',
	  18: 'PhidgetStepper',
	  19: 'PhidgetTemperatureSensor',
	  20: 'PhidgetTextLCD',
	  21: 'PhidgetVINT'
	};

	/**
	 * The core Phidget class deals with functionality common to all Phidgets, such as opening and closing them, or setting Attach, Detach and Event handlers.
	 *
	 * This class is also used to specify the associations between the Phidget software objects and their corresponding physical devices, and makes it possible to determine which Phidget is which in cases where it might otherwise be ambiguous.
	 *
	 * This class contains various functions such as **Release**, **Retain**, and **getParent** designed to be used with the **Phidget Manager**. These specialized functions may be safely ignored if your application does not require a **Manager**. You can check the **Manager API** for more information.
	 * @public
	 */
	class PhidgetBase {
	  static get ANY_SERIAL_NUMBER() {
	    return -1;
	  }

	  static get ANY_HUB_PORT() {
	    return -1;
	  }

	  static get ANY_CHANNEL() {
	    return -1;
	  }

	  static get ANY_LABEL() {
	    return null;
	  }

	  static get INFINITE_TIMEOUT() {
	    return 0;
	  }

	  static get DEFAULT_TIMEOUT() {
	    return 2500;
	  }
	  /**
	   * Gets the attached status of channel. A Phidget is attached after it has been opened and the Phidget library finds and connects to the corresponding hardware device.
	   *
	   * *   Most API calls are only valid on attached Phidgets.
	   * @throws {@link PhidgetError}
	   */


	  get attached() {
	    return this.getAttached();
	  }
	  /**
	   * get: Gets the channel index of the channel on the device.
	   *
	   * set: Specifies the channel index to be opened. The default channel is 0. Set to `ANY_CHANNEL` to open any channel on the specified device.
	   *
	   * If setting this property, it must be set before the channel is opened. The behaviour of setting this property while the channel is open is undefined.
	   * @throws {@link PhidgetError}
	   */


	  get channel() {
	    return this.getChannel();
	  }

	  set channel(channel) {
	    this.setChannel(channel);
	  }
	  /**
	   * Returns true if this represents a channel, false if this represents a device. Mostly for use alongside `getParent()` to distinguish channel handles from device handles.
	   * @throws {@link PhidgetError}
	   */


	  get isChannel() {
	    return this.getIsChannel();
	  }
	  /**
	   * Gets the channel class of the channel.
	   * @throws {@link PhidgetError}
	   */


	  get channelClass() {
	    return this.getChannelClass();
	  }
	  /**
	   * Gets the name of the channel class the channel belongs to.
	   * @throws {@link PhidgetError}
	   */


	  get channelClassName() {
	    return this.getChannelClassName();
	  }
	  /**
	   * Gets the channel's name. This name serves as a description of the specific nature of the channel.
	   * @throws {@link PhidgetError}
	   */


	  get channelName() {
	    return this.getChannelName();
	  }
	  /**
	   * Gets the subclass for this channel. Allows for identifying channels with specific characteristics without needing to know the exact device and channel index.
	   * @throws {@link PhidgetError}
	   */


	  get channelSubclass() {
	    return this.getChannelSubclass();
	  }
	  /**
	   * Gets the connection associated with this Phidget.
	   * @throws {@link PhidgetError}
	   */


	  get connection() {
	    return this.getConnection();
	  }
	  /**
	   * Gets the device class for the Phidget which this channel is a part of.
	   * @throws {@link PhidgetError}
	   */


	  get deviceClass() {
	    return this.getDeviceClass();
	  }
	  /**
	   * Gets the name of the device class for the Phidget which this channel is a part of.
	   * @throws {@link PhidgetError}
	   */


	  get deviceClassName() {
	    return this.getDeviceClassName();
	  }
	  /**
	   * Gets the string which will match the filename of the firmware upgrade file
	   * @throws {@link PhidgetError}
	   * @internal
	   */


	  get deviceFirmwareUpgradeString() {
	    return this.getDeviceFirmwareUpgradeString();
	  }
	  /**
	   * Gets the Device ID for the Phidget which this channel is a part of.
	   * @throws {@link PhidgetError}
	   */


	  get deviceID() {
	    return this.getDeviceID();
	  }
	  /**
	   * get: Gets the label of the Phidget which this channel is a part of. A device label is a custom string used to more easily identify a Phidget. Labels are written to a Phidget using `writeDeviceLabel()`, or by right-clicking the device and setting a label in the Phidget Control Panel for Windows.
	   *
	   * set: Specifies the label of the Phidget to be opened. Leave un-set to open any label. A device label is a custom string used to more easily identify a Phidget. Labels are written to a Phidget using `writeDeviceLabel()`, or by right-clicking the device and setting a label in the Phidget Control Panel for Windows.
	   *
	   * If setting this property, it must be set before the channel is opened. The behaviour of setting this property while the channel is open is undefined.
	   * @throws {@link PhidgetError}
	   */


	  get deviceLabel() {
	    return this.getDeviceLabel();
	  }

	  set deviceLabel(deviceLabel) {
	    this.setDeviceLabel(deviceLabel);
	  }
	  /**
	   * Gets the name of the Phidget which this channel is a part of.
	   * @throws {@link PhidgetError}
	   */


	  get deviceName() {
	    return this.getDeviceName();
	  }
	  /**
	   * get: Gets the serial number of the Phidget which this channel is a part of.
	   * If the channel is part of a VINT device, this will be the serial number of the VINT Hub the device is attached to.
	   *
	   * set: Specifies the serial number of the Phidget to be opened. Leave un-set, or set to `ANY_SERIAL_NUMBER` to open any serial number.
	   * If the channel is part of a VINT device, this will be the serial number of the VINT Hub the device is attached to.
	   *
	   * If setting this property, it must be set before the channel is opened. The behaviour of setting this property while the channel is open is undefined.
	   * @throws {@link PhidgetError}
	   */


	  get deviceSerialNumber() {
	    return this.getDeviceSerialNumber();
	  }

	  set deviceSerialNumber(deviceSerialNumber) {
	    this.setDeviceSerialNumber(deviceSerialNumber);
	  }
	  /**
	   * Gets the SKU (part number) of the Phidget which this channel is a part of.
	   * @throws {@link PhidgetError}
	   */


	  get deviceSKU() {
	    return this.getDeviceSKU();
	  }
	  /**
	   * Gets the firmware version of the Phidget which this channel is a part of.
	   * @throws {@link PhidgetError}
	   */


	  get deviceVersion() {
	    return this.getDeviceVersion();
	  }
	  /**
	   * Gets the vint id for the Phidget which this channel is a part of.
	   * @throws {@link PhidgetError}
	   * @internal
	   */


	  get deviceVINTID() {
	    return this.getDeviceVINTID();
	  }
	  /**
	   * Gets the hub that this channel is attached to.
	   * @throws {@link PhidgetError}
	   */


	  get hub() {
	    return this.getHub();
	  }
	  /**
	   * get: Gets the hub port index of the VINT Hub port that the channel is attached to.
	   *
	   * set: Specifies the hub port index of the VINT Hub port to open this channel on. Leave un-set, or set to `ANY_HUB_PORT` to open the channel on any VINT Hub port
	   *
	   * If setting this property, it must be set before the channel is opened. The behaviour of setting this property while the channel is open is undefined.
	   * @throws {@link PhidgetError}
	   */


	  get hubPort() {
	    return this.getHubPort();
	  }

	  set hubPort(hubPort) {
	    this.setHubPort(hubPort);
	  }
	  /**
	   * Gets the number of VINT ports present on the VINT Hub that the channel is attached to.
	   * @throws {@link PhidgetError}
	   */


	  get hubPortCount() {
	    return this.getHubPortCount();
	  }
	  /**
	   * get: Gets whether this channel is a VINT Hub port channel, or part of a VINT device attached to a hub port.
	   *
	   * set: Specifies whether this channel should be opened on a VINT Hub port directly, or on a VINT device attached to a hub port.
	   *
	   * If setting this property, it must be set before the channel is opened. The behaviour of setting this property while the channel is open is undefined.
	   * @throws {@link PhidgetError}
	   */


	  get isHubPortDevice() {
	    return this.getIsHubPortDevice();
	  }

	  set isHubPortDevice(isHubPortDevice) {
	    this.setIsHubPortDevice(isHubPortDevice);
	  }
	  /**
	   * Configures the communication speed for this VINT device. Available speeds depend on the VINT Device and Hub Port capabilities.
	   * @throws {@link PhidgetError}
	   */


	  get hubPortSpeed() {
	    return this.getHubPortSpeed();
	  }
	  /**
	   * The max communication speed of a high-speed capable VINT Port.
	   * @throws {@link PhidgetError}
	   */


	  get maxHubPortSpeed() {
	    return this.getMaxHubPortSpeed();
	  }
	  /**
	   * Indicates that the communication speed of this VINT port can be set.
	   * @throws {@link PhidgetError}
	   */


	  get hubPortSupportsSetSpeed() {
	    return this.getHubPortSupportsSetSpeed();
	  }
	  /**
	   * Gets a key which identifies this device or channel uniquely. This can be useful for correlating attach/detach events from the **Manager**.
	   * @throws {@link PhidgetError}
	   */


	  get key() {
	    return this.getKey();
	  }
	  /**
	   * get: Returns true when this channel is attached directly on the local machine, or false otherwise.
	   *
	   * set: Set to True if the channel is to be opened locally, and not over a network. If both this and `isRemote` are set to False (the default), the channel will be opened either locally or remotely, on whichever matching channel is found first.
	   *
	   * If setting this property, it must be set before the channel is opened. The behaviour of setting this property while the channel is open is undefined.
	   * @throws {@link PhidgetError}
	   */


	  get isLocal() {
	    return this.getIsLocal();
	  }

	  set isLocal(isLocal) {
	    this.setIsLocal(isLocal);
	  }
	  /**
	   * Returns true if `open()` has been called on this channel.
	   * @throws {@link PhidgetError}
	   */


	  get isOpen() {
	    return this.getIsOpen();
	  }
	  /**
	   * Gets the handle of the parent device of the given Phidget handle.
	   *
	   * For example, this would refer to the device the channel is a part of, or the Hub that a device is plugged into.
	   *
	   * This is useful when used alongside a **Phidget Manager** to create device trees like the one in the Phidget Control Panel.
	   *
	   * *   This can be used to travel up the device tree and get device information at each step.
	   * *   The root device will return a null handle
	   * *   Parent handles always refer to devices. See `getIsChannel()`
	   * @throws {@link PhidgetError}
	   */


	  get parent() {
	    return this.getParent();
	  }
	  /**
	   * get: Returns true when this channel is attached via a Phidget network server, or false otherwise.
	   *
	   * set:
	   *
	   * Set to True if the channel is to be opened remotely, rather than locally. If both this and `isLocal` are set to False (the default), the channel will be opened either locally or remotely, on whichever matching channel is found first.
	   *
	   * If setting this property, it must be set before the channel is opened. The behaviour of setting this property while the channel is open is undefined.
	   * @throws {@link PhidgetError}
	   */


	  get isRemote() {
	    return this.getIsRemote();
	  }

	  set isRemote(isRemote) {
	    this.setIsRemote(isRemote);
	  }
	  /**
	   * The max communication speed of a high-speed capable VINT Device.
	   * @throws {@link PhidgetError}
	   */


	  get maxVINTDeviceSpeed() {
	    return this.getMaxVINTDeviceSpeed();
	  }
	  /**
	   * Indicates that the communication speed of this VINT device can be set.
	   * @throws {@link PhidgetError}
	   */


	  get VINTDeviceSupportsSetSpeed() {
	    return this.getVINTDeviceSupportsSetSpeed();
	  }

	}

	/** @public */

	class Phidget extends PhidgetBase {
	  /** @internal */
	  constructor(chOrDev) {
	    super();
	    this.onAttach = null;
	    this.onDetach = null;
	    this.onError = null;
	    this.onPropertyChange = null;

	    if (chOrDev !== undefined) {
	      this._fromManager = true;
	      this._isattached = true;
	    } else {
	      this._fromManager = false;
	      this._isattached = false;
	    }
	  }
	  /**
	   * Gets the version of the Phidget library being used by the program in human readable form.
	   * @returns The Phidget library version.
	   * @throws {@link PhidgetError}
	  */


	  static get libraryVersion() {
	    return this.getLibraryVersion();
	  }
	  /**
	   * Gets the version of the Phidget library being used by the program in human readable form.
	   * @returns The Phidget library version.
	   * @throws {@link PhidgetError}
	  */


	  static getLibraryVersion() {
	    return LibraryVersion;
	  }

	}
	/** @public */


	class PhidgetChannel extends Phidget {
	  /** @internal */
	  constructor(ch) {
	    super(ch);
	    this._attaching = false;
	    this._useropen = false;
	    this._isopen = false;
	    this._detaching = false;
	    this._isHubPort = false;
	    this._channel = Phidget.ANY_CHANNEL;
	    this._deviceLabel = Phidget.ANY_LABEL;
	    this._serialNumber = Phidget.ANY_SERIAL_NUMBER;
	    this._hubPort = Phidget.ANY_HUB_PORT;
	    this._isLocal = false;
	    this._isRemote = false;
	    this._ch = ch;
	  }
	  /** @internal */


	  _cancelOpenTimeout() {
	    if (this._openTimeoutTimer != undefined) {
	      clearTimeout(this._openTimeoutTimer);
	      delete this._openTimeoutTimer;
	    }

	    delete this._openTimeout;
	    delete this._openTime;
	  }
	  /** @internal */


	  async _wasOpened(ch) {
	    this._ch = ch;
	    this._isopen = true;
	    this._isattached = true;

	    this._cancelOpenTimeout();

	    if (this.onAttach) {
	      try {
	        await this.onAttach(this);
	      } catch (err) {
	        logEventException(err);
	      }
	    }

	    if (this._resolveOpen) this._resolveOpen();
	  }
	  /** @internal */


	  async _close() {
	    let fromDetach = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

	    this._cancelOpenTimeout();

	    if (fromDetach) {
	      this._useropen = true;
	    } else {
	      if (UserPhidgets.includes(this)) UserPhidgets.splice(UserPhidgets.indexOf(this), 1);
	      if (UserPhidgets.length === 0) await stopScanningUserPhidgets();
	    }

	    if (this._isopen) {
	      try {
	        if (this._ch) await this._ch.close();
	      } catch (err) {
	        logwarn("Error while closing channel", err);
	      }

	      this._detaching = true;
	      this._isattached = false;

	      if (this.onDetach) {
	        try {
	          this.onDetach(this);
	        } catch (err) {
	          logEventException(err);
	        }
	      }

	      this._detaching = false;
	      this._isopen = false;
	      delete this._ch;
	    } else {
	      if (this._rejectOpen != undefined) this._rejectOpen(new PhidgetError(exports.ErrorCode.CLOSED, "Closed while waiting for open"));
	    }
	  }
	  /** @internal */


	  _FIREPropertyChange(prop, bp) {
	    if (this.onPropertyChange && this._isAttachedDone && (bp === undefined || bp.local !== true)) {
	      try {
	        this.onPropertyChange(prop);
	      } catch (err) {
	        logEventException(err);
	      }
	    }
	  }
	  /** @internal */


	  _handleSetStatus(bp) {
	    for (const e in bp.entries) {
	      if (e === '_class_version_') continue;
	      if (e === 'dataIntervalDbl') continue;

	      if (!(e in this.data)) {
	        loginfo("Unknown property: " + e + " in setstatus packet. Probably server is newer than client.");
	        continue;
	      }

	      this.data[e] = bp.entries[e].v;
	    }

	    if (bp.entries.dataIntervalDbl !== undefined) this.data.dataInterval = bp.entries.dataIntervalDbl.v;
	    if (this.data.minDataInterval != undefined && bp.entries.maxDataRate === undefined) this.data.maxDataRate = 1000.0 / this.data.minDataInterval;
	    if (this.data.maxDataInterval != undefined && bp.entries.minDataRate === undefined) this.data.minDataRate = 1000.0 / this.data.maxDataInterval;
	  }
	  /** @internal */


	  _assertAttached() {
	    if (!this._ch || !this._isattached && !this._detaching) throw new PhidgetError(exports.ErrorCode.NOT_ATTACHED);
	  }
	  /** @internal */


	  _assertOpen() {
	    if (!this._ch || !this._isopen || !this._isattached && !this._detaching) throw new PhidgetError(exports.ErrorCode.NOT_ATTACHED);
	  }
	  /** @internal */


	  get _isAttachedDone() {
	    if (this._isattached && !this._attaching) return true;
	    return false;
	  }
	  /** @internal */


	  get _isAttachedOrDetaching() {
	    if (this._isattached || this._detaching) return true;
	    return false;
	  }

	  toString() {
	    if (this._ch) return this._ch.toString();
	    return this.constructor.name;
	  }

	  getConnection() {
	    if (this._ch) return this._ch.conn;
	    return null;
	  }

	  getKey() {
	    this._assertAttached();

	    return 'ch' + this._ch.id + "_" + this._ch.conn._id;
	  }

	  async open() {
	    let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	    if (this._useropen) return;
	    this._useropen = true;
	    this._openTime = tm();
	    if (!isNaN(timeout) && timeout > 0) this._openTimeout = timeout;else delete this._openTimeout;
	    UserPhidgets.push(this);

	    if (this._fromManager === true) {
	      this.setChannel(this.getChannel());
	      this.setHubPort(this.getHubPort());
	      this.setDeviceSerialNumber(this.getDeviceSerialNumber());
	      this.setIsHubPortDevice(this.getIsHubPortDevice());
	      this.setIsLocal(this.getIsLocal());
	      this.setIsRemote(this.getIsRemote());
	      this._fromManager = false;
	      this._isattached = false;
	      delete this._ch;
	    }

	    const openPromise = new promise((resolve, reject) => {
	      this._resolveOpen = resolve;
	      this._rejectOpen = reject;
	    });

	    try {
	      await scanChannels(this);
	    } catch (err) {
	      logerr("Problem during open scan", err);
	    }

	    await startScanningUserPhidgets();

	    if (this._openTimeout) {
	      this._openTimeoutTimer = setTimeout(() => {
	        delete this._openTimeoutTimer;
	        const reject = this._rejectOpen;
	        delete this._rejectOpen;
	        this.close().then(() => {
	          if (reject) reject(new PhidgetError(exports.ErrorCode.TIMEOUT, "Open timed out"));
	        }).catch(err => {
	          logwarn("Error calling close after open timeout", err);
	          if (reject) reject(new PhidgetError(exports.ErrorCode.TIMEOUT, "Open timed out"));
	        });
	      }, this._openTimeout);
	    }

	    return openPromise;
	  }

	  async close() {
	    if (this._useropen) {
	      logdebug("closing phidget");
	      this._useropen = false;
	      await this._close();
	    }
	  }

	  getAttached() {
	    return this._isattached;
	  }

	  getIsOpen() {
	    return this._useropen;
	  }

	  getChannel() {
	    if (!this._isattached && !this._detaching) return this._channel;
	    return this._ch.index;
	  }

	  setChannel(ch) {
	    this._channel = ch;
	  }

	  getChannelClass() {
	    return this._class;
	  }

	  getChannelClassName() {
	    return ChannelClassName[this._class];
	  }

	  getChannelName() {
	    this._assertAttached();

	    return this._ch.name;
	  }

	  getChannelSubclass() {
	    this._assertAttached();

	    return this._ch.subclass;
	  }

	  getDeviceClass() {
	    this._assertAttached();

	    return this._ch.parent.class;
	  }

	  getDeviceClassName() {
	    this._assertAttached();

	    return DeviceClassName[this._ch.parent.class];
	  }

	  getDeviceID() {
	    this._assertAttached();

	    return this._ch.parent.deviceID;
	  }

	  getDeviceLabel() {
	    if (!this._isattached && !this._detaching) return this._deviceLabel ? this._deviceLabel : '';
	    return this._ch.parent.label;
	  }

	  setDeviceLabel(label) {
	    this._deviceLabel = label;
	  }

	  getDeviceName() {
	    this._assertAttached();

	    return this._ch.parent.name;
	  }

	  getDeviceSerialNumber() {
	    if (!this._isattached && !this._detaching) return this._serialNumber;
	    return this._ch.parent.serialNumber;
	  }

	  setDeviceSerialNumber(sn) {
	    if (!isNaN(sn)) this._serialNumber = sn;
	  }

	  getDeviceSKU() {
	    this._assertAttached();

	    return this._ch.parent.sku;
	  }

	  getDeviceVersion() {
	    this._assertAttached();

	    return this._ch.parent.version;
	  }

	  getHub() {
	    this._assertAttached();

	    let hub = this._ch.parent;

	    while (hub != undefined && hub.class !== exports.DeviceClass.HUB) hub = hub.parent;

	    if (hub == undefined) throw new PhidgetError(exports.ErrorCode.WRONG_DEVICE, "Hub not found");
	    return new PhidgetDevice(hub);
	  }

	  getHubPort() {
	    if (!this._isattached && !this._detaching) return this._hubPort;
	    return this._ch.parent.hubPort;
	  }

	  setHubPort(hubPort) {
	    if (!isNaN(hubPort)) this._hubPort = hubPort;
	  }

	  getHubPortSpeed() {
	    this._assertAttached();

	    if (this._ch.parent.class !== exports.DeviceClass.VINT) throw new PhidgetError(exports.ErrorCode.WRONG_DEVICE);
	    if (this._ch.parent.vintDeviceProps.commSpeed == undefined || this._ch.parent.vintDeviceProps.commSpeed == 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this._ch.parent.vintDeviceProps.commSpeed;
	  }

	  async setHubPortSpeed(hubPortSpeed) {
	    this._assertAttached();

	    if (this._ch.parent.class !== exports.DeviceClass.VINT) throw new PhidgetError(exports.ErrorCode.WRONG_DEVICE);
	    const bp = new BridgePacket();
	    bp.set({
	      name: '0',
	      type: 'u',
	      value: hubPortSpeed
	    });
	    await bp.send(this._ch, 173);
	  }

	  getIsChannel() {
	    return true;
	  }

	  getIsHubPortDevice() {
	    if (!this._isattached && !this._detaching) return this._isHubPort;
	    return this._ch.parent.isHubPort;
	  }

	  setIsHubPortDevice(isHubPort) {
	    this._isHubPort = isHubPort;
	  }

	  getIsLocal() {
	    if (!this._isattached && !this._detaching) return this._isLocal;
	    return this._ch.parent.conn._isLocal;
	  }

	  setIsLocal(isLocal) {
	    this._isLocal = isLocal;
	  }

	  getIsRemote() {
	    if (!this._isattached && !this._detaching) return this._isRemote;
	    return this._ch.parent.conn._isRemote;
	  }

	  setIsRemote(isRemote) {
	    this._isRemote = isRemote;
	  }

	  getParent() {
	    this._assertAttached();

	    return new PhidgetDevice(this._ch.parent);
	  }

	  getDeviceFirmwareUpgradeString() {
	    this._assertAttached();

	    return this._ch.parent.fwstr;
	  }

	  async writeDeviceLabel(deviceLabel) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "s",
	      value: deviceLabel
	    });
	    await bp.send(this._ch, 140);
	  }

	  getDeviceChannelCount(cls) {
	    this._assertAttached();

	    let count = 0;

	    for (const ch of this._ch.parent.devDef.ch) {
	      if (cls != undefined && ch.c == undefined) throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	      if (cls == undefined || ch.c === cls) count++;
	    }

	    return count;
	  }

	  getDeviceVINTID() {
	    this._assertAttached();

	    if (this.deviceClass !== exports.DeviceClass.VINT) throw new PhidgetError(exports.ErrorCode.WRONG_DEVICE);
	    return this._ch.parent.vintID;
	  }

	  getHubPortCount() {
	    this._assertAttached();

	    const hub = this.getHub();
	    if (hub._device.devDef.cn == undefined) throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    return hub._device.devDef.cn[0];
	  }

	  getHubPortSupportsSetSpeed() {
	    this._assertAttached();

	    if (this.deviceClass !== exports.DeviceClass.VINT) throw new PhidgetError(exports.ErrorCode.WRONG_DEVICE);
	    return this.hub._device.hubPortProps[this.hubPort].portSuppSetSpeed;
	  }

	  getMaxHubPortSpeed() {
	    this._assertAttached();

	    if (this.deviceClass !== exports.DeviceClass.VINT) throw new PhidgetError(exports.ErrorCode.WRONG_DEVICE);
	    if (this.hub._device.hubPortProps[this.hubPort].portMaxSpeed === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.hub._device.hubPortProps[this.hubPort].portMaxSpeed;
	  }

	  getVINTDeviceSupportsSetSpeed() {
	    this._assertAttached();

	    if (this.deviceClass !== exports.DeviceClass.VINT) throw new PhidgetError(exports.ErrorCode.WRONG_DEVICE);
	    return this._ch.parent.vintDeviceProps.suppSetSpeed;
	  }

	  getMaxVINTDeviceSpeed() {
	    this._assertAttached();

	    if (this.deviceClass !== exports.DeviceClass.VINT) throw new PhidgetError(exports.ErrorCode.WRONG_DEVICE);
	    if (this._ch.parent.vintDeviceProps.maxSpeed === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this._ch.parent.vintDeviceProps.maxSpeed;
	  }

	  async reboot() {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    await bp.send(this._ch, 139, false);
	  }

	  async rebootFirmwareUpgrade(upgradeTimeout) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: upgradeTimeout
	    });
	    await bp.send(this._ch, 138, false);
	  }

	}
	/** @public */


	class PhidgetDevice extends Phidget {
	  /** @internal */
	  constructor(dev) {
	    super(dev);
	    this._device = dev;
	    this.name = "PhidgetDevice";
	  }

	  toString() {
	    return this._device.toString();
	  }

	  getConnection() {
	    return this._device.conn;
	  }

	  getKey() {
	    return 'dev' + this._device.id + "_" + this._device.conn._id;
	  }

	  getAttached() {
	    return true;
	  }

	  getIsOpen() {
	    return false;
	  }

	  getDeviceClass() {
	    return this._device.class;
	  }

	  getDeviceClassName() {
	    return DeviceClassName[this._device.class];
	  }

	  getDeviceID() {
	    return this._device.deviceID;
	  }

	  getDeviceLabel() {
	    return this._device.label;
	  }

	  getDeviceName() {
	    return this._device.name;
	  }

	  getDeviceSerialNumber() {
	    return this._device.serialNumber;
	  }

	  getDeviceSKU() {
	    return this._device.sku;
	  }

	  getDeviceVersion() {
	    return this._device.version;
	  }

	  getHub() {
	    let hub = this._device;

	    while (hub != undefined && hub.class !== exports.DeviceClass.HUB) hub = hub.parent;

	    if (hub == undefined) throw new PhidgetError(exports.ErrorCode.WRONG_DEVICE, "Hub not found");
	    return new PhidgetDevice(hub);
	  }

	  getHubPort() {
	    return this._device.hubPort;
	  }

	  getHubPortSpeed() {
	    if (this._device.class !== exports.DeviceClass.VINT) throw new PhidgetError(exports.ErrorCode.WRONG_DEVICE);
	    if (this._device.vintDeviceProps.commSpeed == undefined || this._device.vintDeviceProps.commSpeed == 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this._device.vintDeviceProps.commSpeed;
	  }

	  getIsChannel() {
	    return false;
	  }

	  getIsHubPortDevice() {
	    return this._device.isHubPort;
	  }

	  getIsLocal() {
	    return this._device.conn._isLocal;
	  }

	  getIsRemote() {
	    return this._device.conn._isRemote;
	  }

	  getParent() {
	    const parent = this._device.parent;
	    if (!parent) return null;
	    return new PhidgetDevice(parent);
	  }

	  getDeviceFirmwareUpgradeString() {
	    return this._device.fwstr;
	  }

	  getDeviceChannelCount(cls) {
	    let count = 0;

	    for (const ch of this._device.devDef.ch) {
	      if (cls != undefined && ch.c == undefined) throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	      if (cls == undefined || ch.c === cls) count++;
	    }

	    return count;
	  }

	  getDeviceVINTID() {
	    if (this.deviceClass !== exports.DeviceClass.VINT) throw new PhidgetError(exports.ErrorCode.WRONG_DEVICE);
	    return this._device.vintID;
	  }

	  getHubPortCount() {
	    const hub = this.getHub();
	    if (hub._device.devDef.cn == undefined) throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    return hub._device.devDef.cn[0];
	  }

	  getHubPortSupportsSetSpeed() {
	    if (this.deviceClass !== exports.DeviceClass.VINT) throw new PhidgetError(exports.ErrorCode.WRONG_DEVICE);
	    return this.hub._device.hubPortProps[this.hubPort].portSuppSetSpeed;
	  }

	  getMaxHubPortSpeed() {
	    if (this.deviceClass !== exports.DeviceClass.VINT) throw new PhidgetError(exports.ErrorCode.WRONG_DEVICE);
	    if (this.hub._device.hubPortProps[this.hubPort].portMaxSpeed === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.hub._device.hubPortProps[this.hubPort].portMaxSpeed;
	  }

	  getVINTDeviceSupportsSetSpeed() {
	    if (this.deviceClass !== exports.DeviceClass.VINT) throw new PhidgetError(exports.ErrorCode.WRONG_DEVICE);
	    return this._device.vintDeviceProps.suppSetSpeed;
	  }

	  getMaxVINTDeviceSpeed() {
	    if (this.deviceClass !== exports.DeviceClass.VINT) throw new PhidgetError(exports.ErrorCode.WRONG_DEVICE);
	    if (this._device.vintDeviceProps.maxSpeed === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this._device.vintDeviceProps.maxSpeed;
	  }

	  getChannel() {
	    throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	  }

	  setChannel(_channel) {
	    throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	  }

	  getChannelClass() {
	    throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	  }

	  getChannelClassName() {
	    throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	  }

	  getChannelName() {
	    throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	  }

	  getChannelSubclass() {
	    throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	  }

	  close() {
	    throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	  }

	  setDeviceLabel(_deviceLabel) {
	    throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	  }

	  setDeviceSerialNumber(_deviceSerialNumber) {
	    throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	  }

	  setHubPort(_hubPort) {
	    throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	  }

	  setHubPortSpeed(_hubPortSpeed) {
	    throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	  }

	  setIsHubPortDevice(_isHubPortDevice) {
	    throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	  }

	  setIsLocal(_isLocal) {
	    throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	  }

	  setIsRemote(_isRemote) {
	    throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	  }

	  open(_timeout) {
	    throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	  }

	  writeDeviceLabel(_deviceLabel) {
	    throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	  }

	  reboot() {
	    throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	  }

	  rebootFirmwareUpgrade(_upgradeTimeout) {
	    throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	  }

	}

	/** @internal */

	class Channel {
	  constructor(conn, dev, data) {
	    this.lastErrorEventCode = null;
	    this.lastErrorEventDesc = '';
	    this.lastErrorEventTime = 0;
	    this.conn = conn;
	    this.parent = dev;
	    this.id = data.id;
	    this.chDef = data.chDef;
	    this.uniqueIndex = data.uniqueIndex;
	    this.index = data.index;
	    this.isopen = false;
	  }

	  get subclass() {
	    var _a;

	    return (_a = this.chDef.s) !== null && _a !== void 0 ? _a : exports.ChannelSubclass.NONE;
	  }

	  get isHubPort() {
	    return this.parent.isHubPort;
	  }

	  match(userphid) {
	    if (userphid._attaching || userphid._isattached) return false;
	    if (userphid._class !== this.class) return false;

	    if (userphid._serialNumber !== Phidget.ANY_SERIAL_NUMBER) {
	      if (userphid._serialNumber != this.parent.serialNumber) return false;
	    }

	    if (userphid._channel !== Phidget.ANY_CHANNEL) {
	      if (userphid._channel != this.index) return false;
	    }

	    if (userphid._hubPort !== Phidget.ANY_HUB_PORT) {
	      if (userphid._hubPort != this.parent.hubPort) return false;
	    }

	    if (userphid._isHubPort !== this.isHubPort) return false;

	    if (userphid._deviceLabel !== Phidget.ANY_LABEL) {
	      if (userphid._deviceLabel !== this.parent.label) return false;
	    }

	    if (userphid._isLocal && this.conn._isRemote) return false;
	    if (userphid._isRemote && this.conn._isLocal) return false;
	    logdebug("matched:" + userphid + " -> " + this);
	    return true;
	  }

	  async tryMatchOpen(userphid) {
	    if (this.match(userphid)) {
	      try {
	        await this.open(userphid);
	        return true;
	      } catch (err) {
	        if (userphid.onError) {
	          try {
	            if (err instanceof PhidgetError) {
	              let code;

	              switch (err.errorCode) {
	                case exports.ErrorCode.BUSY:
	                  code = exports.ErrorEventCode.BUSY;
	                  break;

	                case exports.ErrorCode.BAD_VERSION:
	                  code = exports.ErrorEventCode.BAD_VERSION;
	                  break;

	                default:
	                  code = exports.ErrorEventCode.FAILURE;
	                  break;
	              }

	              userphid.onError(code, err.message);
	            } else if (err instanceof Error) {
	              userphid.onError(exports.ErrorEventCode.FAILURE, err.message);
	            } else {
	              userphid.onError(exports.ErrorEventCode.FAILURE, "Error during open");
	            }
	          } catch (err) {
	            logEventException(err);
	          }
	        } else {
	          logerr("Error opening channel", err);
	        }
	      }
	    }

	    return false;
	  }

	  detach() {
	    if (this.isopen) {
	      if (this.userphid) {
	        this.detaching = true;

	        this.userphid._close(true).then(() => {
	          this.isopen = false;
	          delete this.userphid;
	          delete this.detaching;
	        }).catch(err => {
	          this.isopen = false;
	          delete this.userphid;
	          delete this.detaching;
	          logwarn("Error closing during detach", err);
	        });
	      }
	    }
	  }

	  toString() {
	    if (this.parent.class === exports.DeviceClass.VINT) {
	      if (this.isHubPort) return this.name + ' Ch:' + this.index + ' -> ' + this.parent.sku + ' Port:' + this.parent.hubPort + ' Serial#:' + this.parent.serialNumber;
	      return this.name + ' Ch:' + this.index + ' -> ' + this.parent.sku + ' -> ' + this.parent.parent.sku + ' Port:' + this.parent.hubPort + ' Serial#:' + this.parent.serialNumber;
	    }

	    return this.name + ' Ch:' + this.index + ' -> ' + this.parent.sku + ' Serial#:' + this.parent.serialNumber;
	  }

	  supportedBridgePacket(bp) {
	    if (this.chDef.p == undefined || this.chDef.p.includes(bp)) return true;
	    return false;
	  }

	  bridgeInput(bp) {
	    if (!this.userphid) return;

	    switch (bp.vpkt) {
	      case 0:
	        this.userphid._handleSetStatus(bp);

	        break;

	      case 17:
	        if (this.userphid._errorHandler) this.userphid._errorHandler(bp.getNumber(0));

	        if (this.userphid.onError) {
	          try {
	            this.userphid.onError(bp.getNumber(0), bp.getString(1));
	          } catch (err) {
	            logEventException(err);
	          }
	        }

	        break;

	      case 172:
	        this.parent.label = bp.getString(0);

	        this.userphid._FIREPropertyChange('DeviceLabel', bp);

	        break;

	      case 176:
	        this.parent.vintDeviceProps.commSpeed = bp.getNumber(0);

	        this.userphid._FIREPropertyChange('HubPortSpeed', bp);

	        break;

	      case 139:
	      case 138:
	        break;

	      case 173:
	        if (this.conn._isRemote) this.parent.vintDeviceProps.commSpeed = bp.getNumber(0);
	        break;

	      case 140:
	        if (this.conn._isRemote) this.parent.label = bp.getString(0);
	        break;

	      default:
	        {
	          if (!this.supportedBridgePacket(bp.vpkt)) throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);

	          this.userphid._bridgeInput(bp);

	          if (this.userphid._onInitialState && this.userphid._hasInitialState()) this.userphid._onInitialState();
	          break;
	        }
	    }
	  }

	  sendErrorEvent(bp) {
	    const code = bp.getNumber(0);
	    const desc = bp.getString(1);
	    const now = Date.now();

	    if (this.lastErrorEventCode === code && this.lastErrorEventDesc === desc) {
	      if (now - this.lastErrorEventTime < 1000) return;
	    }

	    this.lastErrorEventCode = code;
	    this.lastErrorEventDesc = desc;
	    this.lastErrorEventTime = now;
	    bp.vpkt = 17;
	    this.bridgeInput(bp);
	  }

	  clearErrorEvent() {
	    this.lastErrorEventCode = null;
	  }

	}

	/** @internal */

	class NetworkChannel extends Channel {
	  constructor(conn, dev, data) {
	    super(conn, dev, data);
	    this.cpversion = data.cpversion;
	    this.name = data.name;
	    this.class = data.class;
	  }

	  async open(userphid) {
	    const devInfo = {
	      phid: this.parent.id,
	      channel: this.id,
	      class: this.class,
	      index: this.uniqueIndex,
	      version: this.cpversion
	    };

	    try {
	      userphid._attaching = true;
	      const status = await this.conn._sendRequest(0, 0, 0, 30, 60, devInfo);
	      userphid._attaching = false;
	      this.isopen = true;
	      this.userphid = userphid;
	      const bp = new BridgePacket(this.conn, status);
	      bp.deliver();
	      await userphid._wasOpened(this);
	    } catch (err) {
	      userphid._attaching = false;
	      userphid._isattached = false;
	      throw err;
	    }
	  }

	  async close() {
	    if (this.detaching) return;
	    const closePkt = {
	      phid: this.parent.id,
	      index: this.uniqueIndex
	    };
	    await this.conn._sendRequest(0, 0, 0, 30, 65, closePkt);
	  }

	  async send(bp) {
	    const pkt = bp.getJsonOut(this);
	    const response = await this.conn._sendRequest(0, 0, 0, 30, 70, pkt);
	    return response;
	  }

	}

	/** @internal */
	const PhidgetDevices = {
	  VINT: [{
	    uid: 21,
	    d: 9,
	    c: 21,
	    t: "PhidgetInterfaceKit 0/0/4",
	    s: "1014",
	    i: 64,
	    v: [800, 900],
	    ch: [{
	      uid: 35,
	      t: "Power Relay",
	      c: 6,
	      n: 4,
	      i: 0,
	      p: [82, 55, 147, 146]
	    }]
	  }, {
	    uid: 26,
	    d: 12,
	    c: 21,
	    t: "PhidgetInterfaceKit 0/0/8",
	    s: "1017",
	    i: 135,
	    v: [200, 300],
	    ch: [{
	      uid: 40,
	      t: "Signal Relay",
	      c: 6,
	      n: 8,
	      i: 0,
	      p: [82, 55, 147, 146]
	    }]
	  }, {
	    uid: 66,
	    d: 32,
	    c: 10,
	    t: "PhidgetIR",
	    s: "1055",
	    i: 77,
	    v: [200, 300],
	    ch: [{
	      uid: 130,
	      t: "IR Receiver Transmitter",
	      c: 16,
	      i: 0,
	      p: [33, 97, 99, 98, 5, 25, 32]
	    }]
	  }, {
	    uid: 93,
	    d: 95,
	    c: 21,
	    t: "Hub Port - Digital Input Mode",
	    s: "DIGITALINPUT_PORT",
	    i: 1,
	    v: [100, 200],
	    ch: [{
	      uid: 189,
	      t: "Digital Input",
	      c: 5,
	      i: 0,
	      p: [90]
	    }]
	  }, {
	    uid: 94,
	    d: 96,
	    c: 21,
	    t: "Hub Port - Digital Output Mode",
	    s: "DIGITALOUTPUT_PORT",
	    i: 2,
	    v: [100, 110],
	    ch: [{
	      uid: 190,
	      t: "Digital Output",
	      c: 6,
	      s: 16,
	      i: 0,
	      p: [55, 82]
	    }]
	  }, {
	    uid: 95,
	    d: 96,
	    c: 21,
	    t: "Hub Port - Digital Output Mode",
	    s: "DIGITALOUTPUT_PORT",
	    i: 2,
	    v: [110, 200],
	    ch: [{
	      uid: 191,
	      t: "Digital Output",
	      c: 6,
	      s: 16,
	      i: 0,
	      p: [55, 82, 147, 146]
	    }]
	  }, {
	    uid: 96,
	    d: 97,
	    c: 21,
	    t: "Hub Port - Voltage Input Mode",
	    s: "VOLTAGEINPUT_PORT",
	    i: 3,
	    v: [100, 110],
	    ch: [{
	      uid: 192,
	      t: "Voltage Input",
	      c: 29,
	      s: 48,
	      i: 0,
	      p: [54, 79, 46, 122, 101, 115]
	    }]
	  }, {
	    uid: 97,
	    d: 97,
	    c: 21,
	    t: "Hub Port - Voltage Input Mode",
	    s: "VOLTAGEINPUT_PORT",
	    i: 3,
	    v: [110, 200],
	    ch: [{
	      uid: 193,
	      t: "Voltage Input",
	      c: 29,
	      s: 48,
	      i: 0,
	      p: [54, 79, 46, 122, 101, 115]
	    }]
	  }, {
	    uid: 98,
	    d: 98,
	    c: 21,
	    t: "Hub Port - Voltage Ratio Mode",
	    s: "VOLTAGERATIOINPUT_PORT",
	    i: 4,
	    v: [100, 200],
	    ch: [{
	      uid: 194,
	      t: "Voltage Ratio Input",
	      c: 31,
	      s: 64,
	      i: 0,
	      p: [54, 79, 46, 122, 102, 115]
	    }]
	  }, {
	    uid: 99,
	    d: 49,
	    c: 21,
	    t: "pH Adapter Phidget",
	    s: "ADP1000",
	    i: 29,
	    v: [100, 200],
	    ch: [{
	      uid: 195,
	      t: "PH Sensor Input",
	      c: 37,
	      i: 0,
	      p: [54, 46, 134, 133]
	    }, {
	      uid: 196,
	      t: "Voltage Input",
	      c: 29,
	      i: 0,
	      p: [54, 79, 46, 87, 122, 101, 115]
	    }]
	  }, {
	    uid: 106,
	    d: 51,
	    c: 21,
	    t: "8x Voltage Input Phidget",
	    s: "DAQ1000",
	    i: 50,
	    v: [100, 110],
	    ch: [{
	      uid: 215,
	      t: "Voltage Ratio Input",
	      c: 31,
	      s: 64,
	      n: 8,
	      i: 0,
	      p: [54, 79, 46, 122, 102, 115]
	    }, {
	      uid: 216,
	      t: "Voltage Input",
	      c: 29,
	      s: 48,
	      n: 8,
	      i: 0,
	      p: [54, 79, 46, 122, 101, 115]
	    }]
	  }, {
	    uid: 107,
	    d: 51,
	    c: 21,
	    t: "8x Voltage Input Phidget",
	    s: "DAQ1000",
	    i: 50,
	    v: [110, 200],
	    ch: [{
	      uid: 217,
	      t: "Voltage Ratio Input",
	      c: 31,
	      s: 64,
	      n: 8,
	      i: 0,
	      p: [54, 79, 46, 122, 102, 115]
	    }, {
	      uid: 218,
	      t: "Voltage Input",
	      c: 29,
	      s: 48,
	      n: 8,
	      i: 0,
	      p: [54, 79, 46, 122, 101, 115]
	    }]
	  }, {
	    uid: 108,
	    d: 75,
	    c: 21,
	    t: "12-bit Voltage Output Phidget",
	    s: "OUT1000",
	    i: 41,
	    v: [100, 110],
	    ch: [{
	      uid: 219,
	      t: "Voltage Output",
	      c: 30,
	      i: 0,
	      p: [56, 86]
	    }]
	  }, {
	    uid: 109,
	    d: 75,
	    c: 21,
	    t: "12-bit Voltage Output Phidget",
	    s: "OUT1000",
	    i: 41,
	    v: [110, 200],
	    ch: [{
	      uid: 220,
	      t: "Voltage Output",
	      c: 30,
	      i: 0,
	      p: [56, 86, 147, 146]
	    }]
	  }, {
	    uid: 110,
	    d: 76,
	    c: 21,
	    t: "Isolated 12-bit Voltage Output Phidget",
	    s: "OUT1001",
	    i: 42,
	    v: [100, 110],
	    ch: [{
	      uid: 221,
	      t: "Voltage Output",
	      c: 30,
	      i: 0,
	      p: [86, 87]
	    }]
	  }, {
	    uid: 111,
	    d: 76,
	    c: 21,
	    t: "Isolated 12-bit Voltage Output Phidget",
	    s: "OUT1001",
	    i: 42,
	    v: [110, 200],
	    ch: [{
	      uid: 222,
	      t: "Voltage Output",
	      c: 30,
	      i: 0,
	      p: [86, 87, 147, 146]
	    }]
	  }, {
	    uid: 112,
	    d: 77,
	    c: 21,
	    t: "Isolated 16-bit Voltage Output Phidget",
	    s: "OUT1002",
	    i: 43,
	    v: [100, 110],
	    ch: [{
	      uid: 223,
	      t: "Voltage Output",
	      c: 30,
	      i: 0,
	      p: [86, 87]
	    }]
	  }, {
	    uid: 113,
	    d: 77,
	    c: 21,
	    t: "Isolated 16-bit Voltage Output Phidget",
	    s: "OUT1002",
	    i: 43,
	    v: [110, 200],
	    ch: [{
	      uid: 224,
	      t: "Voltage Output",
	      c: 30,
	      i: 0,
	      p: [86, 87, 147, 146]
	    }]
	  }, {
	    uid: 115,
	    d: 52,
	    c: 21,
	    t: "4x Digital Input Phidget",
	    s: "DAQ1200",
	    i: 28,
	    v: [100, 200],
	    ch: [{
	      uid: 226,
	      t: "Digital Input",
	      c: 5,
	      n: 4,
	      i: 0,
	      p: [90]
	    }]
	  }, {
	    uid: 116,
	    d: 78,
	    c: 21,
	    t: "4x Digital Output Phidget",
	    s: "OUT1100",
	    i: 25,
	    v: [100, 110],
	    ch: [{
	      uid: 227,
	      t: "Digital Output",
	      c: 6,
	      s: 16,
	      n: 4,
	      i: 0,
	      p: [55, 82]
	    }]
	  }, {
	    uid: 117,
	    d: 78,
	    c: 21,
	    t: "4x Digital Output Phidget",
	    s: "OUT1100",
	    i: 25,
	    v: [110, 120],
	    ch: [{
	      uid: 228,
	      t: "Digital Output",
	      c: 6,
	      s: 16,
	      n: 4,
	      i: 0,
	      p: [55, 82, 147, 146]
	    }]
	  }, {
	    uid: 118,
	    d: 78,
	    c: 21,
	    t: "4x Digital Output Phidget",
	    s: "OUT1100",
	    i: 25,
	    v: [120, 200],
	    ch: [{
	      uid: 229,
	      t: "Digital Output",
	      c: 6,
	      s: 18,
	      n: 4,
	      i: 0,
	      p: [55, 82, 156, 147, 146]
	    }]
	  }, {
	    uid: 119,
	    d: 53,
	    c: 21,
	    t: "4x Isolated Digital Input Phidget",
	    s: "DAQ1300",
	    i: 32,
	    v: [100, 200],
	    ch: [{
	      uid: 230,
	      t: "Digital Input Isolated",
	      c: 5,
	      n: 4,
	      i: 0,
	      p: [90]
	    }]
	  }, {
	    uid: 120,
	    d: 54,
	    c: 21,
	    t: "16x Isolated Digital Input Phidget",
	    s: "DAQ1301",
	    i: 54,
	    v: [100, 200],
	    ch: [{
	      uid: 231,
	      t: "Digital Input Isolated",
	      c: 5,
	      n: 16,
	      i: 0,
	      p: [90]
	    }]
	  }, {
	    uid: 121,
	    d: 55,
	    c: 21,
	    t: "Versatile Input Phidget",
	    s: "DAQ1400",
	    i: 34,
	    v: [100, 120],
	    ch: [{
	      uid: 232,
	      t: "Voltage Input",
	      c: 29,
	      i: 0,
	      p: [54, 74, 79, 46, 122, 101, 115]
	    }, {
	      uid: 233,
	      t: "Current Input",
	      c: 2,
	      i: 0,
	      p: [54, 46, 74, 8]
	    }, {
	      uid: 234,
	      t: "Digital Input",
	      c: 5,
	      i: 0,
	      p: [64, 74, 90]
	    }, {
	      uid: 235,
	      t: "Frequency Input",
	      c: 9,
	      i: 0,
	      p: [21, 54, 64, 74, 20, 7]
	    }]
	  }, {
	    uid: 122,
	    d: 55,
	    c: 21,
	    t: "Versatile Input Phidget",
	    s: "DAQ1400",
	    i: 34,
	    v: [120, 200],
	    ch: [{
	      uid: 236,
	      t: "Voltage Input",
	      c: 29,
	      i: 0,
	      p: [54, 74, 79, 46, 122, 101, 115]
	    }, {
	      uid: 237,
	      t: "Current Input",
	      c: 2,
	      i: 0,
	      p: [54, 46, 74, 8]
	    }, {
	      uid: 238,
	      t: "Digital Input",
	      c: 5,
	      i: 0,
	      p: [64, 74, 90]
	    }, {
	      uid: 239,
	      t: "Frequency Input",
	      c: 9,
	      i: 0,
	      p: [21, 54, 64, 74, 20, 7]
	    }]
	  }, {
	    uid: 123,
	    d: 56,
	    c: 21,
	    t: "Wheatstone Bridge Phidget",
	    s: "DAQ1500",
	    i: 24,
	    v: [100, 200],
	    ch: [{
	      uid: 240,
	      t: "Bridge Input",
	      c: 31,
	      s: 65,
	      n: 2,
	      i: 0,
	      p: [45, 54, 46, 56, 102]
	    }]
	  }, {
	    uid: 124,
	    d: 105,
	    c: 21,
	    t: "30A Current Sensor Phidget",
	    s: "VCP1100",
	    i: 64,
	    v: [100, 200],
	    ch: [{
	      uid: 241,
	      t: "Current Input",
	      c: 2,
	      i: 0,
	      p: [54, 46, 8]
	    }]
	  }, {
	    uid: 126,
	    d: 57,
	    c: 21,
	    t: "DC Motor Phidget",
	    s: "DCC1000",
	    i: 47,
	    v: [100, 200],
	    ch: [{
	      uid: 242,
	      t: "DC Motor Controller",
	      c: 4,
	      i: 0,
	      p: [54, 40, 44, 51, 119, 55, 58, 121, 16]
	    }, {
	      uid: 243,
	      t: "Encoder Input",
	      c: 8,
	      s: 96,
	      i: 0,
	      p: [54, 46, 65, 29]
	    }, {
	      uid: 244,
	      t: "Voltage Ratio",
	      c: 31,
	      s: 64,
	      i: 0,
	      p: [54, 46, 79, 122, 102, 115]
	    }, {
	      uid: 245,
	      t: "Temperature Sensor",
	      c: 28,
	      i: 0,
	      p: [54, 46, 95]
	    }, {
	      uid: 246,
	      t: "Current Sensor",
	      c: 2,
	      i: 0,
	      p: [46, 54, 8]
	    }]
	  }, {
	    uid: 127,
	    d: 57,
	    c: 21,
	    t: "DC Motor Phidget",
	    s: "DCC1000",
	    i: 47,
	    v: [200, 210],
	    ch: [{
	      uid: 247,
	      t: "DC Motor Controller",
	      c: 4,
	      i: 0,
	      e: 0,
	      p: [54, 40, 44, 51, 119, 55, 58, 121, 16]
	    }, {
	      uid: 248,
	      t: "Encoder Input",
	      c: 8,
	      s: 96,
	      i: 0,
	      p: [54, 46, 65, 29]
	    }, {
	      uid: 249,
	      t: "Voltage Ratio",
	      c: 31,
	      s: 64,
	      i: 0,
	      p: [54, 46, 79, 122, 102, 115]
	    }, {
	      uid: 250,
	      t: "Temperature Sensor",
	      c: 28,
	      i: 0,
	      p: [54, 46, 95]
	    }, {
	      uid: 251,
	      t: "Current Sensor",
	      c: 2,
	      i: 0,
	      p: [46, 54, 8]
	    }, {
	      uid: 252,
	      t: "Position Controller",
	      c: 34,
	      i: 0,
	      e: 0,
	      p: [40, 54, 51, 119, 57, 55, 83, 58, 120, 65, 135, 136, 142, 147, 146, 29, 16]
	    }]
	  }, {
	    uid: 128,
	    d: 57,
	    c: 21,
	    t: "DC Motor Phidget",
	    s: "DCC1000",
	    i: 47,
	    v: [210, 300],
	    ch: [{
	      uid: 253,
	      t: "DC Motor Controller",
	      c: 4,
	      i: 0,
	      e: 0,
	      p: [54, 40, 44, 51, 119, 55, 58, 147, 146, 121, 16]
	    }, {
	      uid: 254,
	      t: "Encoder Input",
	      c: 8,
	      s: 96,
	      i: 0,
	      p: [54, 46, 65, 29]
	    }, {
	      uid: 255,
	      t: "Voltage Ratio",
	      c: 31,
	      s: 64,
	      i: 0,
	      p: [54, 46, 79, 122, 102, 115]
	    }, {
	      uid: 256,
	      t: "Temperature Sensor",
	      c: 28,
	      i: 0,
	      p: [54, 46, 95]
	    }, {
	      uid: 257,
	      t: "Current Sensor",
	      c: 2,
	      i: 0,
	      p: [46, 54, 8]
	    }, {
	      uid: 258,
	      t: "Position Controller",
	      c: 34,
	      i: 0,
	      e: 0,
	      p: [40, 54, 51, 119, 57, 55, 83, 58, 120, 65, 135, 136, 142, 147, 146, 29, 16]
	    }]
	  }, {
	    uid: 131,
	    d: 110,
	    c: 21,
	    t: "2A DC Motor Phidget",
	    s: "DCC1001",
	    i: 68,
	    v: [100, 120],
	    ch: [{
	      uid: 269,
	      t: "DC Motor Controller",
	      c: 4,
	      i: 0,
	      e: 0,
	      p: [54, 40, 44, 51, 55, 121, 16]
	    }, {
	      uid: 270,
	      t: "Encoder Input",
	      c: 8,
	      i: 0,
	      p: [54, 46, 29]
	    }, {
	      uid: 271,
	      t: "Position Controller",
	      c: 34,
	      i: 0,
	      e: 0,
	      p: [40, 54, 51, 57, 55, 83, 120, 135, 136, 142, 29, 16]
	    }]
	  }, {
	    uid: 132,
	    d: 110,
	    c: 21,
	    t: "2A DC Motor Phidget",
	    s: "DCC1001",
	    i: 68,
	    v: [120, 200],
	    ch: [{
	      uid: 272,
	      t: "DC Motor Controller",
	      c: 4,
	      i: 0,
	      e: 0,
	      p: [54, 40, 44, 51, 55, 147, 146, 121, 16]
	    }, {
	      uid: 273,
	      t: "Encoder Input",
	      c: 8,
	      i: 0,
	      p: [54, 46, 29]
	    }, {
	      uid: 274,
	      t: "Position Controller",
	      c: 34,
	      i: 0,
	      e: 0,
	      p: [40, 54, 51, 57, 55, 83, 120, 135, 136, 142, 147, 146, 29, 16]
	    }]
	  }, {
	    uid: 133,
	    d: 117,
	    c: 21,
	    t: "4A DC Motor Phidget",
	    s: "DCC1002",
	    i: 70,
	    v: [100, 110],
	    ch: [{
	      uid: 275,
	      t: "DC Motor Controller",
	      c: 4,
	      i: 0,
	      e: 0,
	      p: [54, 40, 44, 51, 55, 121, 16]
	    }, {
	      uid: 276,
	      t: "Encoder Input",
	      c: 8,
	      i: 0,
	      p: [54, 46, 29]
	    }, {
	      uid: 277,
	      t: "Position Controller",
	      c: 34,
	      i: 0,
	      e: 0,
	      p: [40, 54, 51, 57, 55, 83, 120, 135, 136, 142, 29, 16]
	    }]
	  }, {
	    uid: 134,
	    d: 117,
	    c: 21,
	    t: "4A DC Motor Phidget",
	    s: "DCC1002",
	    i: 70,
	    v: [110, 200],
	    ch: [{
	      uid: 278,
	      t: "DC Motor Controller",
	      c: 4,
	      i: 0,
	      e: 0,
	      p: [54, 40, 44, 51, 55, 147, 146, 121, 16]
	    }, {
	      uid: 279,
	      t: "Encoder Input",
	      c: 8,
	      i: 0,
	      p: [54, 46, 29]
	    }, {
	      uid: 280,
	      t: "Position Controller",
	      c: 34,
	      i: 0,
	      e: 0,
	      p: [40, 54, 51, 57, 55, 83, 120, 135, 136, 142, 147, 146, 29, 16]
	    }]
	  }, {
	    uid: 135,
	    d: 120,
	    c: 21,
	    t: "2x DC Motor Phidget",
	    s: "DCC1003",
	    i: 73,
	    v: [100, 110],
	    ch: [{
	      uid: 281,
	      t: "DC Motor Controller",
	      c: 4,
	      n: 2,
	      i: 0,
	      p: [54, 40, 44, 51, 55, 121, 16]
	    }]
	  }, {
	    uid: 136,
	    d: 120,
	    c: 21,
	    t: "2x DC Motor Phidget",
	    s: "DCC1003",
	    i: 73,
	    v: [110, 200],
	    ch: [{
	      uid: 282,
	      t: "DC Motor Controller",
	      c: 4,
	      n: 2,
	      i: 0,
	      p: [54, 40, 44, 51, 55, 147, 146, 121, 16]
	    }]
	  }, {
	    uid: 137,
	    d: 108,
	    c: 21,
	    t: "Brushless DC Motor Phidget",
	    s: "DCC1100",
	    i: 65,
	    v: [100, 120],
	    ch: [{
	      uid: 283,
	      t: "Brushless DC Motor Controller",
	      c: 35,
	      i: 0,
	      e: 0,
	      p: [54, 40, 44, 55, 141, 121, 29, 16]
	    }, {
	      uid: 284,
	      t: "Temperature Sensor",
	      c: 28,
	      i: 0,
	      p: [54, 46, 95]
	    }, {
	      uid: 285,
	      t: "Position Controller",
	      c: 34,
	      i: 0,
	      e: 0,
	      p: [54, 40, 55, 57, 83, 120, 135, 136, 142, 141, 147, 146, 29, 16]
	    }]
	  }, {
	    uid: 138,
	    d: 108,
	    c: 21,
	    t: "Brushless DC Motor Phidget",
	    s: "DCC1100",
	    i: 65,
	    v: [120, 200],
	    ch: [{
	      uid: 286,
	      t: "Brushless DC Motor Controller",
	      c: 35,
	      i: 0,
	      e: 0,
	      p: [54, 40, 44, 55, 141, 147, 146, 121, 29, 16]
	    }, {
	      uid: 287,
	      t: "Temperature Sensor",
	      c: 28,
	      i: 0,
	      p: [54, 46, 95]
	    }, {
	      uid: 288,
	      t: "Position Controller",
	      c: 34,
	      i: 0,
	      e: 0,
	      p: [54, 40, 55, 57, 83, 120, 135, 136, 142, 141, 147, 146, 29, 16]
	    }]
	  }, {
	    uid: 139,
	    d: 58,
	    c: 21,
	    t: "Distance Phidget",
	    s: "DST1000",
	    i: 45,
	    v: [100, 200],
	    ch: [{
	      uid: 289,
	      t: "Distance Sensor 200mm",
	      c: 7,
	      i: 0,
	      p: [54, 46, 12]
	    }]
	  }, {
	    uid: 140,
	    d: 121,
	    c: 21,
	    t: "Distance Phidget 650mm",
	    s: "DST1001",
	    i: 121,
	    v: [100, 200],
	    ch: [{
	      uid: 290,
	      t: "Distance Sensor 650mm",
	      c: 7,
	      i: 0,
	      p: [54, 46, 12]
	    }]
	  }, {
	    uid: 141,
	    d: 126,
	    c: 21,
	    t: "Distance Phidget 1300mm",
	    s: "DST1002",
	    i: 126,
	    v: [100, 200],
	    ch: [{
	      uid: 291,
	      t: "Distance Sensor 1300mm",
	      c: 7,
	      i: 0,
	      p: [54, 46, 12]
	    }]
	  }, {
	    uid: 142,
	    d: 59,
	    c: 21,
	    t: "Sonar Phidget",
	    s: "DST1200",
	    i: 46,
	    v: [100, 200],
	    ch: [{
	      uid: 292,
	      t: "Sonar Distance Sensor",
	      c: 7,
	      i: 0,
	      p: [54, 46, 75, 12, 88]
	    }]
	  }, {
	    uid: 143,
	    d: 60,
	    c: 21,
	    t: "Quadrature Encoder Phidget",
	    s: "ENC1000",
	    i: 18,
	    v: [100, 200],
	    ch: [{
	      uid: 293,
	      t: "Encoder Input",
	      c: 8,
	      s: 96,
	      i: 0,
	      p: [54, 46, 56, 65, 29]
	    }]
	  }, {
	    uid: 144,
	    d: 109,
	    c: 21,
	    t: "Phidget Dial",
	    s: "HIN1101",
	    i: 67,
	    v: [100, 200],
	    ch: [{
	      uid: 294,
	      t: "Encoder Input",
	      c: 8,
	      i: 0,
	      p: [54, 46, 56, 29]
	    }, {
	      uid: 295,
	      t: "Digital Input",
	      c: 5,
	      i: 0,
	      p: [90]
	    }]
	  }, {
	    uid: 145,
	    d: 61,
	    c: 21,
	    t: "Touch Keypad Phidget",
	    s: "HIN1000",
	    i: 36,
	    v: [100, 200],
	    ch: [{
	      uid: 296,
	      t: "Capacitive Touch Sensor",
	      c: 14,
	      n: 7,
	      i: 0,
	      p: [46, 54, 66, 96, 137]
	    }]
	  }, {
	    uid: 146,
	    d: 62,
	    c: 21,
	    t: "Touch Wheel Phidget",
	    s: "HIN1001",
	    i: 56,
	    v: [100, 200],
	    ch: [{
	      uid: 297,
	      t: "Capacitive Touch Sensor",
	      c: 14,
	      n: 4,
	      i: 0,
	      p: [46, 54, 66, 96, 137]
	    }, {
	      uid: 298,
	      t: "Capacitive Scroll Wheel",
	      c: 14,
	      i: 4,
	      p: [46, 54, 66, 96, 137]
	    }]
	  }, {
	    uid: 147,
	    d: 63,
	    c: 21,
	    t: "Thumbstick Phidget",
	    s: "HIN1100",
	    i: 37,
	    v: [100, 200],
	    ch: [{
	      uid: 299,
	      t: "Thumbstick Axis",
	      c: 31,
	      n: 2,
	      i: 0,
	      p: [54, 46, 102]
	    }, {
	      uid: 300,
	      t: "Thumbstick Button",
	      c: 5,
	      i: 0,
	      p: [90]
	    }]
	  }, {
	    uid: 148,
	    d: 69,
	    c: 21,
	    t: "Humidity Phidget",
	    s: "HUM1000",
	    i: 20,
	    v: [100, 200],
	    ch: [{
	      uid: 301,
	      t: "Humidity Sensor",
	      c: 15,
	      i: 0,
	      p: [54, 46, 22]
	    }, {
	      uid: 302,
	      t: "Temperature Sensor",
	      c: 28,
	      i: 0,
	      p: [54, 46, 95]
	    }]
	  }, {
	    uid: 149,
	    d: 127,
	    c: 21,
	    t: "Humidity Phidget",
	    s: "HUM1001",
	    i: 127,
	    v: [100, 200],
	    ch: [{
	      uid: 303,
	      t: "Humidity Sensor",
	      c: 15,
	      i: 0,
	      p: [54, 46, 22]
	    }, {
	      uid: 304,
	      t: "Temperature Sensor",
	      c: 28,
	      i: 0,
	      p: [54, 46, 95]
	    }]
	  }, {
	    uid: 150,
	    d: 70,
	    c: 21,
	    t: "Graphic LCD Phidget",
	    s: "LCD1100",
	    i: 40,
	    v: [100, 200],
	    ch: [{
	      uid: 305,
	      t: "Graphic LCD",
	      c: 11,
	      s: 80,
	      i: 0,
	      p: [43, 48, 62, 80, 47, 4, 6, 13, 14, 15, 19, 61, 38, 104, 105]
	    }]
	  }, {
	    uid: 151,
	    d: 71,
	    c: 21,
	    t: "32x Isolated LED Phidget",
	    s: "LED1000",
	    i: 39,
	    v: [100, 200],
	    ch: [{
	      uid: 306,
	      t: "LED Driver",
	      c: 6,
	      s: 17,
	      n: 32,
	      i: 0,
	      p: [55, 67, 68, 82]
	    }]
	  }, {
	    uid: 152,
	    d: 72,
	    c: 21,
	    t: "Light Phidget",
	    s: "LUX1000",
	    i: 33,
	    v: [100, 200],
	    ch: [{
	      uid: 307,
	      t: "Light Sensor",
	      c: 17,
	      i: 0,
	      p: [54, 46, 23]
	    }]
	  }, {
	    uid: 153,
	    d: 136,
	    c: 21,
	    t: "Soil Moisture Phidget",
	    s: "HUM1100",
	    i: 136,
	    v: [100, 200],
	    ch: [{
	      uid: 308,
	      t: "Moisture Sensor",
	      c: 31,
	      i: 0,
	      p: [54, 46, 102]
	    }]
	  }, {
	    uid: 155,
	    d: 73,
	    c: 21,
	    t: "Accelerometer Phidget",
	    s: "MOT1100",
	    i: 51,
	    v: [200, 300],
	    ch: [{
	      uid: 310,
	      t: "3-Axis Accelerometer",
	      c: 1,
	      i: 0,
	      p: [54, 46, 1]
	    }]
	  }, {
	    uid: 158,
	    d: 74,
	    c: 21,
	    t: "Spatial Phidget",
	    s: "MOT1101",
	    i: 52,
	    v: [100, 200],
	    ch: [{
	      uid: 313,
	      t: "3-Axis Accelerometer",
	      c: 1,
	      i: 0,
	      p: [54, 46, 1]
	    }, {
	      uid: 314,
	      t: "3-Axis Gyroscope",
	      c: 12,
	      i: 0,
	      p: [54, 106, 2]
	    }, {
	      uid: 315,
	      t: "3-Axis Magnetometer",
	      c: 18,
	      i: 0,
	      p: [54, 46, 50, 37, 35, 18]
	    }, {
	      uid: 316,
	      t: "Spatial",
	      c: 26,
	      i: 0,
	      p: [54, 106, 50, 37, 35, 89]
	    }]
	  }, {
	    uid: 160,
	    d: 137,
	    c: 21,
	    t: "Spatial Phidget",
	    s: "MOT1102",
	    i: 137,
	    v: [200, 300],
	    ch: [{
	      uid: 318,
	      t: "3-Axis Accelerometer",
	      c: 1,
	      i: 0,
	      p: [54, 46, 1]
	    }, {
	      uid: 319,
	      t: "3-Axis Gyroscope",
	      c: 12,
	      i: 0,
	      p: [54, 106, 2]
	    }, {
	      uid: 320,
	      t: "3-Axis Magnetometer",
	      c: 18,
	      i: 0,
	      p: [54, 46, 50, 37, 35, 18]
	    }, {
	      uid: 321,
	      t: "Spatial",
	      c: 26,
	      s: 112,
	      i: 0,
	      p: [54, 149, 151, 106, 50, 37, 35, 174, 150, 89, 148]
	    }]
	  }, {
	    uid: 165,
	    d: 141,
	    c: 21,
	    t: "PhidgetSpatial Precision 3/3/3",
	    s: "MOT0110",
	    i: 141,
	    v: [100, 200],
	    ch: [{
	      uid: 341,
	      t: "3-Axis Accelerometer",
	      c: 1,
	      i: 0,
	      p: [10, 54, 46, 170, 1]
	    }, {
	      uid: 342,
	      t: "3-Axis Gyroscope",
	      c: 12,
	      i: 0,
	      p: [10, 54, 170, 106, 2]
	    }, {
	      uid: 343,
	      t: "3-Axis Magnetometer",
	      c: 18,
	      i: 0,
	      p: [10, 54, 46, 170, 50, 37, 35, 18]
	    }, {
	      uid: 344,
	      t: "Spatial",
	      c: 26,
	      s: 112,
	      i: 0,
	      p: [10, 54, 149, 170, 106, 50, 37, 35, 174, 150, 89, 148]
	    }, {
	      uid: 345,
	      t: "Temperature Sensor",
	      c: 28,
	      i: 0,
	      p: [10, 54, 46, 95]
	    }]
	  }, {
	    uid: 166,
	    d: 79,
	    c: 21,
	    t: "Barometer Phidget",
	    s: "PRE1000",
	    i: 17,
	    v: [100, 200],
	    ch: [{
	      uid: 346,
	      t: "Barometer",
	      c: 21,
	      i: 0,
	      p: [54, 46, 31]
	    }]
	  }, {
	    uid: 167,
	    d: 80,
	    c: 21,
	    t: "16x RC Servo Phidget",
	    s: "RCC1000",
	    i: 49,
	    v: [100, 110],
	    ch: [{
	      uid: 347,
	      t: "RC Servo Motor Controller",
	      c: 22,
	      n: 16,
	      i: 0,
	      p: [69, 70, 83, 57, 86, 85, 40, 81, 94]
	    }]
	  }, {
	    uid: 168,
	    d: 80,
	    c: 21,
	    t: "16x RC Servo Phidget",
	    s: "RCC1000",
	    i: 49,
	    v: [110, 200],
	    ch: [{
	      uid: 348,
	      t: "RC Servo Motor Controller",
	      c: 22,
	      n: 16,
	      i: 0,
	      p: [69, 70, 83, 57, 86, 85, 40, 81, 147, 146, 94]
	    }]
	  }, {
	    uid: 170,
	    d: 81,
	    c: 21,
	    t: "4x Relay Phidget",
	    s: "REL1000",
	    i: 44,
	    v: [100, 110],
	    ch: [{
	      uid: 350,
	      t: "Power Relay",
	      c: 6,
	      n: 4,
	      i: 0,
	      p: [55, 82]
	    }]
	  }, {
	    uid: 171,
	    d: 81,
	    c: 21,
	    t: "4x Relay Phidget",
	    s: "REL1000",
	    i: 44,
	    v: [110, 200],
	    ch: [{
	      uid: 351,
	      t: "Power Relay",
	      c: 6,
	      n: 4,
	      i: 0,
	      p: [55, 82, 147, 146]
	    }]
	  }, {
	    uid: 172,
	    d: 82,
	    c: 21,
	    t: "4x Isolated Solid State Relay Phidget",
	    s: "REL1100",
	    i: 26,
	    v: [100, 110],
	    ch: [{
	      uid: 352,
	      t: "Digital Output Isolated",
	      c: 6,
	      s: 16,
	      n: 4,
	      i: 0,
	      p: [55, 82]
	    }]
	  }, {
	    uid: 173,
	    d: 82,
	    c: 21,
	    t: "4x Isolated Solid State Relay Phidget",
	    s: "REL1100",
	    i: 26,
	    v: [110, 120],
	    ch: [{
	      uid: 353,
	      t: "Digital Output Isolated",
	      c: 6,
	      s: 16,
	      n: 4,
	      i: 0,
	      p: [55, 82, 147, 146]
	    }]
	  }, {
	    uid: 174,
	    d: 82,
	    c: 21,
	    t: "4x Isolated Solid State Relay Phidget",
	    s: "REL1100",
	    i: 26,
	    v: [120, 200],
	    ch: [{
	      uid: 354,
	      t: "Digital Output Isolated",
	      c: 6,
	      s: 18,
	      n: 4,
	      i: 0,
	      p: [55, 82, 156, 147, 146]
	    }]
	  }, {
	    uid: 175,
	    d: 83,
	    c: 21,
	    t: "16x Isolated Solid State Relay Phidget",
	    s: "REL1101",
	    i: 27,
	    v: [100, 110],
	    ch: [{
	      uid: 355,
	      t: "Digital Output Isolated",
	      c: 6,
	      s: 16,
	      n: 16,
	      i: 0,
	      p: [55, 82]
	    }]
	  }, {
	    uid: 176,
	    d: 83,
	    c: 21,
	    t: "16x Isolated Solid State Relay Phidget",
	    s: "REL1101",
	    i: 27,
	    v: [110, 200],
	    ch: [{
	      uid: 356,
	      t: "Digital Output Isolated",
	      c: 6,
	      s: 16,
	      n: 16,
	      i: 0,
	      p: [55, 82, 147, 146]
	    }]
	  }, {
	    uid: 177,
	    d: 83,
	    c: 21,
	    t: "16x Isolated Solid State Relay Phidget",
	    s: "REL1101",
	    i: 130,
	    v: [100, 300],
	    ch: [{
	      uid: 357,
	      t: "Digital Output Isolated Frequency Control",
	      c: 6,
	      s: 18,
	      n: 8,
	      i: 0,
	      p: [55, 82, 156, 147, 146]
	    }, {
	      uid: 358,
	      t: "Digital Output Isolated",
	      c: 6,
	      s: 16,
	      n: 8,
	      i: 8,
	      p: [55, 82, 147, 146]
	    }]
	  }, {
	    uid: 179,
	    d: 84,
	    c: 21,
	    t: "Programmable Power Guard Phidget",
	    s: "SAF1000",
	    i: 38,
	    v: [100, 110],
	    ch: [{
	      uid: 360,
	      t: "Power Supply Protector",
	      c: 20,
	      i: 0,
	      p: [56, 71, 58]
	    }, {
	      uid: 361,
	      t: "Voltage Sensor",
	      c: 29,
	      i: 0,
	      p: [54, 46, 101]
	    }, {
	      uid: 362,
	      t: "Temperature Sensor",
	      c: 28,
	      i: 0,
	      p: [54, 46, 95]
	    }]
	  }, {
	    uid: 180,
	    d: 84,
	    c: 21,
	    t: "Programmable Power Guard Phidget",
	    s: "SAF1000",
	    i: 38,
	    v: [110, 200],
	    ch: [{
	      uid: 363,
	      t: "Power Supply Protector",
	      c: 20,
	      i: 0,
	      p: [56, 71, 58, 147, 146]
	    }, {
	      uid: 364,
	      t: "Voltage Sensor",
	      c: 29,
	      i: 0,
	      p: [54, 46, 101]
	    }, {
	      uid: 365,
	      t: "Temperature Sensor",
	      c: 28,
	      i: 0,
	      p: [54, 46, 95]
	    }]
	  }, {
	    uid: 181,
	    d: 85,
	    c: 21,
	    t: "Sound Phidget",
	    s: "SND1000",
	    i: 35,
	    v: [100, 200],
	    ch: [{
	      uid: 366,
	      t: "Sound Sensor",
	      c: 25,
	      i: 0,
	      p: [54, 116, 46, 11]
	    }]
	  }, {
	    uid: 182,
	    d: 86,
	    c: 21,
	    t: "Stepper Phidget",
	    s: "STC1000",
	    i: 48,
	    v: [100, 110],
	    ch: [{
	      uid: 367,
	      t: "Bipolar Stepper Controller",
	      c: 27,
	      i: 0,
	      p: [54, 83, 85, 40, 51, 57, 49, 63, 29, 100, 91]
	    }]
	  }, {
	    uid: 183,
	    d: 86,
	    c: 21,
	    t: "Stepper Phidget",
	    s: "STC1000",
	    i: 48,
	    v: [110, 200],
	    ch: [{
	      uid: 368,
	      t: "Bipolar Stepper Controller",
	      c: 27,
	      i: 0,
	      p: [54, 83, 85, 40, 51, 57, 49, 63, 147, 146, 29, 100, 91]
	    }]
	  }, {
	    uid: 184,
	    d: 115,
	    c: 21,
	    t: "2.5A Stepper Phidget",
	    s: "STC1001",
	    i: 69,
	    v: [100, 110],
	    ch: [{
	      uid: 369,
	      t: "Bipolar Stepper Controller",
	      c: 27,
	      i: 0,
	      p: [54, 83, 85, 40, 51, 57, 49, 63, 29, 100, 91]
	    }]
	  }, {
	    uid: 185,
	    d: 115,
	    c: 21,
	    t: "2.5A Stepper Phidget",
	    s: "STC1001",
	    i: 69,
	    v: [110, 200],
	    ch: [{
	      uid: 370,
	      t: "Bipolar Stepper Controller",
	      c: 27,
	      i: 0,
	      p: [54, 83, 85, 40, 51, 57, 49, 63, 147, 146, 29, 100, 91]
	    }]
	  }, {
	    uid: 186,
	    d: 118,
	    c: 21,
	    t: "8A Stepper Phidget",
	    s: "STC1002",
	    i: 71,
	    v: [100, 110],
	    ch: [{
	      uid: 371,
	      t: "Bipolar Stepper Controller",
	      c: 27,
	      i: 0,
	      p: [54, 83, 85, 40, 51, 57, 49, 63, 29, 100, 91]
	    }]
	  }, {
	    uid: 187,
	    d: 118,
	    c: 21,
	    t: "8A Stepper Phidget",
	    s: "STC1002",
	    i: 71,
	    v: [110, 200],
	    ch: [{
	      uid: 372,
	      t: "Bipolar Stepper Controller",
	      c: 27,
	      i: 0,
	      p: [54, 83, 85, 40, 51, 57, 49, 63, 147, 146, 29, 100, 91]
	    }]
	  }, {
	    uid: 188,
	    d: 119,
	    c: 21,
	    t: "4A Stepper Phidget",
	    s: "STC1003",
	    i: 72,
	    v: [100, 110],
	    ch: [{
	      uid: 373,
	      t: "Bipolar Stepper Controller",
	      c: 27,
	      i: 0,
	      p: [54, 83, 85, 40, 51, 57, 49, 63, 29, 100, 91]
	    }]
	  }, {
	    uid: 189,
	    d: 119,
	    c: 21,
	    t: "4A Stepper Phidget",
	    s: "STC1003",
	    i: 72,
	    v: [110, 200],
	    ch: [{
	      uid: 374,
	      t: "Bipolar Stepper Controller",
	      c: 27,
	      i: 0,
	      p: [54, 83, 85, 40, 51, 57, 49, 63, 147, 146, 29, 100, 91]
	    }]
	  }, {
	    uid: 190,
	    d: 119,
	    c: 21,
	    t: "4A Stepper Phidget",
	    s: "STC1003",
	    i: 142,
	    v: [200, 300],
	    ch: [{
	      uid: 375,
	      t: "Bipolar Stepper Controller",
	      c: 27,
	      i: 0,
	      p: [54, 83, 85, 40, 51, 57, 49, 63, 147, 146, 29, 100, 91]
	    }, {
	      uid: 376,
	      t: "Voltage Input",
	      c: 29,
	      i: 0,
	      p: [54, 46, 101]
	    }]
	  }, {
	    uid: 193,
	    d: 87,
	    c: 21,
	    t: "Temperature Phidget",
	    s: "TMP1000",
	    i: 19,
	    v: [100, 200],
	    ch: [{
	      uid: 380,
	      t: "Temperature Sensor (IC)",
	      c: 28,
	      i: 0,
	      p: [54, 46, 95]
	    }]
	  }, {
	    uid: 194,
	    d: 88,
	    c: 21,
	    t: "Isolated Thermocouple Phidget",
	    s: "TMP1100",
	    i: 55,
	    v: [100, 200],
	    ch: [{
	      uid: 381,
	      t: "Thermocouple Input",
	      c: 28,
	      s: 33,
	      i: 0,
	      p: [54, 46, 84, 95]
	    }, {
	      uid: 382,
	      t: "Temperature Sensor (IC)",
	      c: 28,
	      i: 1,
	      p: [54, 46, 95]
	    }, {
	      uid: 383,
	      t: "Voltage Input",
	      c: 29,
	      i: 0,
	      p: [54, 46, 101]
	    }]
	  }, {
	    uid: 195,
	    d: 89,
	    c: 21,
	    t: "4x Thermocouple Phidget",
	    s: "TMP1101",
	    i: 21,
	    v: [100, 200],
	    ch: [{
	      uid: 384,
	      t: "Thermocouple Input",
	      c: 28,
	      s: 33,
	      n: 4,
	      i: 0,
	      p: [54, 46, 84, 95]
	    }, {
	      uid: 385,
	      t: "Temperature Sensor (IC)",
	      c: 28,
	      i: 4,
	      p: [54, 46, 95]
	    }, {
	      uid: 386,
	      t: "Voltage Input",
	      c: 29,
	      n: 4,
	      i: 0,
	      p: [54, 46, 101]
	    }]
	  }, {
	    uid: 196,
	    d: 89,
	    c: 21,
	    t: "4x Thermocouple Phidget",
	    s: "TMP1101",
	    i: 143,
	    v: [200, 300],
	    ch: [{
	      uid: 387,
	      t: "Thermocouple Input",
	      c: 28,
	      s: 33,
	      n: 4,
	      i: 0,
	      p: [54, 46, 84, 95]
	    }, {
	      uid: 388,
	      t: "Temperature Sensor (IC)",
	      c: 28,
	      i: 4,
	      p: [54, 46, 95]
	    }, {
	      uid: 389,
	      t: "Voltage Input",
	      c: 29,
	      n: 4,
	      i: 0,
	      p: [54, 46, 101]
	    }]
	  }, {
	    uid: 197,
	    d: 90,
	    c: 21,
	    t: "RTD Phidget",
	    s: "TMP1200",
	    i: 16,
	    v: [100, 200],
	    ch: [{
	      uid: 390,
	      t: "RTD input",
	      c: 28,
	      s: 32,
	      i: 0,
	      p: [54, 46, 76, 77, 95]
	    }, {
	      uid: 391,
	      t: "Resistance Input",
	      c: 23,
	      i: 0,
	      p: [54, 46, 77, 36]
	    }]
	  }, {
	    uid: 200,
	    d: 92,
	    c: 21,
	    t: "20-bit (+-40V) Voltage Input Phidget",
	    s: "VCP1000",
	    i: 53,
	    v: [100, 200],
	    ch: [{
	      uid: 397,
	      t: "Voltage Input",
	      c: 29,
	      i: 0,
	      p: [54, 46, 87, 101]
	    }]
	  }, {
	    uid: 201,
	    d: 93,
	    c: 21,
	    t: "10-bit (+-40V) Voltage Input Phidget",
	    s: "VCP1001",
	    i: 31,
	    v: [100, 110],
	    ch: [{
	      uid: 398,
	      t: "Voltage Input",
	      c: 29,
	      i: 0,
	      p: [54, 46, 87, 101]
	    }]
	  }, {
	    uid: 202,
	    d: 93,
	    c: 21,
	    t: "10-bit (+-40V) Voltage Input Phidget",
	    s: "VCP1001",
	    i: 31,
	    v: [110, 200],
	    ch: [{
	      uid: 399,
	      t: "Voltage Input",
	      c: 29,
	      i: 0,
	      p: [54, 46, 87, 101]
	    }]
	  }, {
	    uid: 203,
	    d: 94,
	    c: 21,
	    t: "10-bit (+-1V) Voltage Input Phidget",
	    s: "VCP1002",
	    i: 30,
	    v: [100, 110],
	    ch: [{
	      uid: 400,
	      t: "Voltage Input",
	      c: 29,
	      i: 0,
	      p: [54, 46, 87, 101]
	    }]
	  }, {
	    uid: 204,
	    d: 94,
	    c: 21,
	    t: "10-bit (+-1V) Voltage Input Phidget",
	    s: "VCP1002",
	    i: 30,
	    v: [110, 200],
	    ch: [{
	      uid: 401,
	      t: "Voltage Input",
	      c: 29,
	      i: 0,
	      p: [54, 46, 87, 101]
	    }]
	  }, {
	    uid: 223,
	    d: 102,
	    c: 21,
	    t: "VINT Firmware Upgrade (STM32F0)",
	    s: "FIRMWARE_UPGRADE_STM32F0",
	    i: 4093,
	    v: [100, 110],
	    ch: [{
	      uid: 419,
	      t: "Firmware Upgrade",
	      c: 32,
	      i: 0,
	      p: [114, 112, 113]
	    }]
	  }, {
	    uid: 224,
	    d: 143,
	    c: 21,
	    t: "VINT Firmware Upgrade (STM32G0)",
	    s: "FIRMWARE_UPGRADE_STM32G0",
	    i: 4093,
	    v: [110, 120],
	    ch: [{
	      uid: 420,
	      t: "Firmware Upgrade",
	      c: 32,
	      i: 0,
	      p: [114, 112, 113]
	    }]
	  }, {
	    uid: 225,
	    d: 145,
	    c: 21,
	    t: "VINT Firmware Upgrade (STM32F3)",
	    s: "FIRMWARE_UPGRADE_STM32F3",
	    i: 4093,
	    v: [120, 200],
	    ch: [{
	      uid: 421,
	      t: "Firmware Upgrade",
	      c: 32,
	      i: 0,
	      p: [114, 112, 113]
	    }]
	  }, {
	    uid: 226,
	    d: 103,
	    c: 21,
	    t: "VINT Firmware Upgrade (STM8S)",
	    s: "FIRMWARE_UPGRADE_STM8S",
	    i: 4094,
	    v: [100, 200],
	    ch: [{
	      uid: 422,
	      t: "Firmware Upgrade",
	      c: 32,
	      i: 0,
	      p: [114, 112, 113]
	    }]
	  }, {
	    uid: 234,
	    d: 125,
	    c: 21,
	    t: "Unsupported VINT Phidget",
	    s: " ",
	    i: 4080,
	    v: [0, 9999],
	    ch: [{
	      uid: 437,
	      t: "Unsupported VINT Channel",
	      c: 33,
	      i: 0,
	      p: [39, 152, 153, 154, 155, 28]
	    }]
	  }],
	  USB: [{
	    uid: 1,
	    d: 1,
	    c: 9,
	    t: "PhidgetInterfaceKit 4/8/8",
	    s: "ifkit488",
	    i: 33281,
	    v: [0, 101],
	    cn: [0, 4, 8, 8],
	    ch: [{
	      uid: 1,
	      t: "Voltage Ratio Input",
	      c: 31,
	      s: 64,
	      n: 4,
	      i: 0,
	      p: [10, 27, 54, 79, 46, 122, 102, 115]
	    }, {
	      uid: 2,
	      t: "Digital Input",
	      c: 5,
	      n: 8,
	      i: 0,
	      p: [90]
	    }, {
	      uid: 3,
	      t: "Digital Output",
	      c: 6,
	      n: 8,
	      i: 0,
	      p: [82, 55]
	    }]
	  }, {
	    uid: 2,
	    d: 2,
	    c: 16,
	    t: "PhidgetServo 1-Motor",
	    s: "1000",
	    i: 33025,
	    v: [200, 201],
	    cn: [1],
	    ch: [{
	      uid: 4,
	      t: "RC Servo Motor Controller",
	      c: 22,
	      i: 0,
	      p: [70, 69, 83, 57, 29]
	    }]
	  }, {
	    uid: 3,
	    d: 2,
	    c: 16,
	    t: "PhidgetServo 1-Motor",
	    s: "1000",
	    i: 57,
	    v: [200, 201],
	    cn: [1],
	    ch: [{
	      uid: 5,
	      t: "RC Servo Motor Controller",
	      c: 22,
	      i: 0,
	      p: [70, 69, 83, 57, 29]
	    }]
	  }, {
	    uid: 4,
	    d: 2,
	    c: 16,
	    t: "PhidgetServo 1-Motor",
	    s: "1000",
	    i: 57,
	    v: [300, 313],
	    cn: [1],
	    ch: [{
	      uid: 6,
	      t: "RC Servo Motor Controller",
	      c: 22,
	      i: 0,
	      p: [70, 69, 83, 57, 29]
	    }]
	  }, {
	    uid: 5,
	    d: 2,
	    c: 16,
	    t: "PhidgetServo 1-Motor",
	    s: "1000",
	    i: 57,
	    v: [313, 400],
	    cn: [1],
	    ch: [{
	      uid: 7,
	      t: "RC Servo Motor Controller",
	      c: 22,
	      i: 0,
	      p: [70, 69, 83, 57, 29]
	    }]
	  }, {
	    uid: 6,
	    d: 3,
	    c: 16,
	    t: "PhidgetServo 4-Motor",
	    s: "1001",
	    i: 33028,
	    v: [200, 201],
	    cn: [4],
	    ch: [{
	      uid: 8,
	      t: "RC Servo Motor Controller",
	      c: 22,
	      n: 4,
	      i: 0,
	      p: [70, 69, 83, 57, 29]
	    }]
	  }, {
	    uid: 7,
	    d: 3,
	    c: 16,
	    t: "PhidgetServo 4-Motor",
	    s: "1001",
	    i: 56,
	    v: [200, 201],
	    cn: [4],
	    ch: [{
	      uid: 9,
	      t: "RC Servo Motor Controller",
	      c: 22,
	      n: 4,
	      i: 0,
	      p: [70, 69, 83, 57, 29]
	    }]
	  }, {
	    uid: 8,
	    d: 3,
	    c: 16,
	    t: "PhidgetServo 4-Motor",
	    s: "1001",
	    i: 56,
	    v: [300, 313],
	    cn: [4],
	    ch: [{
	      uid: 10,
	      t: "RC Servo Motor Controller",
	      c: 22,
	      n: 4,
	      i: 0,
	      p: [70, 69, 83, 57, 29]
	    }]
	  }, {
	    uid: 9,
	    d: 3,
	    c: 16,
	    t: "PhidgetServo 4-Motor",
	    s: "1001",
	    i: 56,
	    v: [313, 400],
	    cn: [4],
	    ch: [{
	      uid: 11,
	      t: "RC Servo Motor Controller",
	      c: 22,
	      n: 4,
	      i: 0,
	      p: [70, 69, 83, 57, 29]
	    }]
	  }, {
	    uid: 10,
	    d: 4,
	    c: 3,
	    t: "PhidgetAnalog 4-Output",
	    s: "1002",
	    i: 55,
	    v: [100, 200],
	    cn: [4],
	    ch: [{
	      uid: 12,
	      t: "Voltage Output",
	      c: 30,
	      n: 4,
	      i: 0,
	      p: [56, 86]
	    }]
	  }, {
	    uid: 11,
	    d: 5,
	    c: 1,
	    t: "PhidgetAccelerometer 2-Axis",
	    s: "1008",
	    i: 113,
	    v: [0, 200],
	    cn: [2],
	    ch: [{
	      uid: 13,
	      t: "2-Axis Accelerometer",
	      c: 1,
	      i: 0,
	      p: [46, 54, 1]
	    }]
	  }, {
	    uid: 12,
	    d: 7,
	    c: 9,
	    t: "PhidgetInterfaceKit 2/2/2",
	    s: "1011",
	    i: 54,
	    v: [0, 200],
	    cn: [2, 2, 2, 2],
	    ch: [{
	      uid: 14,
	      t: "Voltage Input",
	      c: 29,
	      s: 48,
	      n: 2,
	      i: 0,
	      p: [10, 27, 54, 79, 46, 122, 101, 115]
	    }, {
	      uid: 15,
	      t: "Voltage Ratio Input",
	      c: 31,
	      s: 64,
	      n: 2,
	      i: 0,
	      p: [10, 27, 54, 79, 46, 122, 102, 115]
	    }, {
	      uid: 16,
	      t: "Digital Input",
	      c: 5,
	      n: 2,
	      i: 0,
	      p: [90]
	    }, {
	      uid: 17,
	      t: "Digital Output",
	      c: 6,
	      n: 2,
	      i: 0,
	      p: [82, 55]
	    }]
	  }, {
	    uid: 13,
	    d: 8,
	    c: 9,
	    t: "PhidgetInterfaceKit 0/16/16",
	    s: "1012",
	    i: 68,
	    v: [0, 601],
	    cn: [0, 0, 16, 16],
	    ch: [{
	      uid: 18,
	      t: "Digital Input",
	      c: 5,
	      n: 16,
	      i: 0,
	      p: [90]
	    }, {
	      uid: 19,
	      t: "Digital Output",
	      c: 6,
	      n: 16,
	      i: 0,
	      p: [82, 55]
	    }]
	  }, {
	    uid: 14,
	    d: 8,
	    c: 9,
	    t: "PhidgetInterfaceKit 0/16/16",
	    s: "1012",
	    i: 68,
	    v: [601, 602],
	    cn: [0, 0, 16, 16],
	    ch: [{
	      uid: 20,
	      t: "Digital Input",
	      c: 5,
	      n: 16,
	      i: 0,
	      p: [90]
	    }, {
	      uid: 21,
	      t: "Digital Output",
	      c: 6,
	      n: 16,
	      i: 0,
	      p: [82, 55]
	    }]
	  }, {
	    uid: 15,
	    d: 8,
	    c: 9,
	    t: "PhidgetInterfaceKit 0/16/16",
	    s: "1012",
	    i: 68,
	    v: [602, 700],
	    cn: [0, 0, 16, 16],
	    ch: [{
	      uid: 22,
	      t: "Digital Input",
	      c: 5,
	      n: 16,
	      i: 0,
	      p: [90]
	    }, {
	      uid: 23,
	      t: "Digital Output",
	      c: 6,
	      n: 16,
	      i: 0,
	      p: [82, 55]
	    }]
	  }, {
	    uid: 16,
	    d: 6,
	    c: 9,
	    t: "PhidgetInterfaceKit 8/8/8",
	    s: "1013",
	    i: 69,
	    v: [0, 821],
	    cn: [8, 8, 8, 8],
	    ch: [{
	      uid: 24,
	      t: "Voltage Input",
	      c: 29,
	      s: 48,
	      n: 8,
	      i: 0,
	      p: [10, 27, 54, 79, 46, 122, 101, 115]
	    }, {
	      uid: 25,
	      t: "Voltage Ratio Input",
	      c: 31,
	      s: 64,
	      n: 8,
	      i: 0,
	      p: [10, 27, 54, 79, 46, 122, 102, 115]
	    }, {
	      uid: 26,
	      t: "Digital Input",
	      c: 5,
	      n: 8,
	      i: 0,
	      p: [90]
	    }, {
	      uid: 27,
	      t: "Digital Output",
	      c: 6,
	      n: 8,
	      i: 0,
	      p: [55, 82]
	    }]
	  }, {
	    uid: 17,
	    d: 6,
	    c: 9,
	    t: "PhidgetInterfaceKit 8/8/8",
	    s: "1013/1018/1019",
	    i: 69,
	    v: [821, 900],
	    cn: [8, 8, 8, 8],
	    ch: [{
	      uid: 28,
	      t: "Voltage Input",
	      c: 29,
	      s: 48,
	      n: 8,
	      i: 0,
	      p: [10, 27, 54, 79, 46, 122, 101, 115]
	    }, {
	      uid: 29,
	      t: "Voltage Ratio Input",
	      c: 31,
	      s: 64,
	      n: 8,
	      i: 0,
	      p: [10, 27, 54, 79, 46, 122, 102, 115]
	    }, {
	      uid: 30,
	      t: "Digital Input",
	      c: 5,
	      n: 8,
	      i: 0,
	      p: [90]
	    }, {
	      uid: 31,
	      t: "Digital Output",
	      c: 6,
	      n: 8,
	      i: 0,
	      p: [82, 55]
	    }]
	  }, {
	    uid: 18,
	    d: 9,
	    c: 9,
	    t: "PhidgetInterfaceKit 0/0/4",
	    s: "1014",
	    i: 64,
	    v: [0, 704],
	    cn: [0, 0, 0, 4],
	    ch: [{
	      uid: 32,
	      t: "Power Relay",
	      c: 6,
	      n: 4,
	      i: 0,
	      p: [82, 55]
	    }]
	  }, {
	    uid: 19,
	    d: 9,
	    c: 9,
	    t: "PhidgetInterfaceKit 0/0/4",
	    s: "1014",
	    i: 64,
	    v: [704, 800],
	    cn: [0, 0, 0, 4],
	    ch: [{
	      uid: 33,
	      t: "Power Relay",
	      c: 6,
	      n: 4,
	      i: 0,
	      p: [82, 55]
	    }]
	  }, {
	    uid: 20,
	    d: 9,
	    c: 9,
	    t: "PhidgetInterfaceKit 0/0/4",
	    s: "1014",
	    i: 64,
	    v: [800, 900],
	    cn: [0, 0, 0, 4],
	    ch: [{
	      uid: 34,
	      t: "Power Relay",
	      c: 6,
	      n: 4,
	      i: 0,
	      p: [82, 55, 147, 146]
	    }]
	  }, {
	    uid: 22,
	    d: 10,
	    c: 9,
	    t: "PhidgetLinearTouch",
	    s: "1015",
	    i: 118,
	    v: [0, 9999],
	    cn: [0, 0, 0, 0, 1],
	    ch: [{
	      uid: 36,
	      t: "Capacitive Slider Sensor",
	      c: 14,
	      i: 0,
	      p: [46, 54, 96, 137]
	    }]
	  }, {
	    uid: 23,
	    d: 11,
	    c: 9,
	    t: "PhidgetCircularTouch",
	    s: "1016",
	    i: 119,
	    v: [0, 9999],
	    cn: [0, 0, 0, 0, 1],
	    ch: [{
	      uid: 37,
	      t: "Capacitive Scroll Sensor",
	      c: 14,
	      i: 0,
	      p: [46, 54, 96, 137]
	    }]
	  }, {
	    uid: 24,
	    d: 12,
	    c: 9,
	    t: "PhidgetInterfaceKit 0/0/8",
	    s: "1017",
	    i: 129,
	    v: [0, 9999],
	    cn: [0, 0, 0, 8],
	    ch: [{
	      uid: 38,
	      t: "Signal Relay",
	      c: 6,
	      n: 8,
	      i: 0,
	      p: [82, 55]
	    }]
	  }, {
	    uid: 25,
	    d: 12,
	    c: 9,
	    t: "PhidgetInterfaceKit 0/0/8",
	    s: "1017",
	    i: 135,
	    v: [200, 300],
	    cn: [0, 0, 0, 8],
	    ch: [{
	      uid: 39,
	      t: "Signal Relay",
	      c: 6,
	      n: 8,
	      i: 0,
	      p: [82, 55, 147, 146]
	    }]
	  }, {
	    uid: 27,
	    d: 6,
	    c: 9,
	    t: "PhidgetInterfaceKit 8/8/8",
	    s: "1010/1018/1019",
	    i: 69,
	    v: [900, 1000],
	    cn: [8, 8, 8, 8],
	    ch: [{
	      uid: 41,
	      t: "Voltage Input",
	      c: 29,
	      s: 48,
	      n: 8,
	      i: 0,
	      p: [10, 27, 54, 79, 46, 122, 101, 115]
	    }, {
	      uid: 42,
	      t: "Voltage Ratio Input",
	      c: 31,
	      s: 64,
	      n: 8,
	      i: 0,
	      p: [10, 27, 54, 79, 46, 122, 102, 115]
	    }, {
	      uid: 43,
	      t: "Digital Input",
	      c: 5,
	      n: 8,
	      i: 0,
	      p: [90]
	    }, {
	      uid: 44,
	      t: "Digital Output",
	      c: 6,
	      n: 8,
	      i: 0,
	      p: [82, 55]
	    }]
	  }, {
	    uid: 28,
	    d: 6,
	    c: 9,
	    t: "PhidgetInterfaceKit 8/8/8",
	    s: "1010/1018/1019",
	    i: 69,
	    v: [1000, 1100],
	    cn: [8, 8, 8, 8],
	    ch: [{
	      uid: 45,
	      t: "Voltage Input",
	      c: 29,
	      s: 48,
	      n: 8,
	      i: 0,
	      p: [10, 27, 54, 79, 46, 122, 101, 115]
	    }, {
	      uid: 46,
	      t: "Voltage Ratio Input",
	      c: 31,
	      s: 64,
	      n: 8,
	      i: 0,
	      p: [10, 27, 54, 79, 46, 122, 102, 115]
	    }, {
	      uid: 47,
	      t: "Digital Input",
	      c: 5,
	      n: 8,
	      i: 0,
	      p: [90]
	    }, {
	      uid: 48,
	      t: "Digital Output",
	      c: 6,
	      n: 8,
	      i: 0,
	      p: [82, 55]
	    }]
	  }, {
	    uid: 29,
	    d: 13,
	    c: 15,
	    t: "PhidgetRFID",
	    s: "1023",
	    i: 48,
	    v: [0, 104],
	    cn: [0],
	    ch: [{
	      uid: 49,
	      t: "RFID Reader",
	      c: 24,
	      i: 0,
	      p: [92, 93]
	    }]
	  }, {
	    uid: 30,
	    d: 13,
	    c: 15,
	    t: "PhidgetRFID",
	    s: "1023",
	    i: 48,
	    v: [104, 200],
	    cn: [0],
	    ch: [{
	      uid: 50,
	      t: "RFID Reader",
	      c: 24,
	      i: 0,
	      p: [92, 93]
	    }]
	  }, {
	    uid: 31,
	    d: 13,
	    c: 15,
	    t: "PhidgetRFID",
	    s: "1023",
	    i: 49,
	    v: [200, 201],
	    cn: [3],
	    ch: [{
	      uid: 51,
	      t: "RFID Reader",
	      c: 24,
	      i: 0,
	      p: [41, 92, 93]
	    }, {
	      uid: 52,
	      t: "Digital Output",
	      c: 6,
	      i: 0,
	      p: [82, 55]
	    }, {
	      uid: 53,
	      t: "LED Driver",
	      c: 6,
	      i: 1,
	      p: [82, 55]
	    }, {
	      uid: 54,
	      t: "Onboard LED",
	      c: 6,
	      i: 2,
	      p: [82, 55]
	    }]
	  }, {
	    uid: 32,
	    d: 13,
	    c: 15,
	    t: "PhidgetRFID",
	    s: "1023",
	    i: 49,
	    v: [201, 300],
	    cn: [3],
	    ch: [{
	      uid: 55,
	      t: "RFID Reader",
	      c: 24,
	      i: 0,
	      p: [41, 92, 93]
	    }, {
	      uid: 56,
	      t: "Digital Output",
	      c: 6,
	      i: 0,
	      p: [82, 55]
	    }, {
	      uid: 57,
	      t: "LED Driver",
	      c: 6,
	      i: 1,
	      p: [82, 55]
	    }, {
	      uid: 58,
	      t: "Onboard LED",
	      c: 6,
	      i: 2,
	      p: [82, 55]
	    }]
	  }, {
	    uid: 33,
	    d: 14,
	    c: 15,
	    t: "PhidgetRFID Read-Write",
	    s: "1024",
	    i: 52,
	    v: [100, 200],
	    cn: [3],
	    ch: [{
	      uid: 59,
	      t: "RFID Reader/Writer",
	      c: 24,
	      i: 0,
	      p: [41, 103, 92, 93]
	    }, {
	      uid: 60,
	      t: "Digital Output",
	      c: 6,
	      i: 0,
	      p: [82, 55]
	    }, {
	      uid: 61,
	      t: "LED Driver",
	      c: 6,
	      i: 1,
	      p: [82, 55]
	    }, {
	      uid: 62,
	      t: "Onboard LED",
	      c: 6,
	      i: 2,
	      p: [82, 55]
	    }]
	  }, {
	    uid: 36,
	    d: 15,
	    c: 11,
	    t: "PhidgetLED-64",
	    s: "1030",
	    i: 74,
	    v: [100, 300],
	    cn: [64],
	    ch: [{
	      uid: 71,
	      t: "LED Driver",
	      c: 6,
	      s: 17,
	      n: 64,
	      i: 0,
	      p: [55, 82]
	    }]
	  }, {
	    uid: 37,
	    d: 16,
	    c: 11,
	    t: "PhidgetLED-64 Advanced",
	    s: "1031",
	    i: 76,
	    v: [100, 200],
	    cn: [64],
	    ch: [{
	      uid: 72,
	      t: "LED Driver",
	      c: 6,
	      s: 17,
	      n: 64,
	      i: 0,
	      p: [55, 67, 68, 82]
	    }]
	  }, {
	    uid: 38,
	    d: 17,
	    c: 11,
	    t: "PhidgetLED-64 Advanced",
	    s: "1032",
	    i: 76,
	    v: [200, 300],
	    cn: [64],
	    ch: [{
	      uid: 73,
	      t: "LED Driver",
	      c: 6,
	      s: 17,
	      n: 64,
	      i: 0,
	      p: [55, 67, 68, 82]
	    }]
	  }, {
	    uid: 39,
	    d: 18,
	    c: 7,
	    t: "PhidgetGPS",
	    s: "1040",
	    i: 121,
	    v: [0, 9999],
	    cn: [1],
	    ch: [{
	      uid: 74,
	      t: "GPS",
	      c: 10,
	      i: 0,
	      p: [9, 109, 108, 29, 110, 30]
	    }]
	  }, {
	    uid: 40,
	    d: 19,
	    c: 17,
	    t: "PhidgetSpatial 0/0/3 Basic",
	    s: "1041",
	    i: 127,
	    v: [200, 300],
	    cn: [3, 0, 0],
	    ch: [{
	      uid: 75,
	      t: "3-Axis Accelerometer",
	      c: 1,
	      i: 0,
	      p: [54, 46, 1]
	    }]
	  }, {
	    uid: 41,
	    d: 20,
	    c: 17,
	    t: "PhidgetSpatial 3/3/3 Basic",
	    s: "1042",
	    i: 51,
	    v: [300, 400],
	    cn: [3, 3, 3, 1],
	    ch: [{
	      uid: 76,
	      t: "3-Axis Accelerometer",
	      c: 1,
	      i: 0,
	      p: [10, 54, 46, 1]
	    }, {
	      uid: 77,
	      t: "3-Axis Gyroscope",
	      c: 12,
	      i: 0,
	      p: [10, 54, 106, 2]
	    }, {
	      uid: 78,
	      t: "3-Axis Magnetometer",
	      c: 18,
	      i: 0,
	      p: [10, 54, 46, 50, 37, 35, 18]
	    }, {
	      uid: 79,
	      t: "Spatial",
	      c: 26,
	      i: 0,
	      p: [10, 54, 106, 50, 37, 35, 89]
	    }]
	  }, {
	    uid: 42,
	    d: 21,
	    c: 17,
	    t: "PhidgetSpatial Precision 0/0/3 High Resolution",
	    s: "1043",
	    i: 127,
	    v: [300, 400],
	    cn: [3, 0, 0],
	    ch: [{
	      uid: 80,
	      t: "3-Axis Accelerometer",
	      c: 1,
	      i: 0,
	      p: [54, 46, 145, 1]
	    }]
	  }, {
	    uid: 43,
	    d: 22,
	    c: 17,
	    t: "PhidgetSpatial Precision 3/3/3 High Resolution",
	    s: "1044",
	    i: 51,
	    v: [400, 500],
	    cn: [3, 3, 3, 1],
	    ch: [{
	      uid: 81,
	      t: "3-Axis Accelerometer",
	      c: 1,
	      i: 0,
	      p: [10, 54, 46, 145, 1]
	    }, {
	      uid: 82,
	      t: "3-Axis Gyroscope",
	      c: 12,
	      i: 0,
	      p: [10, 54, 145, 106, 2]
	    }, {
	      uid: 83,
	      t: "3-Axis Magnetometer",
	      c: 18,
	      i: 0,
	      p: [10, 54, 46, 50, 37, 35, 18]
	    }, {
	      uid: 84,
	      t: "Spatial",
	      c: 26,
	      i: 0,
	      p: [10, 54, 145, 106, 50, 37, 35, 89]
	    }]
	  }, {
	    uid: 44,
	    d: 22,
	    c: 17,
	    t: "PhidgetSpatial Precision 3/3/3 High Resolution",
	    s: "1044",
	    i: 51,
	    v: [500, 510],
	    cn: [3, 3, 3, 1],
	    ch: [{
	      uid: 85,
	      t: "3-Axis Accelerometer",
	      c: 1,
	      i: 0,
	      p: [10, 54, 46, 145, 1]
	    }, {
	      uid: 86,
	      t: "3-Axis Gyroscope",
	      c: 12,
	      i: 0,
	      p: [10, 54, 145, 106, 2]
	    }, {
	      uid: 87,
	      t: "3-Axis Magnetometer",
	      c: 18,
	      i: 0,
	      p: [10, 54, 46, 50, 37, 35, 18]
	    }, {
	      uid: 88,
	      t: "Spatial",
	      c: 26,
	      s: 112,
	      i: 0,
	      p: [10, 54, 145, 149, 151, 106, 50, 37, 35, 150, 89, 148]
	    }]
	  }, {
	    uid: 45,
	    d: 22,
	    c: 17,
	    t: "PhidgetSpatial Precision 3/3/3 High Resolution",
	    s: "1044",
	    i: 51,
	    v: [510, 600],
	    cn: [3, 3, 3, 1],
	    ch: [{
	      uid: 89,
	      t: "3-Axis Accelerometer",
	      c: 1,
	      i: 0,
	      p: [10, 54, 46, 145, 1]
	    }, {
	      uid: 90,
	      t: "3-Axis Gyroscope",
	      c: 12,
	      i: 0,
	      p: [10, 54, 145, 106, 2]
	    }, {
	      uid: 91,
	      t: "3-Axis Magnetometer",
	      c: 18,
	      i: 0,
	      p: [10, 54, 46, 50, 37, 35, 18]
	    }, {
	      uid: 92,
	      t: "Spatial",
	      c: 26,
	      s: 112,
	      i: 0,
	      p: [10, 54, 145, 149, 151, 106, 50, 37, 35, 174, 150, 89, 148]
	    }]
	  }, {
	    uid: 46,
	    d: 23,
	    c: 19,
	    t: "PhidgetTemperatureSensor IR",
	    s: "1045",
	    i: 60,
	    v: [100, 200],
	    cn: [2, 0],
	    ch: [{
	      uid: 93,
	      t: "Temperature Sensor (IR)",
	      c: 28,
	      i: 0,
	      p: [46, 54, 95]
	    }, {
	      uid: 94,
	      t: "Temperature Sensor (IC)",
	      c: 28,
	      i: 1,
	      p: [46, 54, 95]
	    }]
	  }, {
	    uid: 47,
	    d: 24,
	    c: 4,
	    t: "PhidgetBridge 4-Input",
	    s: "1046",
	    i: 59,
	    v: [100, 102],
	    cn: [4],
	    ch: [{
	      uid: 95,
	      t: "Bridge Input",
	      c: 31,
	      s: 65,
	      n: 4,
	      i: 0,
	      p: [10, 56, 45, 54, 46, 102]
	    }]
	  }, {
	    uid: 48,
	    d: 24,
	    c: 4,
	    t: "PhidgetBridge 4-Input",
	    s: "1046",
	    i: 59,
	    v: [102, 200],
	    cn: [4],
	    ch: [{
	      uid: 96,
	      t: "Bridge Input",
	      c: 31,
	      s: 65,
	      n: 4,
	      i: 0,
	      p: [10, 56, 45, 54, 46, 102]
	    }]
	  }, {
	    uid: 50,
	    d: 25,
	    c: 5,
	    t: "PhidgetEncoder HighSpeed 4-Input",
	    s: "1047",
	    i: 79,
	    v: [100, 200],
	    cn: [4, 4],
	    ch: [{
	      uid: 98,
	      t: "Encoder Input",
	      c: 8,
	      n: 4,
	      i: 0,
	      p: [46, 56, 54, 29]
	    }, {
	      uid: 99,
	      t: "Digital Input",
	      c: 5,
	      n: 4,
	      i: 0,
	      p: [90]
	    }]
	  }, {
	    uid: 51,
	    d: 25,
	    c: 5,
	    t: "PhidgetEncoder HighSpeed 4-Input",
	    s: "1047",
	    i: 79,
	    v: [200, 300],
	    cn: [4, 4],
	    ch: [{
	      uid: 100,
	      t: "Encoder Input",
	      c: 8,
	      n: 4,
	      i: 0,
	      p: [46, 56, 54, 29]
	    }, {
	      uid: 101,
	      t: "Digital Input",
	      c: 5,
	      n: 4,
	      i: 0,
	      p: [90]
	    }]
	  }, {
	    uid: 52,
	    d: 26,
	    c: 19,
	    t: "PhidgetTemperatureSensor 4-Input",
	    s: "1048",
	    i: 50,
	    v: [100, 200],
	    cn: [5, 4],
	    ch: [{
	      uid: 102,
	      t: "Thermocouple Input",
	      c: 28,
	      s: 33,
	      n: 4,
	      i: 0,
	      p: [46, 84, 54, 95]
	    }, {
	      uid: 103,
	      t: "Temperature Sensor (IC)",
	      c: 28,
	      i: 4,
	      p: [46, 54, 95]
	    }, {
	      uid: 104,
	      t: "Voltage Input",
	      c: 29,
	      n: 4,
	      i: 0,
	      p: [46, 54, 101]
	    }]
	  }, {
	    uid: 53,
	    d: 26,
	    c: 19,
	    t: "PhidgetTemperatureSensor 4-Input",
	    s: "1048",
	    i: 50,
	    v: [200, 300],
	    cn: [5, 4],
	    ch: [{
	      uid: 105,
	      t: "Thermocouple Input",
	      c: 28,
	      s: 33,
	      n: 4,
	      i: 0,
	      p: [46, 84, 54, 95]
	    }, {
	      uid: 106,
	      t: "Temperature Sensor (IC)",
	      c: 28,
	      i: 4,
	      p: [46, 54, 95]
	    }, {
	      uid: 107,
	      t: "Voltage Input",
	      c: 29,
	      n: 4,
	      i: 0,
	      p: [46, 54, 101]
	    }]
	  }, {
	    uid: 54,
	    d: 27,
	    c: 17,
	    t: "PhidgetSpatial 0/0/3",
	    s: "1049",
	    i: 127,
	    v: [0, 200],
	    cn: [3, 0, 0],
	    ch: [{
	      uid: 108,
	      t: "3-Axis Accelerometer",
	      c: 1,
	      i: 0,
	      p: [54, 46, 1]
	    }]
	  }, {
	    uid: 55,
	    d: 28,
	    c: 19,
	    t: "PhidgetTemperatureSensor 1-Input",
	    s: "1051",
	    i: 112,
	    v: [0, 200],
	    cn: [2, 0],
	    ch: [{
	      uid: 109,
	      t: "Thermocouple Input",
	      c: 28,
	      s: 33,
	      i: 0,
	      p: [46, 54, 95]
	    }, {
	      uid: 110,
	      t: "Temperature Sensor (IC)",
	      c: 28,
	      i: 1,
	      p: [46, 54, 95]
	    }]
	  }, {
	    uid: 56,
	    d: 28,
	    c: 19,
	    t: "PhidgetTemperatureSensor 1-Input",
	    s: "1051",
	    i: 112,
	    v: [200, 300],
	    cn: [2, 1],
	    ch: [{
	      uid: 111,
	      t: "Thermocouple Input",
	      c: 28,
	      s: 33,
	      i: 0,
	      p: [46, 84, 54, 95]
	    }, {
	      uid: 112,
	      t: "Temperature Sensor (IC)",
	      c: 28,
	      i: 1,
	      p: [46, 54, 95]
	    }, {
	      uid: 113,
	      t: "Voltage Input",
	      c: 29,
	      i: 0,
	      p: [46, 54, 101]
	    }]
	  }, {
	    uid: 57,
	    d: 28,
	    c: 19,
	    t: "PhidgetTemperatureSensor 1-Input",
	    s: "1051",
	    i: 112,
	    v: [300, 400],
	    cn: [2, 1],
	    ch: [{
	      uid: 114,
	      t: "Thermocouple Input",
	      c: 28,
	      s: 33,
	      i: 0,
	      p: [46, 84, 54, 95]
	    }, {
	      uid: 115,
	      t: "Temperature Sensor (IC)",
	      c: 28,
	      i: 1,
	      p: [46, 54, 95]
	    }, {
	      uid: 116,
	      t: "Voltage Input",
	      c: 29,
	      i: 0,
	      p: [46, 54, 101]
	    }]
	  }, {
	    uid: 58,
	    d: 28,
	    c: 19,
	    t: "PhidgetTemperatureSensor 1-Input",
	    s: "1051",
	    i: 112,
	    v: [400, 500],
	    cn: [2, 1],
	    ch: [{
	      uid: 117,
	      t: "Thermocouple Input",
	      c: 28,
	      s: 33,
	      i: 0,
	      p: [46, 84, 54, 95]
	    }, {
	      uid: 118,
	      t: "Temperature Sensor (IC)",
	      c: 28,
	      i: 1,
	      p: [46, 54, 95]
	    }, {
	      uid: 119,
	      t: "Voltage Input",
	      c: 29,
	      i: 0,
	      p: [46, 54, 101]
	    }]
	  }, {
	    uid: 59,
	    d: 29,
	    c: 5,
	    t: "PhidgetEncoder",
	    s: "1052",
	    i: 75,
	    v: [0, 101],
	    cn: [1, 1],
	    ch: [{
	      uid: 120,
	      t: "Encoder Input",
	      c: 8,
	      i: 0,
	      p: [46, 54, 29]
	    }, {
	      uid: 121,
	      t: "Digital Input",
	      c: 5,
	      i: 0,
	      p: [90]
	    }]
	  }, {
	    uid: 60,
	    d: 29,
	    c: 5,
	    t: "PhidgetEncoder",
	    s: "1052",
	    i: 75,
	    v: [101, 110],
	    cn: [1, 1],
	    ch: [{
	      uid: 122,
	      t: "Encoder Input",
	      c: 8,
	      i: 0,
	      p: [46, 54, 29]
	    }, {
	      uid: 123,
	      t: "Digital Input",
	      c: 5,
	      i: 0,
	      p: [90]
	    }]
	  }, {
	    uid: 61,
	    d: 29,
	    c: 5,
	    t: "PhidgetEncoder",
	    s: "1052",
	    i: 75,
	    v: [110, 300],
	    cn: [1, 1],
	    ch: [{
	      uid: 124,
	      t: "Encoder Input",
	      c: 8,
	      i: 0,
	      p: [46, 54, 29]
	    }, {
	      uid: 125,
	      t: "Digital Input",
	      c: 5,
	      i: 0,
	      p: [90]
	    }]
	  }, {
	    uid: 62,
	    d: 30,
	    c: 1,
	    t: "PhidgetAccelerometer 2-Axis",
	    s: "1053",
	    i: 113,
	    v: [300, 400],
	    cn: [2],
	    ch: [{
	      uid: 126,
	      t: "2-Axis Accelerometer",
	      c: 1,
	      i: 0,
	      p: [46, 54, 1]
	    }]
	  }, {
	    uid: 63,
	    d: 31,
	    c: 6,
	    t: "PhidgetFrequencyCounter",
	    s: "1054",
	    i: 53,
	    v: [0, 200],
	    cn: [2],
	    ch: [{
	      uid: 127,
	      t: "Frequency Input",
	      c: 9,
	      n: 2,
	      i: 0,
	      p: [21, 56, 59, 54, 20, 7]
	    }]
	  }, {
	    uid: 64,
	    d: 32,
	    c: 10,
	    t: "PhidgetIR",
	    s: "1055",
	    i: 77,
	    v: [100, 200],
	    cn: [1],
	    ch: [{
	      uid: 128,
	      t: "IR Receiver Transmitter",
	      c: 16,
	      i: 0,
	      p: [33, 97, 99, 98, 5, 25, 32]
	    }]
	  }, {
	    uid: 65,
	    d: 32,
	    c: 10,
	    t: "PhidgetIR",
	    s: "1055",
	    i: 77,
	    v: [200, 300],
	    cn: [1],
	    ch: [{
	      uid: 129,
	      t: "IR Receiver Transmitter",
	      c: 16,
	      i: 0,
	      p: [33, 97, 99, 98, 5, 25, 32]
	    }]
	  }, {
	    uid: 67,
	    d: 33,
	    c: 17,
	    t: "PhidgetSpatial 3/3/3",
	    s: "1056",
	    i: 51,
	    v: [0, 200],
	    cn: [3, 3, 3, 1],
	    ch: [{
	      uid: 131,
	      t: "3-Axis Accelerometer",
	      c: 1,
	      i: 0,
	      p: [10, 54, 46, 1]
	    }, {
	      uid: 132,
	      t: "3-Axis Gyroscope",
	      c: 12,
	      i: 0,
	      p: [10, 54, 106, 2]
	    }, {
	      uid: 133,
	      t: "3-Axis Magnetometer",
	      c: 18,
	      i: 0,
	      p: [10, 54, 46, 50, 37, 35, 18]
	    }, {
	      uid: 134,
	      t: "Spatial",
	      c: 26,
	      i: 0,
	      p: [10, 54, 106, 50, 37, 35, 89]
	    }]
	  }, {
	    uid: 68,
	    d: 33,
	    c: 17,
	    t: "PhidgetSpatial 3/3/3",
	    s: "1056",
	    i: 51,
	    v: [200, 300],
	    cn: [3, 3, 3, 1],
	    ch: [{
	      uid: 135,
	      t: "3-Axis Accelerometer",
	      c: 1,
	      i: 0,
	      p: [10, 54, 46, 1]
	    }, {
	      uid: 136,
	      t: "3-Axis Gyroscope",
	      c: 12,
	      i: 0,
	      p: [10, 54, 106, 2]
	    }, {
	      uid: 137,
	      t: "3-Axis Magnetometer",
	      c: 18,
	      i: 0,
	      p: [10, 54, 46, 50, 37, 35, 18]
	    }, {
	      uid: 138,
	      t: "Spatial",
	      c: 26,
	      i: 0,
	      p: [10, 54, 106, 50, 37, 35, 89]
	    }]
	  }, {
	    uid: 69,
	    d: 34,
	    c: 5,
	    t: "PhidgetEncoder HighSpeed",
	    s: "1057",
	    i: 128,
	    v: [300, 400],
	    cn: [1],
	    ch: [{
	      uid: 139,
	      t: "Encoder Input",
	      c: 8,
	      i: 0,
	      p: [46, 54, 29]
	    }]
	  }, {
	    uid: 70,
	    d: 34,
	    c: 5,
	    t: "PhidgetEncoder HighSpeed",
	    s: "1057",
	    i: 128,
	    v: [400, 500],
	    cn: [1],
	    ch: [{
	      uid: 140,
	      t: "Encoder Input",
	      c: 8,
	      i: 0,
	      p: [46, 56, 54, 65, 29]
	    }]
	  }, {
	    uid: 71,
	    d: 35,
	    c: 14,
	    t: "PhidgetPHSensor",
	    s: "1058",
	    i: 116,
	    v: [100, 200],
	    cn: [1, 1],
	    ch: [{
	      uid: 141,
	      t: "Voltage Input",
	      c: 29,
	      i: 0,
	      p: [46, 54, 101]
	    }, {
	      uid: 142,
	      t: "PH Input",
	      c: 37,
	      i: 0,
	      p: [54, 46, 134, 133]
	    }]
	  }, {
	    uid: 72,
	    d: 36,
	    c: 1,
	    t: "PhidgetAccelerometer 3-Axis",
	    s: "1059",
	    i: 126,
	    v: [400, 500],
	    cn: [3],
	    ch: [{
	      uid: 143,
	      t: "3-Axis Accelerometer",
	      c: 1,
	      i: 0,
	      p: [46, 54, 1]
	    }]
	  }, {
	    uid: 73,
	    d: 37,
	    c: 13,
	    t: "PhidgetMotorControl LV",
	    s: "1060",
	    i: 88,
	    v: [100, 200],
	    cn: [2, 4, 0, 0, 0, 0],
	    ch: [{
	      uid: 144,
	      t: "DC Motor Controller",
	      c: 4,
	      n: 2,
	      i: 0,
	      p: [54, 55, 40, 16]
	    }, {
	      uid: 145,
	      t: "Digital Input",
	      c: 5,
	      n: 4,
	      i: 0,
	      p: [90]
	    }]
	  }, {
	    uid: 74,
	    d: 38,
	    c: 2,
	    t: "PhidgetAdvancedServo 8-Motor",
	    s: "1061",
	    i: 58,
	    v: [100, 200],
	    cn: [8, 8],
	    ch: [{
	      uid: 146,
	      t: "RC Servo Motor Controller",
	      c: 22,
	      n: 8,
	      i: 0,
	      p: [70, 69, 85, 40, 83, 57, 81, 54, 29, 100, 94]
	    }, {
	      uid: 147,
	      t: "RC Servo Motor Current Sensor",
	      c: 2,
	      n: 8,
	      i: 0,
	      p: [46, 54, 8]
	    }]
	  }, {
	    uid: 75,
	    d: 38,
	    c: 2,
	    t: "PhidgetAdvancedServo 8-Motor",
	    s: "1061",
	    i: 58,
	    v: [200, 300],
	    cn: [8, 8],
	    ch: [{
	      uid: 148,
	      t: "RC Servo Motor Controller",
	      c: 22,
	      n: 8,
	      i: 0,
	      p: [70, 69, 85, 40, 83, 57, 81, 54, 29, 100, 94]
	    }, {
	      uid: 149,
	      t: "RC Servo Motor Current Sensor",
	      c: 2,
	      n: 8,
	      i: 0,
	      p: [46, 54, 8]
	    }]
	  }, {
	    uid: 76,
	    d: 38,
	    c: 2,
	    t: "PhidgetAdvancedServo 8-Motor",
	    s: "1061",
	    i: 58,
	    v: [300, 400],
	    cn: [8, 8],
	    ch: [{
	      uid: 150,
	      t: "RC Servo Motor Controller",
	      c: 22,
	      n: 8,
	      i: 0,
	      p: [70, 69, 85, 40, 83, 57, 81, 54, 29, 100, 94]
	    }, {
	      uid: 151,
	      t: "RC Servo Motor Current Sensor",
	      c: 2,
	      n: 8,
	      i: 0,
	      p: [46, 54, 8]
	    }]
	  }, {
	    uid: 77,
	    d: 124,
	    c: 2,
	    t: "PhidgetAdvancedServo 8-Motor",
	    s: "RCC0004",
	    i: 58,
	    v: [400, 500],
	    cn: [8, 0],
	    ch: [{
	      uid: 152,
	      t: "RC Servo Motor Controller",
	      c: 22,
	      n: 8,
	      i: 0,
	      p: [70, 69, 85, 40, 83, 57, 81, 86, 54, 29, 100, 94]
	    }]
	  }, {
	    uid: 78,
	    d: 39,
	    c: 18,
	    t: "PhidgetStepper Unipolar 4-Motor",
	    s: "1062",
	    i: 122,
	    v: [100, 200],
	    cn: [4],
	    ch: [{
	      uid: 153,
	      t: "Unipolar Stepper Controller",
	      c: 27,
	      n: 4,
	      i: 0,
	      p: [83, 85, 40, 57, 49, 54, 29, 100, 91]
	    }]
	  }, {
	    uid: 79,
	    d: 40,
	    c: 18,
	    t: "PhidgetStepper Bipolar 1-Motor",
	    s: "1063",
	    i: 123,
	    v: [100, 200],
	    cn: [1, 4, 1],
	    ch: [{
	      uid: 154,
	      t: "Bipolar Stepper Controller",
	      c: 27,
	      i: 0,
	      p: [83, 85, 40, 51, 57, 49, 54, 29, 100, 91]
	    }, {
	      uid: 155,
	      t: "Digital Input",
	      c: 5,
	      n: 4,
	      i: 0,
	      p: [90]
	    }, {
	      uid: 156,
	      t: "Bipolar Stepper Current Sensor",
	      c: 2,
	      i: 0,
	      p: [46, 54, 8]
	    }]
	  }, {
	    uid: 80,
	    d: 41,
	    c: 13,
	    t: "PhidgetMotorControl HC",
	    s: "1064",
	    i: 89,
	    v: [100, 200],
	    cn: [2, 0, 0, 0, 0, 2],
	    ch: [{
	      uid: 157,
	      t: "DC Motor Controller",
	      c: 4,
	      n: 2,
	      i: 0,
	      p: [54, 55, 40, 16]
	    }, {
	      uid: 158,
	      t: "DC Motor Current Sensor",
	      c: 2,
	      n: 2,
	      i: 0,
	      p: [46, 54, 8]
	    }]
	  }, {
	    uid: 81,
	    d: 42,
	    c: 13,
	    t: "PhidgetMotorControl 1-Motor",
	    s: "1065",
	    i: 62,
	    v: [100, 200],
	    cn: [1, 2, 1, 3, 2, 1],
	    ch: [{
	      uid: 159,
	      t: "DC Motor Controller",
	      c: 4,
	      i: 0,
	      p: [54, 55, 40, 44, 42, 16, 3]
	    }, {
	      uid: 160,
	      t: "Digital Input",
	      c: 5,
	      n: 2,
	      i: 0,
	      p: [90]
	    }, {
	      uid: 161,
	      t: "Encoder Input",
	      c: 8,
	      i: 0,
	      p: [46, 54, 29]
	    }, {
	      uid: 162,
	      t: "Voltage Input",
	      c: 29,
	      s: 48,
	      n: 2,
	      i: 0,
	      p: [79, 46, 54, 122, 101, 115]
	    }, {
	      uid: 163,
	      t: "Supply Voltage Sensor",
	      c: 29,
	      i: 2,
	      p: [46, 54, 101]
	    }, {
	      uid: 164,
	      t: "Voltage Ratio Input",
	      c: 31,
	      s: 64,
	      n: 2,
	      i: 0,
	      p: [79, 46, 54, 122, 102, 115]
	    }, {
	      uid: 165,
	      t: "DC Motor Current Sensor",
	      c: 2,
	      i: 0,
	      p: [46, 54, 8]
	    }]
	  }, {
	    uid: 82,
	    d: 43,
	    c: 2,
	    t: "PhidgetAdvancedServo 1-Motor",
	    s: "1066",
	    i: 130,
	    v: [100, 200],
	    cn: [1, 1],
	    ch: [{
	      uid: 166,
	      t: "RC Servo Motor Controller",
	      c: 22,
	      i: 0,
	      p: [70, 69, 85, 40, 83, 57, 81, 54, 29, 100, 94]
	    }, {
	      uid: 167,
	      t: "RC Servo Motor Current Sensor",
	      c: 2,
	      i: 0,
	      p: [46, 54, 8]
	    }]
	  }, {
	    uid: 83,
	    d: 44,
	    c: 18,
	    t: "PhidgetStepper Bipolar HC",
	    s: "1067",
	    i: 123,
	    v: [200, 300],
	    cn: [1],
	    ch: [{
	      uid: 168,
	      t: "Bipolar Stepper Controller",
	      c: 27,
	      i: 0,
	      p: [83, 85, 40, 51, 57, 49, 54, 29, 100, 91]
	    }]
	  }, {
	    uid: 84,
	    d: 44,
	    c: 18,
	    t: "PhidgetStepper Bipolar HC",
	    s: "1067",
	    i: 123,
	    v: [300, 400],
	    cn: [1],
	    ch: [{
	      uid: 169,
	      t: "Bipolar Stepper Controller",
	      c: 27,
	      i: 0,
	      p: [83, 85, 40, 51, 57, 49, 54, 29, 100, 91]
	    }]
	  }, {
	    uid: 85,
	    d: 45,
	    c: 9,
	    t: "PhidgetInterfaceKit 8/8/8",
	    s: "1202/1203",
	    i: 125,
	    v: [0, 120],
	    cn: [8, 8, 8, 8],
	    ch: [{
	      uid: 170,
	      t: "Voltage Input",
	      c: 29,
	      s: 48,
	      n: 8,
	      i: 0,
	      p: [10, 27, 54, 79, 46, 122, 101, 115]
	    }, {
	      uid: 171,
	      t: "Voltage Ratio Input",
	      c: 31,
	      s: 64,
	      n: 8,
	      i: 0,
	      p: [10, 27, 54, 79, 46, 122, 102, 115]
	    }, {
	      uid: 172,
	      t: "Digital Input",
	      c: 5,
	      n: 8,
	      i: 0,
	      p: [90]
	    }, {
	      uid: 173,
	      t: "Digital Output",
	      c: 6,
	      n: 8,
	      i: 0,
	      p: [82, 55]
	    }]
	  }, {
	    uid: 86,
	    d: 45,
	    c: 9,
	    t: "PhidgetInterfaceKit 8/8/8",
	    s: "1202/1203",
	    i: 125,
	    v: [120, 200],
	    cn: [8, 8, 8, 8],
	    ch: [{
	      uid: 174,
	      t: "Voltage Input",
	      c: 29,
	      s: 48,
	      n: 8,
	      i: 0,
	      p: [10, 27, 54, 79, 46, 122, 101, 115]
	    }, {
	      uid: 175,
	      t: "Voltage Ratio Input",
	      c: 31,
	      s: 64,
	      n: 8,
	      i: 0,
	      p: [10, 27, 54, 79, 46, 122, 102, 115]
	    }, {
	      uid: 176,
	      t: "Digital Input",
	      c: 5,
	      n: 8,
	      i: 0,
	      p: [90]
	    }, {
	      uid: 177,
	      t: "Digital Output",
	      c: 6,
	      n: 8,
	      i: 0,
	      p: [82, 55]
	    }]
	  }, {
	    uid: 87,
	    d: 45,
	    c: 20,
	    t: "PhidgetTextLCD 20X2",
	    s: "1202/1203",
	    i: 125,
	    v: [0, 200],
	    cn: [1],
	    n: 1,
	    ch: [{
	      uid: 178,
	      t: "Text LCD",
	      c: 11,
	      s: 81,
	      i: 0,
	      p: [43, 48, 52, 53, 47, 4, 19, 105]
	    }]
	  }, {
	    uid: 88,
	    d: 45,
	    c: 9,
	    t: "PhidgetInterfaceKit 8/8/8",
	    s: "1202/1203",
	    i: 125,
	    v: [200, 300],
	    cn: [8, 8, 8, 8],
	    ch: [{
	      uid: 179,
	      t: "Voltage Input",
	      c: 29,
	      s: 48,
	      n: 8,
	      i: 0,
	      p: [10, 27, 54, 79, 46, 122, 101, 115]
	    }, {
	      uid: 180,
	      t: "Voltage Ratio Input",
	      c: 31,
	      s: 64,
	      n: 8,
	      i: 0,
	      p: [10, 27, 54, 79, 46, 122, 102, 115]
	    }, {
	      uid: 181,
	      t: "Digital Input",
	      c: 5,
	      n: 8,
	      i: 0,
	      p: [90]
	    }, {
	      uid: 182,
	      t: "Digital Output",
	      c: 6,
	      n: 8,
	      i: 0,
	      p: [82, 55]
	    }]
	  }, {
	    uid: 89,
	    d: 45,
	    c: 20,
	    t: "PhidgetTextLCD 20X2",
	    s: "1202/1203",
	    i: 125,
	    v: [200, 9999],
	    cn: [1],
	    n: 1,
	    ch: [{
	      uid: 183,
	      t: "Text LCD",
	      c: 11,
	      s: 81,
	      i: 0,
	      p: [43, 48, 52, 53, 47, 4, 19, 105]
	    }]
	  }, {
	    uid: 90,
	    d: 46,
	    c: 20,
	    t: "PhidgetTextLCD Adapter",
	    s: "1204",
	    i: 61,
	    v: [0, 9999],
	    cn: [2],
	    ch: [{
	      uid: 184,
	      t: "Text LCD",
	      c: 11,
	      s: 81,
	      n: 2,
	      i: 0,
	      p: [43, 48, 52, 53, 78, 47, 4, 19, 24, 105]
	    }]
	  }, {
	    uid: 91,
	    d: 47,
	    c: 20,
	    t: "PhidgetTextLCD 20X2",
	    s: "1215/1216/1217/1218",
	    i: 82,
	    v: [0, 9999],
	    cn: [1],
	    ch: [{
	      uid: 185,
	      t: "Text LCD",
	      c: 11,
	      s: 81,
	      i: 0,
	      p: [43, 48, 52, 53, 47, 4, 19, 105]
	    }]
	  }, {
	    uid: 92,
	    d: 48,
	    c: 20,
	    t: "PhidgetTextLCD 20X2 with InterfaceKit 0/8/8",
	    s: "1219/1220/1221/1222",
	    i: 83,
	    v: [0, 9999],
	    cn: [1, 8, 8],
	    ch: [{
	      uid: 186,
	      t: "Text LCD",
	      c: 11,
	      s: 81,
	      i: 0,
	      p: [43, 48, 52, 53, 47, 4, 19, 105]
	    }, {
	      uid: 187,
	      t: "Digital Input",
	      c: 5,
	      n: 8,
	      i: 0,
	      p: [90]
	    }, {
	      uid: 188,
	      t: "Digital Output",
	      c: 6,
	      n: 8,
	      i: 0,
	      p: [82, 55]
	    }]
	  }, {
	    uid: 163,
	    d: 140,
	    c: 17,
	    t: "PhidgetSpatial Precision 3/3/3",
	    s: "MOT0109",
	    i: 140,
	    v: [100, 200],
	    cn: [3, 3, 3, 1, 1],
	    ch: [{
	      uid: 331,
	      t: "3-Axis Accelerometer",
	      c: 1,
	      i: 0,
	      p: [10, 54, 46, 145, 170, 1]
	    }, {
	      uid: 332,
	      t: "3-Axis Gyroscope",
	      c: 12,
	      i: 0,
	      p: [10, 54, 145, 170, 106, 2]
	    }, {
	      uid: 333,
	      t: "3-Axis Magnetometer",
	      c: 18,
	      i: 0,
	      p: [10, 54, 46, 170, 50, 37, 35, 18]
	    }, {
	      uid: 334,
	      t: "Spatial",
	      c: 26,
	      s: 112,
	      i: 0,
	      p: [10, 54, 145, 149, 151, 170, 106, 50, 37, 35, 174, 150, 89, 148]
	    }, {
	      uid: 335,
	      t: "Temperature Sensor",
	      c: 28,
	      i: 0,
	      p: [10, 54, 46, 95]
	    }]
	  }, {
	    uid: 164,
	    d: 141,
	    c: 17,
	    t: "PhidgetSpatial Precision 3/3/3",
	    s: "MOT0110",
	    i: 141,
	    v: [100, 200],
	    cn: [3, 3, 3, 1, 1],
	    ch: [{
	      uid: 336,
	      t: "3-Axis Accelerometer",
	      c: 1,
	      i: 0,
	      p: [10, 54, 46, 170, 1]
	    }, {
	      uid: 337,
	      t: "3-Axis Gyroscope",
	      c: 12,
	      i: 0,
	      p: [10, 54, 170, 106, 2]
	    }, {
	      uid: 338,
	      t: "3-Axis Magnetometer",
	      c: 18,
	      i: 0,
	      p: [10, 54, 46, 170, 50, 37, 35, 18]
	    }, {
	      uid: 339,
	      t: "Spatial",
	      c: 26,
	      s: 112,
	      i: 0,
	      p: [10, 54, 149, 170, 106, 50, 37, 35, 174, 150, 89, 148]
	    }, {
	      uid: 340,
	      t: "Temperature Sensor",
	      c: 28,
	      i: 0,
	      p: [10, 54, 46, 95]
	    }]
	  }, {
	    uid: 205,
	    d: 64,
	    c: 8,
	    t: "6-Port USB VINT Hub Phidget",
	    s: "HUB0000",
	    i: 63,
	    v: [100, 200],
	    cn: [6, 4],
	    ch: [{
	      uid: 402,
	      t: "VINT Hub",
	      c: 13,
	      i: 0,
	      p: [60, 72, 73, 107]
	    }]
	  }, {
	    uid: 207,
	    d: 64,
	    c: 8,
	    t: "6-Port USB VINT Hub Phidget",
	    s: "HUB0000",
	    i: 63,
	    v: [300, 400],
	    cn: [6, 4],
	    ch: [{
	      uid: 403,
	      t: "VINT Hub",
	      c: 13,
	      i: 0,
	      p: [60, 72, 73, 107]
	    }]
	  }, {
	    uid: 208,
	    d: 64,
	    c: 8,
	    t: "6-Port USB VINT Hub Phidget",
	    s: "HUB0000",
	    i: 63,
	    v: [400, 500],
	    cn: [6, 4],
	    ch: [{
	      uid: 404,
	      t: "VINT Hub",
	      c: 13,
	      i: 0,
	      p: [60, 72, 73, 107]
	    }]
	  }, {
	    uid: 209,
	    d: 142,
	    c: 8,
	    t: "6-Port USB VINT Hub Phidget",
	    s: "HUB0001",
	    i: 67,
	    v: [100, 200],
	    cn: [6, 4],
	    ch: [{
	      uid: 405,
	      t: "VINT Hub",
	      c: 13,
	      i: 0,
	      p: [60, 72, 73, 107]
	    }]
	  }, {
	    uid: 217,
	    d: 123,
	    c: 8,
	    t: "6-Port Network VINT Hub Phidget",
	    s: "HUB5000",
	    i: 66,
	    v: [100, 200],
	    cn: [6, 4],
	    ch: [{
	      uid: 413,
	      t: "VINT Hub",
	      c: 13,
	      i: 0,
	      p: [60, 72, 73, 107]
	    }]
	  }, {
	    uid: 218,
	    d: 123,
	    c: 8,
	    t: "6-Port Network VINT Hub Phidget",
	    s: "HUB5000",
	    i: 66,
	    v: [200, 300],
	    cn: [6, 4],
	    ch: [{
	      uid: 414,
	      t: "VINT Hub",
	      c: 13,
	      i: 0,
	      p: [60, 72, 73, 107]
	    }]
	  }, {
	    uid: 219,
	    d: 101,
	    c: 23,
	    t: "USB Firmware Upgrade (NXP M3)",
	    s: "FIRMWARE_UPGRADE_M3",
	    i: 152,
	    v: [0, 9999],
	    cn: [0, 0, 0],
	    ch: [{
	      uid: 415,
	      t: "Firmware Upgrade",
	      c: 32,
	      i: 0,
	      p: [112, 113]
	    }]
	  }, {
	    uid: 220,
	    d: 101,
	    c: 23,
	    t: "USB Firmware Upgrade (STM32)",
	    s: "FIRMWARE_UPGRADE_STM32_USB",
	    i: 156,
	    v: [100, 200],
	    cn: [0, 0, 0],
	    ch: [{
	      uid: 416,
	      t: "Firmware Upgrade",
	      c: 32,
	      i: 0,
	      p: [112, 113]
	    }]
	  }, {
	    uid: 221,
	    d: 101,
	    c: 23,
	    t: "USB Firmware Upgrade (STM32G)",
	    s: "FIRMWARE_UPGRADE_STM32G_USB",
	    i: 156,
	    v: [200, 300],
	    cn: [0, 0, 0],
	    ch: [{
	      uid: 417,
	      t: "Firmware Upgrade",
	      c: 32,
	      i: 0,
	      p: [112, 113]
	    }]
	  }, {
	    uid: 222,
	    d: 101,
	    c: 23,
	    t: "USB Firmware Upgrade (STM32L)",
	    s: "FIRMWARE_UPGRADE_STM32L_USB",
	    i: 156,
	    v: [300, 400],
	    cn: [0, 0, 0],
	    ch: [{
	      uid: 418,
	      t: "Firmware Upgrade",
	      c: 32,
	      i: 0,
	      p: [112, 113]
	    }]
	  }, {
	    uid: 233,
	    d: 125,
	    c: 22,
	    t: "Unsupported USB Phidget",
	    s: " ",
	    i: 175,
	    v: [0, 9999],
	    cn: [0, 0, 0],
	    ch: [{
	      uid: 436,
	      t: "Unsupported USB Channel",
	      c: 33,
	      i: 0,
	      p: [39, 152, 153, 154, 155, 28]
	    }]
	  }],
	  MESH: [],
	  SPI: [{
	    uid: 214,
	    d: 67,
	    c: 8,
	    t: "6-Port PhidgetSBC VINT Hub Phidget",
	    s: "HUB0004",
	    i: 1,
	    v: [100, 200],
	    cn: [6, 4],
	    ch: [{
	      uid: 410,
	      t: "VINT Hub",
	      c: 13,
	      i: 0,
	      p: [60, 72, 73, 107]
	    }]
	  }, {
	    uid: 215,
	    d: 67,
	    c: 8,
	    t: "6-Port PhidgetSBC VINT Hub Phidget",
	    s: "HUB0004",
	    i: 1,
	    v: [200, 300],
	    cn: [6, 4],
	    ch: [{
	      uid: 411,
	      t: "VINT Hub",
	      c: 13,
	      i: 0,
	      p: [60, 72, 73, 107]
	    }]
	  }, {
	    uid: 227,
	    d: 104,
	    c: 23,
	    t: "SPI Firmware Upgrade (M3)",
	    s: "FIRMWARE_UPGRADE_M3",
	    i: 2,
	    v: [0, 9999],
	    cn: [0],
	    ch: [{
	      uid: 423,
	      t: "Firmware Upgrade",
	      c: 32,
	      i: 0,
	      p: [112, 113]
	    }]
	  }, {
	    uid: 235,
	    d: 125,
	    c: 22,
	    t: "Unsupported SPI Phidget",
	    s: " ",
	    i: 65535,
	    v: [0, 9999],
	    cn: [0, 0, 0],
	    ch: [{
	      uid: 438,
	      t: "Unsupported SPI Channel",
	      c: 33,
	      i: 0,
	      p: [39, 152, 153, 154, 155, 28]
	    }]
	  }],
	  LIGHTNING: [],
	  VIRTUAL: [{
	    uid: 232,
	    d: 111,
	    c: 24,
	    t: "Dictionary",
	    s: "Dictionary",
	    i: 0,
	    v: [100, 200],
	    ch: [{
	      uid: 435,
	      t: "Dictionary",
	      c: 36,
	      i: 0,
	      p: [123, 125, 130, 127, 131, 129, 132, 124, 126, 128]
	    }]
	  }]
	};

	function findPhidgetUniqueDevice(data) {
	  var _a;

	  const typeDevs = PhidgetDevices[data.type];

	  for (const d of typeDevs) {
	    if (d.v[0] > data.version || d.v[1] <= data.version) continue;

	    if (data.type === 'VINT') {
	      if (d.i !== data.vintID) continue;
	    } else {
	      if (d.i !== data.productID) continue;
	      if (data.type === 'USB' && ((_a = d.n) !== null && _a !== void 0 ? _a : 0) !== data.interfaceNum) continue;
	    }

	    return d;
	  }

	  throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Couldn't find device in device list!!");
	}
	/** @internal */

	class Device {
	  constructor(conn, data) {
	    this.conn = conn;
	    this.devDef = data.devDef;
	    this.version = data.version;
	    this.label = data.label;
	    this.serialNumber = data.serialNumber;
	    this.fwstr = data.fwstr;
	    this.id = data.id;
	    this.parent = data.parent;
	    if (data.type === 'VINT') this.vintDeviceProps = data.vintDeviceProps;
	    if (data.type === 'HUB') this.hubPortProps = data.hubPortProps;
	  }

	  get parentId() {
	    var _a, _b;

	    return (_b = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : '0';
	  }

	  get vintID() {
	    return this.devDef.i;
	  }

	  get sku() {
	    return this.devDef.s;
	  }

	  get class() {
	    return this.devDef.c;
	  }

	  get hubPort() {
	    var _a, _b;

	    return (_b = (_a = this.vintDeviceProps) === null || _a === void 0 ? void 0 : _a.hubPort) !== null && _b !== void 0 ? _b : 0;
	  }

	  get isHubPort() {
	    var _a, _b;

	    return (_b = (_a = this.vintDeviceProps) === null || _a === void 0 ? void 0 : _a.isHubPort) !== null && _b !== void 0 ? _b : false;
	  }

	  get index() {
	    var _a, _b;

	    return (_b = (_a = this.vintDeviceProps) === null || _a === void 0 ? void 0 : _a.uniqueIndex) !== null && _b !== void 0 ? _b : 0;
	  }

	  toString() {
	    if (this.class === exports.DeviceClass.VINT) {
	      return this.sku + ' (' + this.name + ') v' + this.version + ' -> ' + this.parent.sku + ' Port:' + this.hubPort + ' Serial#:' + this.serialNumber + (this.conn._isRemote ? " NET" : " USB");
	    }

	    return this.sku + ' (' + this.name + ') v' + this.version + ' Serial#:' + this.serialNumber + (this.conn._isRemote ? " NET" : " USB");
	  }

	}

	/** @internal */

	class NetworkDevice extends Device {
	  constructor(conn, data) {
	    super(conn, data);
	    this.deviceID = data.deviceID;
	    this.name = data.name;
	  }

	  findPhidgetUniqueChannel(uniqueIndex) {
	    var _a, _b;

	    let index = 0;

	    for (const c of this.devDef.ch) {
	      if (uniqueIndex < index + ((_a = c.n) !== null && _a !== void 0 ? _a : 1)) return c;
	      index += (_b = c.n) !== null && _b !== void 0 ? _b : 1;
	    }

	    throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Couldn't find channel in channel list!!");
	  }

	}

	const NET_MAJOR = 2;
	const NET_MINOR = 3;
	const NET_IDENT = "phidgetclient";
	class NetworkConnectionBase extends PhidgetConnection {
	  constructor(optsOrUriOrPort, optsOrHostname, opts) {
	    let options = {};
	    let uri = '';
	    let hostname = '';
	    let port = 0;

	    if (optsOrUriOrPort != undefined && typeof optsOrUriOrPort === 'object') {
	      options = optsOrUriOrPort;
	    } else if (optsOrUriOrPort != undefined && typeof optsOrUriOrPort === 'string') {
	      uri = optsOrUriOrPort;
	      if (optsOrHostname != undefined && typeof optsOrHostname === 'object') options = optsOrHostname;
	    } else if (optsOrUriOrPort != undefined && typeof optsOrUriOrPort === 'number') {
	      port = optsOrUriOrPort;

	      if (optsOrHostname != undefined && typeof optsOrHostname === 'string') {
	        hostname = optsOrHostname;
	        if (opts != undefined && typeof opts === 'object') options = opts;
	      }
	    }

	    if (!options.name) options.name = uri;
	    super(options);
	    this._type = 1;
	    this._generation = 0;
	    this._timeout = 8000;
	    this._reqseq = 10;
	    this._requests = new Map();
	    this._uri = uri;

	    if (options.hostname && hostname === '') {
	      if (typeof options.hostname === 'string') hostname = options.hostname;
	    }

	    if (hostname === '') hostname = 'localhost';
	    this._hostname = hostname;

	    if (options.port && port === 0) {
	      if (typeof options.port === 'number') port = options.port;
	      if (typeof options.port === 'string') port = Number(options.port);
	    }

	    this._port = port;
	    if (options.onConnect && typeof options.onConnect === 'function') this.onConnect = options.onConnect;else this.onConnect = null;
	    if (options.onDisconnect && typeof options.onDisconnect === 'function') this.onDisconnect = options.onDisconnect;else this.onDisconnect = null;
	    if (options.onAuthenticationNeeded && typeof options.onAuthenticationNeeded === 'function') this.onAuthenticationNeeded = options.onAuthenticationNeeded;else this.onAuthenticationNeeded = null;
	    if (options.passwd) this._passwd = options.passwd;else this._passwd = '';
	    this._handleAbandonedRequestsInterval = setInterval(this._handleAbandonedRequests.bind(this), 2000);
	  }

	  delete() {
	    if (this._handleAbandonedRequestsInterval != undefined) {
	      clearInterval(this._handleAbandonedRequestsInterval);
	      delete this._handleAbandonedRequestsInterval;
	    }

	    super.delete();
	  }

	  setKeepAlive(timeout) {
	    if (typeof timeout !== 'number' || isNaN(timeout)) throw 'invalid keep alive:' + timeout;
	    this._timeout = timeout;
	  }

	  close() {
	    logdebug("Network Connection close() called");
	    if (this._connectionMaintainer != undefined) clearTimeout(this._connectionMaintainer);
	    delete this._connectionMaintainer;

	    this._detachAllDevices();

	    this._closesocket();
	  }
	  /** @internal */


	  _onmessage(msg, req) {
	    let json;

	    if (msg !== undefined) {
	      const tmp1 = msg.replace(/("[OI]"|"phid"|"chid"|"parent"):([0-9]+)/g, "$1:\"$2\"");
	      const tmp2 = tmp1.replace(/([:[,])[-+]?nan(\([\w]*\))?/ig, "$1\"**NAN**\"");

	      if (tmp1 !== tmp2) {
	        json = JSON.parse(tmp2, (key, value) => {
	          if (key == 'v') {
	            if (value === "**NAN**") return NaN;
	            if (Array.isArray(value)) return value.map(val => {
	              if (val === "**NAN**") return NaN;
	              return val;
	            });
	          }

	          return value;
	        });
	      } else {
	        json = JSON.parse(tmp2);
	      }
	    }

	    try {
	      if (this.connected) this._ondatamessage(json, req);else this._onauthmessage(json);
	    } catch (err) {
	      if (this.onError && err instanceof PhidgetError) {
	        try {
	          this.onError(err.errorCode, err.message);
	        } catch (err) {
	          logEventException(err);
	        }

	        loginfo("Error handling message from server", err);
	      } else {
	        logerr("Error handling message from server", err);
	      }
	    }
	  }
	  /** @internal */


	  _handleAbandonedRequests() {
	    for (const r of this._requests.entries()) {
	      if (r[1].generation != this._generation) {
	        r[1].onError(exports.ErrorCode.CONNECTION_RESET, "Connection Reset");

	        this._requests.delete(r[0]);

	        continue;
	      }

	      if (tm() - r[1].time > 5000) {
	        r[1].onTimeout();

	        this._requests.delete(r[0]);
	      }
	    }
	  }
	  /** @internal */


	  _getNextRequestSequence() {
	    if (this._reqseq >= 65535) this._reqseq = 10;
	    this._reqseq++;
	    return this._reqseq;
	  }
	  /** @internal */


	  _sendRequest(flags, reqseq, repseq, type, stype, data) {
	    if (reqseq === 0) reqseq = this._getNextRequestSequence();
	    return new promise((resolve, reject) => {
	      this._requests.set(reqseq, {
	        generation: this._generation,
	        time: tm(),
	        onReply: function (res) {
	          if ('E' in res) {
	            if (res.E !== exports.ErrorCode.SUCCESS) {
	              if (res.R != undefined) reject(new PhidgetError(res.E, res.R));
	              reject(new PhidgetError(res.E));
	            } else {
	              if (res.R != undefined) resolve(res.R);
	              resolve();
	            }
	          } else {
	            resolve(res);
	          }
	        },
	        onTimeout: function () {
	          reject(new PhidgetError(exports.ErrorCode.TIMEOUT));
	        },
	        onError: function (code, msg) {
	          reject(new PhidgetError(code, msg));
	        }
	      });

	      const json = JSON.stringify(data);
	      const data2 = json.replace(/("[OI]"|"phid"|"channel"):"([0-9]+)"/g, "$1:$2");
	      const req = new Request(data2.length, flags, reqseq, repseq, type, stype);

	      this._send(req, data2);
	    });
	  }
	  /** @internal */


	  _sendReply(repseq, type, stype, reply) {
	    const NRF_REPLY = 0x0002;

	    const reqseq = this._getNextRequestSequence();

	    let data = '';
	    if (reply != undefined) data = JSON.stringify(reply);
	    const req = new Request(data.length, NRF_REPLY, reqseq, repseq, type, stype);

	    this._send(req, data);
	  }
	  /** @internal */


	  _maintainConnection() {
	    logdebug("Maintaining network connection..");

	    const nextMaintainer = () => {
	      if (!this._connectionMaintainer) {
	        logdebug(".. Check again in 4 seconds.");
	        this._connectionMaintainer = setTimeout(this._maintainConnection.bind(this), 4000);
	      }
	    };

	    if (this._connectionMaintainer) delete this._connectionMaintainer;

	    if (this.connected) {
	      logdebug(".. already connected ..");
	      nextMaintainer();
	    } else {
	      logdebug(".. trying to connect ..");
	      this.connect().then(() => {
	        logdebug(".. connected!");
	        nextMaintainer();
	      }).catch(err => {
	        if (this.onError && err instanceof PhidgetError) {
	          try {
	            this.onError(err.errorCode, err.message);
	          } catch (err) {
	            logEventException(err);
	          }
	        }

	        logerr("Error connecting", err);
	        logdebug(".. failed to connect! ..");
	        nextMaintainer();
	      });
	    }
	  }
	  /** @internal */


	  _doclose() {
	    this._detachAllDevices();

	    this._closesocket();
	  }
	  /** @internal */


	  _onauthmessage(data) {
	    if (this._onauthdata == undefined) throw new Error('packet recieved while not connected and authdata is not defined');

	    this._onauthdata(data);
	  }
	  /** @internal */


	  _ondatamessage(data, req) {
	    const request = this._requests.get(req.repseq);

	    if (request) {
	      this._requests.delete(req.repseq);

	      request.onReply(data);
	    }

	    if (req.flgs & 2) {
	      if (request === undefined) throw new PhidgetError(exports.ErrorCode.UNEXPECTED, 'No handler registered for reply: ' + req);
	      return;
	    }

	    switch (req.type) {
	      case 20:
	        this._handleCommand(req);

	        break;

	      case 30:
	        this._handleDevice(req, data);

	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID, 'Unknown request type:' + req.type);
	    }
	  }
	  /** @internal */


	  _handleCommand(req) {
	    switch (req.stype) {
	      case 41:
	        logdebug("Got a keepalive message");

	        if (this._keepAliveTimeout != undefined) {
	          logdebug("Cleaning previous keepalive timeout");
	          clearTimeout(this._keepAliveTimeout);
	        }

	        this._keepAliveTimeout = setTimeout(() => {
	          logdebug("Keepalive timeout passed");
	          delete this._keepAliveTimeout;

	          if (this.connected) {
	            if (this.onError) {
	              try {
	                this.onError(exports.ErrorCode.KEEP_ALIVE, "KeepAlive timeout. Closing connection to server.");
	              } catch (err) {
	                logEventException(err);
	              }
	            }

	            logerr("KeepAlive timeout. Closing connection to server.");

	            this._doclose();
	          }
	        }, this._timeout);

	        this._sendReply(req.reqseq, 20, 41);

	        return;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNEXPECTED, 'Unknown command subrequest:' + req.stype);
	    }
	  }
	  /** @internal */


	  _handleDevice(req, data) {
	    switch (req.stype) {
	      case 50:
	        this._handleDeviceAttach(data);

	        return;

	      case 55:
	        this._handleDeviceDetach(data);

	        return;

	      case 70:
	        this._handleBridgePacket(req, data);

	        return;

	      case 80:
	        this._handleChannel(data);

	        return;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNEXPECTED, 'Unknown device subrequest:' + req.stype);
	    }
	  }
	  /** @internal */


	  _handleDeviceAttach(data) {
	    var _a, _b, _c, _d, _e;

	    const devDef = findPhidgetUniqueDevice(data);
	    let devData;
	    const baseData = {
	      version: data.version,
	      label: data.label,
	      serialNumber: data.serialNumber,
	      devDef: devDef,
	      fwstr: (_a = data.fwstr) !== null && _a !== void 0 ? _a : devDef.s,
	      id: data.phid,
	      parent: (_b = this._getDevice(data.parent)) !== null && _b !== void 0 ? _b : undefined,
	      deviceID: data.deviceID,
	      name: data.name
	    };

	    if (data.type === 'VINT') {
	      devData = Object.assign(Object.assign({}, baseData), {
	        type: 'VINT',
	        vintDeviceProps: {
	          vintProto: (_c = data.vintProto) !== null && _c !== void 0 ? _c : 1,
	          suppSetSpeed: data.suppSetSpeed ? !!data.suppSetSpeed : false,
	          maxSpeed: (_d = data.maxSpeed) !== null && _d !== void 0 ? _d : 4294967295,
	          commSpeed: (_e = data.commSpeed) !== null && _e !== void 0 ? _e : 4294967295,
	          hubPort: data.hubPort,
	          isHubPort: !!data.isHubPort,
	          uniqueIndex: data.index
	        }
	      });
	    } else if (devDef.c === exports.DeviceClass.HUB) {
	      let hubPortCnt;
	      if (data.hubPortsInfo) hubPortCnt = data.hubPortsInfo.portProto.length;else hubPortCnt = devDef.cn ? devDef.cn[0] : 6;
	      const hubPortProps = [];

	      for (let i = 0; i < hubPortCnt; i++) {
	        if (data.hubPortsInfo) {
	          hubPortProps.push({
	            portProto: data.hubPortsInfo.portProto[i],
	            portSuppSetSpeed: !!data.hubPortsInfo.portSuppSetSpeed[i],
	            portMaxSpeed: data.hubPortsInfo.portMaxSpeed[i]
	          });
	        } else {
	          hubPortProps.push({
	            portProto: 1,
	            portSuppSetSpeed: false,
	            portMaxSpeed: 100000
	          });
	        }
	      }

	      devData = Object.assign(Object.assign({}, baseData), {
	        type: 'HUB',
	        hubPortProps: hubPortProps
	      });
	    } else {
	      devData = Object.assign(Object.assign({}, baseData), {
	        type: 'OTHER'
	      });
	    }

	    const dev = new NetworkDevice(this, devData);

	    this._deviceAttach(dev);
	  }
	  /** @internal */


	  _handleDeviceDetach(data) {
	    const dev = this._getDevice(data.phid);

	    if (dev) this._deviceDetach(dev);
	  }
	  /** @internal */


	  _handleChannel(data) {
	    const dev = this._devices.get(data.parent);

	    if (!dev) throw new PhidgetError(exports.ErrorCode.UNEXPECTED, 'missing channel parent');
	    const chDef = dev.findPhidgetUniqueChannel(data.uniqueIndex);
	    const chData = {
	      id: data.chid,
	      chDef: chDef,
	      uniqueIndex: data.uniqueIndex,
	      index: data.index,
	      cpversion: data.version,
	      name: data.name,
	      class: data.class
	    };
	    const ch = new NetworkChannel(this, dev, chData);

	    this._channelAttach(ch);
	  }
	  /** @internal */


	  _handleBridgePacket(req, data) {
	    const bp = new BridgePacket(this, data);
	    let reply;

	    try {
	      bp.deliver();
	    } catch (err) {
	      if (err instanceof PhidgetError) {
	        reply = {
	          E: err.errorCode,
	          R: err.message
	        };
	      } else {
	        reply = {
	          E: exports.ErrorCode.UNEXPECTED,
	          R: '' + err
	        };
	      }
	    }

	    if (!bp.isEvent()) this._sendReply(req.reqseq, req.type, req.stype, reply);
	  }
	  /** @internal */


	  _handshake() {
	    return new promise((resolve, reject) => {
	      const pkt = {
	        type: this._protocol,
	        pmajor: NET_MAJOR,
	        pminor: NET_MINOR
	      };
	      const json = JSON.stringify(pkt);
	      const req = new Request(json.length, 0, 0, 0, 10, 10);

	      this._send(req, json);

	      this._onauthdata = HandShakeS0;

	      function HandShakeS0(data) {
	        if (data.result !== exports.ErrorCode.SUCCESS) {
	          reject(new PhidgetError(data.result, 'server rejected handshake'));
	          return;
	        }

	        this._nonceC = this._createSalt(16);
	        const pkt = {
	          ident: NET_IDENT,
	          nonceC: this._nonceC
	        };
	        const json = JSON.stringify(pkt);
	        const req = new Request(json.length, 0, 0, 0, 10, 30);

	        try {
	          this._send(req, json);
	        } catch (err) {
	          reject(err);
	          return;
	        }

	        this._onauthdata = AuthS0;
	      }

	      function AuthS0(data) {
	        if (data.result !== exports.ErrorCode.SUCCESS) {
	          reject(new PhidgetError(data.result, 'authentication failed'));
	          return;
	        }

	        if (this._nonceC != data.nonceC) {
	          reject(new PhidgetError(exports.ErrorCode.UNEXPECTED, 'Authentication Failure: nonce do not match (' + this._nonceC + ') vs (' + data.nonceC + ')'));
	          return;
	        }

	        const challenge = NET_IDENT + this._passwd + this._nonceC + data.nonceS + data.salt;

	        const proof = this._hash(challenge);

	        const pkt = {
	          nonceC: this._nonceC,
	          nonceS: data.nonceS,
	          proof: proof
	        };
	        const json = JSON.stringify(pkt);
	        const req = new Request(json.length, 0, 0, 0, 10, 32);

	        try {
	          this._send(req, json);
	        } catch (err) {
	          reject(err);
	          return;
	        }

	        this._onauthdata = AuthReply;
	      }

	      function AuthReply(data) {
	        delete this._onauthdata;

	        if (data.E != exports.ErrorCode.SUCCESS) {
	          if (this.onAuthenticationNeeded) {
	            let pass;

	            try {
	              pass = this.onAuthenticationNeeded();
	            } catch (err) {
	              logEventException(err);
	            }

	            if (pass != undefined && typeof pass === 'string') {
	              this._passwd = pass;
	              setTimeout(() => {
	                this.connect().then(() => resolve()).catch(err => reject(err));
	              });
	              return;
	            }
	          } else {
	            logwarn("A password is required for this server. Handle the onAuthenticationNeeded event to return a password.");
	          }

	          reject(new PhidgetError(data.E, 'authentication failed: server rejected proof'));
	          return;
	        }

	        this.connected = true;

	        if (this.onConnect) {
	          try {
	            this.onConnect();
	          } catch (err) {
	            logEventException(err);
	          }
	        }

	        if (this._connectionMaintainer != undefined) clearTimeout(this._connectionMaintainer);
	        delete this._connectionMaintainer;

	        this._maintainConnection();

	        resolve();
	      }
	    });
	  }

	}
	function DecodeUTF8(bytes) {
	  let s = '';
	  let i = 0;

	  while (i < bytes.length) {
	    let c = bytes[i++];

	    if (c > 127) {
	      if (c > 191 && c < 224) {
	        if (i >= bytes.length) throw 'UTF-8 decode: incomplete 2-byte sequence';
	        c = (c & 31) << 6 | bytes[i] & 63;
	      } else if (c > 223 && c < 240) {
	        if (i + 1 >= bytes.length) throw 'UTF-8 decode: incomplete 3-byte sequence';
	        c = (c & 15) << 12 | (bytes[i] & 63) << 6 | bytes[++i] & 63;
	      } else if (c > 239 && c < 248) {
	        if (i + 2 >= bytes.length) throw 'UTF-8 decode: incomplete 4-byte sequence';
	        c = (c & 7) << 18 | (bytes[i] & 63) << 12 | (bytes[++i] & 63) << 6 | bytes[++i] & 63;
	      } else throw 'UTF-8 decode: unknown multibyte start 0x' + c.toString(16) + ' at index ' + (i - 1);

	      ++i;
	    }

	    if (c <= 0xffff) s += String.fromCharCode(c);else if (c <= 0x10ffff) {
	      c -= 0x10000;
	      s += String.fromCharCode(c >> 10 | 0xd800);
	      s += String.fromCharCode(c & 0x3FF | 0xdc00);
	    } else throw 'UTF-8 decode: code point 0x' + c.toString(16) + ' exceeds UTF-16 reach';
	  }

	  return s;
	}
	function EncodeUTF8(s) {
	  let i = 0;
	  const bytes = new Uint8Array(s.length * 4);

	  for (let ci = 0; ci != s.length; ci++) {
	    let c = s.charCodeAt(ci);

	    if (c < 128) {
	      bytes[i++] = c;
	      continue;
	    }

	    if (c < 2048) {
	      bytes[i++] = c >> 6 | 192;
	    } else {
	      if (c > 0xd7ff && c < 0xdc00) {
	        if (++ci == s.length) throw 'UTF-8 encode: incomplete surrogate pair';
	        const c2 = s.charCodeAt(ci);
	        if (c2 < 0xdc00 || c2 > 0xdfff) throw 'UTF-8 encode: second char code 0x' + c2.toString(16) + ' at index ' + ci + ' in surrogate pair out of range';
	        c = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
	        bytes[i++] = c >> 18 | 240;
	        bytes[i++] = c >> 12 & 63 | 128;
	      } else {
	        bytes[i++] = c >> 12 | 224;
	      }

	      bytes[i++] = c >> 6 & 63 | 128;
	    }

	    bytes[i++] = c & 63 | 128;
	  }

	  return bytes.subarray(0, i);
	}

	/**
	 * @public
	 */

	class NetworkConnection extends NetworkConnectionBase {
	  constructor(optsOrUriOrPort, optsOrHostname, opts) {
	    super(optsOrUriOrPort, optsOrHostname, opts);
	    if (this._port === 0) this._port = 8989;
	    if (this._uri === '') this._uri = 'ws://' + this._hostname + ':' + this._port + '/phidgets';
	    this._protocol = "www";
	  }
	  /**
	   * Connects to the server. Once the initial connection has succeeded,
	   * it will be maintained until close is called.
	   *
	   * It retryOnFail is true, the initial connect will retry on failure until a connection is established,
	   * and connect() will not resolve until the connection is established.
	   * Thisis allows connect to be called before the network server is running.
	   *
	   * If retryOnFail is false (the default), connect() will throw an exception
	   * if the connection can not be established.
	   *
	   * @param retryOnFail - Keep trying to connect if the initial attempt fails. Defaults to false.
	   */


	  connect() {
	    let retryOnFail = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	    return new promise((resolve, reject) => {
	      if (this.connected === true) {
	        resolve();
	        return;
	      }

	      if (retryOnFail) {
	        this._resolveConnect = resolve;

	        this._maintainConnection();

	        return;
	      }

	      if (this._ws) {
	        try {
	          this._ws.close();
	        } catch (e) {}

	        delete this._ws;
	      }

	      try {
	        let hasConnected = false;
	        this._ws = new WebSocket(this._uri);
	        this._ws.binaryType = 'arraybuffer';

	        this._ws.onopen = () => {
	          hasConnected = true;

	          this._handshake().then(() => {
	            if (this._resolveConnect) {
	              this._resolveConnect();

	              delete this._resolveConnect;
	            }

	            if (this._connectTimeout !== undefined) {
	              clearTimeout(this._connectTimeout);
	              delete this._connectTimeout;
	            }

	            resolve();
	          }).catch(err => {
	            if (this._connectTimeout !== undefined) {
	              clearTimeout(this._connectTimeout);
	              delete this._connectTimeout;
	            }

	            reject(err);
	          });
	        };

	        this._ws.onclose = () => {
	          this._doclose();
	        };

	        this._ws.onmessage = event => {
	          const array = new Uint8Array(event.data);
	          const req = new Request(array);
	          let msg;

	          if (req.len > 0) {
	            const tmp1 = new Uint8Array(event.data, req.hdrlen, req.len);
	            msg = DecodeUTF8(tmp1);
	          }

	          this._onmessage(msg, req);
	        };

	        this._ws.onerror = () => {
	          const msg = "websocket error - check that server is available";

	          this._doclose();

	          if (!hasConnected) {
	            reject(new PhidgetError(exports.ErrorCode.CONNECTION_REFUSED, msg));
	            return;
	          }

	          if (this.onError) {
	            try {
	              this.onError(exports.ErrorCode.CONNECTION_REFUSED, msg);
	            } catch (err) {
	              logEventException(err);
	            }

	            loginfo(msg);
	          } else {
	            logerr(msg);
	          }
	        };

	        this._connectTimeout = setTimeout(() => {
	          delete this._connectTimeout;

	          this._doclose();

	          reject(new PhidgetError(exports.ErrorCode.TIMEOUT, "Connection Timed Out"));
	        }, this._timeout);
	      } catch (err) {
	        if (this._connectTimeout !== undefined) {
	          clearTimeout(this._connectTimeout);
	          delete this._connectTimeout;
	        }

	        reject(new PhidgetError(exports.ErrorCode.UNEXPECTED, 'Error in connect', err));
	      }
	    });
	  }
	  /** @internal */


	  _closesocket() {
	    if (this.connected === true) {
	      if (this.onDisconnect) {
	        try {
	          this.onDisconnect();
	        } catch (err) {
	          logEventException(err);
	        }
	      }
	    }

	    this.connected = false;

	    if (this._connectTimeout !== undefined) {
	      clearTimeout(this._connectTimeout);
	      delete this._connectTimeout;
	    }

	    if (this._ws != undefined) {
	      try {
	        this._ws.onopen = null;
	        this._ws.onclose = null;
	        this._ws.onmessage = null;
	        this._ws.onerror = null;

	        this._ws.close();
	      } catch (_a) {}

	      delete this._ws;
	    }

	    this._generation++;
	  }
	  /** @internal */


	  _send(req, data) {
	    try {
	      if (!this._ws || this._ws.readyState != WebSocket.OPEN) throw new PhidgetError(exports.ErrorCode.UNEXPECTED, 'invalid websocket state');

	      if (data.length > 0) {
	        const dataArr = EncodeUTF8(data);
	        req.len = dataArr.length;

	        this._ws.send(req.buffer);

	        this._ws.send(dataArr);
	      } else {
	        this._ws.send(req.buffer);
	      }
	    } catch (e) {
	      let msg;
	      if (typeof e === 'string') msg = e;else if (e instanceof Error) msg = e.message;else msg = 'Error in connect';
	      throw new PhidgetError(exports.ErrorCode.UNEXPECTED, msg);
	    }
	  }
	  /** @internal */


	  _hash(challenge) {
	    const digest = sha256hash(challenge);
	    let bin = '';

	    for (let i = 0; i < digest.length; i += 2) {
	      const b = parseInt(digest.substring(i, i + 2), 16);
	      bin += String.fromCharCode(b);
	    }

	    return btoa(bin);
	  }
	  /** @internal */


	  _createSalt(len) {
	    const buf = new Uint8Array(len);
	    crypto.getRandomValues(buf);
	    return btoa(String.fromCharCode(...buf)).substring(len);
	  }

	}

	function GetBigInt64(view, offset) {
	  if ("getBigInt64" in DataView.prototype) {
	    return Number(view.getBigInt64(offset));
	  } else {
	    const isNegative = (view.getUint8(offset) & 0x80) > 0;
	    let uint64 = 0;
	    let carrying = true;

	    for (let i = 0; i < 2; i++) {
	      let uint32 = view.getUint32(offset + (4 - i * 4));

	      if (isNegative) {
	        if (carrying) {
	          if (uint32 !== 0x00000000) {
	            uint32 = ~(uint32 - 1) & 0xFFFFFFFF;
	            carrying = false;
	          }
	        } else {
	          uint32 = ~uint32 & 0xFFFFFFFF;
	        }
	      }

	      uint64 += uint32 * 2 ** (8 * i);
	    }

	    return isNegative ? -uint64 : uint64;
	  }
	}
	function SetBigInt64(view, offset, value) {
	  const temp = value >> 2;
	  view.setInt32(offset, temp >> 30);
	  view.setUint32(offset + 4, value & 0xFFFFFFFF);
	}
	function StringToWordByteArray(buff) {
	  const wordarray = new Uint16Array(buff.length);
	  let i = 0;

	  for (i = 0; i < buff.length; i++) {
	    wordarray[i] = buff.charCodeAt(i);
	  }

	  return wordarray;
	}
	function WordByteArrayToString(bytearray) {
	  return String.fromCharCode(...bytearray);
	}
	function RoundDouble(num, decimals) {
	  return Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals);
	}
	function UpperPowerOfTwo(v) {
	  v--;
	  v |= v >> 1;
	  v |= v >> 2;
	  v |= v >> 4;
	  v |= v >> 8;
	  v |= v >> 16;
	  v++;
	  return v;
	}
	const PhidgetSleep = delay => new promise(resolve => setTimeout(resolve, delay));

	/** @internal */

	const USBVID_PHIDGETS = 0x06C2;
	const USBPID_PHIDGETS_MIN = 0x0030;
	const USBPID_PHIDGETS_MAX = 0x00AF;
	const USBD_PHIDGET_PROTO_VERSION = 0x0110;
	const USB_CONFIGURATION_DESCRIPTOR = 9;
	const USB_COMMON_DESCRIPTOR = 2;

	async function GetPhidgetDeviceParams(usbDevice) {
	  let endpointDesc = null;
	  let phidgetDeviceDesc = null;
	  let phidgetEndpointDesc = null;
	  const params = {
	    maxPacketEP0: 0,
	    ep1type: 0,
	    maxPacketEP1: 0,
	    ep2type: 0,
	    maxPacketEP2: 0,
	    wMaxPacketSizeEP1: 0,
	    labelIndex: 0,
	    skuIndex: 0
	  };
	  let descEnd = null;
	  const configDescData = await GetConfigDescriptor(usbDevice, 0);
	  const configDesc = {
	    bLength: configDescData.getUint8(0),
	    bDescriptorType: configDescData.getUint8(1),
	    wTotalLength: configDescData.getUint8(3) << 8 | configDescData.getUint8(2),
	    bNumInterfaces: configDescData.getUint8(4),
	    bConfigurationValue: configDescData.getUint8(5),
	    iConfiguration: configDescData.getUint8(6),
	    bmAttributes: configDescData.getUint8(7),
	    MaxPower: configDescData.getUint8(8)
	  };
	  descEnd = 0 + configDesc.wTotalLength;
	  params.ep1type = 0;
	  params.maxPacketEP1 = 0;
	  params.ep2type = 0;
	  params.maxPacketEP2 = 0;
	  let i = 0;

	  while (i + 2 < descEnd && i + configDescData.getUint8(i) <= descEnd) {
	    switch (configDescData.getUint8(i + 1)) {
	      case 2:
	        if (configDescData.getUint8(i) !== 9) throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Error parsing config descriptor!");
	        break;

	      case 4:
	        break;

	      case 5:
	        if (configDescData.getUint8(i) !== 7) throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Error parsing config descriptor!");
	        endpointDesc = {
	          bLength: configDescData.getUint8(i),
	          bDescriptorType: configDescData.getUint8(i + 1),
	          bEndpointAddress: configDescData.getUint8(i + 2),
	          bmAttributes: configDescData.getUint8(i + 3),
	          wMaxPacketSize: configDescData.getUint8(i + 5) << 8 | configDescData.getUint8(i + 4),
	          bInterval: configDescData.getUint8(i + 6)
	        };

	        if (endpointDesc.bEndpointAddress === 0x81) {
	          params.wMaxPacketSizeEP1 = endpointDesc.wMaxPacketSize;
	          if (endpointDesc.bmAttributes === 2) params.ep1type = 1;
	          if (endpointDesc.bmAttributes === 3) params.ep1type = 2;
	        }

	        if (endpointDesc.bEndpointAddress === 0x02) {
	          params.maxPacketEP2 = endpointDesc.wMaxPacketSize;
	          params.ep2type = 1;
	        }

	        break;

	      case 64:
	        if (configDescData.getUint8(i) !== 8) throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Error parsing config descriptor!");
	        phidgetDeviceDesc = {
	          bLength: configDescData.getUint8(i),
	          bDescriptorType: configDescData.getUint8(i + 1),
	          bcdVersion: configDescData.getUint8(i + 3) << 8 | configDescData.getUint8(i + 2),
	          iLabel: configDescData.getUint8(i + 4),
	          iSKU: configDescData.getUint8(i + 5),
	          wMaxPacketSize: configDescData.getUint8(i + 7) << 8 | configDescData.getUint8(i + 6)
	        };

	        if (phidgetDeviceDesc.bcdVersion !== USBD_PHIDGET_PROTO_VERSION) {
	          throw new PhidgetError(exports.ErrorCode.UNSUPPORTED, "Unknown Phidget descriptor version: " + phidgetDeviceDesc.bcdVersion + " - Library upgrade may be required.");
	        }

	        params.labelIndex = phidgetDeviceDesc.iLabel;
	        params.skuIndex = phidgetDeviceDesc.iSKU;
	        params.maxPacketEP0 = phidgetDeviceDesc.wMaxPacketSize;
	        break;

	      case 66:
	        if (configDescData.getUint8(i) !== 4) throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Error parsing config descriptor!");
	        phidgetEndpointDesc = {
	          bLength: configDescData.getUint8(i),
	          bDescriptorType: configDescData.getUint8(i + 1),
	          wMaxPacketSize: configDescData.getUint8(i + 3) << 8 | configDescData.getUint8(i + 2)
	        };
	        if (endpointDesc == undefined) throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Didn't get Phidget Endpoint descriptor!");
	        if ((endpointDesc.bEndpointAddress & 0x7F) == 0x01) params.maxPacketEP1 = phidgetEndpointDesc.wMaxPacketSize;
	        if ((endpointDesc.bEndpointAddress & 0x7F) == 0x02) params.maxPacketEP2 = phidgetEndpointDesc.wMaxPacketSize;
	        break;
	    }

	    i += configDescData.getUint8(i);
	  }

	  return params;
	}

	async function GetPhidgetUSBData(usbDevice) {
	  var _a, _b;

	  let desc;
	  if (usbDevice.vendorId !== USBVID_PHIDGETS) throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	  if (usbDevice.productId < USBPID_PHIDGETS_MIN || usbDevice.productId > USBPID_PHIDGETS_MAX) throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	  desc = await GetDescriptor(usbDevice, 1, 0, 0);
	  const devDescriptor = {
	    bLength: desc.getUint8(0),
	    bDescriptorType: desc.getUint8(1),
	    bcdUSB: desc.getUint8(3) << 8 | desc.getUint8(2),
	    bDeviceClass: desc.getUint8(4),
	    bDeviceSubClass: desc.getUint8(5),
	    bDeviceProtocol: desc.getUint8(6),
	    bMaxPacketSize0: desc.getUint8(7),
	    idVendor: desc.getUint8(9) << 8 | desc.getUint8(8),
	    idProduct: desc.getUint8(11) << 8 | desc.getUint8(10),
	    bcdDevice: desc.getUint8(13) << 8 | desc.getUint8(12),
	    iManufacturer: desc.getUint8(14),
	    iProduct: desc.getUint8(15),
	    iSerialNumber: desc.getUint8(16),
	    bNumConfigurations: desc.getUint8(17)
	  };
	  desc = await GetDescriptor(usbDevice, 3, devDescriptor.iSerialNumber, 0);
	  const version = (devDescriptor.bcdDevice >> 12 & 0x0F) * 1000 + (devDescriptor.bcdDevice >> 8 & 0x0F) * 100 + (devDescriptor.bcdDevice >> 4 & 0x0F) * 10 + (devDescriptor.bcdDevice & 0x0F);
	  const serial = parseInt(WordByteArrayToString(new Uint16Array(desc.buffer, 2)));
	  const phidDevParams = await GetPhidgetDeviceParams(usbDevice);
	  desc = await GetDescriptor(usbDevice, 3, phidDevParams.skuIndex, 0);
	  const skuString = WordByteArrayToString(new Uint16Array(desc.buffer, 2));
	  const interfaceNum = (_b = (_a = usbDevice.configuration) === null || _a === void 0 ? void 0 : _a.interfaces[0].interfaceNumber) !== null && _b !== void 0 ? _b : 0;
	  let label = '';

	  if (phidDevParams.labelIndex != 0) {
	    const desc = await GetDescriptor(usbDevice, 3, phidDevParams.labelIndex, 0);

	    if (desc.byteLength <= 22) {
	      const bLength = desc.getUint8(0);

	      if (bLength > 2) {
	        const bStringWordArray = new Uint16Array(desc.buffer);
	        label = WordByteArrayToString(bStringWordArray.slice(1));
	      }
	    }
	  }

	  const devData = {
	    version: version,
	    serialNumber: serial,
	    productID: usbDevice.productId,
	    vendorID: usbDevice.vendorId,
	    interfaceNum: interfaceNum,
	    fwstr: skuString,
	    label: label,
	    pusbParams: phidDevParams
	  };
	  return devData;
	}
	async function GetDescriptor(usbDevice, DescriptorType, DescriptorIndex, wIndex) {
	  let descReq;
	  const controlTransferParams = {
	    requestType: 'standard',
	    recipient: 'device',
	    request: 0x06,
	    value: DescriptorType << 8 | DescriptorIndex,
	    index: wIndex
	  };

	  try {
	    descReq = await usbDevice.controlTransferIn(controlTransferParams, USB_COMMON_DESCRIPTOR);
	  } catch (err) {
	    throw new PhidgetError(exports.ErrorCode.IO, "Failed to read descriptor", err);
	  }

	  if (descReq.status !== 'ok') throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Failed to read descriptor: " + descReq.status);
	  if (!descReq.data || descReq.data.byteLength != USB_COMMON_DESCRIPTOR) throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "GetDescriptor error - returned unexpected number of bytes");
	  const bLength = descReq.data.getUint8(0);
	  if (bLength <= USB_COMMON_DESCRIPTOR) return descReq.data;

	  try {
	    descReq = await usbDevice.controlTransferIn(controlTransferParams, bLength);
	  } catch (err) {
	    throw new PhidgetError(exports.ErrorCode.IO, "Failed to read descriptor", err);
	  }

	  if (descReq.status !== 'ok') throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Failed to read descriptor: " + descReq.status);
	  if (!descReq.data || descReq.data.byteLength != bLength) throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "GetDescriptor error - returned unexpected number of bytes");
	  return descReq.data;
	}

	async function GetConfigDescriptor(usbDevice, DescriptorIndex) {
	  const controlTransferParams = {
	    requestType: 'standard',
	    recipient: 'device',
	    request: 0x06,
	    value: 2 << 8 | DescriptorIndex,
	    index: 0
	  };
	  let configDescReq = await usbDevice.controlTransferIn(controlTransferParams, USB_CONFIGURATION_DESCRIPTOR);
	  if (configDescReq.status !== 'ok') throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Failed to read descriptor: " + configDescReq.status);
	  if (!configDescReq.data) throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "GetDescriptor error - returned unexpected number of bytes");
	  const wTotalLength = configDescReq.data.getUint8(3) << 8 | configDescReq.data.getUint8(2);
	  if (wTotalLength < USB_CONFIGURATION_DESCRIPTOR) throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "GetDescriptor error - too short!");
	  configDescReq = await usbDevice.controlTransferIn(controlTransferParams, wTotalLength);
	  if (configDescReq.status !== 'ok') throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Failed to read descriptor: " + configDescReq.status);
	  if (!configDescReq.data) throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "GetDescriptor error - returned unexpected number of bytes");
	  if (configDescReq.data.byteLength !== wTotalLength) throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "GetDescriptor error - returned unexpected number of bytes");
	  return configDescReq.data;
	}

	const PHIDGET_MAXCHANNELS = 64;
	const MAX_OUT_PACKET_SIZE = 128;
	/** @internal */

	class LocalDevice extends Device {
	  constructor(conn, data) {
	    super(conn, data);
	    this.deviceID = this.devDef.d;
	    this.name = this.devDef.t;
	    this.channels = {};
	  }

	  getChannel(index) {
	    if (this.channels[index] != undefined && this.channels[index].isopen) return this.channels[index];
	    return null;
	  }

	}

	const MAX_PACKET_IDS = 128;
	const PACKETTRACKER_INUSE = 0x01;
	const PACKETTRACKER_SIGNALLED = 0x02;
	const PACKETTRACKER_SENT = 0x04;
	const PACKETTRACKER_ABANDONNED = 0x08;

	class PacketTrackers {
	  constructor() {
	    this.packetTracker = new Map();
	    this.counter = [];
	  }

	  setPacketsReturnCode(child, res) {
	    for (const pt of values(_context = this.packetTracker).call(_context)) {
	      var _context;

	      if (!(pt.state & PACKETTRACKER_INUSE)) return;
	      if (!(pt.state & PACKETTRACKER_SENT)) return;
	      if (pt.childIndex !== child) return;

	      if (pt.state & PACKETTRACKER_ABANDONNED) {
	        pt.state = 0;
	      } else {
	        pt.returnCode = res;
	        pt.state |= PACKETTRACKER_SIGNALLED;
	        if (pt.signal) pt.signal();
	      }
	    }
	  }

	  async getPacketTrackerWait(device, min, max, childIndex, timeout) {
	    const tm = Date.now() + timeout;

	    for (;;) {
	      const tracker = this.getPacketTracker(device, min, max, childIndex);
	      if (tracker !== null) return tracker;
	      if (Date.now() > tm) throw new PhidgetError(exports.ErrorCode.TIMEOUT);
	      await PhidgetSleep(2);
	      logverbose("getPacketTrackerWait tm after sleep: " + Date.now());
	    }
	  }

	  getPacketTracker(device, min, max, childIndex) {
	    let i, j;
	    if (device === null) throw new PhidgetError(exports.ErrorCode.NOT_ATTACHED);
	    if (device.packetTrackers === null) throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	    if (min < 0) throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	    if (max >= MAX_PACKET_IDS) throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	    if (device.packetTrackers.counter[childIndex] == undefined) device.packetTrackers.counter[childIndex] = 0;

	    for (j = min; j <= max; j++) {
	      i = j + device.packetTrackers.counter[childIndex];
	      if (i > max) i -= max - min;
	      if (i < min || i > max) throw new PhidgetError(exports.ErrorCode.INVALID, "Calculated an invalid packetTracker");
	      let pt = device.packetTrackers.packetTracker.get(i);

	      if (pt == undefined) {
	        pt = new PacketTracker();
	        device.packetTrackers.packetTracker.set(i, pt);
	      }

	      if (pt.state & PACKETTRACKER_INUSE) continue;
	      pt.state |= PACKETTRACKER_INUSE;
	      pt.returnCode = exports.ErrorCode.UNKNOWN_VALUE;
	      pt.len = 0;
	      pt.childIndex = childIndex;
	      device.packetTrackers.counter[childIndex]++;
	      if (device.packetTrackers.counter[childIndex] > max - min) device.packetTrackers.counter[childIndex] = 0;
	      return {
	        pt: pt,
	        id: i
	      };
	    }

	    return null;
	  }

	  async waitForPendingPackets(child) {
	    let stillSomeLeft;
	    const timetm = Date.now() + 10;

	    do {
	      stillSomeLeft = 0;

	      for (const pt of values(_context2 = this.packetTracker).call(_context2)) {
	        var _context2;

	        if (pt.childIndex !== child) return;
	        if (!(pt.state & PACKETTRACKER_INUSE)) return;
	        if (!(pt.state & PACKETTRACKER_SIGNALLED)) return;
	        stillSomeLeft++;
	      }

	      if (stillSomeLeft) {
	        if (Date.now() > timetm) {
	          break;
	        }

	        await PhidgetSleep(10);
	      }
	    } while (stillSomeLeft);
	  }

	}

	class PacketTracker {
	  constructor() {
	    this.state = 0;
	    this.returnCode = exports.ErrorCode.SUCCESS;
	    this.childIndex = 0;
	    this.len = 0;
	  }

	  setPacketLength(len) {
	    this.len = len;
	  }

	  setPacketReturnCode(res) {
	    if ((this.state & PACKETTRACKER_INUSE) === 0 || this.state & PACKETTRACKER_SIGNALLED) throw new PhidgetError(exports.ErrorCode.INVALID);
	    this.returnCode = res;
	    this.state |= PACKETTRACKER_SIGNALLED;
	    if (this.signal) this.signal();
	  }

	  get signalled() {
	    return this.state & PACKETTRACKER_SIGNALLED ? true : false;
	  }

	  set sent(val) {
	    if (val) this.state |= PACKETTRACKER_SENT;else this.state &= ~PACKETTRACKER_SENT;
	  }

	  async waitForPendingPacket(timeout) {
	    if (!(this.state & PACKETTRACKER_INUSE)) throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "PacketTracker not INUSE");
	    if (this.state & PACKETTRACKER_SIGNALLED) return this.returnCode;
	    if (timeout === 0) throw new PhidgetError(exports.ErrorCode.TIMEOUT);
	    logverbose("waiting for PendingPacket: " + timeout + "ms...");
	    await new promise((resolve, reject) => {
	      const timer = setTimeout(() => {
	        logwarn("PacketTracker " + this.childIndex + " waitForPendingPacket timeout (" + timeout + "ms).");
	        delete this.signal;
	        reject(new PhidgetError(exports.ErrorCode.TIMEOUT));
	      }, timeout);

	      this.signal = () => {
	        clearTimeout(timer);
	        delete this.signal;
	        resolve();
	      };
	    });
	    logverbose("no longer waiting for PendingPacket");
	    return this.returnCode;
	  }

	  releasePacketTracker(force) {
	    if (force) {
	      this.state = 0;
	    } else {
	      if ((this.state & (PACKETTRACKER_INUSE | PACKETTRACKER_SIGNALLED | PACKETTRACKER_SENT)) !== (PACKETTRACKER_INUSE | PACKETTRACKER_SENT)) {
	        this.state = 0;
	      } else {
	        logverbose("Refusing to release sent but non-signalled packet tracker, Port " + this.childIndex);
	        this.state |= PACKETTRACKER_ABANDONNED;
	      }
	    }
	  }

	}

	var classof = classofRaw$1;
	var isArray$1 = Array.isArray || function isArray(argument) {
	  return classof(argument) == 'Array';
	};

	var $$2 = _export;
	var uncurryThis$1 = functionUncurryThis;
	var isArray = isArray$1;
	var un$Reverse = uncurryThis$1([].reverse);
	var test = [1, 2];
	$$2({ target: 'Array', proto: true, forced: String(test) === String(test.reverse()) }, {
	  reverse: function reverse() {
	    if (isArray(this)) this.length = this.length;
	    return un$Reverse(this);
	  }
	});

	var entryVirtual$2 = entryVirtual$4;
	var reverse$3 = entryVirtual$2('Array').reverse;

	var isPrototypeOf$2 = objectIsPrototypeOf;
	var method$2 = reverse$3;
	var ArrayPrototype$1 = Array.prototype;
	var reverse$2 = function (it) {
	  var own = it.reverse;
	  return it === ArrayPrototype$1 || (isPrototypeOf$2(ArrayPrototype$1, it) && own === ArrayPrototype$1.reverse) ? method$2 : own;
	};

	var parent$2 = reverse$2;
	var reverse$1 = parent$2;

	var reverse = reverse$1;

	/** @internal */

	function supportedEncoderIOMode(ch, val) {
	  if (val < exports.EncoderIOMode.PUSH_PULL || val > exports.EncoderIOMode.OPEN_COLLECTOR_10K) return false;

	  switch (val) {
	    case exports.EncoderIOMode.PUSH_PULL:
	    case exports.EncoderIOMode.LINE_DRIVER_2K2:
	    case exports.EncoderIOMode.LINE_DRIVER_10K:
	    case exports.EncoderIOMode.OPEN_COLLECTOR_2K2:
	    case exports.EncoderIOMode.OPEN_COLLECTOR_10K:
	      switch (ch.chDef.uid) {
	        case 243:
	        case 248:
	        case 254:
	        case 252:
	        case 258:
	        case 293:
	        case 140:
	          return true;

	        default:
	          return false;
	      }

	    default:
	      return true;
	  }
	}
	/** @internal */

	function supportedPowerSupply(ch, val) {
	  if (val < exports.PowerSupply.OFF || val > exports.PowerSupply.VOLTS_24) return false;

	  switch (val) {
	    case exports.PowerSupply.OFF:
	    case exports.PowerSupply.VOLTS_12:
	    case exports.PowerSupply.VOLTS_24:
	      switch (ch.chDef.uid) {
	        case 234:
	        case 233:
	        case 235:
	        case 232:
	        case 238:
	        case 237:
	        case 239:
	        case 236:
	          return true;

	        default:
	          return false;
	      }

	    default:
	      return true;
	  }
	}
	/** @internal */

	function supportedRTDWireSetup(ch, val) {
	  if (val < exports.RTDWireSetup.WIRES_2 || val > exports.RTDWireSetup.WIRES_4) return false;

	  switch (val) {
	    case exports.RTDWireSetup.WIRES_2:
	    case exports.RTDWireSetup.WIRES_3:
	    case exports.RTDWireSetup.WIRES_4:
	      switch (ch.chDef.uid) {
	        case 391:
	        case 390:
	        case 393:
	        case 392:
	          return true;

	        default:
	          return false;
	      }

	    default:
	      return true;
	  }
	}
	/** @internal */

	function supportedInputMode(ch, val) {
	  if (val < exports.InputMode.NPN || val > exports.InputMode.PNP) return false;

	  switch (val) {
	    case exports.InputMode.NPN:
	    case exports.InputMode.PNP:
	      switch (ch.chDef.uid) {
	        case 234:
	        case 235:
	        case 238:
	        case 239:
	          return true;

	        default:
	          return false;
	      }

	    default:
	      return true;
	  }
	}
	/** @internal */

	function supportedFanMode(ch, val) {
	  if (val < exports.FanMode.OFF || val > exports.FanMode.AUTO) return false;

	  switch (val) {
	    case exports.FanMode.OFF:
	      switch (ch.chDef.uid) {
	        case 360:
	        case 363:
	        case 242:
	        case 247:
	        case 253:
	        case 259:
	        case 264:
	        case 252:
	        case 258:
	        case 263:
	        case 268:
	          return true;

	        default:
	          return false;
	      }

	    case exports.FanMode.ON:
	    case exports.FanMode.AUTO:
	      switch (ch.chDef.uid) {
	        case 360:
	        case 363:
	        case 242:
	        case 247:
	        case 253:
	        case 264:
	        case 252:
	        case 258:
	          return true;

	        default:
	          return false;
	      }

	    default:
	      return true;
	  }
	}
	/** @internal */

	function supportedSpatialPrecision(_ch, val) {
	  if (val < exports.SpatialPrecision.HYBRID || val > exports.SpatialPrecision.LOW) return false;
	  return true;
	}
	/** @internal */

	function supportedBridgeGain(ch, val) {
	  if (val < exports.BridgeGain.GAIN_1X || val > exports.BridgeGain.GAIN_128X) return false;

	  switch (val) {
	    case exports.BridgeGain.GAIN_1X:
	    case exports.BridgeGain.GAIN_64X:
	    case exports.BridgeGain.GAIN_128X:
	      switch (ch.chDef.uid) {
	        case 95:
	        case 96:
	        case 240:
	        case 97:
	          return true;

	        default:
	          return false;
	      }

	    case exports.BridgeGain.GAIN_2X:
	      switch (ch.chDef.uid) {
	        case 240:
	          return true;

	        default:
	          return false;
	      }

	    case exports.BridgeGain.GAIN_4X:
	      switch (ch.chDef.uid) {
	        default:
	          return false;
	      }

	    case exports.BridgeGain.GAIN_8X:
	    case exports.BridgeGain.GAIN_16X:
	    case exports.BridgeGain.GAIN_32X:
	      switch (ch.chDef.uid) {
	        case 95:
	        case 96:
	        case 97:
	          return true;

	        default:
	          return false;
	      }

	    default:
	      return true;
	  }
	}
	/** @internal */

	function supportedVoltageRatioSensorType(ch, val) {
	  if (val < exports.VoltageRatioSensorType.VOLTAGE_RATIO || val > exports.VoltageRatioSensorType.PN_3522) return false;

	  switch (val) {
	    case exports.VoltageRatioSensorType.PN_1101_SHARP2D120X:
	    case exports.VoltageRatioSensorType.PN_1101_SHARP2Y0A21:
	    case exports.VoltageRatioSensorType.PN_1101_SHARP2Y0A02:
	    case exports.VoltageRatioSensorType.PN_1102:
	    case exports.VoltageRatioSensorType.PN_1103:
	    case exports.VoltageRatioSensorType.PN_1104:
	    case exports.VoltageRatioSensorType.PN_1105:
	    case exports.VoltageRatioSensorType.PN_1106:
	    case exports.VoltageRatioSensorType.PN_1107:
	    case exports.VoltageRatioSensorType.PN_1108:
	    case exports.VoltageRatioSensorType.PN_1109:
	    case exports.VoltageRatioSensorType.PN_1110:
	    case exports.VoltageRatioSensorType.PN_1111:
	    case exports.VoltageRatioSensorType.PN_1112:
	    case exports.VoltageRatioSensorType.PN_1113:
	    case exports.VoltageRatioSensorType.PN_1115:
	    case exports.VoltageRatioSensorType.PN_1116:
	    case exports.VoltageRatioSensorType.PN_1118_AC:
	    case exports.VoltageRatioSensorType.PN_1118_DC:
	    case exports.VoltageRatioSensorType.PN_1119_AC:
	    case exports.VoltageRatioSensorType.PN_1119_DC:
	    case exports.VoltageRatioSensorType.PN_1120:
	    case exports.VoltageRatioSensorType.PN_1121:
	    case exports.VoltageRatioSensorType.PN_1122_AC:
	    case exports.VoltageRatioSensorType.PN_1122_DC:
	    case exports.VoltageRatioSensorType.PN_1124:
	    case exports.VoltageRatioSensorType.PN_1125_HUMIDITY:
	    case exports.VoltageRatioSensorType.PN_1125_TEMPERATURE:
	    case exports.VoltageRatioSensorType.PN_1126:
	    case exports.VoltageRatioSensorType.PN_1128:
	    case exports.VoltageRatioSensorType.PN_1129:
	    case exports.VoltageRatioSensorType.PN_1131:
	    case exports.VoltageRatioSensorType.PN_1134:
	    case exports.VoltageRatioSensorType.PN_1136:
	    case exports.VoltageRatioSensorType.PN_1137:
	    case exports.VoltageRatioSensorType.PN_1138:
	    case exports.VoltageRatioSensorType.PN_1139:
	    case exports.VoltageRatioSensorType.PN_1140:
	    case exports.VoltageRatioSensorType.PN_1141:
	    case exports.VoltageRatioSensorType.PN_1146:
	    case exports.VoltageRatioSensorType.PN_3120:
	    case exports.VoltageRatioSensorType.PN_3121:
	    case exports.VoltageRatioSensorType.PN_3122:
	    case exports.VoltageRatioSensorType.PN_3123:
	    case exports.VoltageRatioSensorType.PN_3130:
	    case exports.VoltageRatioSensorType.PN_3520:
	    case exports.VoltageRatioSensorType.PN_3521:
	    case exports.VoltageRatioSensorType.PN_3522:
	      switch (ch.chDef.uid) {
	        case 1:
	        case 15:
	        case 25:
	        case 29:
	        case 42:
	        case 46:
	        case 164:
	        case 171:
	        case 175:
	        case 180:
	        case 194:
	        case 215:
	        case 217:
	        case 244:
	        case 249:
	          return true;

	        default:
	          return false;
	      }

	    default:
	      return true;
	  }
	}
	/** @internal */

	function supportedLEDForwardVoltage(ch, val) {
	  if (val < exports.LEDForwardVoltage.VOLTS_1_7 || val > exports.LEDForwardVoltage.VOLTS_5_6) return false;

	  switch (val) {
	    case exports.LEDForwardVoltage.VOLTS_1_7:
	    case exports.LEDForwardVoltage.VOLTS_2_75:
	    case exports.LEDForwardVoltage.VOLTS_3_9:
	    case exports.LEDForwardVoltage.VOLTS_5_0:
	      switch (ch.chDef.uid) {
	        case 72:
	        case 73:
	          return true;

	        default:
	          return false;
	      }

	    case exports.LEDForwardVoltage.VOLTS_3_2:
	      switch (ch.chDef.uid) {
	        case 306:
	        case 71:
	          return true;

	        default:
	          return false;
	      }

	    case exports.LEDForwardVoltage.VOLTS_4_0:
	    case exports.LEDForwardVoltage.VOLTS_4_8:
	    case exports.LEDForwardVoltage.VOLTS_5_6:
	      switch (ch.chDef.uid) {
	        case 306:
	          return true;

	        default:
	          return false;
	      }

	    default:
	      return true;
	  }
	}
	/** @internal */

	function supportedRCServoVoltage(ch, val) {
	  if (val < exports.RCServoVoltage.VOLTS_5_0 || val > exports.RCServoVoltage.VOLTS_7_4) return false;

	  switch (val) {
	    case exports.RCServoVoltage.VOLTS_6_0:
	    case exports.RCServoVoltage.VOLTS_7_4:
	      switch (ch.chDef.uid) {
	        case 347:
	        case 348:
	        case 349:
	        case 152:
	          return true;

	        default:
	          return false;
	      }

	    default:
	      return true;
	  }
	}
	/** @internal */

	function supportedVoltageOutputRange(ch, val) {
	  if (val < exports.VoltageOutputRange.VOLTS_10 || val > exports.VoltageOutputRange.VOLTS_5) return false;

	  switch (val) {
	    case exports.VoltageOutputRange.VOLTS_10:
	      switch (ch.chDef.uid) {
	        case 12:
	        case 221:
	        case 222:
	        case 223:
	        case 224:
	          return true;

	        default:
	          return false;
	      }

	    case exports.VoltageOutputRange.VOLTS_5:
	      switch (ch.chDef.uid) {
	        case 221:
	        case 222:
	        case 223:
	        case 224:
	          return true;

	        default:
	          return false;
	      }

	    default:
	      return true;
	  }
	}
	/** @internal */

	function supportedVoltageRange(ch, val) {
	  if (val < exports.VoltageRange.MILLIVOLTS_10 || val > exports.VoltageRange.AUTO) return false;

	  switch (val) {
	    case exports.VoltageRange.MILLIVOLTS_10:
	    case exports.VoltageRange.MILLIVOLTS_40:
	    case exports.VoltageRange.MILLIVOLTS_200:
	    case exports.VoltageRange.MILLIVOLTS_1000:
	      switch (ch.chDef.uid) {
	        case 400:
	        case 401:
	          return true;

	        default:
	          return false;
	      }

	    case exports.VoltageRange.MILLIVOLTS_312_5:
	      switch (ch.chDef.uid) {
	        case 397:
	          return true;

	        default:
	          return false;
	      }

	    case exports.VoltageRange.MILLIVOLTS_400:
	    case exports.VoltageRange.VOLTS_2:
	      switch (ch.chDef.uid) {
	        case 196:
	          return true;

	        default:
	          return false;
	      }

	    case exports.VoltageRange.VOLTS_5:
	    case exports.VoltageRange.VOLTS_15:
	      switch (ch.chDef.uid) {
	        case 398:
	        case 399:
	          return true;

	        default:
	          return false;
	      }

	    case exports.VoltageRange.VOLTS_40:
	      switch (ch.chDef.uid) {
	        case 397:
	        case 398:
	        case 399:
	          return true;

	        default:
	          return false;
	      }

	    case exports.VoltageRange.AUTO:
	      switch (ch.chDef.uid) {
	        case 398:
	        case 399:
	        case 400:
	        case 401:
	          return true;

	        default:
	          return false;
	      }

	    default:
	      return true;
	  }
	}
	/** @internal */

	function supportedVoltageSensorType(ch, val) {
	  if (val < exports.VoltageSensorType.VOLTAGE || val > exports.VoltageSensorType.PN_VCP4114) return false;

	  switch (val) {
	    case exports.VoltageSensorType.PN_1114:
	    case exports.VoltageSensorType.PN_1117:
	    case exports.VoltageSensorType.PN_1123:
	    case exports.VoltageSensorType.PN_1127:
	    case exports.VoltageSensorType.PN_1130_PH:
	    case exports.VoltageSensorType.PN_1130_ORP:
	    case exports.VoltageSensorType.PN_1132:
	    case exports.VoltageSensorType.PN_1133:
	    case exports.VoltageSensorType.PN_1135:
	    case exports.VoltageSensorType.PN_1142:
	    case exports.VoltageSensorType.PN_1143:
	    case exports.VoltageSensorType.PN_3500:
	    case exports.VoltageSensorType.PN_3501:
	    case exports.VoltageSensorType.PN_3502:
	    case exports.VoltageSensorType.PN_3503:
	    case exports.VoltageSensorType.PN_3585:
	    case exports.VoltageSensorType.PN_3586:
	    case exports.VoltageSensorType.PN_3587:
	    case exports.VoltageSensorType.PN_3588:
	    case exports.VoltageSensorType.PN_3589:
	    case exports.VoltageSensorType.PN_MOT2002_LOW:
	    case exports.VoltageSensorType.PN_MOT2002_MED:
	    case exports.VoltageSensorType.PN_MOT2002_HIGH:
	    case exports.VoltageSensorType.PN_VCP4114:
	      switch (ch.chDef.uid) {
	        case 14:
	        case 24:
	        case 28:
	        case 41:
	        case 45:
	        case 162:
	        case 170:
	        case 174:
	        case 179:
	        case 192:
	        case 193:
	        case 216:
	        case 218:
	          return true;

	        default:
	          return false;
	      }

	    case exports.VoltageSensorType.PN_3507:
	    case exports.VoltageSensorType.PN_3508:
	    case exports.VoltageSensorType.PN_3509:
	    case exports.VoltageSensorType.PN_3510:
	    case exports.VoltageSensorType.PN_3511:
	    case exports.VoltageSensorType.PN_3512:
	    case exports.VoltageSensorType.PN_3513:
	    case exports.VoltageSensorType.PN_3514:
	    case exports.VoltageSensorType.PN_3515:
	    case exports.VoltageSensorType.PN_3516:
	    case exports.VoltageSensorType.PN_3517:
	    case exports.VoltageSensorType.PN_3518:
	    case exports.VoltageSensorType.PN_3519:
	    case exports.VoltageSensorType.PN_3584:
	      switch (ch.chDef.uid) {
	        case 14:
	        case 24:
	        case 28:
	        case 41:
	        case 45:
	        case 162:
	        case 170:
	        case 174:
	        case 179:
	        case 192:
	        case 193:
	        case 216:
	        case 218:
	        case 232:
	        case 236:
	          return true;

	        default:
	          return false;
	      }

	    default:
	      return true;
	  }
	}
	/** @internal */

	function supportedRFIDProtocol(ch, val) {
	  if (val < exports.RFIDProtocol.EM4100 || val > exports.RFIDProtocol.PHIDGET_TAG) return false;

	  switch (val) {
	    case exports.RFIDProtocol.ISO11785_FDX_B:
	    case exports.RFIDProtocol.PHIDGET_TAG:
	      switch (ch.chDef.uid) {
	        case 59:
	        case 63:
	        case 67:
	          return true;

	        default:
	          return false;
	      }

	    default:
	      return true;
	  }
	}
	/** @internal */

	function supportedSpatialAlgorithm(_ch, val) {
	  if (val < exports.SpatialAlgorithm.NONE || val > exports.SpatialAlgorithm.IMU) return false;
	  return true;
	}
	/** @internal */

	function supportedRTDType(ch, val) {
	  if (val < exports.RTDType.PT100_3850 || val > exports.RTDType.PT1000_3920) return false;

	  switch (val) {
	    case exports.RTDType.PT100_3850:
	    case exports.RTDType.PT1000_3850:
	    case exports.RTDType.PT100_3920:
	    case exports.RTDType.PT1000_3920:
	      switch (ch.chDef.uid) {
	        case 390:
	        case 392:
	          return true;

	        default:
	          return false;
	      }

	    default:
	      return true;
	  }
	}
	/** @internal */

	function supportedThermocoupleType(ch, val) {
	  if (val < exports.ThermocoupleType.J || val > exports.ThermocoupleType.T) return false;

	  switch (val) {
	    case exports.ThermocoupleType.J:
	    case exports.ThermocoupleType.E:
	    case exports.ThermocoupleType.T:
	      switch (ch.chDef.uid) {
	        case 102:
	        case 105:
	        case 111:
	        case 114:
	        case 117:
	        case 381:
	        case 384:
	        case 387:
	          return true;

	        default:
	          return false;
	      }

	    case exports.ThermocoupleType.K:
	      switch (ch.chDef.uid) {
	        case 102:
	        case 105:
	        case 109:
	        case 111:
	        case 114:
	        case 117:
	        case 381:
	        case 384:
	        case 387:
	          return true;

	        default:
	          return false;
	      }

	    default:
	      return true;
	  }
	}
	/** @internal */

	function supportedFrequencyFilterType(ch, val) {
	  if (val < exports.FrequencyFilterType.ZERO_CROSSING || val > exports.FrequencyFilterType.LOGIC_LEVEL) return false;

	  switch (val) {
	    case exports.FrequencyFilterType.ZERO_CROSSING:
	      switch (ch.chDef.uid) {
	        case 127:
	          return true;

	        default:
	          return false;
	      }

	    case exports.FrequencyFilterType.LOGIC_LEVEL:
	      switch (ch.chDef.uid) {
	        case 127:
	        case 235:
	        case 239:
	          return true;

	        default:
	          return false;
	      }

	    default:
	      return true;
	  }
	}
	/** @internal */

	function supportedStepperControlMode(_ch, val) {
	  if (val < exports.StepperControlMode.STEP || val > exports.StepperControlMode.RUN) return false;
	  return true;
	}
	/** @internal */

	function supportedLCDFont(ch, val) {
	  if (val < exports.LCDFont.USER1 || val > exports.LCDFont.DIMENSIONS_6X12) return false;

	  switch (val) {
	    case exports.LCDFont.USER1:
	    case exports.LCDFont.USER2:
	    case exports.LCDFont.DIMENSIONS_6X10:
	    case exports.LCDFont.DIMENSIONS_6X12:
	      switch (ch.chDef.uid) {
	        case 305:
	          return true;

	        default:
	          return false;
	      }

	    case exports.LCDFont.DIMENSIONS_5X8:
	      switch (ch.chDef.uid) {
	        case 178:
	        case 183:
	        case 184:
	        case 185:
	        case 186:
	        case 305:
	          return true;

	        default:
	          return false;
	      }

	    default:
	      return true;
	  }
	}
	/** @internal */

	function supportedLCDScreenSize(ch, val) {
	  if (val < exports.LCDScreenSize.NO_SCREEN || val > exports.LCDScreenSize.DIMENSIONS_64X128) return false;

	  switch (val) {
	    case exports.LCDScreenSize.NO_SCREEN:
	    case exports.LCDScreenSize.DIMENSIONS_1X8:
	    case exports.LCDScreenSize.DIMENSIONS_2X8:
	    case exports.LCDScreenSize.DIMENSIONS_1X16:
	    case exports.LCDScreenSize.DIMENSIONS_2X16:
	    case exports.LCDScreenSize.DIMENSIONS_4X16:
	    case exports.LCDScreenSize.DIMENSIONS_4X20:
	    case exports.LCDScreenSize.DIMENSIONS_2X24:
	    case exports.LCDScreenSize.DIMENSIONS_1X40:
	    case exports.LCDScreenSize.DIMENSIONS_2X40:
	    case exports.LCDScreenSize.DIMENSIONS_4X40:
	      switch (ch.chDef.uid) {
	        case 184:
	          return true;

	        default:
	          return false;
	      }

	    case exports.LCDScreenSize.DIMENSIONS_2X20:
	      switch (ch.chDef.uid) {
	        case 178:
	        case 183:
	        case 184:
	        case 185:
	        case 186:
	          return true;

	        default:
	          return false;
	      }

	    case exports.LCDScreenSize.DIMENSIONS_64X128:
	      switch (ch.chDef.uid) {
	        case 305:
	          return true;

	        default:
	          return false;
	      }

	    default:
	      return true;
	  }
	}
	/** @internal */

	function supportedLCDPixelState(ch, val) {
	  if (val < exports.LCDPixelState.OFF || val > exports.LCDPixelState.INVERT) return false;

	  switch (val) {
	    case exports.LCDPixelState.OFF:
	    case exports.LCDPixelState.ON:
	    case exports.LCDPixelState.INVERT:
	      switch (ch.chDef.uid) {
	        case 305:
	          return true;

	        default:
	          return false;
	      }

	    default:
	      return true;
	  }
	}
	/** @internal */

	function supportedSPLRange(_ch, val) {
	  if (val < exports.SPLRange.DB_102 || val > exports.SPLRange.DB_82) return false;
	  return true;
	}
	/** @internal */

	function supportedHubPortMode(_ch, val) {
	  if (val < exports.HubPortMode.VINT || val > exports.HubPortMode.VOLTAGE_RATIO_INPUT) return false;
	  return true;
	}

	const VINT_MAX_OUT_PACKETSIZE = 48;
	const VINTPacketDescription = {
	  0xE0: "Success",
	  0xE1: "Not Ready",
	  0xE2: "Invalid Argument",
	  0xE3: "Invalid Packet Type",
	  0xE4: "Invalid Sequence",
	  0xE5: "Invalid Command",
	  0xE6: "Malformed",
	  0xE7: "No Space",
	  0xE8: "Unexpected",
	  0xE9: "Not Attached",
	  0xEA: "Packet Too Big",
	  0xEB: "Failsafe Tripped"
	};
	const VINTPacketCode_to_PhidgetReturnCode = {
	  0xE0: exports.ErrorCode.SUCCESS,
	  0xE1: exports.ErrorCode.BUSY,
	  0xE2: exports.ErrorCode.INVALID_ARGUMENT,
	  0xE3: exports.ErrorCode.INVALID_PACKET,
	  0xE4: exports.ErrorCode.NOT_CONFIGURED,
	  0xE5: exports.ErrorCode.INVALID,
	  0xE6: exports.ErrorCode.INVALID,
	  0xE7: exports.ErrorCode.NO_SPACE,
	  0xE8: exports.ErrorCode.UNEXPECTED,
	  0xE9: exports.ErrorCode.NOT_ATTACHED,
	  0xEA: exports.ErrorCode.FILE_TOO_BIG,
	  0xEB: exports.ErrorCode.FAILSAFE
	};
	async function send1014_3_VINT(ch, bp) {
	  let dutyCycle;
	  const buf = new DataView(new ArrayBuffer(2));

	  switch (ch.chDef.uid) {
	    case 35:
	      switch (bp.vpkt) {
	        case 82:
	          buf.setUint8(0, bp.getNumber(0) ? 0xFF : 0x00);
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 55:
	          dutyCycle = bp.getNumber(0);

	          if (dutyCycle !== 0 && dutyCycle !== 1) {
	            throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT);
	          }

	          buf.setUint8(0, dutyCycle ? 0xFF : 0x00);
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recv1014_3_VINT(ch, buf) {
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 35:
	      switch (pkt) {
	        case 13:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.FAILSAFE_CONDITION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Failsafe procedure initiated.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function send1017_2_VINT(ch, bp) {
	  let dutyCycle;
	  const buf = new DataView(new ArrayBuffer(2));

	  switch (ch.chDef.uid) {
	    case 40:
	      switch (bp.vpkt) {
	        case 82:
	          buf.setUint8(0, bp.getNumber(0) ? 0xFF : 0x00);
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 55:
	          dutyCycle = bp.getNumber(0);

	          if (dutyCycle !== 0 && dutyCycle !== 1) {
	            throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT);
	          }

	          buf.setUint8(0, dutyCycle ? 0xFF : 0x00);
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recv1017_2_VINT(ch, buf) {
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 40:
	      switch (pkt) {
	        case 13:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.FAILSAFE_CONDITION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Failsafe procedure initiated.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function send1055_1_VINT(ch, bp) {
	  throw new Error("Not Implemented");
	}
	function recv1055_1_VINT(ch, buf) {
	  throw new Error("Not Implemented");
	}
	async function sendDIGITALINPUT_PORT() {
	  throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected command received.");
	}
	function recvDIGITALINPUT_PORT(ch, buf) {
	  const pkt = buf.getUint8(0);

	  switch (ch.chDef.uid) {
	    case 189:
	      {
	        const bp = new BridgePacket();

	        switch (pkt) {
	          case 8:
	            bp.set({
	              name: "0",
	              type: "d",
	              value: 1
	            });
	            break;

	          case 9:
	            bp.set({
	              name: "0",
	              type: "d",
	              value: 0
	            });
	            break;

	          default:
	            throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	        }

	        bp.sendToChannel(ch, 90);
	        break;
	      }

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendDIGITALOUTPUT_PORT(ch, bp) {
	  const buf = new Uint16Array(1);

	  switch (ch.chDef.uid) {
	    case 190:
	      switch (bp.vpkt) {
	        case 82:
	          buf.set(bp.getBoolean(0) ? [1 << 15] : [0], 0);
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, buf.byteLength));
	          break;

	        case 55:
	          buf.set([bp.getNumber(0) * (1 << 15)], 0);
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, buf.byteLength));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 191:
	      switch (bp.vpkt) {
	        case 82:
	          buf.set(bp.getBoolean(0) ? [1 << 7] : [0], 0);
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, buf.byteLength));
	          break;

	        case 55:
	          {
	            buf.set([bp.getNumber(0) * (1 << 15)], 0);
	            const buf8 = new Uint8Array(buf.buffer, 0, buf.byteLength);
	            await ch.sendVINTDataPacket(10, reverse(buf8).call(buf8));
	            break;
	          }

	        case 146:
	          buf.set([bp.getNumber(0)], 0);
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, buf.byteLength));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvDIGITALOUTPUT_PORT(ch, buf) {
	  const pkt = buf.getUint8(0);

	  switch (ch.chDef.uid) {
	    case 190:
	      throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet received.");

	    case 191:
	      {
	        const bp = new BridgePacket();

	        switch (pkt) {
	          case 13:
	            bp.set({
	              name: "0",
	              type: "d",
	              value: exports.ErrorEventCode.FAILSAFE_CONDITION
	            });
	            bp.set({
	              name: "1",
	              type: "s",
	              value: "Failsafe procedure initiated."
	            });
	            ch.sendErrorEvent(bp);
	            break;

	          default:
	            throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	        }

	        break;
	      }

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendDIGITALOUTPUT_PORT_FAILSAFE(ch, bp) {
	  await sendDIGITALOUTPUT_PORT(ch, bp);
	}
	function recvDIGITALOUTPUT_PORT_FAILSAFE(ch, buf) {
	  recvDIGITALOUTPUT_PORT(ch, buf);
	}
	async function sendVOLTAGEINPUT_PORT(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 192:
	    case 193:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint16(0, bp.getNumber(0) / 5 * (1 << 15));
	          await ch.sendVINTDataPacket(16, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 79:
	          if (!supportedVoltageSensorType(ch, bp.getNumber(0))) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT);
	          break;

	        case 122:
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvVOLTAGEINPUT_PORT(ch, buf) {
	  const pkt = buf.getUint8(0);
	  let voltage;

	  switch (ch.chDef.uid) {
	    case 192:
	    case 193:
	      {
	        const bp = new BridgePacket();

	        switch (pkt) {
	          case 17:
	            voltage = buf.getUint16(1) * 5.0 / (1 << 15);
	            bp.set({
	              name: "0",
	              type: "g",
	              value: RoundDouble(voltage, 5)
	            });
	            bp.sendToChannel(ch, 101);
	            break;

	          case 18:
	            bp.set({
	              name: "0",
	              type: "d",
	              value: exports.ErrorEventCode.SATURATION
	            });
	            bp.set({
	              name: "1",
	              type: "s",
	              value: "Saturation Detected."
	            });
	            ch.sendErrorEvent(bp);
	            break;

	          default:
	            throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	        }

	        break;
	      }

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendVOLTAGEINPUT_PORT_5V25(ch, bp) {
	  await sendVOLTAGEINPUT_PORT(ch, bp);
	}
	function recvVOLTAGEINPUT_PORT_5V25(ch, buf) {
	  recvVOLTAGEINPUT_PORT(ch, buf);
	}
	async function sendVOLTAGERATIOINPUT_PORT(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 194:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint16(0, bp.getNumber(0) * 32768);
	          await ch.sendVINTDataPacket(26, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 79:
	          if (!supportedVoltageRatioSensorType(ch, bp.getNumber(0))) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT);
	          break;

	        case 122:
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvVOLTAGERATIOINPUT_PORT(ch, buf) {
	  let voltageRatio;
	  const pkt = buf.getUint8(0);

	  switch (ch.chDef.uid) {
	    case 194:
	      {
	        const bp = new BridgePacket();

	        switch (pkt) {
	          case 27:
	            voltageRatio = buf.getUint16(1) / (1 << 15);
	            bp.set({
	              name: "0",
	              type: "g",
	              value: RoundDouble(voltageRatio, 5)
	            });
	            bp.sendToChannel(ch, 102);
	            break;

	          case 28:
	            bp.set({
	              name: "0",
	              type: "d",
	              value: exports.ErrorEventCode.SATURATION
	            });
	            bp.set({
	              name: "1",
	              type: "s",
	              value: "Saturation Detected."
	            });
	            ch.sendErrorEvent(bp);
	            break;

	          default:
	            throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	        }

	        break;
	      }

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendADP1000(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 195:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 24));
	          await ch.sendVINTDataPacket(187, new Uint8Array(buf.buffer));
	          break;

	        case 134:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 3));
	          await ch.sendVINTDataPacket(188, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 196:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 24));
	          await ch.sendVINTDataPacket(16, new Uint8Array(buf.buffer));
	          break;

	        case 87:
	          {
	            const range = bp.getNumber(0);

	            switch (range) {
	              case exports.VoltageRange.MILLIVOLTS_400:
	              case exports.VoltageRange.VOLTS_2:
	                buf.setUint8(0, range);
	                await ch.sendVINTDataPacket(22, new Uint8Array(buf.buffer, 0, 1));
	                break;

	              default:
	                throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Invalid or unsupported voltage range for this device.");
	            }

	            break;
	          }

	        case 79:
	          {
	            const sensorType = bp.getNumber(0);

	            if (!supportedVoltageSensorType(ch, sensorType)) {
	              throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Invalid or unsupported voltage sensor type");
	            }

	            break;
	          }

	        case 122:
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvADP1000(ch, buf) {
	  let voltage;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 195:
	      switch (pkt) {
	        case 185:
	          voltage = buf.getInt32(1) / (1 << 24);
	          bp.set({
	            name: "0",
	            type: "g",
	            value: RoundDouble(voltage, 5)
	          });
	          bp.sendToChannel(ch, 133);
	          break;

	        case 186:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Saturation Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 196:
	      switch (pkt) {
	        case 17:
	          voltage = buf.getInt32(1) / (1 << 24);
	          bp.set({
	            name: "0",
	            type: "g",
	            value: RoundDouble(voltage, 5)
	          });
	          bp.sendToChannel(ch, 101);
	          break;

	        case 18:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Saturation Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendDAQ1000(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 215:
	    case 217:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(26, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 79:
	          if (!supportedVoltageRatioSensorType(ch, bp.getNumber(0))) {
	            throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT);
	          }

	          break;

	        case 122:
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 216:
	    case 218:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(16, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 79:
	          if (!supportedVoltageSensorType(ch, bp.getNumber(0))) {
	            throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT);
	          }

	          break;

	        case 122:
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvDAQ1000(ch, buf) {
	  let voltage;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 215:
	    case 217:
	      switch (pkt) {
	        case 27:
	          voltage = buf.getFloat32(1, true);
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(voltage, 4)
	          });
	          bp.sendToChannel(ch, 102);
	          break;

	        case 18:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Saturation Detected.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 216:
	    case 218:
	      switch (pkt) {
	        case 17:
	          voltage = buf.getFloat32(1, true);
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(voltage, 4)
	          });
	          bp.sendToChannel(ch, 101);
	          break;

	        case 18:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Saturation Detected.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendDAQ1000_5V25(ch, bp) {
	  await sendDAQ1000(ch, bp);
	}
	function recvDAQ1000_5V25(ch, buf) {
	  recvDAQ1000(ch, buf);
	}
	async function sendOUT1000(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 219:
	      switch (bp.vpkt) {
	        case 86:
	          buf.setInt32(0, bp.getNumber(0) * (1 << 24));
	          await ch.sendVINTDataPacket(5, new Uint8Array(buf.buffer));
	          break;

	        case 56:
	          buf.setUint8(0, bp.getNumber(0) ? 0xFF : 0x00);
	          await ch.sendVINTDataPacket(4, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 220:
	      switch (bp.vpkt) {
	        case 86:
	          buf.setInt32(0, bp.getNumber(0) * (1 << 24));
	          await ch.sendVINTDataPacket(5, new Uint8Array(buf.buffer));
	          break;

	        case 56:
	          buf.setUint8(0, bp.getNumber(0) ? 0xFF : 0x00);
	          await ch.sendVINTDataPacket(4, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvOUT1000(ch, buf) {
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 219:
	      switch (pkt) {
	        case 6:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.VOLTAGE_ERROR
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Voltage Error Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 220:
	      switch (pkt) {
	        case 6:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.VOLTAGE_ERROR
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Voltage Error Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        case 14:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.FAILSAFE_CONDITION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Failsafe procedure initiated."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendOUT1000_Failsafe(ch, bp) {
	  await sendOUT1000(ch, bp);
	}
	function recvOUT1000_Failsafe(ch, buf) {
	  recvOUT1000(ch, buf);
	}
	async function sendOUT1001(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 221:
	      switch (bp.vpkt) {
	        case 86:
	          buf.setInt32(0, bp.getNumber(0) * (1 << 24));
	          await ch.sendVINTDataPacket(5, new Uint8Array(buf.buffer));
	          break;

	        case 87:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(7, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 222:
	      switch (bp.vpkt) {
	        case 86:
	          buf.setInt32(0, bp.getNumber(0) * (1 << 24));
	          await ch.sendVINTDataPacket(5, new Uint8Array(buf.buffer));
	          break;

	        case 87:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(7, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvOUT1001(ch, buf) {
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 221:
	      switch (pkt) {
	        case 6:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.VOLTAGE_ERROR
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Voltage Error Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 222:
	      switch (pkt) {
	        case 6:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.VOLTAGE_ERROR
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Voltage Error Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        case 14:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.FAILSAFE_CONDITION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Failsafe procedure initiated."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendOUT1001_Failsafe(ch, bp) {
	  await sendOUT1001(ch, bp);
	}
	function recvOUT1001_Failsafe(ch, buf) {
	  recvOUT1001(ch, buf);
	}
	async function sendOUT1002(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 223:
	      switch (bp.vpkt) {
	        case 86:
	          buf.setInt32(0, bp.getNumber(0) * (1 << 24));
	          await ch.sendVINTDataPacket(5, new Uint8Array(buf.buffer));
	          break;

	        case 87:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(7, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 224:
	      switch (bp.vpkt) {
	        case 86:
	          buf.setInt32(0, bp.getNumber(0) * (1 << 24));
	          await ch.sendVINTDataPacket(5, new Uint8Array(buf.buffer));
	          break;

	        case 87:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(7, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvOUT1002(ch, buf) {
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 223:
	      switch (pkt) {
	        case 6:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.VOLTAGE_ERROR
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Voltage Error Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 224:
	      switch (pkt) {
	        case 6:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.VOLTAGE_ERROR
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Voltage Error Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        case 14:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.FAILSAFE_CONDITION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Failsafe procedure initiated."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendOUT1002_Failsafe(ch, bp) {
	  await sendOUT1002(ch, bp);
	}
	function recvOUT1002_Failsafe(ch, buf) {
	  recvOUT1002(ch, buf);
	}
	async function sendDAQ1200() {
	  throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected command received");
	}
	function recvDAQ1200(ch, buf) {
	  let state;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 226:
	      switch (pkt) {
	        case 8:
	          state = buf.getUint8(1) & 0x1;
	          bp.set({
	            name: "0",
	            type: "d",
	            value: state
	          });
	          bp.sendToChannel(ch, 90);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendOUT1100(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 227:
	      switch (bp.vpkt) {
	        case 82:
	          buf.setUint16(0, bp.getNumber(0) ? 1 << 15 : 0);
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 55:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 15));
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 228:
	      switch (bp.vpkt) {
	        case 82:
	          buf.setUint16(0, bp.getNumber(0) ? 1 << 15 : 0);
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 55:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 15));
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 229:
	      switch (bp.vpkt) {
	        case 82:
	          buf.setUint16(0, bp.getNumber(0) ? 1 << 15 : 0);
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 55:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 15));
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        case 156:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(15, new Uint8Array(buf.buffer));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvOUT1100(ch, buf) {
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 227:
	      throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet received.");

	    case 228:
	    case 229:
	      switch (pkt) {
	        case 13:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.FAILSAFE_CONDITION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Failsafe procedure initiated."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendOUT1100_Failsafe(ch, bp) {
	  await sendOUT1100(ch, bp);
	}
	function recvOUT1100_Failsafe(ch, buf) {
	  recvOUT1100(ch, buf);
	}
	async function sendOUT1100_Failsafe_Frequency(ch, bp) {
	  await sendOUT1100(ch, bp);
	}
	function recvOUT1100_Failsafe_Frequency(ch, buf) {
	  recvOUT1100(ch, buf);
	}
	async function sendDAQ1300() {
	  throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected command received.");
	}
	function recvDAQ1300(ch, buf) {
	  let state;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 230:
	      switch (pkt) {
	        case 8:
	          state = buf.getUint8(1) & 0x1;
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: state
	          });
	          bp.sendToChannel(ch, 90);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendDAQ1301() {
	  throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected command received.");
	}
	function recvDAQ1301(ch, buf) {
	  let state;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 231:
	      switch (pkt) {
	        case 8:
	          state = buf.getUint8(1) & 0x1;
	          bp.set({
	            name: "0",
	            type: "d",
	            value: state
	          });
	          bp.sendToChannel(ch, 90);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendDAQ1400(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 235:
	    case 239:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 74:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(193, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 64:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(194, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 234:
	    case 238:
	      switch (bp.vpkt) {
	        case 74:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(193, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 64:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(194, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 233:
	    case 237:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 24));
	          await ch.sendVINTDataPacket(83, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 74:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(193, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 232:
	    case 236:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 24));
	          await ch.sendVINTDataPacket(16, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 74:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(193, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 79:
	          if (!supportedVoltageSensorType(ch, bp.getNumber(0))) {
	            throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT);
	          }

	          break;

	        case 122:
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvDAQ1400(ch, buf) {
	  let ticksAtLastCount;
	  let counts;
	  let ticks;
	  let current;
	  let voltage;
	  let state;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 235:
	    case 239:
	      switch (pkt) {
	        case 132:
	          ticks = buf.getUint32(1) / 1000;
	          counts = buf.getUint32(5);
	          ticksAtLastCount = buf.getUint32(9) / 1000;
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: ticks
	          });
	          bp.set({
	            name: '1',
	            type: 'u',
	            value: counts
	          });
	          bp.set({
	            name: '2',
	            type: 'g',
	            value: ticksAtLastCount
	          });
	          bp.sendToChannel(ch, 21);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 234:
	    case 238:
	      switch (pkt) {
	        case 8:
	          state = buf.getUint8(1) & 0x01;
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: state
	          });
	          bp.sendToChannel(ch, 90);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 233:
	    case 237:
	      switch (pkt) {
	        case 84:
	          current = buf.getInt32(1) / (1 << 24);

	          if (current < 0.0005) {
	            bp.set({
	              name: '0',
	              type: 'd',
	              value: exports.ErrorEventCode.OUT_OF_RANGE
	            });
	            bp.set({
	              name: '1',
	              type: 's',
	              value: 'Sensor value is ouside the valid range for this sensor.'
	            });
	            ch.sendErrorEvent(bp);
	            break;
	          }

	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(current, 5)
	          });
	          bp.sendToChannel(ch, 8);
	          break;

	        case 85:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Saturation Detected.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 232:
	    case 236:
	      switch (pkt) {
	        case 17:
	          voltage = buf.getInt32(1) / (1 << 24);
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(voltage, 8)
	          });
	          bp.sendToChannel(ch, 101);
	          break;

	        case 18:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Saturation Detected.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendDAQ1400_120(ch, bp) {
	  await sendDAQ1400(ch, bp);
	}
	function recvDAQ1400_120(ch, buf) {
	  recvDAQ1400(ch, buf);
	}
	async function sendDAQ1500(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 240:
	      switch (bp.vpkt) {
	        case 56:
	          buf.setUint8(0, bp.getNumber(0) ? 0xFF : 0x00);
	          await ch.sendVINTDataPacket(30, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint32(0, bp.getNumber(0) * 0x80000000);
	          await ch.sendVINTDataPacket(26, new Uint8Array(buf.buffer));
	          break;

	        case 45:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(29, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvDAQ1500(ch, buf) {
	  let voltageratio;
	  const bp = new BridgePacket();
	  const pkt = buf.getUint8(0);

	  switch (ch.chDef.uid) {
	    case 240:
	      switch (pkt) {
	        case 27:
	          voltageratio = buf.getInt32(1) / (0x80000000 - 1.0);
	          bp.set({
	            name: "0",
	            type: "g",
	            value: voltageratio
	          });
	          bp.sendToChannel(ch, 102);
	          break;

	        case 151:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Saturation Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendVCP1100(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 241:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint32(0, bp.getNumber(0) * 0x00010000);
	          await ch.sendVINTDataPacket(83, new Uint8Array(buf.buffer));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvVCP1100(ch, buf) {
	  let current;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 241:
	      switch (pkt) {
	        case 84:
	          current = buf.getInt32(1) / 65536;
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: current
	          });
	          bp.sendToChannel(ch, 8);
	          break;

	        case 85:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Saturation Detected.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendDCC1000(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(8));

	  switch (ch.chDef.uid) {
	    case 246:
	    case 251:
	    case 257:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint16(0, bp.getNumber(0) * (4095 / 3.3) * 0.045);
	          await ch.sendVINTDataPacket(83, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 245:
	    case 250:
	    case 256:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint16(0, bp.getNumber(0) * 256);
	          await ch.sendVINTDataPacket(58, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 244:
	    case 249:
	    case 255:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 16));
	          await ch.sendVINTDataPacket(26, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 79:
	          if (!supportedVoltageRatioSensorType(ch, bp.getNumber(0))) {
	            throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT);
	          }

	          break;

	        case 122:
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 243:
	    case 248:
	    case 254:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(48, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 65:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(50, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 56:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(51, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 242:
	    case 247:
	      switch (bp.vpkt) {
	        case 40:
	          buf.setUint32(0, bp.getNumber(0) * 8192);
	          await ch.sendVINTDataPacket(90, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 55:
	          buf.setInt32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(100, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 44:
	          buf.setUint32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(101, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 51:
	          buf.setInt32(0, bp.getNumber(0) * 0.045 * 4095 / 3.3 + 2048);
	          await ch.sendVINTDataPacket(98, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 58:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(94, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 119:
	          buf.setUint32(0, (bp.getNumber(0) - 1) * 1804.070707 + 897);
	          await ch.sendVINTDataPacket(102, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 253:
	      switch (bp.vpkt) {
	        case 40:
	          buf.setUint32(0, bp.getNumber(0) * 8192);
	          await ch.sendVINTDataPacket(90, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 55:
	          buf.setInt32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(100, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 44:
	          buf.setUint32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(101, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 51:
	          buf.setInt32(0, bp.getNumber(0) * 0.045 * 4095 / 3.3 + 2048);
	          await ch.sendVINTDataPacket(98, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 58:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(94, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 119:
	          buf.setUint32(0, (bp.getNumber(0) - 1) * 1804.070707 + 897);
	          await ch.sendVINTDataPacket(102, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 252:
	      switch (bp.vpkt) {
	        case 120:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(51, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 135:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(48, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 136:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(49, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 142:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(50, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 83:
	          {
	            const position = bp.getNumber(0);
	            SetBigInt64(buf, 0, position);
	            await ch.sendVINTDataPacket(52, new Uint8Array(buf.buffer));
	            break;
	          }

	        case 40:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(90, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 55:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(100, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 44:
	          buf.setUint32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(101, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 51:
	          buf.setInt32(0, bp.getNumber(0) * 0.045 * 4095 / 3.3 + 2048);
	          await ch.sendVINTDataPacket(98, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 119:
	          buf.setUint32(0, (bp.getNumber(0) - 1) * 1804.070707 + 897);
	          await ch.sendVINTDataPacket(102, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 58:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(94, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 65:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(56, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 57:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(57, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 258:
	      switch (bp.vpkt) {
	        case 120:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(51, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 135:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(48, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 136:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(49, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 142:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(50, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 83:
	          {
	            const position = bp.getNumber(0);
	            SetBigInt64(buf, 0, position);
	            await ch.sendVINTDataPacket(52, new Uint8Array(buf.buffer));
	            break;
	          }

	        case 40:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(90, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 55:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(100, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 44:
	          buf.setUint32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(101, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 51:
	          buf.setInt32(0, bp.getNumber(0) * 0.045 * 4095 / 3.3 + 2048);
	          await ch.sendVINTDataPacket(98, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 119:
	          buf.setUint32(0, (bp.getNumber(0) - 1) * 1804.070707 + 897);
	          await ch.sendVINTDataPacket(102, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 58:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(94, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 65:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(56, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 57:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(57, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvDCC1000(ch, buf) {
	  let dutyCycle, brakingDutyCycle, sign;
	  let temperature, current, voltageRatio;
	  let position;
	  let indexPosition;
	  let timeChange;
	  let indexTriggered;
	  let positionChange;
	  let userphid;
	  const pkt = buf.getUint8(0);
	  let bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 246:
	    case 251:
	    case 257:
	      switch (pkt) {
	        case 84:
	          current = (buf.getUint16(1) - 2048) * 0.017908017;
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(current, 4)
	          });
	          bp.sendToChannel(ch, 8);
	          break;

	        case 85:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Saturation Detected.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 245:
	    case 250:
	    case 256:
	      switch (pkt) {
	        case 59:
	          temperature = buf.getInt32(1) / (1 << 16);
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(temperature, 2)
	          });
	          bp.sendToChannel(ch, 95);
	          break;

	        case 60:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Saturation Detected.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 244:
	    case 249:
	    case 255:
	      switch (pkt) {
	        case 27:
	          voltageRatio = buf.getInt32(1) / (1 << 16);
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(voltageRatio, 5)
	          });
	          bp.sendToChannel(ch, 102);
	          break;

	        case 28:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Saturation Detected.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 243:
	    case 248:
	    case 254:
	      switch (pkt) {
	        case 49:
	          positionChange = buf.getInt32(1);
	          timeChange = buf.getUint32(5) * 1000 / 48;
	          indexTriggered = buf.getUint8(9);

	          if (indexTriggered) {
	            indexPosition = buf.getUint32(10);
	          } else {
	            indexPosition = 0;
	          }

	          bp.set({
	            name: '0',
	            type: 'd',
	            value: positionChange
	          });
	          bp.set({
	            name: '1',
	            type: 'g',
	            value: timeChange / 1000000.0
	          });
	          bp.set({
	            name: '2',
	            type: 'c',
	            value: indexTriggered
	          });
	          bp.set({
	            name: '3',
	            type: 'd',
	            value: indexPosition
	          });
	          bp.sendToChannel(ch, 29);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 242:
	      switch (pkt) {
	        case 96:
	          brakingDutyCycle = buf.getUint16(3) / 65535;
	          sign = buf.getUint8(6) ? -1 : 1;
	          dutyCycle = buf.getUint16(1) / 65535 * sign;
	          userphid = ch.userphid;

	          if (userphid.data.brakingStrength !== brakingDutyCycle) {
	            bp.set({
	              name: '0',
	              type: 'g',
	              value: RoundDouble(brakingDutyCycle, 3)
	            });
	            bp.sendToChannel(ch, 121);
	          }

	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(dutyCycle, 3)
	          });
	          bp.sendToChannel(ch, 16);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 247:
	      switch (pkt) {
	        case 96:
	          brakingDutyCycle = buf.getInt32(5) / 940;
	          dutyCycle = buf.getInt32(1) / 940;
	          userphid = ch.userphid;

	          if (userphid.data.brakingStrength !== brakingDutyCycle) {
	            bp.set({
	              name: '0',
	              type: 'g',
	              value: RoundDouble(brakingDutyCycle, 3)
	            });
	            bp.sendToChannel(ch, 121);
	          }

	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(dutyCycle, 3)
	          });
	          bp.sendToChannel(ch, 16);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 253:
	      switch (pkt) {
	        case 96:
	          brakingDutyCycle = buf.getInt32(5) / 940;
	          dutyCycle = buf.getInt32(1) / 940;
	          userphid = ch.userphid;

	          if (userphid.data.brakingStrength !== brakingDutyCycle) {
	            bp.set({
	              name: '0',
	              type: 'g',
	              value: RoundDouble(brakingDutyCycle, 3)
	            });
	            bp.sendToChannel(ch, 121);
	          }

	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(dutyCycle, 3)
	          });
	          bp.sendToChannel(ch, 16);
	          break;

	        case 93:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.FAILSAFE_CONDITION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Failsafe procedure initiated.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 252:
	      switch (pkt) {
	        case 53:
	          dutyCycle = buf.getInt32(1) / 940;
	          position = GetBigInt64(buf, 5);
	          userphid = ch.userphid;

	          if (userphid.data.position !== position) {
	            bp.set({
	              name: '0',
	              type: 'l',
	              value: position
	            });
	            bp.sendToChannel(ch, 29);
	          }

	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(dutyCycle, 3)
	          });
	          bp.sendToChannel(ch, 16);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 258:
	      switch (pkt) {
	        case 53:
	          dutyCycle = buf.getInt32(1) / 940;
	          position = GetBigInt64(buf, 5);
	          userphid = ch.userphid;

	          if (userphid.data.position !== position) {
	            bp.set({
	              name: '0',
	              type: 'l',
	              value: position
	            });
	            bp.sendToChannel(ch, 29);
	          }

	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(dutyCycle, 3)
	          });
	          bp.sendToChannel(ch, 16);
	          break;

	        case 93:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.FAILSAFE_CONDITION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Failsafe procedure initiated.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendDCC1000_POSITIONCONTROL(ch, bp) {
	  await sendDCC1000(ch, bp);
	}
	function recvDCC1000_POSITIONCONTROL(ch, buf) {
	  recvDCC1000(ch, buf);
	}
	async function sendDCC1000_POSITIONCONTROL_FAILSAFE(ch, bp) {
	  await sendDCC1000(ch, bp);
	}
	function recvDCC1000_POSITIONCONTROL_FAILSAFE(ch, buf) {
	  recvDCC1000(ch, buf);
	}
	async function sendDCC1001(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(8));

	  switch (ch.chDef.uid) {
	    case 270:
	    case 273:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(48, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 65:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(50, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 56:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(51, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 269:
	      switch (bp.vpkt) {
	        case 40:
	          buf.setUint32(0, bp.getNumber(0) * 8192);
	          await ch.sendVINTDataPacket(90, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 55:
	          buf.setInt32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(100, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 44:
	          buf.setUint32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(101, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 51:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(98, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 272:
	      switch (bp.vpkt) {
	        case 40:
	          buf.setUint32(0, bp.getNumber(0) * 8192);
	          await ch.sendVINTDataPacket(90, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 55:
	          buf.setInt32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(100, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 44:
	          buf.setUint32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(101, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 51:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(98, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 271:
	      switch (bp.vpkt) {
	        case 120:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(51, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 135:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(48, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 136:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(49, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 142:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(50, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 83:
	          {
	            const position = bp.getNumber(0);
	            SetBigInt64(buf, 0, position);
	            await ch.sendVINTDataPacket(52, new Uint8Array(buf.buffer));
	            break;
	          }

	        case 40:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(90, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 55:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(100, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 44:
	          buf.setUint32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(101, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 51:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(98, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 57:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(57, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 274:
	      switch (bp.vpkt) {
	        case 120:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(51, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 135:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(48, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 136:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(49, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 142:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(50, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 83:
	          {
	            const position = bp.getNumber(0);
	            SetBigInt64(buf, 0, position);
	            await ch.sendVINTDataPacket(52, new Uint8Array(buf.buffer));
	            break;
	          }

	        case 40:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(90, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 55:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(100, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 44:
	          buf.setUint32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(101, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 51:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(98, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 57:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(57, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvDCC1001(ch, buf) {
	  let dutyCycle, brakingDutyCycle;
	  let indexPosition;
	  let timeChange;
	  let position;
	  let indexTriggered;
	  let positionChange;
	  let userphid;
	  const pkt = buf.getUint8(0);
	  let bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 270:
	    case 273:
	      switch (pkt) {
	        case 49:
	          positionChange = buf.getInt32(1);
	          timeChange = buf.getUint32(5) * 1000 / 48;
	          indexTriggered = buf.getUint8(9);

	          if (indexTriggered) {
	            indexPosition = buf.getUint32(10);
	          } else {
	            indexPosition = 0;
	          }

	          bp.set({
	            name: '0',
	            type: 'd',
	            value: positionChange
	          });
	          bp.set({
	            name: '1',
	            type: 'g',
	            value: timeChange / 1000000.0
	          });
	          bp.set({
	            name: '2',
	            type: 'c',
	            value: indexTriggered
	          });
	          bp.set({
	            name: '3',
	            type: 'd',
	            value: indexPosition
	          });
	          bp.sendToChannel(ch, 29);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 269:
	      switch (pkt) {
	        case 96:
	          brakingDutyCycle = buf.getInt32(5) / 940;
	          dutyCycle = buf.getInt32(1) / 940;
	          userphid = ch.userphid;

	          if (userphid.data.brakingStrength !== brakingDutyCycle) {
	            bp.set({
	              name: '0',
	              type: 'g',
	              value: RoundDouble(brakingDutyCycle, 3)
	            });
	            bp.sendToChannel(ch, 121);
	          }

	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(dutyCycle, 3)
	          });
	          bp.sendToChannel(ch, 16);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 272:
	      switch (pkt) {
	        case 96:
	          brakingDutyCycle = buf.getInt32(5) / 940;
	          dutyCycle = buf.getInt32(1) / 940;
	          userphid = ch.userphid;

	          if (userphid.data.brakingStrength !== brakingDutyCycle) {
	            bp.set({
	              name: '0',
	              type: 'g',
	              value: RoundDouble(brakingDutyCycle, 3)
	            });
	            bp.sendToChannel(ch, 121);
	          }

	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(dutyCycle, 3)
	          });
	          bp.sendToChannel(ch, 16);
	          break;

	        case 93:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.FAILSAFE_CONDITION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Failsafe procedure initiated.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 271:
	      switch (pkt) {
	        case 53:
	          dutyCycle = buf.getInt32(1) / 940;
	          position = GetBigInt64(buf, 5);
	          userphid = ch.userphid;

	          if (userphid.data.position !== position) {
	            bp.set({
	              name: '0',
	              type: 'l',
	              value: position
	            });
	            bp.sendToChannel(ch, 29);
	          }

	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(dutyCycle, 3)
	          });
	          bp.sendToChannel(ch, 16);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 274:
	      switch (pkt) {
	        case 53:
	          dutyCycle = buf.getInt32(1) / 940;
	          position = GetBigInt64(buf, 5);
	          userphid = ch.userphid;

	          if (userphid.data.position !== position) {
	            bp.set({
	              name: '0',
	              type: 'l',
	              value: position
	            });
	            bp.sendToChannel(ch, 29);
	          }

	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(dutyCycle, 3)
	          });
	          bp.sendToChannel(ch, 16);
	          break;

	        case 93:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.FAILSAFE_CONDITION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Failsafe procedure initiated.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendDCC1001_Failsafe(ch, bp) {
	  await sendDCC1001(ch, bp);
	}
	function recvDCC1001_Failsafe(ch, buf) {
	  recvDCC1001(ch, buf);
	}
	async function sendDCC1002(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(8));

	  switch (ch.chDef.uid) {
	    case 276:
	    case 279:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(48, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 65:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(50, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 56:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(51, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 275:
	      switch (bp.vpkt) {
	        case 40:
	          buf.setUint32(0, bp.getNumber(0) * 8192);
	          await ch.sendVINTDataPacket(90, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 55:
	          buf.setInt32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(100, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 44:
	          buf.setUint32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(101, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 51:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(98, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 278:
	      switch (bp.vpkt) {
	        case 40:
	          buf.setUint32(0, bp.getNumber(0) * 8192);
	          await ch.sendVINTDataPacket(90, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 55:
	          buf.setInt32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(100, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 44:
	          buf.setUint32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(101, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 51:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(98, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 277:
	      switch (bp.vpkt) {
	        case 120:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(51, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 135:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(48, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 136:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(49, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 142:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(50, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 83:
	          {
	            const position = bp.getNumber(0);
	            SetBigInt64(buf, 0, position);
	            await ch.sendVINTDataPacket(52, new Uint8Array(buf.buffer));
	            break;
	          }

	        case 40:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(90, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 55:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(100, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 44:
	          buf.setUint32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(101, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 51:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(98, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 57:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(57, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 280:
	      switch (bp.vpkt) {
	        case 120:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(51, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 135:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(48, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 136:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(49, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 142:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(50, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 83:
	          {
	            const position = bp.getNumber(0);
	            SetBigInt64(buf, 0, position);
	            await ch.sendVINTDataPacket(52, new Uint8Array(buf.buffer));
	            break;
	          }

	        case 40:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(90, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 55:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(100, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 44:
	          buf.setUint32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(101, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 51:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(98, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 57:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(57, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvDCC1002(ch, buf) {
	  let dutyCycle, brakingDutyCycle;
	  let indexPosition;
	  let timeChange;
	  let position;
	  let indexTriggered;
	  let positionChange;
	  let userphid;
	  const pkt = buf.getUint8(0);
	  let bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 276:
	    case 279:
	      switch (pkt) {
	        case 49:
	          positionChange = buf.getInt32(1);
	          timeChange = buf.getUint32(5) * 1000 / 48;
	          indexTriggered = buf.getUint8(9);

	          if (indexTriggered) {
	            indexPosition = buf.getUint32(10);
	          } else {
	            indexPosition = 0;
	          }

	          bp.set({
	            name: '0',
	            type: 'd',
	            value: positionChange
	          });
	          bp.set({
	            name: '1',
	            type: 'g',
	            value: timeChange / 1000000.0
	          });
	          bp.set({
	            name: '2',
	            type: 'c',
	            value: indexTriggered
	          });
	          bp.set({
	            name: '3',
	            type: 'd',
	            value: indexPosition
	          });
	          bp.sendToChannel(ch, 29);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 275:
	      switch (pkt) {
	        case 96:
	          brakingDutyCycle = buf.getInt32(5) / 940;
	          dutyCycle = buf.getInt32(1) / 940;
	          userphid = ch.userphid;

	          if (userphid.data.brakingStrength !== brakingDutyCycle) {
	            bp.set({
	              name: '0',
	              type: 'g',
	              value: RoundDouble(brakingDutyCycle, 3)
	            });
	            bp.sendToChannel(ch, 121);
	          }

	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(dutyCycle, 3)
	          });
	          bp.sendToChannel(ch, 16);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 278:
	      switch (pkt) {
	        case 96:
	          brakingDutyCycle = buf.getInt32(5) / 940;
	          dutyCycle = buf.getInt32(1) / 940;
	          userphid = ch.userphid;

	          if (userphid.data.brakingStrength !== brakingDutyCycle) {
	            bp.set({
	              name: '0',
	              type: 'g',
	              value: RoundDouble(brakingDutyCycle, 3)
	            });
	            bp.sendToChannel(ch, 121);
	          }

	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(dutyCycle, 3)
	          });
	          bp.sendToChannel(ch, 16);
	          break;

	        case 93:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.FAILSAFE_CONDITION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Failsafe procedure initiated.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 277:
	      switch (pkt) {
	        case 53:
	          dutyCycle = buf.getInt32(1) / 940;
	          position = GetBigInt64(buf, 5);
	          userphid = ch.userphid;

	          if (userphid.data.position !== position) {
	            bp.set({
	              name: '0',
	              type: 'l',
	              value: position
	            });
	            bp.sendToChannel(ch, 29);
	          }

	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(dutyCycle, 3)
	          });
	          bp.sendToChannel(ch, 16);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 280:
	      switch (pkt) {
	        case 53:
	          dutyCycle = buf.getInt32(1) / 940;
	          position = GetBigInt64(buf, 5);
	          userphid = ch.userphid;

	          if (userphid.data.position !== position) {
	            bp.set({
	              name: '0',
	              type: 'l',
	              value: position
	            });
	            bp.sendToChannel(ch, 29);
	          }

	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(dutyCycle, 3)
	          });
	          bp.sendToChannel(ch, 16);
	          break;

	        case 93:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.FAILSAFE_CONDITION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Failsafe procedure initiated.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendDCC1002_Failsafe(ch, bp) {
	  await sendDCC1002(ch, bp);
	}
	function recvDCC1002_Failsafe(ch, buf) {
	  recvDCC1002(ch, buf);
	}
	async function sendDCC1003(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 281:
	      switch (bp.vpkt) {
	        case 40:
	          buf.setUint32(0, bp.getNumber(0) * 8192);
	          await ch.sendVINTDataPacket(90, new Uint8Array(buf.buffer));
	          break;

	        case 55:
	          buf.setInt32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(100, new Uint8Array(buf.buffer));
	          break;

	        case 44:
	          buf.setInt32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(101, new Uint8Array(buf.buffer));
	          break;

	        case 51:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(98, new Uint8Array(buf.buffer));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 282:
	      switch (bp.vpkt) {
	        case 40:
	          buf.setUint32(0, bp.getNumber(0) * 8192);
	          await ch.sendVINTDataPacket(90, new Uint8Array(buf.buffer));
	          break;

	        case 55:
	          buf.setInt32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(100, new Uint8Array(buf.buffer));
	          break;

	        case 44:
	          buf.setInt32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(101, new Uint8Array(buf.buffer));
	          break;

	        case 51:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(98, new Uint8Array(buf.buffer));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvDCC1003(ch, buf) {
	  let dutyCycle, brakingDutyCycle;
	  const pkt = buf.getUint8(0);
	  let bp = new BridgePacket();
	  const userphid = ch.userphid;

	  switch (ch.chDef.uid) {
	    case 281:
	      switch (pkt) {
	        case 96:
	          brakingDutyCycle = buf.getInt32(5);
	          brakingDutyCycle = brakingDutyCycle / 959.0;
	          dutyCycle = buf.getInt32(1);
	          dutyCycle = dutyCycle / 959.0;

	          if (userphid.data.brakingStrength !== brakingDutyCycle) {
	            bp.set({
	              name: "0",
	              type: "g",
	              value: RoundDouble(brakingDutyCycle, 3)
	            });
	            bp.sendToChannel(ch, 121);
	          }

	          bp = new BridgePacket();
	          bp.set({
	            name: "0",
	            type: "g",
	            value: RoundDouble(dutyCycle, 3)
	          });
	          bp.sendToChannel(ch, 16);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 282:
	      switch (pkt) {
	        case 96:
	          brakingDutyCycle = buf.getInt32(5);
	          brakingDutyCycle = brakingDutyCycle / 959.0;
	          dutyCycle = buf.getInt32(1);
	          dutyCycle = dutyCycle / 959.0;

	          if (userphid.data.brakingStrength !== brakingDutyCycle) {
	            bp.set({
	              name: "0",
	              type: "g",
	              value: RoundDouble(brakingDutyCycle, 3)
	            });
	            bp.sendToChannel(ch, 121);
	          }

	          bp = new BridgePacket();
	          bp.set({
	            name: "0",
	            type: "g",
	            value: RoundDouble(dutyCycle, 3)
	          });
	          bp.sendToChannel(ch, 16);
	          break;

	        case 93:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.FAILSAFE_CONDITION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Failsafe procedure initiated."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendDCC1003_Failsafe(ch, bp) {
	  await sendDCC1003(ch, bp);
	}
	function recvDCC1003_Failsafe(ch, buf) {
	  recvDCC1003(ch, buf);
	}
	async function sendDCC1100(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(8));

	  switch (ch.chDef.uid) {
	    case 285:
	      switch (bp.vpkt) {
	        case 120:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(51, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 135:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(48, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 136:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(49, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 142:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(50, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 83:
	          {
	            const position = bp.getNumber(0);
	            SetBigInt64(buf, 0, position);
	            await ch.sendVINTDataPacket(52, new Uint8Array(buf.buffer));
	            break;
	          }

	        case 40:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(54, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 55:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(55, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 44:
	          buf.setUint32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(36, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 57:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(57, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 141:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(58, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 288:
	      switch (bp.vpkt) {
	        case 120:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(51, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 135:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(48, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 136:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(49, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 142:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(50, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 83:
	          {
	            const position = bp.getNumber(0);
	            SetBigInt64(buf, 0, position);
	            await ch.sendVINTDataPacket(52, new Uint8Array(buf.buffer));
	            break;
	          }

	        case 40:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(54, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 55:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(55, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 44:
	          buf.setUint32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(36, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 57:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(57, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 141:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(58, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 284:
	    case 287:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint16(0, bp.getNumber(0) * 256);
	          await ch.sendVINTDataPacket(58, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 283:
	      switch (bp.vpkt) {
	        case 40:
	          buf.setUint32(0, bp.getNumber(0) * 8192);
	          await ch.sendVINTDataPacket(35, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 55:
	          buf.setInt32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(34, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 44:
	          buf.setUint32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(36, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 51:
	          buf.setInt32(0, bp.getNumber(0) * 0.045 * 4095 / 3.3 + 2048);
	          await ch.sendVINTDataPacket(98, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 141:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(37, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 286:
	      switch (bp.vpkt) {
	        case 40:
	          buf.setUint32(0, bp.getNumber(0) * 8192);
	          await ch.sendVINTDataPacket(35, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 55:
	          buf.setInt32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(34, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 44:
	          buf.setUint32(0, bp.getNumber(0) * 2097151);
	          await ch.sendVINTDataPacket(36, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 51:
	          buf.setInt32(0, bp.getNumber(0) * 0.045 * 4095 / 3.3 + 2048);
	          await ch.sendVINTDataPacket(98, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 141:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(37, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvDCC1100(ch, buf) {
	  let temperature, dutyCycle, brakingDutyCycle;
	  let position;
	  let userphid;
	  const pkt = buf.getUint8(0);
	  let bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 284:
	    case 287:
	      switch (pkt) {
	        case 59:
	          temperature = buf.getInt32(1) / (1 << 16);
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(temperature, 2)
	          });
	          bp.sendToChannel(ch, 95);
	          break;

	        case 60:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Saturation Detected.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 283:
	      switch (pkt) {
	        case 32:
	          dutyCycle = buf.getInt32(1) / 940;
	          brakingDutyCycle = buf.getInt32(5) / 940;
	          position = GetBigInt64(buf, 9);
	          userphid = ch.userphid;

	          if (userphid.data.brakingStrength !== brakingDutyCycle) {
	            bp.set({
	              name: '0',
	              type: 'g',
	              value: RoundDouble(brakingDutyCycle, 3)
	            });
	            bp.sendToChannel(ch, 121);
	          }

	          if (userphid.data.position !== position) {
	            bp = new BridgePacket();
	            bp.set({
	              name: '0',
	              type: 'l',
	              value: position
	            });
	            bp.sendToChannel(ch, 29);
	          }

	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(dutyCycle, 3)
	          });
	          bp.sendToChannel(ch, 16);
	          break;

	        case 38:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.MOTOR_STALL_CONDITION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Dangerous motor stall detected. Velocity has been reduced in order to prevent damage.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 286:
	      switch (pkt) {
	        case 32:
	          dutyCycle = buf.getInt32(1) / 940;
	          brakingDutyCycle = buf.getInt32(5) / 940;
	          position = GetBigInt64(buf, 9);
	          userphid = ch.userphid;

	          if (userphid.data.brakingStrength !== brakingDutyCycle) {
	            bp.set({
	              name: '0',
	              type: 'g',
	              value: RoundDouble(brakingDutyCycle, 3)
	            });
	            bp.sendToChannel(ch, 121);
	          }

	          if (userphid.data.position !== position) {
	            bp = new BridgePacket();
	            bp.set({
	              name: '0',
	              type: 'l',
	              value: position
	            });
	            bp.sendToChannel(ch, 29);
	          }

	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(dutyCycle, 3)
	          });
	          bp.sendToChannel(ch, 16);
	          break;

	        case 38:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.MOTOR_STALL_CONDITION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Dangerous motor stall detected. Velocity has been reduced in order to prevent damage.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        case 93:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.FAILSAFE_CONDITION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Failsafe procedure initiated.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 285:
	      switch (pkt) {
	        case 53:
	          dutyCycle = buf.getInt32(1) / 940;
	          position = GetBigInt64(buf, 5);
	          userphid = ch.userphid;

	          if (userphid.data.position !== position) {
	            bp.set({
	              name: '0',
	              type: 'l',
	              value: position
	            });
	            bp.sendToChannel(ch, 29);
	          }

	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(dutyCycle, 3)
	          });
	          bp.sendToChannel(ch, 16);
	          break;

	        case 38:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.MOTOR_STALL_CONDITION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Dangerous motor stall detected. Velocity has been reduced in order to prevent damage.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 288:
	      switch (pkt) {
	        case 53:
	          dutyCycle = buf.getInt32(1) / 940;
	          position = GetBigInt64(buf, 5);
	          userphid = ch.userphid;

	          if (userphid.data.position !== position) {
	            bp.set({
	              name: '0',
	              type: 'l',
	              value: position
	            });
	            bp.sendToChannel(ch, 29);
	          }

	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(dutyCycle, 3)
	          });
	          bp.sendToChannel(ch, 16);
	          break;

	        case 38:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.MOTOR_STALL_CONDITION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Dangerous motor stall detected. Velocity has been reduced in order to prevent damage.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        case 93:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.FAILSAFE_CONDITION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Failsafe procedure initiated.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendDCC1100_Failsafe(ch, bp) {
	  await sendDCC1100(ch, bp);
	}
	function recvDCC1100_Failsafe(ch, buf) {
	  recvDCC1100(ch, buf);
	}
	async function sendDST1000(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 289:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(149, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvDST1000(ch, buf) {
	  let distance;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 289:
	      switch (pkt) {
	        case 150:
	          distance = buf.getUint16(1, true);
	          bp.set({
	            name: "0",
	            type: "u",
	            value: distance
	          });
	          bp.sendToChannel(ch, 12);
	          break;

	        case 151:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.OUT_OF_RANGE
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Sensor value is outside the valid range for this sensor."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendDST1001(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 290:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(149, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvDST1001(ch, buf) {
	  let distance;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 290:
	      switch (pkt) {
	        case 150:
	          distance = buf.getUint16(1, true);
	          bp.set({
	            name: "0",
	            type: "u",
	            value: distance
	          });
	          bp.sendToChannel(ch, 12);
	          break;

	        case 151:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.OUT_OF_RANGE
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Sensor value is outside the valid range for this sensor."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendDST1002(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 291:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(149, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvDST1002(ch, buf) {
	  let distance;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 291:
	      switch (pkt) {
	        case 150:
	          distance = buf.getUint16(1, true);
	          bp.set({
	            name: "0",
	            type: "u",
	            value: distance
	          });
	          bp.sendToChannel(ch, 12);
	          break;

	        case 151:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.OUT_OF_RANGE
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Sensor value is outside the valid range for this sensor."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendDST1200(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 292:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(149, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 75:
	          buf.setUint8(0, bp.getNumber(0) ? 1 : 0);
	          await ch.sendVINTDataPacket(153, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvDST1200(ch, buf) {
	  const DISTANCE_MAX_REFLECTIONS = 8;
	  const reflections_distance = new Array(DISTANCE_MAX_REFLECTIONS);
	  const reflections_strength = new Array(DISTANCE_MAX_REFLECTIONS);
	  let reflections_count;
	  let distance;
	  let i;
	  const pkt = buf.getUint8(0);
	  let bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 292:
	      switch (pkt) {
	        case 152:
	          reflections_count = buf.getUint8(1);

	          for (i = 0; i < DISTANCE_MAX_REFLECTIONS; i++) {
	            if (i < reflections_count) {
	              reflections_distance[i] = buf.getUint16(2 * i + 2);
	            } else {
	              reflections_distance[i] = 4294967295;
	            }
	          }

	          for (i = 0; i < DISTANCE_MAX_REFLECTIONS; i++) {
	            if (i < reflections_count) {
	              reflections_strength[i] = buf.getUint16(2 * i + 2 * reflections_count + 2);

	              if (reflections_strength[i] === 0x7FFF) {
	                reflections_strength[i] = 4294967295;
	              }
	            } else {
	              reflections_strength[i] = 4294967295;
	            }
	          }

	          if (reflections_count === 0) {
	            bp.set({
	              name: "0",
	              type: "U",
	              value: reflections_distance
	            });
	            bp.set({
	              name: "1",
	              type: "U",
	              value: reflections_strength
	            });
	            bp.set({
	              name: "2",
	              type: "u",
	              value: reflections_count
	            });
	            bp.sendToChannel(ch, 88);
	            break;
	          }

	          bp.set({
	            name: "0",
	            type: "U",
	            value: reflections_distance
	          });
	          bp.set({
	            name: "1",
	            type: "U",
	            value: reflections_strength
	          });
	          bp.set({
	            name: "2",
	            type: "u",
	            value: reflections_count
	          });
	          bp.sendToChannel(ch, 88);
	          bp = new BridgePacket();
	          bp.set({
	            name: "0",
	            type: "u",
	            value: reflections_distance[0]
	          });
	          bp.sendToChannel(ch, 12);
	          break;

	        case 150:
	          distance = buf.getUint32(1);
	          bp.set({
	            name: "0",
	            type: "u",
	            value: distance
	          });
	          bp.sendToChannel(ch, 12);
	          break;

	        case 151:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Saturation Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendENC1000(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 293:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(48, new Uint8Array(buf.buffer));
	          break;

	        case 65:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(50, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 56:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(51, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvENC1000(ch, buf) {
	  let indexPosition;
	  let indexTriggered;
	  let positionChange;
	  let timeChange;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 293:
	      switch (pkt) {
	        case 49:
	          positionChange = buf.getInt32(1);
	          timeChange = buf.getUint32(5) * 1000 / 16;
	          indexTriggered = buf.getUint8(9);

	          if (indexTriggered) {
	            indexPosition = buf.getInt32(10);
	          } else {
	            indexPosition = 0;
	          }

	          bp.set({
	            name: "0",
	            type: "d",
	            value: positionChange
	          });
	          bp.set({
	            name: "1",
	            type: "g",
	            value: timeChange / 1000000.0
	          });
	          bp.set({
	            name: "2",
	            type: "c",
	            value: indexTriggered
	          });
	          bp.set({
	            name: "3",
	            type: "d",
	            value: indexPosition
	          });
	          bp.sendToChannel(ch, 29);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendHIN1101(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 294:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(48, new Uint8Array(buf.buffer));
	          break;

	        case 65:
	          buf.setInt32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(50, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 56:
	          buf.setInt8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(51, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvHIN1101(ch, buf) {
	  let positionChange;
	  let timeChange;
	  let state;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 294:
	      switch (pkt) {
	        case 49:
	          positionChange = buf.getInt32(1);
	          timeChange = buf.getInt32(5) * 1000 / 16;
	          bp.set({
	            name: "0",
	            type: "d",
	            value: positionChange
	          });
	          bp.set({
	            name: "1",
	            type: "g",
	            value: timeChange / 1000000.0
	          });
	          bp.set({
	            name: "2",
	            type: "c",
	            value: 0
	          });
	          bp.set({
	            name: "3",
	            type: "d",
	            value: 0
	          });
	          bp.sendToChannel(ch, 29);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 295:
	      switch (pkt) {
	        case 8:
	          state = buf.getUint8(1) & 0x01;
	          bp.set({
	            name: "0",
	            type: "d",
	            value: state
	          });
	          bp.sendToChannel(ch, 90);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendHIN1000(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 296:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          break;

	        case 66:
	          buf.setUint8(0, (1 - bp.getNumber(0)) * 80 + 20);
	          await ch.sendVINTDataPacket(54, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvHIN1000(ch, buf) {
	  let touched;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 296:
	      switch (pkt) {
	        case 53:
	          touched = buf.getUint8(1) ? 1 : 0;

	          if (touched) {
	            bp.set({
	              name: "0",
	              type: "g",
	              value: touched
	            });
	            bp.sendToChannel(ch, 96);
	            break;
	          }

	          bp.sendToChannel(ch, 137);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendHIN1001(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 297:
	    case 298:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 15));
	          await ch.sendVINTDataPacket(55, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 66:
	          if (ch.index === 4) {
	            buf.setUint8(0, (1 - bp.getNumber(0)) * 32 + 1);
	          } else {
	            buf.setUint8(0, (1 - bp.getNumber(0)) * 64 + 1);
	          }

	          await ch.sendVINTDataPacket(54, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvHIN1001(ch, buf) {
	  let value;
	  let touched;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 297:
	    case 298:
	      switch (pkt) {
	        case 53:
	          touched = buf.getUint8(1) ? 1 : 0;

	          if (ch.index < 4) {
	            value = touched;
	          } else {
	            value = buf.getUint16(2) / 65536.0;
	          }

	          if (touched) {
	            bp.set({
	              name: "0",
	              type: "g",
	              value: value
	            });
	            bp.sendToChannel(ch, 96);
	            break;
	          }

	          bp.sendToChannel(ch, 137);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendHIN1100(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 299:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint16(0, bp.getNumber(0) * 16384);
	          await ch.sendVINTDataPacket(26, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvHIN1100(ch, buf) {
	  let axis;
	  let value;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 299:
	      switch (pkt) {
	        case 27:
	          axis = RoundDouble(buf.getInt16(1) / 16384, 4);
	          bp.set({
	            name: "0",
	            type: "g",
	            value: axis
	          });
	          bp.sendToChannel(ch, 102);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 300:
	      switch (pkt) {
	        case 8:
	          value = buf.getUint8(1) ? 1 : 0;
	          bp.set({
	            name: "0",
	            type: "d",
	            value: value
	          });
	          bp.sendToChannel(ch, 90);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendHUM1000(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 302:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 16));
	          await ch.sendVINTDataPacket(58, new Uint8Array(buf.buffer));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 301:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 16));
	          await ch.sendVINTDataPacket(68, new Uint8Array(buf.buffer));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvHUM1000(ch, buf) {
	  let temperature;
	  let humidity;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 302:
	      switch (pkt) {
	        case 59:
	          temperature = buf.getInt32(1) / (1 << 16);
	          bp.set({
	            name: "0",
	            type: "g",
	            value: RoundDouble(temperature, 2)
	          });
	          bp.sendToChannel(ch, 95);
	          break;

	        case 60:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Saturation Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 301:
	      switch (pkt) {
	        case 69:
	          humidity = buf.getInt32(1) / (1 << 16);
	          bp.set({
	            name: "0",
	            type: "g",
	            value: RoundDouble(humidity, 2)
	          });
	          bp.sendToChannel(ch, 22);
	          break;

	        case 70:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Saturation Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendHUM1001(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 303:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 16));
	          await ch.sendVINTDataPacket(68, new Uint8Array(buf.buffer));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 304:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 16));
	          await ch.sendVINTDataPacket(58, new Uint8Array(buf.buffer));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvHUM1001(ch, buf) {
	  let temperature;
	  let humidity;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 303:
	      switch (pkt) {
	        case 69:
	          humidity = buf.getInt32(1) / (1 << 16);
	          bp.set({
	            name: "0",
	            type: "g",
	            value: RoundDouble(humidity, 2)
	          });
	          bp.sendToChannel(ch, 22);
	          break;

	        case 70:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Saturation Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 304:
	      switch (pkt) {
	        case 59:
	          temperature = buf.getInt32(1) / (1 << 16);
	          bp.set({
	            name: "0",
	            type: "g",
	            value: RoundDouble(temperature, 2)
	          });
	          bp.sendToChannel(ch, 95);
	          break;

	        case 60:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Saturation Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendLCD1100_WRITETEXT(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(48));
	  const userphid = ch.userphid;
	  const font = bp.getNumber(0);
	  let xpos = bp.getNumber(1);
	  const ypos = bp.getNumber(2);
	  const chars = bp.getString(3);
	  const fontSize = userphid.getFontSize(font);
	  const frameBuffer = userphid.data.frameBuffer;
	  const width = userphid.data.width;
	  const height = userphid.data.height;
	  let numchars = chars.length;

	  if (font == frameBuffer) {
	    throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Invalid font/framebuffer combination.");
	  }

	  numchars = Math.min(width - xpos, fontSize.width * numchars) / fontSize.width;

	  if (ypos + fontSize.height > height) {
	    numchars = 0;
	  }

	  if (numchars === 0) {
	    return;
	  }

	  let numsent = 0;

	  while (numsent < numchars) {
	    const count = Math.min(VINT_MAX_OUT_PACKETSIZE - 6, numchars - numsent);
	    buf.setUint8(0, font);
	    buf.setUint8(1, fontSize.width);
	    buf.setUint8(2, fontSize.height);
	    buf.setUint8(3, xpos);
	    buf.setUint8(4, ypos);
	    buf.setUint8(5, count);

	    for (let i = 0; i < count; i++) buf.setUint8(i + 6, chars.charCodeAt(numsent++));

	    xpos += count * fontSize.width;
	    await ch.sendVINTDataPacket(37, new Uint8Array(buf.buffer, 0, count + 6));
	  }
	}
	async function sendLCD1100_WRITEBITMAP(ch, bp) {
	  let buf = new DataView(new ArrayBuffer(48));
	  let count = 0;
	  const bitmap = bp.getArray(4);
	  const xsize = bp.getNumber(2);
	  const ysize = bp.getNumber(3);
	  buf.setUint8(0, bp.getNumber(0));
	  buf.setUint8(1, bp.getNumber(1));
	  buf.setUint8(2, xsize);
	  buf.setUint8(3, ysize);
	  await ch.sendVINTDataPacket(38, new Uint8Array(buf.buffer, 0, 4));
	  let x = 0;
	  let y = 0;

	  while (x < xsize) {
	    buf = new DataView(new ArrayBuffer(48));

	    for (let i = 0; i < VINT_MAX_OUT_PACKETSIZE * 8 && x < xsize; i++) {
	      const byteIdx = Math.floor(i / 8);
	      count = byteIdx + 1;
	      const bit = 1 << 7 - i % 8 & (bitmap[y * xsize + x] ? 0xFF : 0x00);
	      const newbyte = buf.getUint8(byteIdx) | bit;
	      buf.setUint8(byteIdx, newbyte);
	      y++;

	      if (y >= ysize) {
	        x++;
	        y = 0;
	      }
	    }

	    await ch.sendVINTDataPacket(39, new Uint8Array(buf.buffer, 0, count));
	  }
	}
	async function sendLCD1100_SETCHARACTERBITMAP(ch, bp) {
	  const userphid = ch.userphid;
	  const font = bp.getNumber(0);
	  const characterStr = bp.getString(1);
	  const bitmap = bp.getArray(2);
	  if (font != exports.LCDFont.USER1 && font != exports.LCDFont.USER2) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Font must be user font 1 or 2.");
	  const frameBuffer = userphid.frameBuffer;
	  const maxchars = userphid.getMaxCharacters(font);
	  const fontSize = userphid.getFontSize(font);
	  const lcdw = userphid.width;
	  if (characterStr.length != 1) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Multibyte characters are unsupported.");
	  let character = characterStr.charCodeAt(0);
	  character -= 1;
	  if (character < 0 || character > maxchars) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Character code must be between 0x00 and 0x" + maxchars.toString(16) + " ('" + String.fromCharCode(maxchars) + "'). Number of supported characters depends on the font size.");

	  if (frameBuffer != font) {
	    const buf = new DataView(new ArrayBuffer(1));
	    buf.setUint8(0, font);
	    await ch.sendVINTDataPacket(43, new Uint8Array(buf.buffer, 0, 1));
	  }

	  const buf = new DataView(new ArrayBuffer(4));
	  buf.setUint8(0, fontSize.width * (character % Math.floor(lcdw / fontSize.width)));
	  buf.setUint8(1, fontSize.height * Math.floor(character / Math.floor(lcdw / fontSize.width)));
	  buf.setUint8(2, fontSize.width);
	  buf.setUint8(3, fontSize.height);
	  await ch.sendVINTDataPacket(38, new Uint8Array(buf.buffer, 0, 4));
	  let x = 0;
	  let y = 0;

	  while (x < fontSize.width) {
	    const buf = new DataView(new ArrayBuffer(VINT_MAX_OUT_PACKETSIZE));
	    let count;

	    for (let i = 0; i < VINT_MAX_OUT_PACKETSIZE * 8 && x < fontSize.width; i++) {
	      const byteIdx = Math.floor(i / 8);
	      count = byteIdx + 1;
	      const bit = 1 << 7 - i % 8 & (bitmap[y * fontSize.width + x] ? 0xFF : 0x00);
	      const newbyte = buf.getUint8(byteIdx) | bit;
	      buf.setUint8(byteIdx, newbyte);
	      y++;

	      if (y >= fontSize.height) {
	        x++;
	        y = 0;
	      }
	    }

	    await ch.sendVINTDataPacket(39, new Uint8Array(buf.buffer, 0, count));
	  }

	  if (frameBuffer != font) {
	    const buf = new DataView(new ArrayBuffer(1));
	    buf.setUint8(0, frameBuffer);
	    await ch.sendVINTDataPacket(43, new Uint8Array(buf.buffer, 0, 1));
	  }
	}
	async function sendLCD1100(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(48));
	  const userphid = ch.userphid;

	  switch (ch.chDef.uid) {
	    case 305:
	      await userphid._transactionLock.acquire();

	      try {
	        switch (bp.vpkt) {
	          case 38:
	            {
	              const fb = bp.getNumber(0);

	              if (fb < 0 || fb > 2) {
	                throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Framebuffer must be 0, 1 or 2.");
	              }

	              buf.setUint8(0, fb);
	              await ch.sendVINTDataPacket(44, new Uint8Array(buf.buffer, 0, 1));
	              break;
	            }

	          case 62:
	            buf.setUint8(0, bp.getNumber(0));
	            await ch.sendVINTDataPacket(43, new Uint8Array(buf.buffer, 0, 1));
	            break;

	          case 43:
	            if (bp.getNumber(0) >= 1) {
	              buf.setUint8(0, 0xFF);
	            } else {
	              buf.setUint8(0, bp.getNumber(0) * (1 << 8));
	            }

	            await ch.sendVINTDataPacket(32, new Uint8Array(buf.buffer, 0, 1));
	            break;

	          case 48:
	            if (bp.getNumber(0) >= 1) {
	              buf.setUint8(0, 0xFF);
	            } else {
	              buf.setUint8(0, bp.getNumber(0) * (1 << 8));
	            }

	            await ch.sendVINTDataPacket(33, new Uint8Array(buf.buffer, 0, 1));
	            break;

	          case 14:
	            buf.setUint8(0, bp.getNumber(0));
	            buf.setUint8(1, bp.getNumber(1));
	            buf.setUint8(2, bp.getNumber(2));
	            await ch.sendVINTDataPacket(34, new Uint8Array(buf.buffer, 0, 3));
	            break;

	          case 13:
	            buf.setUint8(0, bp.getNumber(0));
	            buf.setUint8(1, bp.getNumber(1));
	            buf.setUint8(2, bp.getNumber(2));
	            buf.setUint8(3, bp.getNumber(3));
	            await ch.sendVINTDataPacket(35, new Uint8Array(buf.buffer, 0, 4));
	            break;

	          case 15:
	            buf.setUint8(0, bp.getNumber(0));
	            buf.setUint8(1, bp.getNumber(1));
	            buf.setUint8(2, bp.getNumber(2));
	            buf.setUint8(3, bp.getNumber(3));
	            buf.setUint8(4, bp.getNumber(4) ? 0xFF : 0x00);
	            buf.setUint8(5, bp.getNumber(5) ? 0xFF : 0x00);
	            await ch.sendVINTDataPacket(36, new Uint8Array(buf.buffer, 0, 6));
	            break;

	          case 105:
	            await sendLCD1100_WRITETEXT(ch, bp);
	            break;

	          case 104:
	            await sendLCD1100_WRITEBITMAP(ch, bp);
	            break;

	          case 19:
	            await ch.sendVINTDataPacket(40);
	            break;

	          case 4:
	            await ch.sendVINTDataPacket(41);
	            break;

	          case 80:
	            buf.setUint8(0, bp.getNumber(0) ? 0xFF : 0x00);
	            await ch.sendVINTDataPacket(42, new Uint8Array(buf.buffer, 0, 1));
	            break;

	          case 47:
	            await sendLCD1100_SETCHARACTERBITMAP(ch, bp);
	            break;

	          case 6:
	            buf.setUint8(0, bp.getNumber(0));
	            buf.setUint8(1, bp.getNumber(1));
	            buf.setUint8(2, bp.getNumber(2));
	            buf.setUint8(3, bp.getNumber(3));
	            buf.setUint8(4, bp.getNumber(4));
	            buf.setUint8(5, bp.getNumber(5));
	            buf.setUint8(6, bp.getNumber(6));
	            buf.setUint8(7, bp.getNumber(7));
	            buf.setUint8(8, bp.getNumber(8) ? 0xFF : 0x00);
	            await ch.sendVINTDataPacket(45, new Uint8Array(buf.buffer, 0, 9));
	            break;

	          case 24:
	            await ch.sendVINTDataPacket(47);
	            break;

	          case 61:
	            break;

	          default:
	            throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	        }

	        break;
	      } finally {
	        userphid._transactionLock.release();
	      }

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvLCD1100() {
	  throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet received.");
	}
	async function sendLED1000(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 306:
	      switch (bp.vpkt) {
	        case 82:
	          buf.setUint16(0, bp.getNumber(0) ? 1 << 15 : 0);
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 55:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 15));
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 68:
	          buf.setUint8(0, bp.getNumber(0));

	          switch (buf.getUint8(0)) {
	            case exports.LEDForwardVoltage.VOLTS_3_2:
	            case exports.LEDForwardVoltage.VOLTS_4_0:
	            case exports.LEDForwardVoltage.VOLTS_4_8:
	            case exports.LEDForwardVoltage.VOLTS_5_6:
	              await ch.sendVINTDataPacket(12, new Uint8Array(buf.buffer, 0, 1));
	              break;

	            default:
	              throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Invalid or unsupported voltage for this device.");
	          }

	          break;

	        case 67:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 16));
	          await ch.sendVINTDataPacket(11, new Uint8Array(buf.buffer));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvLED1000() {
	  throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet received.");
	}
	async function sendLUX1000(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 307:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 14));
	          await ch.sendVINTDataPacket(80, new Uint8Array(buf.buffer));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvLUX1000(ch, buf) {
	  let illuminance;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 307:
	      switch (pkt) {
	        case 81:
	          illuminance = buf.getInt32(1) / (1 << 14);
	          illuminance = illuminance < 100 ? RoundDouble(illuminance, 4) : RoundDouble(illuminance, 2);
	          bp.set({
	            name: "0",
	            type: "g",
	            value: illuminance
	          });
	          bp.sendToChannel(ch, 23);
	          break;

	        case 82:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Saturation Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendHUM1100(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 308:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint16(0, bp.getNumber(0) * 0xFFFF);
	          await ch.sendVINTDataPacket(26, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvHUM1100(ch, buf) {
	  let value;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 308:
	      switch (pkt) {
	        case 27:
	          value = buf.getUint16(1) / 65535.0;
	          bp.set({
	            name: "0",
	            type: "g",
	            value: RoundDouble(value, 3)
	          });
	          bp.sendToChannel(ch, 102);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendMOT1100(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 310:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(195, new Uint8Array(buf.buffer));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvMOT1100(ch, buf) {
	  let timestamp;
	  const acc = [0, 0, 0];
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 310:
	      switch (pkt) {
	        case 196:
	          acc[0] = buf.getInt16(1) / (1 << 12);
	          acc[0] = RoundDouble(acc[0], 4);
	          acc[1] = buf.getInt16(3) / (1 << 12);
	          acc[1] = RoundDouble(acc[1], 4);
	          acc[2] = buf.getInt16(5) / (1 << 12);
	          acc[2] = RoundDouble(acc[2], 4);
	          timestamp = buf.getUint32(7);
	          bp.set({
	            name: "0",
	            type: "G",
	            value: acc
	          });
	          bp.set({
	            name: "1",
	            type: "g",
	            value: timestamp
	          });
	          bp.sendToChannel(ch, 1);
	          break;

	        case 198:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Acceleration Saturation."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendMOT1101(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 313:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(195, new Uint8Array(buf.buffer));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 314:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 106:
	          await ch.sendVINTDataPacket(51);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 315:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(195, new Uint8Array(buf.buffer));
	          break;

	        case 35:
	          await ch.sendVINTDataPacket(77);
	          break;

	        case 37:
	          await ch.sendVINTDataPacket(79);
	          break;

	        case 50:
	          await sendMOT1101_SETCORRECTIONPARAMETERS(ch, bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 316:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 106:
	          await ch.sendVINTDataPacket(51);
	          break;

	        case 35:
	          await ch.sendVINTDataPacket(77);
	          break;

	        case 37:
	          await ch.sendVINTDataPacket(79);
	          break;

	        case 50:
	          await sendMOT1101_SETCORRECTIONPARAMETERS(ch, bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvMOT1101(ch, buf) {
	  let fireSaturation = 0;
	  let timestamp;
	  const compass = [0, 0, 0];
	  const accel = [0, 0, 0];
	  const gyro = [0, 0, 0];
	  const pkt = buf.getUint8(0);
	  let i;
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 313:
	      switch (pkt) {
	        case 196:
	          accel[0] = RoundDouble(buf.getInt16(1) / (1 << 12), 4);
	          accel[1] = RoundDouble(buf.getInt16(3) / (1 << 12), 4);
	          accel[2] = RoundDouble(buf.getInt16(5) / (1 << 12), 4);
	          timestamp = buf.getUint32(7);
	          bp.set({
	            name: "0",
	            type: "G",
	            value: accel
	          });
	          bp.set({
	            name: "1",
	            type: "g",
	            value: timestamp
	          });
	          bp.sendToChannel(ch, 1);
	          break;

	        case 198:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Saturation Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 314:
	      switch (pkt) {
	        case 197:
	          gyro[0] = RoundDouble(buf.getFloat32(1, true), 5);
	          gyro[1] = RoundDouble(buf.getFloat32(5, true), 5);
	          gyro[2] = RoundDouble(buf.getFloat32(9, true), 5);
	          timestamp = buf.getUint32(13);
	          bp.set({
	            name: "0",
	            type: "G",
	            value: gyro
	          });
	          bp.set({
	            name: "1",
	            type: "g",
	            value: timestamp
	          });
	          bp.sendToChannel(ch, 2);
	          break;

	        case 198:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Saturation Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 315:
	      switch (pkt) {
	        case 196:
	          compass[0] = RoundDouble(buf.getInt16(1) / (1 << 12), 4);
	          compass[1] = RoundDouble(buf.getInt16(3) / (1 << 12), 4);
	          compass[2] = RoundDouble(buf.getInt16(5) / (1 << 12), 4);
	          timestamp = buf.getUint32(7);
	          bp.set({
	            name: "0",
	            type: "G",
	            value: compass
	          });
	          bp.set({
	            name: "1",
	            type: "g",
	            value: timestamp
	          });
	          bp.sendToChannel(ch, 18);
	          break;

	        case 198:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Saturation Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 316:
	      switch (pkt) {
	        case 196:
	          for (i = 0; i < 3; i++) {
	            if (buf.getUint8(1 + i * 2) === 0x7F && buf.getUint8(2 + i * 2) === 0xFF || buf.getUint8(1 + i * 2) === 0x80 && buf.getUint8(2 + i * 2) === 0x00) {
	              fireSaturation |= 0x04;
	            } else {
	              compass[i] = RoundDouble(buf.getInt16(1 + i * 2) / (1 << 12), 5);
	            }
	          }

	          for (i = 0; i < 3; i++) {
	            if (buf.getUint8(7 + i * 2) === 0x7F && buf.getUint8(8 + i * 2) === 0xFF || buf.getUint8(7 + i * 2) === 0x80 && buf.getUint8(8 + i * 2) === 0x00) {
	              fireSaturation |= 0x01;
	            } else {
	              accel[i] = RoundDouble(buf.getInt16(7 + i * 2) / (1 << 12), 5);
	            }
	          }

	          for (i = 0; i < 3; i++) {
	            const tmp = buf.getFloat32(13 + i * 4, true);

	            if (tmp === 1e+30 || tmp === -1e+30) {
	              fireSaturation |= 0x02;
	            } else {
	              gyro[i] = RoundDouble(tmp, 5);
	            }
	          }

	          if (fireSaturation === 0) {
	            timestamp = buf.getUint32(25);
	            bp.set({
	              name: "0",
	              type: "G",
	              value: accel
	            });
	            bp.set({
	              name: "1",
	              type: "G",
	              value: gyro
	            });
	            bp.set({
	              name: "2",
	              type: "G",
	              value: compass
	            });
	            bp.set({
	              name: "3",
	              type: "g",
	              value: timestamp
	            });
	            bp.sendToChannel(ch, 89);
	          } else {
	            let saturationError = true;

	            if (fireSaturation & 0x01) {
	              bp.set({
	                name: "0",
	                type: "d",
	                value: exports.ErrorEventCode.SATURATION
	              });
	              bp.set({
	                name: "1",
	                type: "s",
	                value: "Acceleration Saturation Detected."
	              });
	              ch.sendErrorEvent(bp);
	              saturationError = false;
	            }

	            if (fireSaturation & 0x02) {
	              bp.set({
	                name: "0",
	                type: "d",
	                value: exports.ErrorEventCode.SATURATION
	              });
	              bp.set({
	                name: "1",
	                type: "s",
	                value: "Gyroscope Saturation Detected."
	              });
	              ch.sendErrorEvent(bp);
	              saturationError = false;
	            }

	            if (fireSaturation & 0x04) {
	              bp.set({
	                name: "0",
	                type: "d",
	                value: exports.ErrorEventCode.SATURATION
	              });
	              bp.set({
	                name: "1",
	                type: "s",
	                value: "Magnetometer Saturation Detected."
	              });
	              ch.sendErrorEvent(bp);
	              saturationError = false;
	            }

	            if (saturationError) {
	              throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected saturation flag. This is likely a firmware bug.");
	            }
	          }

	          break;

	        case 198:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Saturation Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendMOT1101_SETCORRECTIONPARAMETERS(ch, bp) {
	  const firmware_userMagnetometerTransform = [0, 0, 0, 0, 0, 0];
	  const firmware_userMagnetometerOffset = [0, 0, 0];
	  const firmware_userMagnetometerGain = [0, 0, 0];
	  const buf = new DataView(new ArrayBuffer(28));
	  const firmware_userMagField = bp.getNumber(0);

	  for (let i = 0; i < 3; i++) {
	    firmware_userMagnetometerOffset[i] = bp.getNumber((i + 1).toString());
	    firmware_userMagnetometerGain[i] = bp.getNumber((i + 4).toString());
	  }

	  for (let i = 0; i < 6; i++) {
	    firmware_userMagnetometerTransform[i] = bp.getNumber((i + 7).toString());
	  }

	  buf.setFloat32(0, firmware_userMagField, true);

	  for (let i = 0; i < 3; i++) {
	    buf.setFloat32(4 + i * 4, firmware_userMagnetometerOffset[i], true);
	    buf.setFloat32(16 + i * 4, firmware_userMagnetometerGain[i], true);
	  }

	  await ch.sendVINTDataPacket(78, new Uint8Array(buf.buffer));

	  for (let i = 0; i < 6; i++) {
	    buf.setFloat32(i * 4, firmware_userMagnetometerTransform[i], true);
	  }

	  await ch.sendVINTDataPacket(78, new Uint8Array(buf.buffer, 0, 24));
	}
	async function sendMOT1102(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(24));
	  let userphid;

	  switch (ch.chDef.uid) {
	    case 318:
	    case 322:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(195, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 319:
	    case 323:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 106:
	          await ch.sendVINTDataPacket(51);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 320:
	    case 324:
	      userphid = ch.userphid;
	      await userphid.transactionLock.acquire();

	      try {
	        switch (bp.vpkt) {
	          case 54:
	            buf.setUint16(0, bp.getNumber(0));
	            await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	            break;

	          case 46:
	            buf.setFloat32(0, bp.getNumber(0), true);
	            await ch.sendVINTDataPacket(195, new Uint8Array(buf.buffer, 0, 4));
	            break;

	          case 35:
	            await ch.sendVINTDataPacket(77);
	            break;

	          case 37:
	            await ch.sendVINTDataPacket(79);
	            break;

	          case 50:
	            await sendMOT1102_SETCORRECTIONPARAMETERS(ch, bp);
	            break;

	          default:
	            throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	        }
	      } finally {
	        userphid.transactionLock.release();
	      }

	      break;

	    case 321:
	    case 325:
	      userphid = ch.userphid;
	      await userphid._transactionLock.acquire();

	      try {
	        switch (bp.vpkt) {
	          case 54:
	            buf.setUint16(0, bp.getNumber(0));
	            await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	            break;

	          case 106:
	            await ch.sendVINTDataPacket(51);
	            break;

	          case 35:
	            await ch.sendVINTDataPacket(77);
	            break;

	          case 37:
	            await ch.sendVINTDataPacket(79);
	            break;

	          case 50:
	            await sendMOT1102_SETCORRECTIONPARAMETERS(ch, bp);
	            break;

	          case 150:
	            await ch.sendVINTDataPacket(80);
	            break;

	          case 149:
	            buf.setUint8(0, bp.getNumber(0));
	            await ch.sendVINTDataPacket(81, new Uint8Array(buf.buffer, 0, 1));
	            break;

	          case 151:
	            buf.setFloat32(0, bp.getNumber(0), true);
	            await ch.sendVINTDataPacket(82, new Uint8Array(buf.buffer, 0, 4));
	            break;

	          case 174:
	            buf.setFloat32(0, bp.getNumber(0), true);
	            buf.setFloat32(4, bp.getNumber(1), true);
	            buf.setFloat32(8, bp.getNumber(2), true);
	            buf.setFloat32(12, bp.getNumber(3), true);
	            buf.setFloat32(16, bp.getNumber(4), true);
	            buf.setFloat32(20, bp.getNumber(5), true);
	            await ch.sendVINTDataPacket(84, new Uint8Array(buf.buffer));
	            break;

	          default:
	            throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	        }
	      } finally {
	        userphid._transactionLock.release();
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvMOT1102(ch, buf) {
	  let fireSaturation = 0;
	  let timestamp;
	  const compass = [0, 0, 0];
	  const accel = [0, 0, 0];
	  const gyro = [0, 0, 0];
	  const quaternion = [0, 0, 0, 0];
	  const pkt = buf.getUint8(0);
	  let i;
	  let bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 318:
	    case 322:
	      switch (pkt) {
	        case 196:
	          accel[0] = RoundDouble(buf.getInt16(1) / (1 << 12), 4);
	          accel[1] = RoundDouble(buf.getInt16(3) / (1 << 12), 4);
	          accel[2] = RoundDouble(buf.getInt16(5) / (1 << 12), 4);
	          timestamp = buf.getUint32(7);
	          bp.set({
	            name: "0",
	            type: "G",
	            value: accel
	          });
	          bp.set({
	            name: "1",
	            type: "g",
	            value: timestamp
	          });
	          bp.sendToChannel(ch, 1);
	          break;

	        case 198:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Saturation Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 319:
	    case 323:
	      switch (pkt) {
	        case 197:
	          gyro[0] = RoundDouble(buf.getFloat32(1, true), 5);
	          gyro[1] = RoundDouble(buf.getFloat32(5, true), 5);
	          gyro[2] = RoundDouble(buf.getFloat32(9, true), 5);
	          timestamp = buf.getUint32(13);
	          bp.set({
	            name: "0",
	            type: "G",
	            value: gyro
	          });
	          bp.set({
	            name: "1",
	            type: "g",
	            value: timestamp
	          });
	          bp.sendToChannel(ch, 2);
	          break;

	        case 198:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Saturation Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        case 199:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.INVALID_STATE_CONDITION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "The gyroscope has received invalid data and will recover shortly."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 320:
	    case 324:
	      switch (pkt) {
	        case 196:
	          compass[0] = RoundDouble(buf.getInt16(1) / (1 << 12), 4);
	          compass[1] = RoundDouble(buf.getInt16(3) / (1 << 12), 4);
	          compass[2] = RoundDouble(buf.getInt16(5) / (1 << 12), 4);
	          timestamp = buf.getUint32(7);
	          bp.set({
	            name: "0",
	            type: "G",
	            value: compass
	          });
	          bp.set({
	            name: "1",
	            type: "g",
	            value: timestamp
	          });
	          bp.sendToChannel(ch, 18);
	          break;

	        case 198:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Saturation Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 321:
	    case 325:
	      switch (pkt) {
	        case 196:
	          for (i = 0; i < 3; i++) {
	            if (buf.getUint8(1 + i * 2) === 0x7F && buf.getUint8(2 + i * 2) === 0xFF || buf.getUint8(1 + i * 2) === 0x80 && buf.getUint8(2 + i * 2) === 0x00) {
	              fireSaturation |= 0x04;
	            } else {
	              compass[i] = RoundDouble(buf.getInt16(1 + i * 2) / (1 << 12), 5);
	            }
	          }

	          for (i = 0; i < 3; i++) {
	            if (buf.getUint8(7 + i * 2) === 0x7F && buf.getUint8(8 + i * 2) === 0xFF || buf.getUint8(7 + i * 2) === 0x80 && buf.getUint8(8 + i * 2) === 0x00) {
	              fireSaturation |= 0x01;
	            } else {
	              accel[i] = RoundDouble(buf.getInt16(7 + i * 2) / (1 << 12), 5);
	            }
	          }

	          for (i = 0; i < 3; i++) {
	            const tmp = buf.getFloat32(13 + i * 4, true);

	            if (tmp === 1e+30 || tmp === -1e+30) {
	              fireSaturation |= 0x02;
	            } else {
	              gyro[i] = RoundDouble(tmp, 5);
	            }
	          }

	          quaternion[0] = buf.getFloat32(29, true);
	          quaternion[1] = buf.getFloat32(33, true);
	          quaternion[2] = buf.getFloat32(37, true);
	          quaternion[3] = buf.getFloat32(41, true);

	          if (fireSaturation === 0) {
	            timestamp = buf.getUint32(25);
	            bp.set({
	              name: "0",
	              type: "G",
	              value: accel
	            });
	            bp.set({
	              name: "1",
	              type: "G",
	              value: gyro
	            });
	            bp.set({
	              name: "2",
	              type: "G",
	              value: compass
	            });
	            bp.set({
	              name: "3",
	              type: "g",
	              value: timestamp
	            });
	            bp.sendToChannel(ch, 89);
	            bp = new BridgePacket();
	            bp.set({
	              name: "0",
	              type: "G",
	              value: quaternion
	            });
	            bp.set({
	              name: "1",
	              type: "g",
	              value: timestamp
	            });
	            bp.sendToChannel(ch, 148);
	          } else {
	            let saturationError = true;

	            if (fireSaturation & 0x01) {
	              bp.set({
	                name: "0",
	                type: "d",
	                value: exports.ErrorEventCode.SATURATION
	              });
	              bp.set({
	                name: "1",
	                type: "s",
	                value: "Acceleration Saturation Detected."
	              });
	              ch.sendErrorEvent(bp);
	              saturationError = false;
	            }

	            if (fireSaturation & 0x02) {
	              bp.set({
	                name: "0",
	                type: "d",
	                value: exports.ErrorEventCode.SATURATION
	              });
	              bp.set({
	                name: "1",
	                type: "s",
	                value: "Gyroscope Saturation Detected."
	              });
	              ch.sendErrorEvent(bp);
	              saturationError = false;
	            }

	            if (fireSaturation & 0x04) {
	              bp.set({
	                name: "0",
	                type: "d",
	                value: exports.ErrorEventCode.SATURATION
	              });
	              bp.set({
	                name: "1",
	                type: "s",
	                value: "Magnetometer Saturation Detected."
	              });
	              ch.sendErrorEvent(bp);
	              saturationError = false;
	            }

	            if (saturationError) {
	              throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected saturation flag. This is likely a firmware bug.");
	            }
	          }

	          break;

	        case 198:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Saturation Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        case 199:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.INVALID_STATE_CONDITION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "The gyroscope has received invalid data and will recover shortly."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendMOT1102_SETCORRECTIONPARAMETERS(ch, bp) {
	  const firmware_userMagnetometerTransform = [0, 0, 0, 0, 0, 0];
	  const firmware_userMagnetometerOffset = [0, 0, 0];
	  const firmware_userMagnetometerGain = [0, 0, 0];
	  const buf = new DataView(new ArrayBuffer(28));
	  const firmware_userMagField = bp.getNumber(0);

	  for (let i = 0; i < 3; i++) {
	    firmware_userMagnetometerOffset[i] = bp.getNumber((i + 1).toString());
	    firmware_userMagnetometerGain[i] = bp.getNumber((i + 4).toString());
	  }

	  for (let i = 0; i < 6; i++) {
	    firmware_userMagnetometerTransform[i] = bp.getNumber((i + 7).toString());
	  }

	  buf.setFloat32(0, firmware_userMagField, true);

	  for (let i = 0; i < 3; i++) {
	    buf.setFloat32(4 + i * 4, firmware_userMagnetometerOffset[i], true);
	    buf.setFloat32(16 + i * 4, firmware_userMagnetometerGain[i], true);
	  }

	  await ch.sendVINTDataPacket(78, new Uint8Array(buf.buffer));

	  for (let i = 0; i < 6; i++) {
	    buf.setFloat32(i * 4, firmware_userMagnetometerTransform[i], true);
	  }

	  await ch.sendVINTDataPacket(78, new Uint8Array(buf.buffer, 0, 24));
	}
	async function sendMOT0110_VINT(ch, bp) {
	  var _a, _b, _c, _d, _e;

	  const buf = new DataView(new ArrayBuffer(24));
	  let userphid;

	  switch (ch.chDef.uid) {
	    case 344:
	      userphid = ch.userphid;
	      await userphid._transactionLock.acquire();

	      try {
	        switch (bp.vpkt) {
	          case 54:
	            {
	              const dataInterval = (_a = ch.parent.parent) === null || _a === void 0 ? void 0 : _a._handleDataIntervalPacket(bp, 1);
	              if (dataInterval) buf.setUint16(0, dataInterval);else throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	              await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	            }
	            break;

	          case 106:
	            await ch.sendVINTDataPacket(51);
	            break;

	          case 35:
	            await ch.sendVINTDataPacket(77);
	            break;

	          case 37:
	            await ch.sendVINTDataPacket(79);
	            break;

	          case 50:
	            await sendMOT0110_SETCORRECTIONPARAMETERS(ch, bp);
	            break;

	          case 150:
	            await ch.sendVINTDataPacket(80);
	            break;

	          case 149:
	            buf.setUint8(0, bp.getNumber(0));
	            await ch.sendVINTDataPacket(81, new Uint8Array(buf.buffer, 0, 1));
	            break;

	          case 151:
	            buf.setFloat32(0, bp.getNumber(0), true);
	            await ch.sendVINTDataPacket(82, new Uint8Array(buf.buffer, 0, 4));
	            break;

	          case 174:
	            buf.setFloat32(0, bp.getNumber(0), true);
	            buf.setFloat32(4, bp.getNumber(1), true);
	            buf.setFloat32(8, bp.getNumber(2), true);
	            buf.setFloat32(12, bp.getNumber(3), true);
	            buf.setFloat32(16, bp.getNumber(4), true);
	            buf.setFloat32(20, bp.getNumber(5), true);
	            await ch.sendVINTDataPacket(84, new Uint8Array(buf.buffer));
	            break;

	          case 170:
	            buf.setUint8(0, bp.getNumber(0));
	            await ch.sendVINTDataPacket(85, new Uint8Array(buf.buffer, 0, 1));
	            break;

	          default:
	            throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	        }
	      } finally {
	        userphid._transactionLock.release();
	      }

	      break;

	    case 343:
	      userphid = ch.userphid;
	      await userphid.transactionLock.acquire();

	      try {
	        switch (bp.vpkt) {
	          case 54:
	            {
	              const dataInterval = (_b = ch.parent.parent) === null || _b === void 0 ? void 0 : _b._handleDataIntervalPacket(bp, 1);
	              if (dataInterval) buf.setUint16(0, dataInterval);else throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	              await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	            }
	            break;

	          case 46:
	            buf.setFloat32(0, bp.getNumber(0), true);
	            await ch.sendVINTDataPacket(195, new Uint8Array(buf.buffer, 0, 4));
	            break;

	          case 35:
	            await ch.sendVINTDataPacket(77);
	            break;

	          case 37:
	            await ch.sendVINTDataPacket(79);
	            break;

	          case 50:
	            await sendMOT0110_SETCORRECTIONPARAMETERS(ch, bp);
	            break;

	          case 170:
	            buf.setUint8(0, bp.getNumber(0));
	            await ch.sendVINTDataPacket(85, new Uint8Array(buf.buffer, 0, 1));
	            break;

	          default:
	            throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	        }
	      } finally {
	        userphid.transactionLock.release();
	      }

	      break;

	    case 342:
	      switch (bp.vpkt) {
	        case 54:
	          {
	            const dataInterval = (_c = ch.parent.parent) === null || _c === void 0 ? void 0 : _c._handleDataIntervalPacket(bp, 1);
	            if (dataInterval) buf.setUint16(0, dataInterval);else throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	            await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          }
	          break;

	        case 106:
	          await ch.sendVINTDataPacket(51);
	          break;

	        case 170:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(85, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 341:
	      switch (bp.vpkt) {
	        case 54:
	          {
	            const dataInterval = (_d = ch.parent.parent) === null || _d === void 0 ? void 0 : _d._handleDataIntervalPacket(bp, 1);
	            if (dataInterval) buf.setUint16(0, dataInterval);else throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	            await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          }
	          break;

	        case 46:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(195, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 170:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(85, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 345:
	      switch (bp.vpkt) {
	        case 54:
	          {
	            const dataInterval = (_e = ch.parent.parent) === null || _e === void 0 ? void 0 : _e._handleDataIntervalPacket(bp, 1);
	            if (dataInterval) buf.setUint16(0, dataInterval);else throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	            await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          }
	          break;

	        case 46:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(58, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvMOT0110_VINT(ch, buf) {
	  let timestamp;
	  let temperature;
	  const compass = [0, 0, 0];
	  const accel = [0, 0, 0];
	  const gyro = [0, 0, 0];
	  const quaternion = [0, 0, 0, 0];
	  let tmpFlt;
	  let interval;
	  const pkt = buf.getUint8(0);
	  let bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 344:
	      switch (pkt) {
	        case 196:
	          if (buf.byteLength > 41) {
	            if (buf.getUint8(41) & 0x20) {
	              bp.set({
	                name: "0",
	                type: "d",
	                value: exports.ErrorEventCode.OUT_OF_RANGE
	              });
	              bp.set({
	                name: "1",
	                type: "s",
	                value: "One or more spatial readings is out of range."
	              });
	              ch.sendErrorEvent(bp);
	            }
	          }

	          for (let i = 0; i < 3; i++) {
	            tmpFlt = buf.getFloat32(i * 4 + 1, true);

	            if (!Number.isNaN(tmpFlt)) {
	              compass[i] = RoundDouble(tmpFlt, 5);
	            }

	            tmpFlt = buf.getFloat32(i * 4 + 13, true);

	            if (!Number.isNaN(tmpFlt)) {
	              accel[i] = RoundDouble(tmpFlt, 5);
	            }

	            tmpFlt = buf.getFloat32(i * 4 + 25, true);

	            if (!Number.isNaN(tmpFlt)) {
	              gyro[i] = RoundDouble(tmpFlt, 5);
	            }
	          }

	          timestamp = buf.getUint32(37);
	          bp = new BridgePacket();
	          bp.set({
	            name: "0",
	            type: "G",
	            value: accel
	          });
	          bp.set({
	            name: "1",
	            type: "G",
	            value: gyro
	          });
	          bp.set({
	            name: "2",
	            type: "G",
	            value: compass
	          });
	          bp.set({
	            name: "3",
	            type: "g",
	            value: timestamp
	          });
	          bp.sendToChannel(ch, 89);
	          break;

	        case 197:
	          quaternion[0] = buf.getFloat32(1, true);
	          quaternion[1] = buf.getFloat32(5, true);
	          quaternion[2] = buf.getFloat32(8, true);
	          quaternion[3] = buf.getFloat32(13, true);
	          timestamp = buf.getUint16(17);
	          bp.set({
	            name: "0",
	            type: "G",
	            value: quaternion
	          });
	          bp.set({
	            name: "1",
	            type: "g",
	            value: timestamp
	          });
	          bp.sendToChannel(ch, 148);
	          break;

	        case 245:
	          interval = buf.getUint16(1);
	          bp.set({
	            name: "0",
	            type: "u",
	            value: interval
	          });
	          bp.sendToChannel(ch, 10);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 343:
	      switch (pkt) {
	        case 196:
	          if (buf.byteLength > 17) {
	            if (buf.getUint8(17) & 0x04) {
	              bp.set({
	                name: "0",
	                type: "d",
	                value: exports.ErrorEventCode.OUT_OF_RANGE
	              });
	              bp.set({
	                name: "1",
	                type: "s",
	                value: "One or more magnetometer readings is out of range."
	              });
	              ch.sendErrorEvent(bp);
	            }
	          }

	          compass[0] = RoundDouble(buf.getFloat32(1, true), 4);
	          compass[1] = RoundDouble(buf.getFloat32(5, true), 4);
	          compass[2] = RoundDouble(buf.getFloat32(9, true), 4);
	          timestamp = buf.getUint32(13);
	          bp.set({
	            name: "0",
	            type: "G",
	            value: compass
	          });
	          bp.set({
	            name: "1",
	            type: "g",
	            value: timestamp
	          });
	          bp.sendToChannel(ch, 18);
	          break;

	        case 245:
	          interval = buf.getUint16(1);
	          bp.set({
	            name: "0",
	            type: "u",
	            value: interval
	          });
	          bp.sendToChannel(ch, 10);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 342:
	      switch (pkt) {
	        case 197:
	          if (buf.byteLength > 17) {
	            if (buf.getUint8(17) & 0x02) {
	              bp.set({
	                name: "0",
	                type: "d",
	                value: exports.ErrorEventCode.OUT_OF_RANGE
	              });
	              bp.set({
	                name: "1",
	                type: "s",
	                value: "One or more gyroscope readings is out of range."
	              });
	              ch.sendErrorEvent(bp);
	            }
	          }

	          gyro[0] = RoundDouble(buf.getFloat32(1, true), 6);
	          gyro[1] = RoundDouble(buf.getFloat32(5, true), 6);
	          gyro[2] = RoundDouble(buf.getFloat32(9, true), 6);
	          timestamp = buf.getUint32(13);
	          bp.set({
	            name: "0",
	            type: "G",
	            value: gyro
	          });
	          bp.set({
	            name: "1",
	            type: "g",
	            value: timestamp
	          });
	          bp.sendToChannel(ch, 2);
	          break;

	        case 245:
	          interval = buf.getUint16(1);
	          bp.set({
	            name: "0",
	            type: "u",
	            value: interval
	          });
	          bp.sendToChannel(ch, 10);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 341:
	      switch (pkt) {
	        case 196:
	          if (buf.byteLength > 17) {
	            if (buf.getUint8(17) & 0x01) {
	              bp.set({
	                name: "0",
	                type: "d",
	                value: exports.ErrorEventCode.OUT_OF_RANGE
	              });
	              bp.set({
	                name: "1",
	                type: "s",
	                value: "One or more accelerometer readings is out of range."
	              });
	              ch.sendErrorEvent(bp);
	            }
	          }

	          accel[0] = RoundDouble(buf.getFloat32(1, true), 6);
	          accel[1] = RoundDouble(buf.getFloat32(5, true), 6);
	          accel[2] = RoundDouble(buf.getFloat32(9, true), 6);
	          timestamp = buf.getUint32(13);
	          bp = new BridgePacket();
	          bp.set({
	            name: "0",
	            type: "G",
	            value: accel
	          });
	          bp.set({
	            name: "1",
	            type: "g",
	            value: timestamp
	          });
	          bp.sendToChannel(ch, 1);
	          break;

	        case 245:
	          interval = buf.getUint16(1);
	          bp.set({
	            name: "0",
	            type: "u",
	            value: interval
	          });
	          bp.sendToChannel(ch, 10);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 345:
	      switch (pkt) {
	        case 59:
	          if (buf.byteLength > 5) {
	            switch (buf.getUint8(5) & 0x18) {
	              case 0x08:
	                bp.set({
	                  name: "0",
	                  type: "d",
	                  value: exports.ErrorEventCode.OUT_OF_RANGE_LOW_CONDITION
	                });
	                bp.set({
	                  name: "1",
	                  type: "s",
	                  value: "Temperature is too low to be accurately measured."
	                });
	                break;

	              case 0x10:
	                bp.set({
	                  name: "0",
	                  type: "d",
	                  value: exports.ErrorEventCode.OUT_OF_RANGE_HIGH_CONDITION
	                });
	                bp.set({
	                  name: "1",
	                  type: "s",
	                  value: "Temperature is too high to be accurately measured."
	                });
	                break;

	              case 0x18:
	                bp.set({
	                  name: "0",
	                  type: "d",
	                  value: exports.ErrorEventCode.OUT_OF_RANGE
	                });
	                bp.set({
	                  name: "1",
	                  type: "s",
	                  value: "Temperature is unknown."
	                });
	                break;
	            }

	            ch.sendErrorEvent(bp);
	          }

	          temperature = RoundDouble(buf.getFloat32(1, true), 3);
	          bp = new BridgePacket();
	          bp.set({
	            name: "0",
	            type: "g",
	            value: temperature
	          });
	          bp.sendToChannel(ch, 95);
	          break;

	        case 245:
	          interval = buf.getUint16(1);
	          bp.set({
	            name: "0",
	            type: "u",
	            value: interval
	          });
	          bp.sendToChannel(ch, 10);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendMOT0110_SETCORRECTIONPARAMETERS(ch, bp) {
	  const firmware_userMagnetometerTransform = [0, 0, 0, 0, 0, 0];
	  const firmware_userMagnetometerOffset = [0, 0, 0];
	  const firmware_userMagnetometerGain = [0, 0, 0];
	  const buf = new DataView(new ArrayBuffer(28));
	  const firmware_userMagField = bp.getNumber(0);

	  for (let i = 0; i < 3; i++) {
	    firmware_userMagnetometerOffset[i] = bp.getNumber((i + 1).toString());
	    firmware_userMagnetometerGain[i] = bp.getNumber((i + 4).toString());
	  }

	  for (let i = 0; i < 6; i++) {
	    firmware_userMagnetometerTransform[i] = bp.getNumber((i + 7).toString());
	  }

	  buf.setFloat32(0, firmware_userMagField, true);

	  for (let i = 0; i < 3; i++) {
	    buf.setFloat32(4 + i * 4, firmware_userMagnetometerOffset[i], true);
	    buf.setFloat32(16 + i * 4, firmware_userMagnetometerGain[i], true);
	  }

	  await ch.sendVINTDataPacket(78, new Uint8Array(buf.buffer));

	  for (let i = 0; i < 6; i++) {
	    buf.setFloat32(i * 4, firmware_userMagnetometerTransform[i], true);
	  }

	  await ch.sendVINTDataPacket(78, new Uint8Array(buf.buffer, 0, 24));
	}
	async function sendPRE1000(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 346:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 16));
	          await ch.sendVINTDataPacket(64, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvPRE1000(ch, buf) {
	  let pressure;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 346:
	      switch (pkt) {
	        case 65:
	          pressure = buf.getInt32(1) / (1 << 16);
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(pressure, 3)
	          });
	          bp.sendToChannel(ch, 31);
	          break;

	        case 66:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Saturation Detected.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendRCC1000(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(8));

	  switch (ch.chDef.uid) {
	    case 347:
	      switch (bp.vpkt) {
	        case 57:
	          buf.setUint8(0, bp.getNumber(0) ? 0xFF : 0x00);
	          await ch.sendVINTDataPacket(113, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 86:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(118, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 70:
	          buf.setUint32(0, bp.getNumber(0) * 1000);
	          await ch.sendVINTDataPacket(114, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 69:
	          buf.setUint32(0, bp.getNumber(0) * 1000);
	          await ch.sendVINTDataPacket(115, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 40:
	          buf.setUint32(0, bp.getNumber(0) * 16 / 2500);
	          await ch.sendVINTDataPacket(90, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 85:
	          buf.setUint32(0, bp.getNumber(0) * 16 / 50);
	          await ch.sendVINTDataPacket(89, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 83:
	          buf.setUint32(0, bp.getNumber(0) * 1000);
	          await ch.sendVINTDataPacket(88, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 81:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(119, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 348:
	    case 349:
	      switch (bp.vpkt) {
	        case 57:
	          buf.setUint8(0, bp.getNumber(0) ? 0xFF : 0x00);
	          await ch.sendVINTDataPacket(113, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 86:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(118, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 70:
	          buf.setUint32(0, bp.getNumber(0) * 1000);
	          await ch.sendVINTDataPacket(114, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 69:
	          buf.setUint32(0, bp.getNumber(0) * 1000);
	          await ch.sendVINTDataPacket(115, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 40:
	          buf.setUint32(0, bp.getNumber(0) * 16 / 2500);
	          await ch.sendVINTDataPacket(90, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 85:
	          buf.setUint32(0, bp.getNumber(0) * 16 / 50);
	          await ch.sendVINTDataPacket(89, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 83:
	          buf.setUint32(0, bp.getNumber(0) * 1000);
	          await ch.sendVINTDataPacket(88, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 81:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(119, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvRCC1000(ch, buf) {
	  let motorPosition;
	  const pkt = buf.getUint8(0);
	  let bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 347:
	      switch (pkt) {
	        case 116:
	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.BAD_POWER
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Servo motors are drawing too much power or the power supply is not providing enough voltage or current.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        case 112:
	          motorPosition = buf.getUint16(1) / 16;
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: motorPosition
	          });
	          bp.sendToChannel(ch, 94);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 348:
	    case 349:
	      switch (pkt) {
	        case 116:
	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.BAD_POWER
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Servo motors are drawing too much power or the power supply is not providing enough voltage or current.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        case 112:
	          motorPosition = buf.getUint16(1) / 16;
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: motorPosition
	          });
	          bp.sendToChannel(ch, 94);
	          break;

	        case 121:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.FAILSAFE_CONDITION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Failsafe procedure initiated.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendRCC1000_Failsafe(ch, bp) {
	  await sendRCC1000(ch, bp);
	}
	function recvRCC1000_Failsafe(ch, buf) {
	  recvRCC1000(ch, buf);
	}
	async function sendREL1000(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(2));

	  switch (ch.chDef.uid) {
	    case 350:
	      switch (bp.vpkt) {
	        case 82:
	          buf.setUint16(0, bp.getNumber(0) ? 1 << 15 : 0);
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer));
	          break;

	        case 55:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 15));
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 351:
	      switch (bp.vpkt) {
	        case 82:
	          buf.setUint16(0, bp.getNumber(0) ? 1 << 15 : 0);
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer));
	          break;

	        case 55:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 15));
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvREL1000(ch, buf) {
	  const pkt = buf.getUint8(0);

	  switch (ch.chDef.uid) {
	    case 350:
	      throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet received.");

	    case 351:
	      switch (pkt) {
	        case 13:
	          {
	            const bp = new BridgePacket();
	            bp.set({
	              name: "0",
	              type: "d",
	              value: exports.ErrorEventCode.FAILSAFE_CONDITION
	            });
	            bp.set({
	              name: "1",
	              type: "s",
	              value: "Failsafe procedure initiated."
	            });
	            ch.sendErrorEvent(bp);
	            break;
	          }

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendREL1000_Failsafe(ch, bp) {
	  await sendREL1000(ch, bp);
	}
	function recvREL1000_Failsafe(ch, buf) {
	  recvREL1000(ch, buf);
	}
	async function sendREL1100(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 352:
	      switch (bp.vpkt) {
	        case 82:
	          buf.setUint16(0, bp.getNumber(0) ? 1 << 15 : 0);
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 55:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 15));
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 353:
	      switch (bp.vpkt) {
	        case 82:
	          buf.setUint16(0, bp.getNumber(0) ? 1 << 15 : 0);
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 55:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 15));
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 354:
	      switch (bp.vpkt) {
	        case 82:
	          buf.setUint16(0, bp.getNumber(0) ? 1 << 15 : 0);
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 55:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 15));
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        case 156:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(15, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvREL1100(ch, buf) {
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 352:
	      throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet received.");

	    case 353:
	    case 354:
	      switch (pkt) {
	        case 13:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.FAILSAFE_CONDITION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Failsafe procedure initiated.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendREL1100_Failsafe(ch, bp) {
	  await sendREL1100(ch, bp);
	}
	function recvREL1100_Failsafe(ch, buf) {
	  recvREL1100(ch, buf);
	}
	async function sendREL1100_Failsafe_Frequency(ch, bp) {
	  await sendREL1100(ch, bp);
	}
	function recvREL1100_Failsafe_Frequency(ch, buf) {
	  recvREL1100(ch, buf);
	}
	async function sendREL1101(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(2));

	  switch (ch.chDef.uid) {
	    case 355:
	      switch (bp.vpkt) {
	        case 82:
	          buf.setUint8(0, bp.getNumber(0) ? 0xFF : 0x00);
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 55:
	          buf.setUint8(0, bp.getNumber(0) * 255);
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 356:
	      switch (bp.vpkt) {
	        case 82:
	          buf.setUint8(0, bp.getNumber(0) ? 0xFF : 0x00);
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 55:
	          buf.setUint8(0, bp.getNumber(0) * 255);
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvREL1101(ch, buf) {
	  const pkt = buf.getUint8(0);
	  let bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 355:
	      switch (pkt) {
	        case 13:
	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.FAILSAFE_CONDITION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Failsafe procedure initiated.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendREL1101_Failsafe(ch, bp) {
	  await sendREL1101(ch, bp);
	}
	function recvREL1101_Failsafe(ch, buf) {
	  recvREL1101(ch, buf);
	}
	async function sendREL1101_1(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 357:
	      switch (bp.vpkt) {
	        case 82:
	          buf.setUint8(0, bp.getNumber(0) ? 0xFF : 0x00);
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 55:
	          buf.setUint8(0, bp.getNumber(0) * 255);
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        case 156:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(15, new Uint8Array(buf.buffer));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 358:
	      switch (bp.vpkt) {
	        case 82:
	          buf.setUint8(0, bp.getNumber(0) ? 0xFF : 0x00);
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 55:
	          buf.setUint8(0, bp.getNumber(0) * 255);
	          await ch.sendVINTDataPacket(10, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvREL1101_1(ch, buf) {
	  const pkt = buf.getUint8(0);
	  let bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 358:
	    case 357:
	      switch (pkt) {
	        case 13:
	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.FAILSAFE_CONDITION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Failsafe procedure initiated.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendSAF1000(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 360:
	      switch (bp.vpkt) {
	        case 56:
	          buf.setUint8(0, bp.getNumber(0) ? 0xFF : 0x00);
	          await ch.sendVINTDataPacket(166, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 71:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 24));
	          await ch.sendVINTDataPacket(162, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 58:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(159, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 363:
	      switch (bp.vpkt) {
	        case 56:
	          buf.setUint8(0, bp.getNumber(0) ? 0xFF : 0x00);
	          await ch.sendVINTDataPacket(166, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 71:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 24));
	          await ch.sendVINTDataPacket(162, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 58:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(159, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 361:
	    case 364:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 24));
	          await ch.sendVINTDataPacket(16, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 362:
	    case 365:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 16));
	          await ch.sendVINTDataPacket(58, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvSAF1000(ch, buf) {
	  let temperature;
	  let voltage;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 360:
	      switch (pkt) {
	        case 164:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.ENERGY_DUMP_CONDITION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Energy Dump in Progress.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        case 165:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.OVER_TEMPERATURE
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Overtemperature Condition Detected.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        case 163:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.OVER_VOLTAGE
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Overvoltage Condition Detected.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        case 160:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.SUCCESS
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'All error conditions have been resolved'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 363:
	      switch (pkt) {
	        case 164:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.ENERGY_DUMP_CONDITION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Energy Dump in Progress.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        case 165:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.OVER_TEMPERATURE
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Overtemperature Condition Detected.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        case 163:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.OVER_VOLTAGE
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Overvoltage Condition Detected.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        case 160:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.SUCCESS
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'All error conditions have been resolved'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        case 167:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.FAILSAFE_CONDITION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Failsafe procedure initiated.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 361:
	    case 364:
	      switch (pkt) {
	        case 17:
	          voltage = buf.getUint32(1) / (1 << 24);
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(voltage, 7)
	          });
	          bp.sendToChannel(ch, 101);
	          break;

	        case 18:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Saturation Detected.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 362:
	    case 365:
	      switch (pkt) {
	        case 59:
	          temperature = buf.getInt32(1) / (1 << 16);
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(temperature, 2)
	          });
	          bp.sendToChannel(ch, 95);
	          break;

	        case 60:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Saturation Detected.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendSAF1000_Failsafe(ch, bp) {
	  await sendSAF1000(ch, bp);
	}
	function recvSAF1000_Failsafe(ch, buf) {
	  recvSAF1000(ch, buf);
	}
	async function sendSND1000(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 366:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          break;

	        case 116:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(147, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvSND1000(ch, buf) {
	  const octaves = new Array(10);
	  const finaloctaves = new Array(10);
	  let tempDouble,
	      gain,
	      dB = 0.0,
	      dBA = 0.0,
	      dBC = 0.0,
	      changeTrigger,
	      lastdB;
	  let saturatedFlag = false;
	  const userphid = ch.userphid;
	  const dBA_weight = [-6.700912224792721, -1.144507424157968, 0.9642291552357972, 1.2016993444284976, 0.0, -3.098968656056327, -8.456545621324212, -16.189851062139507, -26.22302364022129, -39.52906401331724];
	  const dBC_weight = [-8.62944227232129, -3.0448821481317507, -0.8252420358959885, -0.16942156787436816, 0.0, 0.03251328929742176, 0.0019618319836562453, -0.1718184155510175, -0.8206982482269319, 3.030794594641769];
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 366:
	      switch (pkt) {
	        case 146:
	          gain = buf.getUint8(41) == 1 ? 39.912703891951 : 59.912703891951;
	          saturatedFlag = buf.getUint8(42) == 1 ? true : false;

	          for (let i = 0; i < 10; i++) {
	            tempDouble = Math.sqrt(buf.getFloat32(i * 4 + 1, true));
	            tempDouble *= 3300.0 / 4095.0;
	            tempDouble /= 6.309573444801932;
	            octaves[i] = 20.0 * Math.log10(tempDouble) + 94.0 - gain;
	            dB += Math.pow(10, octaves[i] / 10.0);
	            dBA += Math.pow(10, (octaves[i] + dBA_weight[i]) / 10.0);
	            dBC += Math.pow(10, (octaves[i] + dBC_weight[i]) / 10.0);
	          }

	          if (saturatedFlag) {
	            bp.set({
	              name: "0",
	              type: "d",
	              value: exports.ErrorEventCode.SATURATION
	            });
	            bp.set({
	              name: "1",
	              type: "s",
	              value: "Saturation Detected."
	            });
	            ch.sendErrorEvent(bp);
	          } else {
	            dB = 10 * Math.log10(dB);
	            dBA = 10 * Math.log10(dBA);
	            dBC = 10 * Math.log10(dBC);

	            for (let i = 0; i < 10; i++) {
	              finaloctaves[i] = RoundDouble(octaves[9 - i], 4);
	            }

	            changeTrigger = userphid.data.SPLChangeTrigger;
	            lastdB = userphid.data.lastdB;

	            if (Math.abs(lastdB - dB) > changeTrigger) {
	              userphid.data.lastdB = dB;
	              bp.set({
	                name: "0",
	                type: "g",
	                value: RoundDouble(dB, 4)
	              });
	              bp.set({
	                name: "1",
	                type: "g",
	                value: RoundDouble(dBA, 4)
	              });
	              bp.set({
	                name: "2",
	                type: "g",
	                value: RoundDouble(dBC, 4)
	              });
	              bp.set({
	                name: "3",
	                type: "G",
	                value: finaloctaves
	              });
	              bp.sendToChannel(ch, 11);
	            }
	          }

	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendSTC1000(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(8));

	  switch (ch.chDef.uid) {
	    case 367:
	      switch (bp.vpkt) {
	        case 83:
	          {
	            const position = bp.getNumber(0);
	            SetBigInt64(buf, 0, position);
	            await ch.sendVINTDataPacket(88, new Uint8Array(buf.buffer));
	            break;
	          }

	        case 85:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(89, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 40:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 7));
	          await ch.sendVINTDataPacket(90, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 51:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 8));
	          await ch.sendVINTDataPacket(127, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 63:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 8));
	          await ch.sendVINTDataPacket(122, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 57:
	          buf.setUint8(0, bp.getNumber(0) ? 0xFF : 0x00);
	          await ch.sendVINTDataPacket(120, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 49:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(119, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 368:
	      switch (bp.vpkt) {
	        case 83:
	          {
	            const position = bp.getNumber(0);
	            SetBigInt64(buf, 0, position);
	            await ch.sendVINTDataPacket(88, new Uint8Array(buf.buffer));
	            break;
	          }

	        case 85:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(89, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 40:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 7));
	          await ch.sendVINTDataPacket(90, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 51:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 8));
	          await ch.sendVINTDataPacket(127, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 63:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 8));
	          await ch.sendVINTDataPacket(122, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 57:
	          buf.setUint8(0, bp.getNumber(0) ? 0xFF : 0x00);
	          await ch.sendVINTDataPacket(120, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 49:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(119, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvSTC1000(ch, buf) {
	  let motorPosition;
	  let velocity;
	  let stopped;
	  let moving;
	  const pkt = buf.getUint8(0);
	  let bp = new BridgePacket();
	  const userphid = ch.userphid;

	  switch (ch.chDef.uid) {
	    case 367:
	      switch (pkt) {
	        case 123:
	          motorPosition = GetBigInt64(buf, 1);
	          velocity = buf.getInt32(9) / 256;
	          stopped = buf.getUint8(13) ? 1 : 0;
	          bp.set({
	            name: '0',
	            type: 'l',
	            value: motorPosition
	          });
	          bp.sendToChannel(ch, 29);
	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: velocity
	          });
	          bp.sendToChannel(ch, 100);
	          moving = userphid.data.isMoving;

	          if (stopped == moving) {
	            bp = new BridgePacket();
	            bp.sendToChannel(ch, 91);
	          }

	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 368:
	      switch (pkt) {
	        case 123:
	          motorPosition = GetBigInt64(buf, 1);
	          velocity = buf.getInt32(9) / 256;
	          stopped = buf.getUint8(13) ? 1 : 0;
	          bp.set({
	            name: '0',
	            type: 'l',
	            value: motorPosition
	          });
	          bp.sendToChannel(ch, 29);
	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: velocity
	          });
	          bp.sendToChannel(ch, 100);
	          moving = userphid.data.isMoving;

	          if (stopped == moving) {
	            bp = new BridgePacket();
	            bp.sendToChannel(ch, 91);
	          }

	          break;

	        case 93:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.FAILSAFE_CONDITION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Failsafe procedure initiated.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendSTC1000_Failsafe(ch, bp) {
	  await sendSTC1000(ch, bp);
	}
	function recvSTC1000_Failsafe(ch, buf) {
	  recvSTC1000(ch, buf);
	}
	async function sendSTC1001(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(8));

	  switch (ch.chDef.uid) {
	    case 369:
	      switch (bp.vpkt) {
	        case 83:
	          {
	            const position = bp.getNumber(0);
	            SetBigInt64(buf, 0, position);
	            await ch.sendVINTDataPacket(88, new Uint8Array(buf.buffer));
	            break;
	          }

	        case 85:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(89, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 40:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 7));
	          await ch.sendVINTDataPacket(90, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 51:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 8));
	          await ch.sendVINTDataPacket(127, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 63:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 8));
	          await ch.sendVINTDataPacket(122, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 57:
	          buf.setUint8(0, bp.getNumber(0) ? 0xFF : 0x00);
	          await ch.sendVINTDataPacket(120, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 49:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(119, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 370:
	      switch (bp.vpkt) {
	        case 83:
	          {
	            const position = bp.getNumber(0);
	            SetBigInt64(buf, 0, position);
	            await ch.sendVINTDataPacket(88, new Uint8Array(buf.buffer));
	            break;
	          }

	        case 85:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(89, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 40:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 7));
	          await ch.sendVINTDataPacket(90, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 51:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 8));
	          await ch.sendVINTDataPacket(127, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 63:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 8));
	          await ch.sendVINTDataPacket(122, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 57:
	          buf.setUint8(0, bp.getNumber(0) ? 0xFF : 0x00);
	          await ch.sendVINTDataPacket(120, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 49:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(119, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvSTC1001(ch, buf) {
	  let motorPosition;
	  let velocity;
	  let stopped;
	  let moving;
	  const pkt = buf.getUint8(0);
	  let bp = new BridgePacket();
	  const userphid = ch.userphid;

	  switch (ch.chDef.uid) {
	    case 369:
	      switch (pkt) {
	        case 123:
	          motorPosition = GetBigInt64(buf, 1);
	          velocity = buf.getInt32(9) / 256;
	          stopped = buf.getUint8(13) ? 1 : 0;
	          bp.set({
	            name: '0',
	            type: 'l',
	            value: motorPosition
	          });
	          bp.sendToChannel(ch, 29);
	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: velocity
	          });
	          bp.sendToChannel(ch, 100);
	          moving = userphid.data.isMoving;

	          if (stopped == moving) {
	            bp = new BridgePacket();
	            bp.sendToChannel(ch, 91);
	          }

	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 370:
	      switch (pkt) {
	        case 123:
	          motorPosition = GetBigInt64(buf, 1);
	          velocity = buf.getInt32(9) / 256;
	          stopped = buf.getUint8(13) ? 1 : 0;
	          bp.set({
	            name: '0',
	            type: 'l',
	            value: motorPosition
	          });
	          bp.sendToChannel(ch, 29);
	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: velocity
	          });
	          bp.sendToChannel(ch, 100);
	          moving = userphid.data.isMoving;

	          if (stopped == moving) {
	            bp = new BridgePacket();
	            bp.sendToChannel(ch, 91);
	          }

	          break;

	        case 93:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.FAILSAFE_CONDITION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Failsafe procedure initiated.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendSTC1001_Failsafe(ch, bp) {
	  await sendSTC1001(ch, bp);
	}
	function recvSTC1001_Failsafe(ch, buf) {
	  recvSTC1001(ch, buf);
	}
	async function sendSTC1002(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(8));

	  switch (ch.chDef.uid) {
	    case 371:
	      switch (bp.vpkt) {
	        case 83:
	          {
	            const position = bp.getNumber(0);
	            SetBigInt64(buf, 0, position);
	            await ch.sendVINTDataPacket(88, new Uint8Array(buf.buffer));
	            break;
	          }

	        case 85:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(89, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 40:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 7));
	          await ch.sendVINTDataPacket(90, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 51:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 8));
	          await ch.sendVINTDataPacket(127, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 63:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 8));
	          await ch.sendVINTDataPacket(122, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 57:
	          buf.setUint8(0, bp.getNumber(0) ? 0xFF : 0x00);
	          await ch.sendVINTDataPacket(120, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 49:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(119, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 372:
	      switch (bp.vpkt) {
	        case 83:
	          {
	            const position = bp.getNumber(0);
	            SetBigInt64(buf, 0, position);
	            await ch.sendVINTDataPacket(88, new Uint8Array(buf.buffer));
	            break;
	          }

	        case 85:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(89, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 40:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 7));
	          await ch.sendVINTDataPacket(90, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 51:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 8));
	          await ch.sendVINTDataPacket(127, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 63:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 8));
	          await ch.sendVINTDataPacket(122, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 57:
	          buf.setUint8(0, bp.getNumber(0) ? 0xFF : 0x00);
	          await ch.sendVINTDataPacket(120, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 49:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(119, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvSTC1002(ch, buf) {
	  let motorPosition;
	  let velocity;
	  let stopped;
	  let moving;
	  const pkt = buf.getUint8(0);
	  let bp = new BridgePacket();
	  const userphid = ch.userphid;

	  switch (ch.chDef.uid) {
	    case 371:
	      switch (pkt) {
	        case 123:
	          motorPosition = GetBigInt64(buf, 1);
	          velocity = buf.getInt32(9) / 256;
	          stopped = buf.getUint8(13) ? 1 : 0;
	          bp.set({
	            name: '0',
	            type: 'l',
	            value: motorPosition
	          });
	          bp.sendToChannel(ch, 29);
	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: velocity
	          });
	          bp.sendToChannel(ch, 100);
	          moving = userphid.data.isMoving;

	          if (stopped == moving) {
	            bp = new BridgePacket();
	            bp.sendToChannel(ch, 91);
	          }

	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 372:
	      switch (pkt) {
	        case 123:
	          motorPosition = GetBigInt64(buf, 1);
	          velocity = buf.getInt32(9) / 256;
	          stopped = buf.getUint8(13) ? 1 : 0;
	          bp.set({
	            name: '0',
	            type: 'l',
	            value: motorPosition
	          });
	          bp.sendToChannel(ch, 29);
	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: velocity
	          });
	          bp.sendToChannel(ch, 100);
	          moving = userphid.data.isMoving;

	          if (stopped == moving) {
	            bp = new BridgePacket();
	            bp.sendToChannel(ch, 91);
	          }

	          break;

	        case 93:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.FAILSAFE_CONDITION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Failsafe procedure initiated.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendSTC1002_Failsafe(ch, bp) {
	  await sendSTC1002(ch, bp);
	}
	function recvSTC1002_Failsafe(ch, buf) {
	  recvSTC1002(ch, buf);
	}
	async function sendSTC1003(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(8));

	  switch (ch.chDef.uid) {
	    case 373:
	      switch (bp.vpkt) {
	        case 83:
	          {
	            const position = bp.getNumber(0);
	            SetBigInt64(buf, 0, position);
	            await ch.sendVINTDataPacket(88, new Uint8Array(buf.buffer));
	            break;
	          }

	        case 85:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(89, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 40:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 7));
	          await ch.sendVINTDataPacket(90, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 51:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 8));
	          await ch.sendVINTDataPacket(127, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 63:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 8));
	          await ch.sendVINTDataPacket(122, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 57:
	          buf.setUint8(0, bp.getNumber(0) ? 0xFF : 0x00);
	          await ch.sendVINTDataPacket(120, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 49:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(119, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 374:
	      switch (bp.vpkt) {
	        case 83:
	          {
	            const position = bp.getNumber(0);
	            SetBigInt64(buf, 0, position);
	            await ch.sendVINTDataPacket(88, new Uint8Array(buf.buffer));
	            break;
	          }

	        case 85:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(89, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 40:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 7));
	          await ch.sendVINTDataPacket(90, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 51:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 8));
	          await ch.sendVINTDataPacket(127, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 63:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 8));
	          await ch.sendVINTDataPacket(122, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 57:
	          buf.setUint8(0, bp.getNumber(0) ? 0xFF : 0x00);
	          await ch.sendVINTDataPacket(120, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 49:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(119, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvSTC1003(ch, buf) {
	  let motorPosition;
	  let velocity;
	  let stopped;
	  let moving;
	  const pkt = buf.getUint8(0);
	  let bp = new BridgePacket();
	  const userphid = ch.userphid;

	  switch (ch.chDef.uid) {
	    case 373:
	      switch (pkt) {
	        case 123:
	          motorPosition = GetBigInt64(buf, 1);
	          velocity = buf.getInt32(9) / 256;
	          stopped = buf.getUint8(13) ? 1 : 0;
	          bp.set({
	            name: '0',
	            type: 'l',
	            value: motorPosition
	          });
	          bp.sendToChannel(ch, 29);
	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: velocity
	          });
	          bp.sendToChannel(ch, 100);
	          moving = userphid.data.isMoving;

	          if (stopped == moving) {
	            bp = new BridgePacket();
	            bp.sendToChannel(ch, 91);
	          }

	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 374:
	      switch (pkt) {
	        case 123:
	          motorPosition = GetBigInt64(buf, 1);
	          velocity = buf.getInt32(9) / 256;
	          stopped = buf.getUint8(13) ? 1 : 0;
	          bp.set({
	            name: '0',
	            type: 'l',
	            value: motorPosition
	          });
	          bp.sendToChannel(ch, 29);
	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: velocity
	          });
	          bp.sendToChannel(ch, 100);
	          moving = userphid.data.isMoving;

	          if (stopped && stopped == moving) {
	            bp = new BridgePacket();
	            bp.sendToChannel(ch, 91);
	          }

	          break;

	        case 93:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.FAILSAFE_CONDITION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Failsafe procedure initiated.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        case 118:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.BAD_POWER
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Overcurrent error detected. Device has been reset.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendSTC1003_Failsafe(ch, bp) {
	  await sendSTC1003(ch, bp);
	}
	function recvSTC1003_Failsafe(ch, buf) {
	  recvSTC1003(ch, buf);
	}
	async function sendSTC1003_1(ch, bp) {
	  var _a, _b;

	  const buf = new DataView(new ArrayBuffer(8));

	  switch (ch.chDef.uid) {
	    case 375:
	    case 377:
	      switch (bp.vpkt) {
	        case 83:
	          {
	            const position = bp.getNumber(0);
	            SetBigInt64(buf, 0, position);
	            await ch.sendVINTDataPacket(88, new Uint8Array(buf.buffer));
	            break;
	          }

	        case 85:
	          buf.setUint32(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(89, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 40:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 7));
	          await ch.sendVINTDataPacket(90, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 51:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 8));
	          await ch.sendVINTDataPacket(127, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 63:
	          buf.setUint16(0, bp.getNumber(0) * (1 << 8));
	          await ch.sendVINTDataPacket(122, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 57:
	          buf.setUint8(0, bp.getNumber(0) ? 0xFF : 0x00);
	          await ch.sendVINTDataPacket(120, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 49:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(119, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 54:
	          {
	            const dataInterval = (_a = ch.parent.parent) === null || _a === void 0 ? void 0 : _a._handleDataIntervalPacket(bp, 1);
	            if (dataInterval) buf.setUint16(0, dataInterval);else throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	            await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          }
	          break;

	        case 146:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(246, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 147:
	          await ch.sendVINTDataPacket(247);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 376:
	    case 378:
	      switch (bp.vpkt) {
	        case 54:
	          {
	            const dataInterval = (_b = ch.parent.parent) === null || _b === void 0 ? void 0 : _b._handleDataIntervalPacket(bp, 1);
	            if (dataInterval) buf.setUint16(0, dataInterval);else throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	            await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          }
	          break;

	        case 46:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(16, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvSTC1003_1(ch, buf) {
	  let motorPosition;
	  let velocity;
	  let voltage;
	  let stopped;
	  let moving;
	  let userphid;
	  const pkt = buf.getUint8(0);
	  let bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 375:
	      switch (pkt) {
	        case 123:
	          motorPosition = GetBigInt64(buf, 1);
	          velocity = buf.getInt32(9) / 256;
	          stopped = buf.getUint8(13) ? 1 : 0;
	          bp.set({
	            name: '0',
	            type: 'l',
	            value: motorPosition
	          });
	          bp.sendToChannel(ch, 29);
	          bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: velocity
	          });
	          bp.sendToChannel(ch, 100);
	          userphid = ch.userphid;
	          moving = userphid.data.isMoving;

	          if (stopped && moving) {
	            bp = new BridgePacket();
	            bp.sendToChannel(ch, 91);
	          }

	          break;

	        case 93:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.FAILSAFE_CONDITION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Failsafe procedure initiated.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        case 118:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.BAD_POWER
	          });

	          if (buf.getUint8(1)) {
	            bp.set({
	              name: '1',
	              type: 's',
	              value: 'Supply Voltage above expected range.'
	            });
	          } else {
	            bp.set({
	              name: '1',
	              type: 's',
	              value: 'Supply Voltage below expected range.  Possible overcurrent condition.'
	            });
	          }

	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 376:
	      switch (pkt) {
	        case 17:
	          voltage = buf.getFloat32(1, true);
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(voltage, 7)
	          });
	          bp.sendToChannel(ch, 101);
	          break;

	        case 18:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Saturation Detected.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendTMP1000(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 380:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 16));
	          await ch.sendVINTDataPacket(58, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvTMP1000(ch, buf) {
	  let temperature;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 380:
	      switch (pkt) {
	        case 59:
	          temperature = buf.getInt32(1) / (1 << 16);
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(temperature, 2)
	          });
	          bp.sendToChannel(ch, 95);
	          break;

	        case 60:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Saturation Detected.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendTMP1100(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 383:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(16, new Uint8Array(buf.buffer));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 382:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(58, new Uint8Array(buf.buffer));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 381:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(58, new Uint8Array(buf.buffer));
	          break;

	        case 84:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(62, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvTMP1100(ch, buf) {
	  let temperature;
	  let voltage;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 382:
	    case 381:
	      switch (pkt) {
	        case 59:
	          temperature = buf.getFloat32(1, true);
	          bp.set({
	            name: "0",
	            type: "g",
	            value: RoundDouble(temperature, 3)
	          });
	          bp.sendToChannel(ch, 95);
	          break;

	        case 60:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Saturation Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 383:
	      switch (pkt) {
	        case 17:
	          voltage = buf.getFloat32(1, true);
	          bp.set({
	            name: "0",
	            type: "g",
	            value: RoundDouble(voltage, 6)
	          });
	          bp.sendToChannel(ch, 101);
	          break;

	        case 18:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Saturation Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendTMP1101(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 384:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(58, new Uint8Array(buf.buffer));
	          break;

	        case 84:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(62, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 385:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(58, new Uint8Array(buf.buffer));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 386:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(16, new Uint8Array(buf.buffer));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvTMP1101(ch, buf) {
	  let temperature;
	  let voltage;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 384:
	    case 385:
	      switch (pkt) {
	        case 59:
	          temperature = buf.getFloat32(1, true);
	          bp.set({
	            name: "0",
	            type: "g",
	            value: RoundDouble(temperature, 3)
	          });
	          bp.sendToChannel(ch, 95);
	          break;

	        case 60:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Saturation Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 386:
	      switch (pkt) {
	        case 17:
	          voltage = buf.getFloat32(1, true);
	          bp.set({
	            name: "0",
	            type: "g",
	            value: RoundDouble(voltage, 6)
	          });
	          bp.sendToChannel(ch, 101);
	          break;

	        case 18:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Saturation Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendTMP1101_1(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 387:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(58, new Uint8Array(buf.buffer));
	          break;

	        case 84:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(62, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 388:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(58, new Uint8Array(buf.buffer));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 389:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(16, new Uint8Array(buf.buffer));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvTMP1101_1(ch, buf) {
	  let temperature;
	  let voltage;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 387:
	      switch (pkt) {
	        case 59:
	          temperature = buf.getFloat32(1, true);
	          bp.set({
	            name: "0",
	            type: "g",
	            value: RoundDouble(temperature, 3)
	          });
	          bp.sendToChannel(ch, 95);
	          break;

	        case 60:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Saturation Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        case 64:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.BAD_CONNECTION_CONDITION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Bad Connection"
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 388:
	      switch (pkt) {
	        case 59:
	          temperature = buf.getFloat32(1, true);
	          bp.set({
	            name: "0",
	            type: "g",
	            value: RoundDouble(temperature, 3)
	          });
	          bp.sendToChannel(ch, 95);
	          break;

	        case 60:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Saturation Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 389:
	      switch (pkt) {
	        case 17:
	          voltage = buf.getFloat32(1, true);
	          bp.set({
	            name: "0",
	            type: "g",
	            value: RoundDouble(voltage, 6)
	          });
	          bp.sendToChannel(ch, 101);
	          break;

	        case 18:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Saturation Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        case 23:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.BAD_CONNECTION_CONDITION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Bad Connection"
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendTMP1200(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 390:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(58, new Uint8Array(buf.buffer));
	          break;

	        case 77:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(192, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        case 76:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(63, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 391:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setFloat32(0, bp.getNumber(0), true);
	          await ch.sendVINTDataPacket(155, new Uint8Array(buf.buffer));
	          break;

	        case 77:
	          buf.setUint8(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(192, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvTMP1200(ch, buf) {
	  let temperature, resistance;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 390:
	      switch (pkt) {
	        case 59:
	          temperature = buf.getFloat32(1, true);
	          bp.set({
	            name: "0",
	            type: "g",
	            value: RoundDouble(temperature, 3)
	          });
	          bp.sendToChannel(ch, 95);
	          break;

	        case 60:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Saturation Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    case 391:
	      switch (pkt) {
	        case 154:
	          resistance = buf.getFloat32(1, true);
	          bp.set({
	            name: "0",
	            type: "g",
	            value: RoundDouble(resistance, 3)
	          });
	          bp.sendToChannel(ch, 36);
	          break;

	        case 156:
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Saturation Detected."
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendVCP1000(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 397:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 24));
	          await ch.sendVINTDataPacket(16, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 87:
	          buf.setUint8(0, bp.getNumber(0));

	          switch (bp.getNumber(0)) {
	            case exports.VoltageRange.MILLIVOLTS_312_5:
	            case exports.VoltageRange.VOLTS_40:
	              break;

	            default:
	              throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Invalid or unsupported voltage range for this device.");
	          }

	          await ch.sendVINTDataPacket(21, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvVCP1000(ch, buf) {
	  let voltage;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 397:
	      switch (pkt) {
	        case 17:
	          voltage = buf.getInt32(1) / (1 << 24);
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(voltage, 7)
	          });
	          bp.sendToChannel(ch, 101);
	          break;

	        case 18:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Saturation Detected.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendVCP1001(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 398:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 24));
	          await ch.sendVINTDataPacket(16, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 87:
	          buf.setUint8(0, bp.getNumber(0));

	          switch (bp.getNumber(0)) {
	            case exports.VoltageRange.VOLTS_5:
	            case exports.VoltageRange.VOLTS_15:
	            case exports.VoltageRange.VOLTS_40:
	            case exports.VoltageRange.AUTO:
	              break;

	            default:
	              throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Invalid or unsupported voltage range for this device.");
	          }

	          await ch.sendVINTDataPacket(19, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvVCP1001(ch, buf) {
	  let voltage;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 398:
	      switch (pkt) {
	        case 17:
	          voltage = buf.getInt32(1) / (1 << 24);
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(voltage, 4)
	          });
	          bp.sendToChannel(ch, 101);
	          break;

	        case 18:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Saturation Detected.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendVCP1002(ch, bp) {
	  const buf = new DataView(new ArrayBuffer(4));

	  switch (ch.chDef.uid) {
	    case 400:
	      switch (bp.vpkt) {
	        case 54:
	          buf.setUint16(0, bp.getNumber(0));
	          await ch.sendVINTDataPacket(252, new Uint8Array(buf.buffer, 0, 2));
	          break;

	        case 46:
	          buf.setUint32(0, bp.getNumber(0) * (1 << 24));
	          await ch.sendVINTDataPacket(16, new Uint8Array(buf.buffer, 0, 4));
	          break;

	        case 87:
	          buf.setUint8(0, bp.getNumber(0));

	          switch (bp.getNumber(0)) {
	            case exports.VoltageRange.MILLIVOLTS_10:
	            case exports.VoltageRange.MILLIVOLTS_40:
	            case exports.VoltageRange.MILLIVOLTS_200:
	            case exports.VoltageRange.MILLIVOLTS_1000:
	            case exports.VoltageRange.AUTO:
	              break;

	            default:
	              throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Invalid or unsupported voltage range for this device.");
	          }

	          await ch.sendVINTDataPacket(20, new Uint8Array(buf.buffer, 0, 1));
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	function recvVCP1002(ch, buf) {
	  let voltage;
	  const pkt = buf.getUint8(0);
	  const bp = new BridgePacket();

	  switch (ch.chDef.uid) {
	    case 400:
	      switch (pkt) {
	        case 17:
	          voltage = buf.getInt32(1) / (1 << 24);
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: RoundDouble(voltage, 7)
	          });
	          bp.sendToChannel(ch, 101);
	          break;

	        case 18:
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.SATURATION
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Saturation Detected.'
	          });
	          ch.sendErrorEvent(bp);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }

	      break;

	    default:
	      throw new PhidgetError(exports.ErrorCode.INVALID, "Invalid Channel UID");
	  }
	}
	async function sendVCP1001_110(ch, bp) {
	  await sendVCP1001(ch, bp);
	}
	function recvVCP1001_110(ch, buf) {
	  return recvVCP1001(ch, buf);
	}
	async function sendVCP1002_110(ch, bp) {
	  await sendVCP1002(ch, bp);
	}
	function recvVCP1002_110(ch, buf) {
	  return recvVCP1002(ch, buf);
	}
	async function sendFIRMWARE_UPGRADE_STM32F0(ch, bp) {
	  throw new Error("Not Implemented");
	}
	function recvFIRMWARE_UPGRADE_STM32F0(ch, buf) {
	  throw new Error("Not Implemented");
	}
	async function sendFIRMWARE_UPGRADE_STM32G0(ch, bp) {
	  throw new Error("Not Implemented");
	}
	function recvFIRMWARE_UPGRADE_STM32G0(ch, buf) {
	  throw new Error("Not Implemented");
	}
	async function sendFIRMWARE_UPGRADE_STM32F3(ch, bp) {
	  throw new Error("Not Implemented");
	}
	function recvFIRMWARE_UPGRADE_STM32F3(ch, buf) {
	  throw new Error("Not Implemented");
	}
	async function sendFIRMWARE_UPGRADE_STM8S(ch, bp) {
	  throw new Error("Not Implemented");
	}
	function recvFIRMWARE_UPGRADE_STM8S(ch, buf) {
	  throw new Error("Not Implemented");
	}
	async function sendUNKNOWNVINT(ch, bp) {
	  throw new Error("Not Implemented");
	}
	function recvUNKNOWNVINT(ch, buf) {
	  throw new Error("Not Implemented");
	}

	/** @internal */

	class PhidgetUSBDevice extends LocalDevice {
	  constructor(conn, data, usbDev) {
	    super(conn, data);
	    this.usbDevice = usbDev;
	    this.phidlock = new PhidgetLock();
	    this.readlock = new PhidgetLock();
	    this.writelock = new PhidgetLock();
	    this.openCnt = 0;
	    this.interfaceNum = data.interfaceNum;
	    this.pusbParams = data.pusbParams;
	    this.sku;
	  }

	  get opened() {
	    return this.usbDevice.opened;
	  }

	  get claimed() {
	    var _a, _b;

	    return (_b = (_a = this.usbDevice.configuration) === null || _a === void 0 ? void 0 : _a.interfaces[0].claimed) !== null && _b !== void 0 ? _b : false;
	  }

	  async open() {
	    let fullOpen = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	    if (!this.phidlock.locked) throw new Error("Device MUST be locked before calling open");
	    this.closing = false;

	    if (!this.opened) {
	      try {
	        this.openCnt = 0;
	        await this.usbDevice.open();
	        if (this.usbDevice.configuration === null) await this.usbDevice.selectConfiguration(1);
	      } catch (err) {
	        this.closing = true;
	        await this.usbDevice.close();
	        this.openCnt = 0;
	        throw new PhidgetError(exports.ErrorCode.IO, "Error during USB open", err);
	      }
	    }

	    this.openCnt++;

	    if (fullOpen && !this.claimed) {
	      try {
	        await this.usbDevice.claimInterface(0);
	      } catch (err) {
	        this.closing = true;
	        await this.usbDevice.close();
	        this.openCnt = 0;
	        throw new PhidgetError(exports.ErrorCode.IO, "Failed to claim interface: ", err);
	      }

	      try {
	        await this.openReset();
	        await this.initAfterOpen();
	      } catch (err) {
	        this.closing = true;
	        await this.usbDevice.close();
	        this.openCnt = 0;
	        logerr("Device Initialization failed", err);
	        if (err instanceof PhidgetError && err.errorCode === exports.ErrorCode.BAD_VERSION) logwarn("This Phidget requires a new library - please upgrade.");
	        throw err;
	      }

	      loginfo("Opened USB Phidget: " + this);
	      if (this.conn._usbType === 1) this.conn._setEpTimeout(this.usbDevice, 0x81, 500);
	      this.pollUSBData().catch(err => {
	        if (this.closing) return;
	        logerr("Error polling USB Data", err);

	        this.conn._usbErrorDetach(this);
	      });
	    }
	  }

	  async pollUSBData() {
	    while (this.opened && !this.closing) {
	      try {
	        this.dataInput(await this.readPacket());
	      } catch (err) {
	        if (err.errorCode !== exports.ErrorCode.TIMEOUT) throw err;
	      }
	    }

	    throw new PhidgetError(exports.ErrorCode.NOT_ATTACHED);
	  }

	  async close() {
	    let fullClose = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	    if (!this.phidlock.locked) throw new Error("Device MUST be locked before calling close");

	    if (!this.opened) {
	      return;
	    }

	    this.openCnt--;

	    if (this.openCnt > 0) {
	      logdebug("Leaving USB device open, as open count is: " + this.openCnt);
	      return;
	    }

	    if (fullClose) {
	      if (!this.claimed) throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "USB Interface is already released");

	      try {
	        this.closing = true;
	        await this.closeReset();

	        try {
	          if (this.conn._usbType === 1) {
	            await this.readlock.acquire();
	            await this.writelock.acquire();
	          }

	          this.openCnt = 0;
	          await this.usbDevice.releaseInterface(0);
	          await this.usbDevice.close();
	        } finally {
	          if (this.conn._usbType === 1) {
	            this.readlock.release();
	            this.writelock.release();
	          }
	        }

	        loginfo("Closed USB Phidget: " + this);
	      } catch (err) {
	        throw new PhidgetError(exports.ErrorCode.IO, 'Failure during USB close', err);
	      }
	    } else {
	      try {
	        this.closing = true;
	        this.openCnt = 0;
	        await this.usbDevice.close();
	      } catch (err) {
	        throw new PhidgetError(exports.ErrorCode.IO, "Failed to close USB handle", err);
	      }
	    }
	  }

	  async transferPacket(transferType, packetType, index, bufferOrReadLen) {
	    switch (transferType) {
	      case 0:
	      case 2:
	      case 4:
	      case 6:
	        {
	          let result;

	          if (transferType === 6) {
	            if (bufferOrReadLen == undefined || typeof bufferOrReadLen !== 'object') throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT);
	            if (bufferOrReadLen.byteLength > this.pusbParams.maxPacketEP2) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT);
	            if (this.pusbParams.ep2type !== 1) throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	            logbuffer("USB Bulk OUT Packet", bufferOrReadLen);

	            try {
	              if (this.conn._usbType === 1) await this.writelock.acquire();
	              result = await this.usbDevice.transferOut(2, bufferOrReadLen);
	            } catch (err) {
	              throw new PhidgetError(exports.ErrorCode.IO, "USB Bulk transfer failed", err);
	            } finally {
	              if (this.conn._usbType === 1) this.writelock.release();
	            }
	          } else {
	            const controlTransferParams = {
	              requestType: "vendor",
	              recipient: 'interface',
	              request: transferType,
	              value: packetType << 8 | index,
	              index: this.interfaceNum
	            };

	            if (bufferOrReadLen != undefined && typeof bufferOrReadLen === 'object') {
	              if (bufferOrReadLen.byteLength > this.pusbParams.maxPacketEP0) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT);
	              logbuffer("USB Control OUT Packet", bufferOrReadLen);

	              try {
	                if (this.conn._usbType === 1) await this.writelock.acquire();
	                result = await this.usbDevice.controlTransferOut(controlTransferParams, bufferOrReadLen);
	              } catch (err) {
	                throw new PhidgetError(exports.ErrorCode.IO, "USB Control OUT transfer failed", err);
	              } finally {
	                if (this.conn._usbType === 1) this.writelock.release();
	              }
	            } else {
	              try {
	                if (this.conn._usbType === 1) await this.writelock.acquire();
	                result = await this.usbDevice.controlTransferOut(controlTransferParams);
	              } catch (err) {
	                throw new PhidgetError(exports.ErrorCode.IO, "USB Control OUT transfer failed", err);
	              } finally {
	                if (this.conn._usbType === 1) this.writelock.release();
	              }
	            }
	          }

	          if (result.status !== 'ok') throw new PhidgetError(exports.ErrorCode.IO, "controlTransferOut error. Status: " + result.status);
	          if (bufferOrReadLen != undefined && typeof bufferOrReadLen === 'object' && result.bytesWritten !== bufferOrReadLen.byteLength) throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "USB send failed to write expected number of bytes.");
	          break;
	        }

	      case 1:
	      case 3:
	      case 5:
	        {
	          if (!(typeof bufferOrReadLen === 'number')) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT);
	          if (bufferOrReadLen > this.pusbParams.maxPacketEP0) bufferOrReadLen = this.pusbParams.maxPacketEP0;
	          const controlTransferParams = {
	            requestType: "vendor",
	            recipient: 'interface',
	            request: transferType,
	            value: packetType << 8 | index,
	            index: this.interfaceNum
	          };
	          let descReq;

	          try {
	            if (this.conn._usbType === 1) await this.writelock.acquire();
	            descReq = await this.usbDevice.controlTransferIn(controlTransferParams, bufferOrReadLen);
	          } catch (err) {
	            throw new PhidgetError(exports.ErrorCode.IO, "USB Control IN transfer failed", err);
	          } finally {
	            if (this.conn._usbType === 1) this.writelock.release();
	          }

	          if (descReq.status !== 'ok') throw new PhidgetError(exports.ErrorCode.IO, "USB Control Transfer failure: " + descReq.status);
	          if (descReq.data == undefined) throw new PhidgetError(exports.ErrorCode.IO, "USB Control IN failed to read data");
	          logbuffer("USB Control IN Packet", descReq.data);
	          return descReq.data;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	    }
	  }

	  async readPacket() {
	    let xfer;

	    if (this.conn._usbType === 1) {
	      try {
	        await this.readlock.acquire();
	        xfer = await this.usbDevice.transferIn(1, this.pusbParams.maxPacketEP1);
	      } catch (err) {
	        if (err instanceof Error && err.message.includes('LIBUSB_TRANSFER_TIMED_OUT')) throw new PhidgetError(exports.ErrorCode.TIMEOUT, "Read timed out", err);
	        throw new PhidgetError(exports.ErrorCode.IO, "Error reading USB packet", err);
	      } finally {
	        this.readlock.release();
	      }
	    } else {
	      try {
	        xfer = await this.usbDevice.transferIn(1, this.pusbParams.maxPacketEP1);
	      } catch (err) {
	        throw new PhidgetError(exports.ErrorCode.IO, "Error reading USB packet", err);
	      }
	    }

	    if (xfer.status !== 'ok') throw new PhidgetError(exports.ErrorCode.IO, "USB IN Transfer failure: " + xfer.status);
	    if (xfer.data == undefined) throw new PhidgetError(exports.ErrorCode.IO, "USB IN Transfer failed to read data");
	    logbuffer("Received USB Packet", xfer.data);
	    return xfer.data;
	  }

	  async readDescriptor(type, index) {
	    let desc;

	    try {
	      if (this.conn._usbType === 1) await this.writelock.acquire();
	      desc = await GetDescriptor(this.usbDevice, type, index, 0);
	    } finally {
	      if (this.conn._usbType === 1) this.writelock.release();
	    }

	    return desc;
	  }

	  getMaxOutPacketSize() {
	    if (this.pusbParams.ep2type !== 0) return this.pusbParams.maxPacketEP2;
	    return this.pusbParams.maxPacketEP0;
	  }

	  async writeLabel(label) {
	    if (label.length > 10) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Label is too long. Max 10 characters.");

	    if (label !== undefined || label !== null) {
	      const bufftemp = new Uint8Array(StringToWordByteArray(label).buffer);
	      const buffer = [0, 3, ...values(bufftemp).call(bufftemp)];
	      buffer[0] = buffer.length;
	      await this.transferPacket(4, 36, 0, new Uint8Array(buffer));
	      this.label = label;
	    }
	  }

	  async closeReset() {
	    await this.transferPacket(4, 33, 0);
	  }

	  async openReset() {
	    await this.transferPacket(4, 32, 0);
	  }

	  async rebootFirmwareUpgrade() {
	    await this.transferPacket(4, 1, 0);
	  }

	  async lock() {
	    await this.phidlock.acquire();
	  }

	  unlock() {
	    this.phidlock.release();
	  }

	  _handleDataIntervalPacket(bp, interruptRate) {
	    let __di = bp.getNumber(0);

	    if (__di % interruptRate !== 0) {
	      __di = (__di / interruptRate + 1) * interruptRate;
	      bp.remove("0");
	      bp.set({
	        name: "0",
	        type: "u",
	        value: __di
	      });
	    }

	    if (bp.entryCount > 1) bp.set({
	      name: "1",
	      type: "g",
	      value: __di
	    });
	    return __di;
	  }

	}

	const HUB_PORT_ID_MAX = 0x0F;
	const VINTHUB_MAXPORTS = 6;
	const PACKETID_MAX = 126;
	const PACKETIDS_PER_PORT = PACKETID_MAX / 6;
	const PACKETRETURN_notACK = 0x80;
	const INPACKET_HUBMSG_FLAG = 0x80;
	const IN_VINTPACKET_START = 0x08;
	const UNKNOWN_VINT_ID = 0xff0;

	class HubDevice extends PhidgetUSBDevice {
	  constructor(conn, data, usbDev) {
	    super(conn, data, usbDev);

	    switch (this.devDef.uid) {
	      case 207:
	      case 209:
	      case 218:
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }

	    this.vintDevices = {};
	    this.hubPortProps = [];
	    this.outstandingPacketCnt = new Array(this.numVintPorts).fill(0);
	    this.packetOutCounter = new Array(this.numVintPorts).fill(0);
	    this.internalPacketInBufferLen = 0;
	    this.packetCounter = -1;
	    this.splitPacketStoragePtr = 0;
	    this.splitPacketStorage = new Array(54).fill(0);
	    this.scanError = 0;
	    this.packetTrackers = new PacketTrackers();
	  }

	  get numVintPorts() {
	    return this.devDef.cn[0];
	  }

	  get numVintPortModes() {
	    return this.devDef.cn[1];
	  }

	  async initAfterCreate() {
	    for (let i = 0; i < this.numVintPorts; i++) await this.updatePortProperties(i);
	  }

	  makePacket(vintDevice, packetID, bufferIn) {
	    const buffer = new Uint8Array(new ArrayBuffer(MAX_OUT_PACKET_SIZE));
	    if (buffer.byteLength < this.getMaxOutPacketSize()) throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	    if (bufferIn == undefined) bufferIn = new Uint8Array(0);
	    if (this.getMaxOutPacketSize() < bufferIn.length + 4) throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	    buffer.set([this.packetOutCounter[vintDevice.hubPort] << 4 & 0xF0 | vintDevice.hubPort & 0x0F], 0);
	    buffer.set([vintDevice.vintID & 0xFF], 1);
	    buffer.set([vintDevice.vintID >> 4 & 0xF0], 2);
	    buffer.set([packetID], 3);
	    buffer.set(bufferIn, 4);
	    return buffer.slice(0, bufferIn.length + 4);
	  }

	  async openAndUpdatePortProperties(port) {
	    try {
	      await this.lock();
	      let opened = false;

	      try {
	        await this.open(false);
	        opened = true;
	        await this.updatePortProperties(port);
	      } finally {
	        if (opened) await this.close(false);
	      }
	    } finally {
	      this.unlock();
	    }
	  }

	  async updatePortProperties(port) {
	    let prop, propLen;
	    const buf = await this.readDescriptor(69, port);
	    const vintPortDesc = {
	      bLength: buf.getUint8(0),
	      bDescriptorType: buf.getUint8(1),
	      bPortMode: buf.getUint8(2),
	      bPowered: buf.getUint8(3),
	      dwSpeedHz: buf.getUint32(4, true),
	      bVINTProtocolVersion: buf.getUint8(8),
	      VINTProperties: new DataView(buf.buffer, 9)
	    };
	    this.hubPortProps[port] = {
	      portProto: vintPortDesc.bVINTProtocolVersion,
	      portSpeed: vintPortDesc.dwSpeedHz,
	      portMode: vintPortDesc.bPortMode,
	      portPowered: !!vintPortDesc.bPowered,
	      portSuppSetSpeed: false,
	      portMaxSpeed: 100000
	    };

	    for (let i = 0; i < vintPortDesc.VINTProperties.byteLength; i += propLen) {
	      prop = vintPortDesc.VINTProperties.getUint8(i) & 0x1F;
	      propLen = ((vintPortDesc.VINTProperties.getUint8(i) & 0xE0) >> 5) + 1;

	      switch (prop) {
	        case 2:
	          this.hubPortProps[port].portSuppSetSpeed = true;
	          break;

	        case 3:
	          this.hubPortProps[port].portMaxSpeed = vintPortDesc.VINTProperties.getUint32(i + 1, false);
	          break;

	        default:
	          loginfo("Unknown VINT Port property: " + prop);
	      }
	    }
	  }

	  async sendHubPacket(hubPacketType, bufferIn) {
	    await this.transferPacket(2, 64 | hubPacketType, 0, bufferIn);
	  }

	  async sendHubPortPacket(hubPort, hubPacketType, bufferIn) {
	    await this.transferPacket(0, 64 | hubPacketType, hubPort, bufferIn);
	  }

	  processPacketReturnCodes(buffer, length) {
	    let readPtr = 0;

	    while (readPtr < length) {
	      const packetID = buffer.getUint8(readPtr) & 0x7F;
	      const port = Math.trunc((packetID - 1) / PACKETIDS_PER_PORT);
	      let response = 224;

	      if (buffer.getUint8(readPtr) & PACKETRETURN_notACK) {
	        readPtr++;
	        response = buffer.getUint8(readPtr);
	      }

	      readPtr++;

	      const NotFound = () => {
	        if (response !== 233) {
	          loginfo("An unexpected PacketID was returned: " + packetID + "(" + response + " - " + VINTPacketDescription[response] + "). " + "Probably this packet is from a previous session or detached device.");
	        }

	        this.readInTXBufferCounts(port).catch(err => {
	          logwarn("Failure to read TX Buffer counts", err);
	        });
	      };

	      const packetTracker = this.packetTrackers.packetTracker.get(packetID);

	      if (!packetTracker) {
	        NotFound();
	        continue;
	      }

	      const packetSpace = packetTracker.len;
	      logverbose("Packet " + packetID + " response: " + response + " - " + VINTPacketDescription[response] + ", Port " + port);
	      const res = VINTPacketCode_to_PhidgetReturnCode[response];

	      try {
	        packetTracker.setPacketReturnCode(res);
	      } catch (err) {
	        NotFound();
	        continue;
	      }

	      this.releasePacketSpace(port, packetSpace);

	      switch (res) {
	        case exports.ErrorCode.SUCCESS:
	          break;

	        case exports.ErrorCode.NOT_CONFIGURED:
	        case exports.ErrorCode.INVALID_ARGUMENT:
	        case exports.ErrorCode.INVALID:
	        case exports.ErrorCode.INVALID_PACKET:
	          break;

	        case exports.ErrorCode.NO_SPACE:
	          logerr("Got a NOSPACE response from a VINT device, Port " + port + ". " + "This usually indicates firmware problems.");
	          this.readInTXBufferCounts(port).catch(err => {
	            logwarn("Failure to read TX Buffer counts", err);
	          });
	          break;

	        case exports.ErrorCode.NOT_ATTACHED:
	          loginfo("Got a NOTATTACHED response from a VINT device, Port " + port);
	          break;

	        case exports.ErrorCode.BUSY:
	          logerr("Got a NAK response form a VINT device, Port " + port + ". " + "This means the device decided not to deal with this data; try again.");
	          break;

	        case exports.ErrorCode.FILE_TOO_BIG:
	          logerr("Got a TOOBIG response from a VINT device, Port " + port + ". " + "This means the packet was too big.");
	          break;

	        case exports.ErrorCode.UNEXPECTED:
	        default:
	          logerr("Got an unexpected response from a VINT device: " + response + " - " + VINTPacketDescription[response] + ". " + "This usually indicates firmware problems.");
	          break;
	      }
	    }
	  }

	  processVintPacket(buffer) {
	    const vintPort = buffer.getUint8(0) & 0x07;
	    const vintID = ((buffer.getUint8(0) & 0xF0) << 4) + buffer.getUint8(1);
	    const dataCount = buffer.getUint8(2) & 0x3F;
	    let childIndex = vintPort;
	    if (vintID <= HUB_PORT_ID_MAX) childIndex += vintID * this.numVintPorts;
	    const vintDevice = this.vintDevices[childIndex];
	    if (!vintDevice) return;

	    if (vintDevice.vintID !== vintID) {
	      loginfo("Seeing VINT Data on Port: " + vintPort + " for VINT Device: " + vintID + ", but device in structure is: " + vintDevice.vintID);
	      return;
	    }

	    vintDevice.dataInput(new DataView(buffer.buffer, 2 + buffer.byteOffset, dataCount + 1));
	  }

	  async readInTXBufferCounts(port) {
	    this.outstandingPacketCnt[port] = 18446744073709552000;
	    await this.sendHubPacket(2);
	  }

	  async initAfterOpen() {
	    let i;
	    this.internalPacketInBufferLen = 18446744073709552000;

	    for (i = 0; i < this.numVintPorts; i++) this.outstandingPacketCnt[i] = 18446744073709552000;

	    this.packetCounter = -1;
	    this.splitPacketStoragePtr = 0;
	    const len = VINTHUB_MAXPORTS + 1;
	    const buffer = await this.transferPacket(3, 64 | 2, 0, len);
	    if (len !== this.numVintPorts + 1) throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Bad buffer length from transferpacket from HubDevice");
	    this.internalPacketInBufferLen = buffer.getUint8(0);

	    for (i = 0; i < this.numVintPorts; i++) {
	      this.outstandingPacketCnt[i] = this.internalPacketInBufferLen - 1 - buffer.getUint8(i + 1);
	    }
	  }

	  dataInput(buffer) {
	    let dataCount;
	    let i;
	    const packetCounter = buffer.getUint8(0) >> 4 & 0x07;
	    const packetReturnLen = buffer.getUint8(0) & 0x0F;
	    const dataEndIndex = buffer.byteLength - packetReturnLen;
	    let nextPacketStart = buffer.getUint8(1) & 0x3F;
	    let readPtr = 2;
	    let killOutstandingPackets = false;
	    this.processPacketReturnCodes(new DataView(buffer.buffer, dataEndIndex), buffer.byteLength - dataEndIndex);

	    if (buffer.getUint8(1) & INPACKET_HUBMSG_FLAG) {
	      switch (buffer.getUint8(readPtr)) {
	        case 0:
	          readPtr++;
	          logdebug("VINTHUB_HUBINPACKET_TXBUFFERSTATUS packet filling outstandingPacketCnt");

	          for (i = 0; i < this.numVintPorts; i++) {
	            this.outstandingPacketCnt[i] = this.internalPacketInBufferLen - 1 - buffer.getUint8(readPtr++);
	          }

	          break;

	        case 1:
	          readPtr++;

	          for (i = 0; i < this.numVintPorts; i++) {
	            if (buffer.getUint8(readPtr) & 0x01 << i) {
	              logwarn("Hub overcurrent detected on Port: " + i);
	              const bp = new BridgePacket();
	              bp.set({
	                name: "0",
	                type: "d",
	                value: exports.ErrorEventCode.OVER_CURRENT
	              });
	              bp.set({
	                name: "1",
	                type: "s",
	                value: "Hub overcurrent detected on Port " + i + ". Check for short."
	              });

	              for (const v in this.vintDevices) {
	                if (this.vintDevices[v].hubPort !== i) continue;

	                for (const c in this.vintDevices[v].channels) {
	                  const ch = this.vintDevices[v].channels[c];
	                  if (ch.isopen) ch.sendErrorEvent(bp);
	                }
	              }
	            }
	          }

	          readPtr++;
	          break;

	        case 2:
	          readPtr++;

	          for (i = 0; i < this.numVintPorts; i++) {
	            if (buffer.getUint8(readPtr) & 0x01 << i) {
	              if (this.vintDevices[i]) {
	                this.conn._deviceDetach(this.vintDevices[i]);

	                delete this.vintDevices[i];
	              }
	            }
	          }

	          readPtr++;
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Got unexpected InPacketType: " + buffer.getUint8(readPtr));
	      }
	    }

	    if (this.packetCounter === -1) {
	      readPtr += nextPacketStart;
	    } else {
	      if (this.packetCounter !== packetCounter) {
	        logwarn("One or more data packets were lost on the Hub.");
	        this.splitPacketStoragePtr = 0;
	        readPtr += nextPacketStart;
	        killOutstandingPackets = true;
	        this.sendHubPacket(2).catch(err => {
	          logwarn("Error reading TX Buffer Status", err);
	        });
	      } else {
	        if (nextPacketStart && !this.splitPacketStoragePtr) {
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Problem with split data in vint packet. This should be a firmware/library bug.");
	        }
	      }
	    }

	    this.packetCounter = packetCounter + 1 & 0x07;

	    if (this.splitPacketStoragePtr) {
	      while (nextPacketStart--) this.splitPacketStorage[this.splitPacketStoragePtr++] = buffer.getUint8(readPtr++);

	      this.processVintPacket(new DataView(new Uint8Array(this.splitPacketStorage).buffer));
	      this.splitPacketStoragePtr = 0;
	    }

	    while (readPtr < dataEndIndex) {
	      if ((buffer.getUint8(readPtr) & IN_VINTPACKET_START) === 0x00) break;

	      if (readPtr < dataEndIndex - 2) {
	        if (buffer.getUint8(readPtr + 2) & 0x80) {
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Got an unexpected MSG in vint data: " + buffer.getUint8(readPtr + 2));
	        }

	        dataCount = buffer.getUint8(readPtr + 2) & 0x3F;

	        if (readPtr + 3 + dataCount <= dataEndIndex) {
	          this.processVintPacket(new DataView(buffer.buffer, readPtr));
	          readPtr += dataCount + 3;
	          continue;
	        }
	      }

	      while (readPtr < dataEndIndex) this.splitPacketStorage[this.splitPacketStoragePtr++] = buffer.getUint8(readPtr++);
	    }

	    if (killOutstandingPackets) {
	      loginfo("Killing outstanding packets on hub");

	      for (i = 0; i < this.numVintPorts; i++) {
	        if (this.outstandingPacketCnt[i]) this.outstandingPacketCnt[i] = 18446744073709552000;
	        this.packetTrackers.setPacketsReturnCode(i, exports.ErrorCode.INTERRUPTED);
	      }
	    }
	  }

	  async bridgeInput(_channel, bp) {
	    switch (bp.vpkt) {
	      case 60:
	        {
	          const hubPort = bp.getNumber(0);
	          const timeout = bp.getNumber(1);
	          const buffer = new Uint8Array([timeout & 0xFF, timeout >> 8 & 0xFF]);
	          await this.sendHubPortPacket(hubPort, 1, buffer);
	          break;
	        }

	      case 72:
	        {
	          const hubPort = bp.getNumber(0);
	          await this.setPortMode(hubPort, bp.getNumber(1));
	          break;
	        }

	      case 73:
	        {
	          const hubPort = bp.getNumber(0);
	          const buffer = new Uint8Array([bp.getNumber(1)]);
	          await this.sendHubPortPacket(hubPort, 3, buffer);
	          break;
	        }

	      case 107:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);

	      case 34:
	      case 111:
	      case 143:
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type");
	    }
	  }

	  async setPortMode(index, newVal) {
	    if (!this.opened) throw new PhidgetError(exports.ErrorCode.NOT_ATTACHED);
	    const buffer = new Uint8Array([newVal]);
	    logdebug("Setting Port: " + index + " mode to " + newVal + " on " + this.name);
	    await this.sendHubPortPacket(index, 0, buffer);
	  }

	  releasePacketSpace(hubPort, packetSize) {
	    if (this.outstandingPacketCnt[hubPort] !== 18446744073709552000) {
	      if (this.outstandingPacketCnt[hubPort] < packetSize) this.outstandingPacketCnt[hubPort] = 0;else this.outstandingPacketCnt[hubPort] -= packetSize;
	      if (this.outstandingPacketCnt[hubPort] > this.internalPacketInBufferLen) throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "PacketSpace is out of spec");
	      logverbose("Releasing " + packetSize + " bytes, " + (this.internalPacketInBufferLen - this.outstandingPacketCnt[hubPort]) + " remaining, Port " + hubPort);
	    }
	  }

	  async claimPacketSpace(hubPort, packetSize) {
	    if (!this.opened) throw new PhidgetError(exports.ErrorCode.NOT_ATTACHED);
	    const tm = Date.now() + 2000;

	    for (;;) {
	      const pktCnt = this.outstandingPacketCnt[hubPort];
	      if (pktCnt !== 18446744073709552000 && pktCnt + packetSize < this.internalPacketInBufferLen) break;
	      if (Date.now() >= tm) throw new PhidgetError(exports.ErrorCode.TIMEOUT, "Timed out claiming packet space, Port " + hubPort);
	      await PhidgetSleep(2);
	    }

	    this.outstandingPacketCnt[hubPort] += packetSize;
	    logverbose("Claiming " + packetSize + " bytes, " + (this.internalPacketInBufferLen - this.outstandingPacketCnt[hubPort]) + " remaining, Port " + hubPort);
	  }

	  async scanVINTDevice(childIndex, id, version, port, realID) {
	    var _a;

	    let vintDeviceDesc;
	    let buf;
	    let prop, propLen;

	    for (const dev of PhidgetDevices.VINT) {
	      if (dev.i !== id) continue;
	      if (version >= dev.v[1] || version < dev.v[0]) continue;
	      const vint = this.vintDevices[childIndex];

	      if (vint) {
	        if (vint.devDef === dev && vint.version === version) return;

	        this.conn._deviceDetach(vint);

	        delete this.vintDevices[childIndex];
	      }

	      const data = {
	        vintProto: 255,
	        suppSetSpeed: false,
	        maxSpeed: 4294967295,
	        commSpeed: 4294967295,
	        hubPort: port,
	        isHubPort: id <= HUB_PORT_ID_MAX,
	        uniqueIndex: childIndex
	      };

	      if (id > HUB_PORT_ID_MAX) {
	        try {
	          buf = await this.readDescriptor(68, port);
	          vintDeviceDesc = {
	            bLength: buf.getUint8(0),
	            bDescriptorType: buf.getUint8(1),
	            wID: buf.getUint16(2),
	            wVersion: buf.getUint16(4, true),
	            bVINTProtocolVersion: buf.getUint8(6),
	            VINTProperties: new DataView(buf.buffer, 7)
	          };
	          data.vintProto = vintDeviceDesc.bVINTProtocolVersion;

	          for (let i = 0; i < vintDeviceDesc.VINTProperties.byteLength; i += propLen) {
	            prop = vintDeviceDesc.VINTProperties.getUint8(i) & 0x1F;
	            propLen = ((vintDeviceDesc.VINTProperties.getUint8(i) & 0xE0) >> 5) + 1;

	            switch (prop) {
	              case 0:
	              case 1:
	                break;

	              case 2:
	                data.suppSetSpeed = true;
	                break;

	              case 3:
	                data.maxSpeed = vintDeviceDesc.VINTProperties.getUint32(i + 1, false);
	                break;

	              default:
	                loginfo("Unknown VINT Device Property: " + vintDeviceDesc.VINTProperties.getUint8(i));
	                break;
	            }
	          }

	          await this.updatePortProperties(port);
	        } catch (err) {
	          logwarn("Couldn't read VINT Device descriptor from a Hub", err);
	        }
	      }

	      data.commSpeed = (_a = this.hubPortProps[port].portSpeed) !== null && _a !== void 0 ? _a : 4294967295;
	      const vintData = {
	        type: 'VINT',
	        version: version,
	        label: this.label,
	        serialNumber: this.serialNumber,
	        devDef: dev,
	        fwstr: dev.s,
	        id: this.devDef.uid + "_" + this.serialNumber + '_' + port + '_' + dev.uid,
	        parent: this,
	        vintDeviceProps: data
	      };
	      const vintDev = new VINTDevice(this.conn, vintData);
	      this.vintDevices[vintDev.index] = vintDev;

	      this.conn._attachLocalDevice(vintDev);

	      if (id === UNKNOWN_VINT_ID) logwarn("A VINT Phidget (ID: " + realID + " Version: " + version + " HubPort: " + port + ") was found which is not supported by the library. A library upgrade is required to work with this Phidget.");
	      return;
	    }

	    await this.scanVINTDevice(childIndex, UNKNOWN_VINT_ID, version, port, id);
	  }

	  async scanVINTDevices() {
	    let i, j, childIndex;
	    let deviceID;
	    let version;
	    let buf = await this.readDescriptor(67, 0);
	    const len = buf.byteLength;
	    buf = new DataView(buf.buffer.slice(2));

	    if (len !== this.numVintPorts * 4 + this.numVintPortModes * 4 + 2) {
	      throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Wrong VINT Ports descriptor length from Hub: " + len + "/" + (this.numVintPorts * 4 + this.numVintPortModes * 4 + 2));
	    }

	    for (childIndex = 0, i = 0; i < this.numVintPorts; i++) {
	      deviceID = buf.getUint16(0, true);
	      version = buf.getUint8(3) * 100 + buf.getUint8(2);
	      buf = new DataView(buf.buffer.slice(4));

	      if (deviceID > HUB_PORT_ID_MAX) {
	        await this.scanVINTDevice(childIndex, deviceID, version, i);
	      } else {
	        if (this.vintDevices[childIndex]) {
	          this.conn._deviceDetach(this.vintDevices[childIndex]);

	          delete this.vintDevices[childIndex];
	        }
	      }

	      childIndex++;
	      if (deviceID > exports.HubPortMode.VINT && deviceID <= HUB_PORT_ID_MAX) await this.resetVINTPortModeIfNeeded(i, deviceID);
	    }

	    for (j = 0; j < this.numVintPortModes; j++) {
	      deviceID = buf.getUint16(0, true);
	      version = buf.getUint8(3) * 100 + buf.getUint8(2);
	      buf = new DataView(buf.buffer.slice(4));

	      for (i = 0; i < this.numVintPorts; i++) await this.scanVINTDevice(childIndex++, deviceID, version, i);
	    }
	  }

	  async resetVINTPortModeIfNeeded(port, mode) {
	    if (mode === exports.HubPortMode.VINT) return;

	    for (const userphid of UserPhidgets) {
	      if (userphid._isattached) continue;
	      if (userphid._hubPort !== port) continue;
	      if (userphid._isHubPort) continue;
	      if (userphid._serialNumber === Phidget.ANY_SERIAL_NUMBER && userphid._deviceLabel === Phidget.ANY_LABEL) continue;

	      if (userphid._serialNumber !== Phidget.ANY_SERIAL_NUMBER) {
	        if (userphid._serialNumber !== this.serialNumber) continue;
	      }

	      if (userphid._deviceLabel !== Phidget.ANY_LABEL) {
	        if (userphid._deviceLabel !== this.label) continue;
	      }

	      let opened = false;

	      try {
	        await this.open();
	        opened = true;
	        await this.setPortMode(port, exports.HubPortMode.VINT);
	      } finally {
	        if (opened) await this.close();
	      }
	    }
	  }

	}

	/** @internal */

	function getVINTIO(uid) {
	  switch (uid) {
	    case 21:
	      return {
	        send: send1014_3_VINT,
	        recv: recv1014_3_VINT
	      };

	    case 26:
	      return {
	        send: send1017_2_VINT,
	        recv: recv1017_2_VINT
	      };

	    case 66:
	      return {
	        send: send1055_1_VINT,
	        recv: recv1055_1_VINT
	      };

	    case 93:
	      return {
	        send: sendDIGITALINPUT_PORT,
	        recv: recvDIGITALINPUT_PORT
	      };

	    case 94:
	      return {
	        send: sendDIGITALOUTPUT_PORT,
	        recv: recvDIGITALOUTPUT_PORT
	      };

	    case 95:
	      return {
	        send: sendDIGITALOUTPUT_PORT_FAILSAFE,
	        recv: recvDIGITALOUTPUT_PORT_FAILSAFE
	      };

	    case 96:
	      return {
	        send: sendVOLTAGEINPUT_PORT,
	        recv: recvVOLTAGEINPUT_PORT
	      };

	    case 97:
	      return {
	        send: sendVOLTAGEINPUT_PORT_5V25,
	        recv: recvVOLTAGEINPUT_PORT_5V25
	      };

	    case 98:
	      return {
	        send: sendVOLTAGERATIOINPUT_PORT,
	        recv: recvVOLTAGERATIOINPUT_PORT
	      };

	    case 99:
	      return {
	        send: sendADP1000,
	        recv: recvADP1000
	      };

	    case 106:
	      return {
	        send: sendDAQ1000,
	        recv: recvDAQ1000
	      };

	    case 107:
	      return {
	        send: sendDAQ1000_5V25,
	        recv: recvDAQ1000_5V25
	      };

	    case 108:
	      return {
	        send: sendOUT1000,
	        recv: recvOUT1000
	      };

	    case 109:
	      return {
	        send: sendOUT1000_Failsafe,
	        recv: recvOUT1000_Failsafe
	      };

	    case 110:
	      return {
	        send: sendOUT1001,
	        recv: recvOUT1001
	      };

	    case 111:
	      return {
	        send: sendOUT1001_Failsafe,
	        recv: recvOUT1001_Failsafe
	      };

	    case 112:
	      return {
	        send: sendOUT1002,
	        recv: recvOUT1002
	      };

	    case 113:
	      return {
	        send: sendOUT1002_Failsafe,
	        recv: recvOUT1002_Failsafe
	      };

	    case 115:
	      return {
	        send: sendDAQ1200,
	        recv: recvDAQ1200
	      };

	    case 116:
	      return {
	        send: sendOUT1100,
	        recv: recvOUT1100
	      };

	    case 117:
	      return {
	        send: sendOUT1100_Failsafe,
	        recv: recvOUT1100_Failsafe
	      };

	    case 118:
	      return {
	        send: sendOUT1100_Failsafe_Frequency,
	        recv: recvOUT1100_Failsafe_Frequency
	      };

	    case 119:
	      return {
	        send: sendDAQ1300,
	        recv: recvDAQ1300
	      };

	    case 120:
	      return {
	        send: sendDAQ1301,
	        recv: recvDAQ1301
	      };

	    case 121:
	      return {
	        send: sendDAQ1400,
	        recv: recvDAQ1400
	      };

	    case 122:
	      return {
	        send: sendDAQ1400_120,
	        recv: recvDAQ1400_120
	      };

	    case 123:
	      return {
	        send: sendDAQ1500,
	        recv: recvDAQ1500
	      };

	    case 124:
	      return {
	        send: sendVCP1100,
	        recv: recvVCP1100
	      };

	    case 126:
	      return {
	        send: sendDCC1000,
	        recv: recvDCC1000
	      };

	    case 127:
	      return {
	        send: sendDCC1000_POSITIONCONTROL,
	        recv: recvDCC1000_POSITIONCONTROL
	      };

	    case 128:
	      return {
	        send: sendDCC1000_POSITIONCONTROL_FAILSAFE,
	        recv: recvDCC1000_POSITIONCONTROL_FAILSAFE
	      };

	    case 131:
	      return {
	        send: sendDCC1001,
	        recv: recvDCC1001
	      };

	    case 132:
	      return {
	        send: sendDCC1001_Failsafe,
	        recv: recvDCC1001_Failsafe
	      };

	    case 133:
	      return {
	        send: sendDCC1002,
	        recv: recvDCC1002
	      };

	    case 134:
	      return {
	        send: sendDCC1002_Failsafe,
	        recv: recvDCC1002_Failsafe
	      };

	    case 135:
	      return {
	        send: sendDCC1003,
	        recv: recvDCC1003
	      };

	    case 136:
	      return {
	        send: sendDCC1003_Failsafe,
	        recv: recvDCC1003_Failsafe
	      };

	    case 137:
	      return {
	        send: sendDCC1100,
	        recv: recvDCC1100
	      };

	    case 138:
	      return {
	        send: sendDCC1100_Failsafe,
	        recv: recvDCC1100_Failsafe
	      };

	    case 139:
	      return {
	        send: sendDST1000,
	        recv: recvDST1000
	      };

	    case 140:
	      return {
	        send: sendDST1001,
	        recv: recvDST1001
	      };

	    case 141:
	      return {
	        send: sendDST1002,
	        recv: recvDST1002
	      };

	    case 142:
	      return {
	        send: sendDST1200,
	        recv: recvDST1200
	      };

	    case 143:
	      return {
	        send: sendENC1000,
	        recv: recvENC1000
	      };

	    case 144:
	      return {
	        send: sendHIN1101,
	        recv: recvHIN1101
	      };

	    case 145:
	      return {
	        send: sendHIN1000,
	        recv: recvHIN1000
	      };

	    case 146:
	      return {
	        send: sendHIN1001,
	        recv: recvHIN1001
	      };

	    case 147:
	      return {
	        send: sendHIN1100,
	        recv: recvHIN1100
	      };

	    case 148:
	      return {
	        send: sendHUM1000,
	        recv: recvHUM1000
	      };

	    case 149:
	      return {
	        send: sendHUM1001,
	        recv: recvHUM1001
	      };

	    case 150:
	      return {
	        send: sendLCD1100,
	        recv: recvLCD1100
	      };

	    case 151:
	      return {
	        send: sendLED1000,
	        recv: recvLED1000
	      };

	    case 152:
	      return {
	        send: sendLUX1000,
	        recv: recvLUX1000
	      };

	    case 153:
	      return {
	        send: sendHUM1100,
	        recv: recvHUM1100
	      };

	    case 155:
	      return {
	        send: sendMOT1100,
	        recv: recvMOT1100
	      };

	    case 158:
	      return {
	        send: sendMOT1101,
	        recv: recvMOT1101
	      };

	    case 160:
	      return {
	        send: sendMOT1102,
	        recv: recvMOT1102
	      };

	    case 165:
	      return {
	        send: sendMOT0110_VINT,
	        recv: recvMOT0110_VINT
	      };

	    case 166:
	      return {
	        send: sendPRE1000,
	        recv: recvPRE1000
	      };

	    case 167:
	      return {
	        send: sendRCC1000,
	        recv: recvRCC1000
	      };

	    case 168:
	      return {
	        send: sendRCC1000_Failsafe,
	        recv: recvRCC1000_Failsafe
	      };

	    case 170:
	      return {
	        send: sendREL1000,
	        recv: recvREL1000
	      };

	    case 171:
	      return {
	        send: sendREL1000_Failsafe,
	        recv: recvREL1000_Failsafe
	      };

	    case 172:
	      return {
	        send: sendREL1100,
	        recv: recvREL1100
	      };

	    case 173:
	      return {
	        send: sendREL1100_Failsafe,
	        recv: recvREL1100_Failsafe
	      };

	    case 174:
	      return {
	        send: sendREL1100_Failsafe_Frequency,
	        recv: recvREL1100_Failsafe_Frequency
	      };

	    case 175:
	      return {
	        send: sendREL1101,
	        recv: recvREL1101
	      };

	    case 176:
	      return {
	        send: sendREL1101_Failsafe,
	        recv: recvREL1101_Failsafe
	      };

	    case 177:
	      return {
	        send: sendREL1101_1,
	        recv: recvREL1101_1
	      };

	    case 179:
	      return {
	        send: sendSAF1000,
	        recv: recvSAF1000
	      };

	    case 180:
	      return {
	        send: sendSAF1000_Failsafe,
	        recv: recvSAF1000_Failsafe
	      };

	    case 181:
	      return {
	        send: sendSND1000,
	        recv: recvSND1000
	      };

	    case 182:
	      return {
	        send: sendSTC1000,
	        recv: recvSTC1000
	      };

	    case 183:
	      return {
	        send: sendSTC1000_Failsafe,
	        recv: recvSTC1000_Failsafe
	      };

	    case 184:
	      return {
	        send: sendSTC1001,
	        recv: recvSTC1001
	      };

	    case 185:
	      return {
	        send: sendSTC1001_Failsafe,
	        recv: recvSTC1001_Failsafe
	      };

	    case 186:
	      return {
	        send: sendSTC1002,
	        recv: recvSTC1002
	      };

	    case 187:
	      return {
	        send: sendSTC1002_Failsafe,
	        recv: recvSTC1002_Failsafe
	      };

	    case 188:
	      return {
	        send: sendSTC1003,
	        recv: recvSTC1003
	      };

	    case 189:
	      return {
	        send: sendSTC1003_Failsafe,
	        recv: recvSTC1003_Failsafe
	      };

	    case 190:
	      return {
	        send: sendSTC1003_1,
	        recv: recvSTC1003_1
	      };

	    case 193:
	      return {
	        send: sendTMP1000,
	        recv: recvTMP1000
	      };

	    case 194:
	      return {
	        send: sendTMP1100,
	        recv: recvTMP1100
	      };

	    case 195:
	      return {
	        send: sendTMP1101,
	        recv: recvTMP1101
	      };

	    case 196:
	      return {
	        send: sendTMP1101_1,
	        recv: recvTMP1101_1
	      };

	    case 197:
	      return {
	        send: sendTMP1200,
	        recv: recvTMP1200
	      };

	    case 200:
	      return {
	        send: sendVCP1000,
	        recv: recvVCP1000
	      };

	    case 201:
	      return {
	        send: sendVCP1001,
	        recv: recvVCP1001
	      };

	    case 202:
	      return {
	        send: sendVCP1001_110,
	        recv: recvVCP1001_110
	      };

	    case 203:
	      return {
	        send: sendVCP1002,
	        recv: recvVCP1002
	      };

	    case 204:
	      return {
	        send: sendVCP1002_110,
	        recv: recvVCP1002_110
	      };

	    case 223:
	      return {
	        send: sendFIRMWARE_UPGRADE_STM32F0,
	        recv: recvFIRMWARE_UPGRADE_STM32F0
	      };

	    case 224:
	      return {
	        send: sendFIRMWARE_UPGRADE_STM32G0,
	        recv: recvFIRMWARE_UPGRADE_STM32G0
	      };

	    case 225:
	      return {
	        send: sendFIRMWARE_UPGRADE_STM32F3,
	        recv: recvFIRMWARE_UPGRADE_STM32F3
	      };

	    case 226:
	      return {
	        send: sendFIRMWARE_UPGRADE_STM8S,
	        recv: recvFIRMWARE_UPGRADE_STM8S
	      };

	    case 234:
	      return {
	        send: sendUNKNOWNVINT,
	        recv: recvUNKNOWNVINT
	      };

	    default:
	      throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	  }
	}

	const VINT_DATA_wCHANNEL = 0x40;
	const NUM_VINT_SUPPORTED_SPEEDS = 10;
	const supportedSpeeds = [10000, 25000, 50000, 100000, 160000, 250000, 400000, 500000, 800000, 1000000];

	class VINTDevice extends LocalDevice {
	  constructor(conn, data) {
	    super(conn, data);
	    const io = getVINTIO(this.devDef.uid);
	    if (io == undefined) throw new Error("Invalid VINT Device UID");
	    this.vintIO = io;
	  }

	  async open() {
	    await this.parent.open();
	  }

	  async close() {
	    await this.parent.close();
	  }

	  async lock() {
	    await this.parent.lock();
	  }

	  unlock() {
	    this.parent.unlock();
	  }

	  async bridgeInput(channel, bp) {
	    const hub = this.parent;

	    switch (bp.vpkt) {
	      case 111:
	        await channel.sendVINTDataPacket(250);
	        await hub.setPortMode(this.hubPort, exports.HubPortMode.VINT);
	        await hub.packetTrackers.waitForPendingPackets(this.hubPort);
	        break;

	      case 34:
	        {
	          let portMode = exports.HubPortMode.VINT;

	          if (channel.isHubPort) {
	            switch (channel.class) {
	              case exports.ChannelClass.DIGITAL_INPUT:
	                portMode = exports.HubPortMode.DIGITAL_INPUT;
	                break;

	              case exports.ChannelClass.DIGITAL_OUTPUT:
	                portMode = exports.HubPortMode.DIGITAL_OUTPUT;
	                break;

	              case exports.ChannelClass.VOLTAGE_INPUT:
	                portMode = exports.HubPortMode.VOLTAGE_INPUT;
	                break;

	              case exports.ChannelClass.VOLTAGE_RATIO_INPUT:
	                portMode = exports.HubPortMode.VOLTAGE_RATIO_INPUT;
	                break;
	            }
	          }

	          await hub.setPortMode(channel.parent.hubPort, portMode);
	          await channel.sendVINTDataPacket(250);
	          break;
	        }

	      case 143:
	        await channel.sendVINTDataPacket(251);
	        break;

	      default:
	        await this.vintIO.send(channel, bp);
	        break;
	    }
	  }

	  dataInput(buffer) {
	    let channelIndex;
	    let readPtr;

	    if (buffer.getUint8(0) & VINT_DATA_wCHANNEL) {
	      channelIndex = buffer.getUint8(1);
	      readPtr = 2;
	    } else {
	      channelIndex = 0;
	      readPtr = 1;
	    }

	    const vintChannel = this.getChannel(channelIndex);
	    if (!vintChannel) return;
	    this.vintIO.recv(vintChannel, new DataView(buffer.buffer, readPtr + buffer.byteOffset));
	  }

	  makePacket(vintChannel, deviceCommand, devicePacketType, bufferIn) {
	    const buffer = new Uint8Array(new ArrayBuffer(MAX_OUT_PACKET_SIZE));
	    let bufIndex = 0;
	    if (bufferIn == undefined) bufferIn = new Uint8Array(0);

	    switch (deviceCommand) {
	      case 0:
	        if (vintChannel.uniqueIndex) {
	          buffer.set([VINT_DATA_wCHANNEL | bufferIn.length + 2], bufIndex++);
	          buffer.set([vintChannel.uniqueIndex], bufIndex++);
	          buffer.set([devicePacketType], bufIndex++);
	        } else {
	          buffer.set([bufferIn.length + 1], bufIndex++);
	          buffer.set([devicePacketType], bufIndex++);
	        }

	        if (bufferIn) buffer.set(bufferIn, bufIndex);
	        break;

	      case 131:
	      case 139:
	      case 140:
	        buffer.set([deviceCommand], bufIndex++);
	        break;

	      case 143:
	        if (bufferIn.length !== 4) throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	        buffer.set([deviceCommand], bufIndex++);
	        buffer.set(bufferIn, bufIndex);
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET);
	    }

	    return buffer.slice(0, bufIndex + bufferIn.length);
	  }

	  async sendpacket(bufferIn) {
	    if (bufferIn.length > MAX_OUT_PACKET_SIZE) throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "BufferIn length too big in sendpacket");
	    const hubDevice = this.parent;
	    const tracker = await hubDevice.packetTrackers.getPacketTrackerWait(hubDevice, this.hubPort * PACKETIDS_PER_PORT + 1, (this.hubPort + 1) * PACKETIDS_PER_PORT, this.hubPort, 500);
	    logverbose("Claimed Hub packet ID " + tracker.id + ", Port " + this.hubPort);

	    try {
	      const buffer = hubDevice.makePacket(this, tracker.id, bufferIn);
	      await hubDevice.claimPacketSpace(this.hubPort, buffer.byteLength);
	      tracker.pt.setPacketLength(buffer.byteLength);
	      await this.sendpacketWithTracking(buffer, tracker.pt);
	      tracker.pt.releasePacketTracker(false);
	      hubDevice.packetOutCounter[this.hubPort]++;
	      logverbose("Packet " + tracker.id + " send successfully, Port " + this.hubPort);
	    } catch (err) {
	      logverbose("Packet " + tracker.id + " failed, Port " + this.hubPort, err);
	      tracker.pt.releasePacketTracker(true);
	      throw err;
	    }
	  }

	  async sendpacketWithTracking(buf, packetTracker) {
	    if (packetTracker.signalled) {
	      if (packetTracker.returnCode != exports.ErrorCode.SUCCESS) throw new PhidgetError(packetTracker.returnCode);
	      return;
	    }

	    await this.parent.transferPacket(6, 0, 0, buf);
	    packetTracker.sent = true;
	    const res = await packetTracker.waitForPendingPacket(1000);
	    if (res != exports.ErrorCode.SUCCESS) throw new PhidgetError(res);
	  }

	  async setHubPortSpeed(vintChannel, speed) {
	    let i;
	    const hubPortProps = this.parent.hubPortProps[this.hubPort];

	    if (hubPortProps.portProto === 255 || this.vintDeviceProps.vintProto < 2 || this.vintDeviceProps.vintProto === 255 || this.vintDeviceProps.vintProto < 2) {
	      throw new PhidgetError(exports.ErrorCode.UNSUPPORTED, "VINT Port and Device must support VINT2 protocol.");
	    }

	    if (!hubPortProps.portSuppSetSpeed) {
	      throw new PhidgetError(exports.ErrorCode.UNSUPPORTED, "VINT Port does not support High Speed.");
	    }

	    if (!this.vintDeviceProps.suppSetSpeed) {
	      throw new PhidgetError(exports.ErrorCode.UNSUPPORTED, "VINT Device does not support High Speed.");
	    }

	    if (speed > hubPortProps.portMaxSpeed) {
	      throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Speed must be <= Port max speed of: " + hubPortProps.portMaxSpeed + "Hz.");
	    }

	    if (speed > this.vintDeviceProps.maxSpeed) {
	      throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Speed must be <= Device max speed of: " + this.vintDeviceProps.maxSpeed + "Hz.");
	    }

	    for (i = NUM_VINT_SUPPORTED_SPEEDS - 1; i >= 0; i--) {
	      if (speed >= supportedSpeeds[i]) {
	        break;
	      }
	    }

	    if (speed !== supportedSpeeds[i]) {
	      loginfo("Requested VINT speed of " + speed + "HZ is not supported.  Setting nearest lower speed of " + supportedSpeeds[i] + "Hz instead.");
	    }

	    speed = supportedSpeeds[i];
	    const buf = new DataView(new ArrayBuffer(4));
	    buf.setUint32(0, speed);
	    await vintChannel.sendVINTPacket(143, 0, new Uint8Array(buf.buffer));
	    this.vintDeviceProps.commSpeed = speed;

	    for (let i = 0; i < PHIDGET_MAXCHANNELS; i++) {
	      const ch = this.getChannel(i);

	      if (ch != undefined && ch !== vintChannel) {
	        const bp = new BridgePacket();
	        bp.set({
	          name: '0',
	          type: 'u',
	          value: this.vintDeviceProps.commSpeed
	        });
	        bp.sendToChannel(ch, 176);
	      }
	    }
	  }

	  async reboot(vintChannel) {
	    await vintChannel.sendVINTPacket(131);
	  }

	  async rebootFirmwareUpgrade(vintChannel, timeout) {
	    const hubDevice = this.parent;
	    const buffer = new Uint8Array([timeout & 0xFF, timeout >> 8 & 0xFF]);
	    await hubDevice.sendHubPortPacket(this.hubPort, 1, buffer);
	    await vintChannel.sendVINTPacket(131);
	  }

	}

	/** @internal */

	class LocalChannel extends Channel {
	  constructor(conn, dev, data) {
	    super(conn, dev, data);
	    this.name = this.chDef.t;
	    this.class = this.chDef.c;
	  }

	  async open(userphid) {
	    var _a;

	    const dev = this.parent;

	    if (dev instanceof VINTDevice) {
	      for (const ch of values(_context = this.conn._channels).call(_context)) {
	        var _context;

	        if (ch.parent == dev) continue;
	        if (!ch.isopen) continue;

	        if (ch.parent.parentId === dev.parentId && ch.parent.hubPort === dev.hubPort) {
	          throw new PhidgetError(exports.ErrorCode.BUSY, "Failed to open Channel " + this + " on local device: " + dev + " because Channel: " + ch + " is opened on the same Hub Port, and these channels are mutually exclusive.");
	        }
	      }
	    }

	    if (this.chDef.e != undefined) {
	      for (const c in this.parent.channels) {
	        const ch = this.parent.channels[c];
	        if (ch === this) continue;
	        if (!ch.isopen) continue;

	        if (ch.chDef.e === this.chDef.e) {
	          throw new PhidgetError(exports.ErrorCode.BUSY, "Failed to open Channel " + this + " on local device: " + dev + " because Channel: " + ch + " is opened, and these channels are mutually exclusive.");
	        }
	      }
	    }

	    userphid._attaching = true;
	    let opened = false;

	    try {
	      await dev.lock();
	      await dev.open();
	      opened = true;
	      this.isopen = true;
	      this.userphid = userphid;
	      userphid._ch = this;
	      userphid._isattached = true;

	      userphid._initAfterOpen();

	      userphid._isopen = true;
	    } catch (err) {
	      try {
	        if (opened) await dev.close();
	      } finally {
	        userphid._attaching = false;
	        userphid._isattached = false;
	        userphid._isopen = false;
	        this.isopen = false;
	      }

	      throw err;
	    } finally {
	      dev.unlock();
	    }

	    try {
	      const bp = new BridgePacket();
	      await bp.send(this, 34, false);
	      await userphid._setDefaults();

	      if (userphid.onAttach) {
	        try {
	          await userphid.onAttach(userphid);
	        } catch (err) {
	          logEventException(err);
	        }
	      }

	      await bp.send(this, 143, false);

	      userphid._fireInitialEvents();

	      userphid._attaching = false;

	      if (userphid._hasInitialState()) {
	        userphid._cancelOpenTimeout();

	        (_a = userphid._resolveOpen) === null || _a === void 0 ? void 0 : _a.call(userphid);
	      } else {
	        userphid._onInitialState = () => {
	          var _a;

	          userphid._cancelOpenTimeout();

	          (_a = userphid._resolveOpen) === null || _a === void 0 ? void 0 : _a.call(userphid);
	          delete userphid._onInitialState;
	        };

	        let remaining = 500;
	        if (userphid._openTimeout != undefined && userphid._openTime !== undefined) remaining = userphid._openTimeout - (tm() - userphid._openTime);
	        if (remaining > 2500) remaining = 2500;
	        if (remaining < 500) remaining = 500;
	        setTimeout(() => {
	          if (userphid._onInitialState) userphid._onInitialState();
	        }, remaining);
	      }
	    } catch (err) {
	      try {
	        await dev.lock();
	        await dev.close();
	      } finally {
	        dev.unlock();
	        userphid._attaching = false;
	        userphid._isattached = false;
	        userphid._isopen = false;
	        this.isopen = false;
	      }

	      throw err;
	    }
	  }

	  async close() {
	    if (this.detaching) return;

	    try {
	      const bp = new BridgePacket();
	      await bp.send(this, 111, false);
	    } finally {
	      try {
	        await this.parent.lock();
	        await this.parent.close();
	      } finally {
	        if (this.userphid && this.isopen) {
	          this.userphid._isopen = false;
	          this.isopen = false;
	        }

	        this.parent.unlock();
	      }
	    }
	  }

	  async send(bp) {
	    switch (bp.vpkt) {
	      case 173:
	        if (!(this.parent instanceof VINTDevice)) throw new PhidgetError(exports.ErrorCode.WRONG_DEVICE);
	        await this.parent.setHubPortSpeed(this, bp.getNumber(0));
	        break;

	      case 140:
	        if (!(this.parent instanceof PhidgetUSBDevice)) throw new PhidgetError(exports.ErrorCode.WRONG_DEVICE);
	        await this.parent.writeLabel(bp.getString(0));

	        for (let i = 0; i < PHIDGET_MAXCHANNELS; i++) {
	          const ch = this.parent.getChannel(i);

	          if (ch && ch !== this) {
	            const bp = new BridgePacket();
	            bp.set({
	              name: '0',
	              type: 's',
	              value: this.parent.label
	            });
	            bp.sendToChannel(ch, 172);
	          }
	        }

	        break;

	      case 139:
	        if (this.parent instanceof VINTDevice) {
	          await this.parent.reboot(this);
	        } else if (this.parent instanceof PhidgetUSBDevice) {
	          await this.parent.rebootFirmwareUpgrade();
	        } else {
	          throw new PhidgetError(exports.ErrorCode.WRONG_DEVICE);
	        }

	        break;

	      case 138:
	        if (this.parent instanceof VINTDevice) {
	          await this.parent.rebootFirmwareUpgrade(this, bp.getNumber(0));
	        } else if (this.parent instanceof PhidgetUSBDevice) {
	          await this.parent.rebootFirmwareUpgrade();
	        } else {
	          throw new PhidgetError(exports.ErrorCode.WRONG_DEVICE);
	        }

	        break;

	      default:
	        await this.parent.bridgeInput(this, bp);
	        break;
	    }
	  }

	  async sendVINTPacket(command) {
	    let devicePacketType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    let buffer = arguments.length > 2 ? arguments[2] : undefined;
	    const vintDevice = this.parent;
	    if (!(vintDevice instanceof VINTDevice)) throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Parent device does not exist in sendVINTPacket.");
	    const bufferOut = vintDevice.makePacket(this, command, devicePacketType, buffer);
	    await vintDevice.sendpacket(bufferOut);
	  }

	  async sendVINTDataPacket(devicePacketType, buffer) {
	    await this.sendVINTPacket(0, devicePacketType, buffer);
	  }

	}

	class InterfaceKitDevice extends PhidgetUSBDevice {
	  constructor(conn, data, usbDev) {
	    super(conn, data, usbDev);

	    switch (this.devDef.uid) {
	      case 20:
	      case 25:
	      case 28:
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }

	    this.data = {
	      outputState: new Array(this.numOutputs).fill(2),
	      failsafeState: new Array(this.numOutputs).fill(0),
	      inputState: new Array(this.numInputs).fill(2),
	      voltage: new Array(this.numVoltageInputs).fill(1e+300),
	      voltageRatio: new Array(this.numSensors).fill(1e+300)
	    };
	  }

	  get numVoltageInputs() {
	    return this.devDef.cn[0];
	  }

	  get numSensors() {
	    return this.devDef.cn[1];
	  }

	  get numInputs() {
	    return this.devDef.cn[2];
	  }

	  get numOutputs() {
	    return this.devDef.cn[3];
	  }

	  get numCapTouches() {
	    return this.devDef.cn[4];
	  }

	  async initAfterOpen() {
	    switch (this.devDef.uid) {
	      case 28:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED, "This Phidget is not yet supported via direct USB connection in JavaScript.");
	    }

	    for (let i = 0; i < this.numOutputs; i++) this.data.failsafeState[i] = 0;

	    const buf = await this.transferPacket(3, 0, 0, 1);

	    for (let i = 0; i < this.numOutputs; i++) this.data.outputState[i] = buf.getUint8(0) & 1 << i ? 1 : 0;
	  }

	  async bridgeInput(ch, bp) {
	    let dutyCycle;
	    const buf = new DataView(new ArrayBuffer(2));

	    switch (ch.class) {
	      case exports.ChannelClass.DIGITAL_OUTPUT:
	        if (this.data.failsafeState[ch.index] && bp.vpkt !== 34 && bp.vpkt !== 111) {
	          throw new PhidgetError(exports.ErrorCode.FAILSAFE);
	        }

	        switch (bp.vpkt) {
	          case 82:
	            this.data.outputState[ch.index] = bp.getNumber(0);
	            buf.setUint8(0, this.data.outputState[ch.index]);
	            await this.transferPacket(0, 10, ch.index, new Uint8Array(buf.buffer, 0, 1));
	            break;

	          case 55:
	            dutyCycle = bp.getNumber(0);
	            if (dutyCycle !== 0.0 && dutyCycle !== 1) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Duty cycle must be either 0 or 1");
	            this.data.outputState[ch.index] = dutyCycle;
	            buf.setUint8(0, this.data.outputState[ch.index] ? 0xFF : 0x00);
	            await this.transferPacket(0, 10, ch.index, new Uint8Array(buf.buffer, 0, 1));
	            break;

	          case 34:
	          case 111:
	            this.data.failsafeState[ch.index] = 0;
	            await this.transferPacket(0, 250, ch.index);
	            break;

	          case 143:
	            break;

	          case 146:
	            buf.setUint16(0, bp.getNumber('0'));
	            await this.transferPacket(0, 246, ch.index, new Uint8Array(buf.buffer, 0, 2));
	            break;

	          case 147:
	            await this.transferPacket(0, 247, ch.index);
	            break;

	          default:
	            throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type");
	        }

	        break;

	      case exports.ChannelClass.DIGITAL_INPUT:
	      case exports.ChannelClass.VOLTAGE_RATIO_INPUT:
	      case exports.ChannelClass.VOLTAGE_INPUT:
	        throw new Error("Class not implemented");

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected channel class");
	    }
	  }

	  dataInput(buf) {
	    const ch = this.getChannel(buf.getUint8(1));

	    if (ch) {
	      const pkt = buf.getUint8(0);
	      const bp = new BridgePacket();

	      switch (pkt) {
	        case 13:
	          {
	            const i = buf.getUint8(1);
	            this.data.failsafeState[i] = 1;
	            bp.set({
	              name: '0',
	              type: 'd',
	              value: exports.ErrorEventCode.FAILSAFE_CONDITION
	            });
	            bp.set({
	              name: '1',
	              type: 's',
	              value: 'Failsafe procedure initiated.'
	            });
	            ch.sendErrorEvent(bp);
	            break;
	          }

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type");
	      }
	    }
	  }

	}

	class RFIDDevice extends PhidgetUSBDevice {
	  constructor(conn, data, usbDev) {
	    super(conn, data, usbDev);

	    switch (this.devDef.uid) {
	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }

	  get numOutputs() {
	    return this.devDef.cn[0];
	  }

	  async initAfterOpen() {
	    const buffer = await this.transferPacket(3, 5, 0, 5);
	    this.data.antennaEnabled[0] = buffer.getUint8(0) & 0x01 ? 1 : 0;
	    this.data.outputState[0] = buffer.getUint8(0) & 0x02 ? 1 : 0;
	    this.data.outputState[1] = buffer.getUint8(0) & 0x04 ? 1 : 0;
	    this.data.outputState[2] = buffer.getUint8(0) & 0x08 ? 1 : 0;
	  }

	  async bridgeInput(ch, bp) {
	    const buf = new DataView(new ArrayBuffer(MAX_OUT_PACKET_SIZE));
	    let protocol;
	    let tagString;
	    let dutyCycle;
	    let len;

	    switch (ch.class) {
	      case exports.ChannelClass.DIGITAL_OUTPUT:
	        switch (bp.vpkt) {
	          case 82:
	            this.data.outputState[ch.index] = bp.getNumber(0);
	            buf.setUint8(0, bp.getNumber(0));
	            await this.transferPacket(0, 10, ch.uniqueIndex, new Uint8Array(buf.buffer, 0, 1));
	            break;

	          case 55:
	            dutyCycle = bp.getNumber(0);
	            if (dutyCycle !== 0 && dutyCycle !== 1) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Duty cycle myust be 0 or 1.");
	            this.data.outputState[ch.index] = dutyCycle;
	            buf.setUint8(0, dutyCycle);
	            await this.transferPacket(0, 10, ch.uniqueIndex, new Uint8Array(buf.buffer, 0, 1));
	            break;

	          case 34:
	          case 111:
	            buf.setUint8(0, 0);
	            await this.transferPacket(0, 10, ch.uniqueIndex, new Uint8Array(buf.buffer, 0, 1));
	            break;

	          case 143:
	            break;

	          default:
	            throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type");
	        }

	        break;

	      case exports.ChannelClass.RFID:
	        if (ch.index !== 0) {
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	        }

	        switch (bp.vpkt) {
	          case 41:
	            buf.setUint8(0, bp.getNumber(0));
	            this.data.antennaEnabled[0] = bp.getNumber(0);
	            await this.transferPacket(0, 99, ch.uniqueIndex, new Uint8Array(buf.buffer, 0, 1));
	            break;

	          case 103:
	            {
	              protocol = bp.getNumber(1);
	              if (protocol < exports.RFIDProtocol.EM4100 || protocol > exports.RFIDProtocol.PHIDGET_TAG) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Invalid protocol type");
	              if (this.data.antennaEnabled[0] !== 1) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Cannot write tag while antenna is off");
	              buf.setUint8(0, bp.getNumber(1));
	              buf.setUint8(1, bp.getNumber(2));
	              tagString = bp.getString(0);
	              if (protocol === exports.RFIDProtocol.EM4100 && tagString.charAt(1) === 'x') tagString = tagString.slice(2);
	              if (tagString.length > MAX_OUT_PACKET_SIZE - 3) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT);

	              for (let i = 0; i < tagString.length; i++) buf.setUint8(2 + i, tagString.charCodeAt(i));

	              buf.setUint8(2 + tagString.length, 0x00);

	              if (protocol === exports.RFIDProtocol.EM4100) {
	                for (let i = 0; i < 10; i++) {
	                  const toLower = String.fromCharCode(buf.getUint8(2 + i)).toLowerCase();
	                  buf.setUint8(2 + i, toLower.charCodeAt(0));
	                }
	              }

	              len = tagString.length + 2;
	              const userphid = ch.userphid;

	              userphid._setLatestTagString("");

	              await this.transferPacket(0, 98, ch.uniqueIndex, new Uint8Array(buf.buffer, 0, len));

	              try {
	                await userphid._waitForTag(tagString, 600);
	              } catch (_a) {
	                throw new PhidgetError(exports.ErrorCode.TIMEOUT, "Timed out waiting for tag to appear after writing. Try again.");
	              }

	              break;
	            }

	          case 34:
	          case 111:
	          case 143:
	            break;

	          default:
	            throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type");
	        }

	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected channel class");
	    }
	  }

	  dataInput(buffer) {
	    const pkt = buffer.getUint8(0);
	    const ch = this.getChannel(0);
	    let tagString;

	    if (ch) {
	      const bp = new BridgePacket();

	      switch (pkt) {
	        case 96:
	          {
	            tagString = "";

	            for (let i = 2, byteChar = buffer.getUint8(i); i < buffer.byteLength && String.fromCharCode(byteChar) !== '\0'; i++, byteChar = buffer.getUint8(i)) {
	              tagString += String.fromCharCode(byteChar);
	            }

	            const userphid = ch.userphid;

	            userphid._setLatestTagString(tagString);

	            this.data.tagPresent[0] = 1;
	            bp.set({
	              name: '0',
	              type: 's',
	              value: tagString
	            });
	            bp.set({
	              name: '1',
	              type: 'd',
	              value: buffer.getUint8(1)
	            });
	            bp.sendToChannel(ch, 92);
	            break;
	          }

	        case 97:
	          tagString = "";

	          for (let i = 2, byteChar = buffer.getUint8(i); i < buffer.byteLength && String.fromCharCode(byteChar) !== '\0'; i++, byteChar = buffer.getUint8(i)) {
	            tagString += String.fromCharCode(byteChar);
	          }

	          this.data.tagPresent[0] = 0;
	          bp.set({
	            name: '0',
	            type: 's',
	            value: tagString
	          });
	          bp.set({
	            name: '1',
	            type: 'd',
	            value: buffer.getUint8(1)
	          });
	          bp.sendToChannel(ch, 93);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	      }
	    }
	  }

	}

	const ZERO_GYRO_TIME = 2000;
	const MIN_DATA_RATE = 1000;
	const ACCEL_CHANNEL = 0;
	const GYRO_CHANNEL = 1;
	const MAG_CHANNEL = 2;
	const SPT_CHANNEL = 3;
	const TMP_CHANNEL = 4;
	const ACCEL_SEND_FLAG = 1 << ACCEL_CHANNEL;
	const GYRO_SEND_FLAG = 1 << GYRO_CHANNEL;
	const MAG_SEND_FLAG = 1 << MAG_CHANNEL;
	const SPT_SEND_FLAG = 1 << SPT_CHANNEL;
	const TMP_SEND_FLAG = 1 << TMP_CHANNEL;

	class SpatialDevice extends PhidgetUSBDevice {
	  constructor(conn, data, usbDev) {
	    super(conn, data, usbDev);

	    switch (this.devDef.uid) {
	      case 163:
	      case 164:
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }

	    this.data = this.initData();
	  }

	  get numAccelAxes() {
	    return this.devDef.cn[0];
	  }

	  get numGyroAxes() {
	    return this.devDef.cn[1];
	  }

	  get numCompassAxes() {
	    return this.devDef.cn[2];
	  }

	  get numSpatialInputs() {
	    return this.devDef.cn[3];
	  }

	  get numTempInputs() {
	    return this.devDef.cn[4];
	  }

	  updateTimestamp(time) {
	    if (this.data.lastTimeCounter != undefined) {
	      const timechange = time - this.data.lastTimeCounter & 0xFFFF;
	      this.data.timestamp[0] += timechange;
	    }

	    this.data.lastTimeCounter = time;
	  }

	  updateLatestDataTime(i) {
	    this.data.latestDataTime = this.data.timestamp[0] + (i + 1) * this.data.dataRateMax;
	  }

	  timestampDiff(time1, time2) {
	    return time1 - time2;
	  }

	  initData() {
	    const data = {
	      timestamp: [0],
	      acceleration: [new Array(this.numAccelAxes).fill(1e+300)],
	      angularRate: [new Array(this.numGyroAxes).fill(1e+300)],
	      magneticField: [new Array(this.numCompassAxes).fill(1e+300)],
	      temperature: new Array(this.numTempInputs).fill(1e+300),
	      quaternion: [null],
	      dataInterval: 0,
	      temperatureDataInterval: 0,
	      accelerationChangeTrigger: 0,
	      magneticFieldChangeTrigger: 0,
	      temperatureChangeTrigger: 0,
	      accelAxisLastTrigger: new Array(this.numAccelAxes).fill(1e+300),
	      gyroCorrection: new Array(this.numGyroAxes).fill(0),
	      magAxisLastTrigger: new Array(this.numCompassAxes).fill(1e+300),
	      lastEventTime: 0,
	      latestDataTime: 0,
	      doZeroGyro: false,
	      dataBuffer: [],
	      accelerationMax: 0,
	      accelerationMin: 0,
	      interruptRate: 0,
	      dataRateMax: 0,
	      dataRateMin: 0,
	      angularRateMax: 0,
	      angularRateMin: 0,
	      magneticFieldMax: 0,
	      magneticFieldMin: 0,
	      AHRSMagGain: 0,
	      userMagField: 0,
	      calDataValid: false,
	      algorithm: 0,
	      temperatureMax: 0,
	      temperatureMin: 0,
	      lastTemperatureEventTime: 0,
	      temperatureLastTrigger: 1e+300,
	      heatingEnabled: false
	    };
	    return data;
	  }

	  async initAfterOpen() {
	    this.data = this.initData();
	    this.data.accelerationMax = 8;
	    this.data.accelerationMin = -8;
	    this.data.interruptRate = 4;
	    this.data.dataRateMin = MIN_DATA_RATE;
	    this.data.dataInterval = 8;
	    this.data.temperatureDataInterval = 100;
	    this.data.dataRateMax = 4;
	    this.data.angularRateMax = 2000;
	    this.data.angularRateMin = -2000;
	    this.data.magneticFieldMax = 5000;
	    this.data.magneticFieldMin = -5000;
	    this.data.userMagField = 1.0;
	    this.data.calDataValid = false;
	    this.data.AHRSMagGain = 0.005;
	    this.data.algorithm = exports.SpatialAlgorithm.AHRS;
	    this.data.temperatureMax = 85;
	    this.data.temperatureMin = -40;
	  }

	  async bridgeInput(channel, bp) {
	    let buffer;
	    const buf = new DataView(new ArrayBuffer(24));
	    let userphid;

	    switch (this.devDef.uid) {
	      case 163:
	        switch (channel.class) {
	          case exports.ChannelClass.ACCELEROMETER:
	            if (channel.index !== 0) throw new PhidgetError(exports.ErrorCode.INVALID);

	            switch (bp.vpkt) {
	              case 54:
	                this.setDataRate(channel, bp.getNumber(0));
	                break;

	              case 46:
	                this.data.accelerationChangeTrigger = bp.getNumber(0);
	                break;

	              case 145:
	                await this.setPrecision(bp.getNumber(0));
	                break;

	              case 170:
	                buffer = new Uint8Array([bp.getNumber(0)]);
	                await this.transferPacket(0, 18, channel.uniqueIndex, buffer);
	                break;

	              case 34:
	              case 111:
	                await this.transferPacket(0, 17, channel.uniqueIndex);
	                break;

	              case 143:
	                break;

	              default:
	                throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	            }

	            break;

	          case exports.ChannelClass.GYROSCOPE:
	            if (channel.index !== 0) throw new PhidgetError(exports.ErrorCode.INVALID);

	            switch (bp.vpkt) {
	              case 54:
	                this.setDataRate(channel, bp.getNumber(0));
	                break;

	              case 106:
	                await this.zeroGyro();
	                break;

	              case 145:
	                await this.setPrecision(bp.getNumber(0));
	                break;

	              case 170:
	                buffer = new Uint8Array([bp.getNumber(0)]);
	                await this.transferPacket(0, 18, channel.uniqueIndex, buffer);
	                break;

	              case 34:
	              case 111:
	                await this.transferPacket(0, 17, channel.uniqueIndex);
	                break;

	              case 143:
	                break;

	              default:
	                throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	            }

	            break;

	          case exports.ChannelClass.MAGNETOMETER:
	            if (channel.index !== 0) throw new PhidgetError(exports.ErrorCode.INVALID);

	            switch (bp.vpkt) {
	              case 54:
	                this.setDataRate(channel, bp.getNumber(0));
	                break;

	              case 46:
	                this.data.magneticFieldChangeTrigger = bp.getNumber(0);
	                break;

	              case 37:
	                await this.saveCompassCorrectionParameters();
	                break;

	              case 35:
	                await this.resetCompassCorrectionParameters();
	                break;

	              case 50:
	                {
	                  const corrParams = {
	                    magField: bp.getNumber(0),
	                    offset0: bp.getNumber(1),
	                    offset1: bp.getNumber(2),
	                    offset2: bp.getNumber(3),
	                    gain0: bp.getNumber(4),
	                    gain1: bp.getNumber(5),
	                    gain2: bp.getNumber(6),
	                    T0: bp.getNumber(7),
	                    T1: bp.getNumber(8),
	                    T2: bp.getNumber(9),
	                    T3: bp.getNumber(10),
	                    T4: bp.getNumber(11),
	                    T5: bp.getNumber(12)
	                  };
	                  await this.setCompassCorrectionParameters(corrParams);
	                  break;
	                }

	              case 170:
	                buffer = new Uint8Array([bp.getNumber(0)]);
	                await this.transferPacket(0, 18, channel.uniqueIndex, buffer);
	                break;

	              case 34:
	              case 111:
	                await this.transferPacket(0, 17, channel.uniqueIndex);
	                break;

	              case 143:
	                break;

	              default:
	                throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	            }

	            break;

	          case exports.ChannelClass.SPATIAL:
	            if (channel.index !== 0) throw new PhidgetError(exports.ErrorCode.INVALID);

	            switch (bp.vpkt) {
	              case 54:
	                this.setDataRate(channel, bp.getNumber(0));
	                break;

	              case 106:
	                await this.zeroGyro();
	                break;

	              case 37:
	                await this.saveCompassCorrectionParameters();
	                break;

	              case 35:
	                await this.resetCompassCorrectionParameters();
	                break;

	              case 50:
	                {
	                  const corrParams = {
	                    magField: bp.getNumber(0),
	                    offset0: bp.getNumber(1),
	                    offset1: bp.getNumber(2),
	                    offset2: bp.getNumber(3),
	                    gain0: bp.getNumber(4),
	                    gain1: bp.getNumber(5),
	                    gain2: bp.getNumber(6),
	                    T0: bp.getNumber(7),
	                    T1: bp.getNumber(8),
	                    T2: bp.getNumber(9),
	                    T3: bp.getNumber(10),
	                    T4: bp.getNumber(11),
	                    T5: bp.getNumber(12)
	                  };
	                  await this.setCompassCorrectionParameters(corrParams);
	                  break;
	                }

	              case 145:
	                await this.setPrecision(bp.getNumber(0));
	                break;

	              case 150:
	                await this.zeroAHRS();
	                break;

	              case 149:
	                this.data.algorithm = bp.getNumber(0);
	                await this.configureAlgorithm();
	                break;

	              case 151:
	                this.data.AHRSMagGain = bp.getNumber(0);
	                await this.configureAlgorithm();
	                break;

	              case 170:
	                buffer = new Uint8Array([bp.getNumber(0)]);
	                await this.transferPacket(0, 18, channel.uniqueIndex, buffer);
	                break;

	              case 174:
	                {
	                  const buf = new ArrayBuffer(24);
	                  buffer = new DataView(buf);
	                  buffer.setFloat32(0, bp.getNumber(0), true);
	                  buffer.setFloat32(4, bp.getNumber(1), true);
	                  buffer.setFloat32(8, bp.getNumber(2), true);
	                  buffer.setFloat32(12, bp.getNumber(3), true);
	                  buffer.setFloat32(16, bp.getNumber(4), true);
	                  buffer.setFloat32(20, bp.getNumber(5), true);
	                  await this.transferPacket(0, 18, channel.uniqueIndex, buffer);
	                  break;
	                }

	              case 34:
	              case 111:
	                await this.transferPacket(0, 17, channel.uniqueIndex);
	                break;

	              case 143:
	                break;

	              default:
	                throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	            }

	            break;

	          case exports.ChannelClass.TEMPERATURE_SENSOR:
	            if (channel.index !== 0) throw new PhidgetError(exports.ErrorCode.INVALID);

	            switch (bp.vpkt) {
	              case 54:
	                this.setTemperatureDataRate(bp.getNumber(0));
	                break;

	              case 46:
	                this.data.temperatureChangeTrigger = bp.getNumber(0);
	                break;

	              case 34:
	              case 111:
	                await this.transferPacket(0, 17, channel.uniqueIndex);
	                break;

	              case 143:
	                break;

	              default:
	                throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	            }

	            break;

	          default:
	            throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	        }

	        break;

	      case 164:
	        switch (channel.chDef.uid) {
	          case 339:
	            userphid = channel.userphid;
	            await userphid._transactionLock.acquire();

	            try {
	              switch (bp.vpkt) {
	                case 54:
	                  buf.setUint16(0, this._handleDataIntervalPacket(bp, 1));
	                  await this.transferPacket(0, 252, channel.uniqueIndex, new Uint8Array(buf.buffer, 0, 2));
	                  break;

	                case 106:
	                  await this.transferPacket(0, 51, channel.uniqueIndex);
	                  break;

	                case 35:
	                  await this.transferPacket(0, 77, channel.uniqueIndex);
	                  break;

	                case 37:
	                  await this.transferPacket(0, 79, channel.uniqueIndex);
	                  break;

	                case 50:
	                  {
	                    const corrParams = {
	                      magField: bp.getNumber(0),
	                      offset0: bp.getNumber(1),
	                      offset1: bp.getNumber(2),
	                      offset2: bp.getNumber(3),
	                      gain0: bp.getNumber(4),
	                      gain1: bp.getNumber(5),
	                      gain2: bp.getNumber(6),
	                      T0: bp.getNumber(7),
	                      T1: bp.getNumber(8),
	                      T2: bp.getNumber(9),
	                      T3: bp.getNumber(10),
	                      T4: bp.getNumber(11),
	                      T5: bp.getNumber(12)
	                    };
	                    await this.setCompassCorrectionParameters(corrParams);
	                  }
	                  break;

	                case 150:
	                  await this.transferPacket(0, 80, channel.uniqueIndex);
	                  break;

	                case 149:
	                  this.data.algorithm = bp.getNumber(0);
	                  buf.setUint8(0, bp.getNumber(0));
	                  await this.transferPacket(0, 81, channel.uniqueIndex, new Uint8Array(buf.buffer, 0, 1));
	                  break;

	                case 151:
	                  this.data.AHRSMagGain = bp.getNumber(0);
	                  buf.setFloat32(0, bp.getNumber(0), true);
	                  await this.transferPacket(0, 82, channel.uniqueIndex, new Uint8Array(buf.buffer, 0, 4));
	                  break;

	                case 174:
	                  buf.setFloat32(0, bp.getNumber(0), true);
	                  buf.setFloat32(4, bp.getNumber(1), true);
	                  buf.setFloat32(8, bp.getNumber(2), true);
	                  buf.setFloat32(12, bp.getNumber(3), true);
	                  buf.setFloat32(16, bp.getNumber(4), true);
	                  buf.setFloat32(20, bp.getNumber(5), true);
	                  await this.transferPacket(0, 84, channel.uniqueIndex, buf);
	                  break;

	                case 170:
	                  this.data.heatingEnabled = bp.getBoolean(0);
	                  buf.setUint8(0, bp.getNumber(0));
	                  await this.transferPacket(0, 85, channel.uniqueIndex, new Uint8Array(buf.buffer, 0, 1));
	                  break;

	                case 34:
	                case 111:
	                  await this.transferPacket(0, 250, channel.uniqueIndex);
	                  break;

	                case 143:
	                  await this.transferPacket(0, 251, channel.uniqueIndex);
	                  break;

	                default:
	                  throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	              }
	            } finally {
	              userphid._transactionLock.release();
	            }

	            break;

	          case 338:
	            userphid = channel.userphid;
	            await userphid.transactionLock.acquire();

	            try {
	              switch (bp.vpkt) {
	                case 54:
	                  buf.setUint16(0, this._handleDataIntervalPacket(bp, 1));
	                  await this.transferPacket(0, 252, channel.uniqueIndex, new Uint8Array(buf.buffer, 0, 2));
	                  break;

	                case 46:
	                  this.data.magneticFieldChangeTrigger = bp.getNumber(0);
	                  buf.setFloat32(0, bp.getNumber(0), true);
	                  await this.transferPacket(0, 195, channel.uniqueIndex, new Uint8Array(buf.buffer, 0, 4));
	                  break;

	                case 35:
	                  await this.transferPacket(0, 77, channel.uniqueIndex);
	                  break;

	                case 37:
	                  await this.transferPacket(0, 79, channel.uniqueIndex);
	                  break;

	                case 50:
	                  {
	                    const corrParams = {
	                      magField: bp.getNumber(0),
	                      offset0: bp.getNumber(1),
	                      offset1: bp.getNumber(2),
	                      offset2: bp.getNumber(3),
	                      gain0: bp.getNumber(4),
	                      gain1: bp.getNumber(5),
	                      gain2: bp.getNumber(6),
	                      T0: bp.getNumber(7),
	                      T1: bp.getNumber(8),
	                      T2: bp.getNumber(9),
	                      T3: bp.getNumber(10),
	                      T4: bp.getNumber(11),
	                      T5: bp.getNumber(12)
	                    };
	                    await this.setCompassCorrectionParameters(corrParams);
	                  }
	                  break;

	                case 170:
	                  this.data.heatingEnabled = bp.getBoolean(0);
	                  buf.setUint8(0, bp.getNumber(0));
	                  await this.transferPacket(0, 85, channel.uniqueIndex, new Uint8Array(buf.buffer, 0, 1));
	                  break;

	                case 34:
	                case 111:
	                  await this.transferPacket(0, 250, channel.uniqueIndex);
	                  break;

	                case 143:
	                  await this.transferPacket(0, 251, channel.uniqueIndex);
	                  break;

	                default:
	                  throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	              }
	            } finally {
	              userphid.transactionLock.release();
	            }

	            break;

	          case 337:
	            switch (bp.vpkt) {
	              case 54:
	                buf.setUint16(0, this._handleDataIntervalPacket(bp, 1));
	                await this.transferPacket(0, 252, channel.uniqueIndex, new Uint8Array(buf.buffer, 0, 2));
	                break;

	              case 106:
	                await this.transferPacket(0, 51, channel.uniqueIndex);
	                break;

	              case 170:
	                this.data.heatingEnabled = bp.getBoolean(0);
	                buf.setUint8(0, bp.getNumber(0));
	                await this.transferPacket(0, 85, channel.uniqueIndex, new Uint8Array(buf.buffer, 0, 1));
	                break;

	              case 34:
	              case 111:
	                await this.transferPacket(0, 250, channel.uniqueIndex);
	                break;

	              case 143:
	                await this.transferPacket(0, 251, channel.uniqueIndex);
	                break;

	              default:
	                throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	            }

	            break;

	          case 336:
	            switch (bp.vpkt) {
	              case 54:
	                buf.setUint16(0, this._handleDataIntervalPacket(bp, 1));
	                await this.transferPacket(0, 252, channel.uniqueIndex, new Uint8Array(buf.buffer, 0, 2));
	                break;

	              case 46:
	                this.data.accelerationChangeTrigger = bp.getNumber(0);
	                buf.setFloat32(0, bp.getNumber(0), true);
	                await this.transferPacket(0, 195, channel.uniqueIndex, new Uint8Array(buf.buffer, 0, 4));
	                break;

	              case 170:
	                this.data.heatingEnabled = bp.getBoolean(0);
	                buf.setUint8(0, bp.getNumber(0));
	                await this.transferPacket(0, 85, channel.uniqueIndex, new Uint8Array(buf.buffer, 0, 1));
	                break;

	              case 34:
	              case 111:
	                await this.transferPacket(0, 250, channel.uniqueIndex);
	                break;

	              case 143:
	                await this.transferPacket(0, 251, channel.uniqueIndex);
	                break;

	              default:
	                throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	            }

	            break;

	          case 340:
	            switch (bp.vpkt) {
	              case 54:
	                buf.setUint16(0, this._handleDataIntervalPacket(bp, 1));
	                await this.transferPacket(0, 252, channel.uniqueIndex, new Uint8Array(buf.buffer, 0, 2));
	                break;

	              case 46:
	                this.data.temperatureChangeTrigger = bp.getNumber(0);
	                buf.setFloat32(0, bp.getNumber(0), true);
	                await this.transferPacket(0, 58, channel.uniqueIndex, new Uint8Array(buf.buffer, 0, 4));
	                break;

	              case 34:
	              case 111:
	                await this.transferPacket(0, 250, channel.uniqueIndex);
	                break;

	              case 143:
	                await this.transferPacket(0, 251, channel.uniqueIndex);
	                break;

	              default:
	                throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	            }

	            break;

	          default:
	            throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	        }

	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	    }
	  }

	  dataInput(buffer) {
	    let channel;
	    let j = 0;
	    let doneGyroZero = false;
	    const accelAvg = [0, 0, 0];
	    const angularRateAvg = [0, 0, 0];
	    const magneticFieldAvg = [0, 0, 0];
	    const quaternion = [0, 0, 0, 0];
	    const eventData = [];
	    let fireSaturation;
	    let fireEvent;
	    const dataRate = this.data.dataInterval;
	    let temperature = 1e+300;
	    const incData = {
	      acceleration: [],
	      angularRate: [],
	      magneticField: [],
	      quaternion: [],
	      timestamp: 0,
	      temperature: 0
	    };

	    switch (this.devDef.uid) {
	      case 164:
	        {
	          let dataIndex = 1;
	          const channelFlags = buffer.getUint8(0);
	          const evData = {
	            acceleration: [],
	            angularRate: [],
	            magneticField: [],
	            quaternion: [],
	            timestamp: 0,
	            temperature: 0
	          };
	          evData.timestamp = buffer.getUint32(1);
	          dataIndex += 4;

	          if (channelFlags & ACCEL_SEND_FLAG || channelFlags & SPT_SEND_FLAG) {
	            for (let j = 0; j < 3; j++) {
	              evData.acceleration[j] = buffer.getFloat32(dataIndex + j * 4, true);

	              if (!Number.isNaN(evData.acceleration[j])) {
	                evData.acceleration[j] = RoundDouble(evData.acceleration[j], 6);
	              }
	            }

	            dataIndex += 12;
	          }

	          if (channelFlags & GYRO_SEND_FLAG || channelFlags & SPT_SEND_FLAG) {
	            for (let j = 0; j < 3; j++) {
	              evData.angularRate[j] = buffer.getFloat32(dataIndex + j * 4, true);

	              if (!Number.isNaN(evData.angularRate[j])) {
	                evData.angularRate[j] = RoundDouble(evData.angularRate[j], 6);
	              }
	            }

	            dataIndex += 12;
	          }

	          if (channelFlags & MAG_SEND_FLAG || channelFlags & SPT_SEND_FLAG) {
	            for (let j = 0; j < 3; j++) {
	              evData.magneticField[j] = buffer.getFloat32(dataIndex + j * 4, true);

	              if (!Number.isNaN(evData.magneticField[j])) {
	                evData.magneticField[j] = RoundDouble(evData.magneticField[j], 6);
	              }
	            }

	            dataIndex += 12;
	          }

	          if (channelFlags & SPT_SEND_FLAG) {
	            evData.quaternion[0] = buffer.getFloat32(dataIndex, true);
	            evData.quaternion[1] = buffer.getFloat32(dataIndex + 4, true);
	            evData.quaternion[2] = buffer.getFloat32(dataIndex + 8, true);
	            evData.quaternion[3] = buffer.getFloat32(dataIndex + 12, true);
	            dataIndex += 16;
	          }

	          if (channelFlags & TMP_SEND_FLAG) {
	            evData.temperature = buffer.getFloat32(dataIndex, true);

	            if (!Number.isNaN(evData.temperature)) {
	              evData.temperature = RoundDouble(evData.temperature, 3);
	            }

	            dataIndex += 4;
	          }

	          for (let i = 0; i < 5; i++) {
	            if ((channelFlags & 1 << i) === 0) {
	              continue;
	            }

	            if ((channel = this.getChannel(i)) !== null) {
	              switch (channel.chDef.uid) {
	                case 339:
	                  {
	                    if (buffer.byteLength > dataIndex) {
	                      if (buffer.getUint8(dataIndex) & 0x20) {
	                        const bp = new BridgePacket();
	                        bp.set({
	                          name: "0",
	                          type: "d",
	                          value: exports.ErrorEventCode.OUT_OF_RANGE
	                        });
	                        bp.set({
	                          name: "1",
	                          type: "s",
	                          value: "One or more spatial readings is out of range."
	                        });
	                        channel.sendErrorEvent(bp);
	                      }
	                    }

	                    let bp = new BridgePacket();
	                    bp.set({
	                      name: "0",
	                      type: "G",
	                      value: evData.acceleration
	                    });
	                    bp.set({
	                      name: "1",
	                      type: "G",
	                      value: evData.angularRate
	                    });
	                    bp.set({
	                      name: "2",
	                      type: "G",
	                      value: evData.magneticField
	                    });
	                    bp.set({
	                      name: "3",
	                      type: "g",
	                      value: evData.timestamp
	                    });
	                    bp.sendToChannel(channel, 89);
	                    bp = new BridgePacket();
	                    bp.set({
	                      name: "0",
	                      type: "G",
	                      value: evData.quaternion
	                    });
	                    bp.set({
	                      name: "1",
	                      type: "g",
	                      value: evData.timestamp
	                    });
	                    bp.sendToChannel(channel, 148);
	                  }
	                  break;

	                case 338:
	                  {
	                    if (buffer.byteLength > dataIndex) {
	                      if (buffer.getUint8(dataIndex) & 0x04) {
	                        const bp = new BridgePacket();
	                        bp.set({
	                          name: "0",
	                          type: "d",
	                          value: exports.ErrorEventCode.OUT_OF_RANGE
	                        });
	                        bp.set({
	                          name: "1",
	                          type: "s",
	                          value: "One or more magnetometer readings is out of range."
	                        });
	                        channel.sendErrorEvent(bp);
	                      }
	                    }

	                    const bp = new BridgePacket();
	                    bp.set({
	                      name: "0",
	                      type: "G",
	                      value: evData.magneticField
	                    });
	                    bp.set({
	                      name: "1",
	                      type: "g",
	                      value: evData.timestamp
	                    });
	                    bp.sendToChannel(channel, 18);
	                  }
	                  break;

	                case 337:
	                  {
	                    if (buffer.byteLength > dataIndex) {
	                      if (buffer.getUint8(dataIndex) & 0x02) {
	                        const bp = new BridgePacket();
	                        bp.set({
	                          name: "0",
	                          type: "d",
	                          value: exports.ErrorEventCode.OUT_OF_RANGE
	                        });
	                        bp.set({
	                          name: "1",
	                          type: "s",
	                          value: "One or more gyroscope readings is out of range."
	                        });
	                        channel.sendErrorEvent(bp);
	                      }
	                    }

	                    const bp = new BridgePacket();
	                    bp.set({
	                      name: "0",
	                      type: "G",
	                      value: evData.angularRate
	                    });
	                    bp.set({
	                      name: "1",
	                      type: "g",
	                      value: evData.timestamp
	                    });
	                    bp.sendToChannel(channel, 2);
	                  }
	                  break;

	                case 336:
	                  {
	                    if (buffer.byteLength > dataIndex) {
	                      if (buffer.getUint8(dataIndex) & 0x01) {
	                        const bp = new BridgePacket();
	                        bp.set({
	                          name: "0",
	                          type: "d",
	                          value: exports.ErrorEventCode.OUT_OF_RANGE
	                        });
	                        bp.set({
	                          name: "1",
	                          type: "s",
	                          value: "One or more accelerometer readings is out of range."
	                        });
	                        channel.sendErrorEvent(bp);
	                      }
	                    }

	                    const bp = new BridgePacket();
	                    bp.set({
	                      name: "0",
	                      type: "G",
	                      value: evData.acceleration
	                    });
	                    bp.set({
	                      name: "1",
	                      type: "g",
	                      value: evData.timestamp
	                    });
	                    bp.sendToChannel(channel, 1);
	                  }
	                  break;

	                case 340:
	                  {
	                    if (buffer.byteLength > dataIndex) {
	                      const bp = new BridgePacket();

	                      switch (buffer.getUint8(dataIndex) & 0x18) {
	                        case 0x08:
	                          bp.set({
	                            name: "0",
	                            type: "d",
	                            value: exports.ErrorEventCode.OUT_OF_RANGE_LOW_CONDITION
	                          });
	                          bp.set({
	                            name: "1",
	                            type: "s",
	                            value: "Temperature is too low to be accurately measured."
	                          });
	                          break;

	                        case 0x10:
	                          bp.set({
	                            name: "0",
	                            type: "d",
	                            value: exports.ErrorEventCode.OUT_OF_RANGE_HIGH_CONDITION
	                          });
	                          bp.set({
	                            name: "1",
	                            type: "s",
	                            value: "Temperature is too high to be accurately measured."
	                          });
	                          break;

	                        case 0x18:
	                          bp.set({
	                            name: "0",
	                            type: "d",
	                            value: exports.ErrorEventCode.OUT_OF_RANGE
	                          });
	                          bp.set({
	                            name: "1",
	                            type: "s",
	                            value: "Temperature is unknown."
	                          });
	                          break;
	                      }

	                      channel.sendErrorEvent(bp);
	                    }

	                    const bp = new BridgePacket();
	                    bp.set({
	                      name: "0",
	                      type: "g",
	                      value: evData.temperature
	                    });
	                    bp.sendToChannel(channel, 95);
	                  }
	              }
	            }
	          }
	        }
	        break;

	      case 163:
	        {
	          const time = buffer.getUint32(1, true);
	          this.updateTimestamp(time & 0xFFFF);

	          for (j = 0; j < 3; j++) {
	            const indexOffset = j * 4;
	            incData.acceleration.push(buffer.getFloat32(5 + indexOffset, true));
	            incData.angularRate.push(buffer.getFloat32(17 + indexOffset, true));
	            incData.magneticField.push(buffer.getFloat32(29 + indexOffset, true));
	          }

	          incData.quaternion.push(buffer.getFloat32(41, true));
	          incData.quaternion.push(buffer.getFloat32(45, true));
	          incData.quaternion.push(buffer.getFloat32(49, true));
	          incData.quaternion.push(buffer.getFloat32(53, true));
	          incData.temperature = buffer.getFloat32(57, true);
	          this.updateLatestDataTime(0);
	          incData.timestamp = this.data.latestDataTime;
	          this.data.dataBuffer.push(incData);

	          if (this.data.doZeroGyro) {
	            if (this.timestampDiff(this.data.latestDataTime, this.data.dataBuffer[0].timestamp) >= ZERO_GYRO_TIME) {
	              const gyroCorrectionTemp = [0, 0, 0];
	              this.data.dataBuffer.forEach(v => {
	                gyroCorrectionTemp.map((_value, index, arary) => {
	                  arary[index] += v.angularRate[index];
	                });
	              });
	              this.data.gyroCorrection.forEach((_value, index, arary) => {
	                arary[index] = gyroCorrectionTemp[index] / this.data.dataBuffer.length;
	              });
	              doneGyroZero = true;
	            }
	          }

	          if (this.timestampDiff(this.data.latestDataTime, this.data.lastEventTime) >= dataRate) {
	            let tempTime = 0;
	            let accelCounter = [0, 0, 0];
	            let angularRateCounter = [0, 0, 0];
	            let magneticFieldCounter = [0, 0, 0];
	            let dataPerEvent = 0;
	            let multipleDataPerEvent = false;
	            if (dataRate < this.data.interruptRate) multipleDataPerEvent = true;

	            for (let j = 0;; j++) {
	              if (this.data.dataBuffer.length === 0 || j >= 16) {
	                dataPerEvent = j;
	                break;
	              }

	              tempTime = this.data.dataBuffer[0].timestamp;
	              this.data.dataBuffer.forEach(v => {
	                if (!multipleDataPerEvent || this.timestampDiff(v.timestamp, tempTime) < dataRate) {
	                  accelAvg.map((_value, index, array) => {
	                    if (v.acceleration[index] !== 1e+300) {
	                      array[index] += v.acceleration[index];
	                      accelCounter[index]++;
	                    }
	                  });
	                  angularRateAvg.map((_value, index, array) => {
	                    if (v.angularRate[index] !== 1e+300) {
	                      const rate = v.angularRate[index] - this.data.gyroCorrection[index];
	                      array[index] += rate;
	                      angularRateCounter[index]++;
	                    }
	                  });
	                  magneticFieldAvg.map((_value, index, array) => {
	                    if (v.magneticField[index] !== 1e+300) {
	                      array[index] += v.magneticField[index];
	                      magneticFieldCounter[index]++;
	                    }
	                  });
	                  quaternion.forEach((_value, index, array) => {
	                    array[index] = v.quaternion[index];
	                  });
	                  temperature = v.temperature;
	                }
	              });
	              this.data.dataBuffer = [];
	              const evData = {
	                acceleration: [],
	                angularRate: [],
	                magneticField: [],
	                quaternion: [],
	                timestamp: 0,
	                temperature: 0
	              };
	              accelAvg.map((value, index, array) => {
	                if (accelCounter[index] > 0) evData.acceleration.push(value / accelCounter[index]);else evData.acceleration.push(1e+300);
	                array[index] = 0;
	              });
	              angularRateAvg.map((value, index, array) => {
	                if (angularRateCounter[index] > 0) {
	                  if (this.data.doZeroGyro && !doneGyroZero) evData.angularRate.push(0);else evData.angularRate.push(value / angularRateCounter[index]);
	                } else evData.angularRate.push(1e+300);

	                array[index] = 0;
	              });
	              magneticFieldAvg.map((value, index, array) => {
	                if (magneticFieldCounter[index] > 0) evData.magneticField.push(value / magneticFieldCounter[index]);else evData.magneticField.push(1e+300);
	                array[index] = 0;
	              });
	              evData.quaternion = quaternion;
	              evData.timestamp = tempTime;
	              evData.temperature = temperature;
	              eventData.push(evData);
	            }

	            accelCounter = [0, 0, 0];
	            angularRateCounter = [0, 0, 0];
	            magneticFieldCounter = [0, 0, 0];

	            for (j = 0; j < dataPerEvent; j++) {
	              for (let i = 0; i < this.numAccelAxes; i++) if (eventData[j].acceleration[i] !== 1e+300) {
	                accelAvg[i] += eventData[j].acceleration[i];
	                accelCounter[i]++;
	              }

	              for (let i = 0; i < this.numGyroAxes; i++) if (eventData[j].angularRate[i] !== 1e+300) {
	                angularRateAvg[i] += eventData[j].angularRate[i];
	                angularRateCounter[i]++;
	              }

	              for (let i = 0; i < this.numCompassAxes; i++) if (eventData[j].magneticField[i] !== 1e+300) {
	                magneticFieldAvg[i] += eventData[j].magneticField[i];
	                magneticFieldCounter[i]++;
	              }

	              eventData[j].quaternion.forEach((value, index) => {
	                quaternion[index] = value;
	              });
	              temperature = eventData[j].temperature;
	            }

	            for (let i = 0; i < this.numAccelAxes; i++) {
	              if (accelCounter[i] > 0) this.data.acceleration[0][i] = accelAvg[i] / accelCounter[i];else this.data.acceleration[0][i] = 1e+300;
	            }

	            for (let i = 0; i < this.numGyroAxes; i++) {
	              if (angularRateCounter[i] > 0) {
	                if (this.data.doZeroGyro && !doneGyroZero) this.data.angularRate[0][i] = 0;else this.data.angularRate[0][i] = angularRateAvg[i] / angularRateCounter[i];
	              } else this.data.angularRate[0][i] = 1e+300;
	            }

	            for (let i = 0; i < this.numCompassAxes; i++) {
	              if (magneticFieldCounter[i] > 0) this.data.magneticField[0][i] = magneticFieldAvg[i] / magneticFieldCounter[i];else this.data.magneticField[0][i] = 1e+300;
	            }

	            this.data.quaternion[0] = {
	              x: quaternion[0],
	              y: quaternion[1],
	              z: quaternion[2],
	              w: quaternion[3]
	            };
	            this.data.temperature[0] = temperature;

	            for (let j = 0; j < dataPerEvent; j++) {
	              fireSaturation = 0;

	              if (this.numSpatialInputs) {
	                if ((channel = this.getChannel(3)) !== null) {
	                  for (let i = 0; i < this.numAccelAxes; i++) {
	                    if (eventData[j].acceleration[i] > this.data.accelerationMax || eventData[j].acceleration[i] < this.data.accelerationMin) fireSaturation |= 0x01;
	                  }

	                  for (let i = 0; i < this.numGyroAxes; i++) {
	                    if (eventData[j].angularRate[i] > this.data.angularRateMax || eventData[j].angularRate[i] < this.data.angularRateMin) fireSaturation |= 0x02;
	                  }

	                  for (let i = 0; i < this.numCompassAxes; i++) {
	                    if (eventData[j].magneticField[i] === 1e+300) continue;
	                    if (eventData[j].magneticField[i] > this.data.magneticFieldMax || eventData[j].magneticField[i] < this.data.magneticFieldMin) fireSaturation |= 0x04;
	                  }

	                  if (fireSaturation === 0) {
	                    let bp = new BridgePacket();
	                    bp.set({
	                      name: "0",
	                      type: "G",
	                      value: eventData[j].acceleration
	                    });
	                    bp.set({
	                      name: "1",
	                      type: "G",
	                      value: eventData[j].angularRate
	                    });
	                    bp.set({
	                      name: "2",
	                      type: "G",
	                      value: eventData[j].magneticField
	                    });
	                    bp.set({
	                      name: "3",
	                      type: "g",
	                      value: eventData[j].timestamp
	                    });
	                    bp.sendToChannel(channel, 89);
	                    bp = new BridgePacket();
	                    bp.set({
	                      name: "0",
	                      type: "G",
	                      value: eventData[j].quaternion
	                    });
	                    bp.set({
	                      name: "1",
	                      type: "g",
	                      value: eventData[j].timestamp
	                    });
	                    bp.sendToChannel(channel, 148);
	                  } else {
	                    if (fireSaturation & 0x01) {
	                      const bp = new BridgePacket();
	                      bp.set({
	                        name: "0",
	                        type: "d",
	                        value: exports.ErrorEventCode.SATURATION
	                      });
	                      bp.set({
	                        name: "1",
	                        type: "s",
	                        value: "Accelerometer Saturation Detected."
	                      });
	                      channel.sendErrorEvent(bp);
	                    }

	                    if (fireSaturation & 0x02) {
	                      const bp = new BridgePacket();
	                      bp.set({
	                        name: "0",
	                        type: "d",
	                        value: exports.ErrorEventCode.SATURATION
	                      });
	                      bp.set({
	                        name: "1",
	                        type: "s",
	                        value: "Gyroscope Saturation Detected."
	                      });
	                      channel.sendErrorEvent(bp);
	                    }

	                    if (fireSaturation & 0x04) {
	                      const bp = new BridgePacket();
	                      bp.set({
	                        name: "0",
	                        type: "d",
	                        value: exports.ErrorEventCode.SATURATION
	                      });
	                      bp.set({
	                        name: "1",
	                        type: "s",
	                        value: "Magnetometer Saturation Detected."
	                      });
	                      channel.sendErrorEvent(bp);
	                    }
	                  }
	                }
	              }

	              if (this.numAccelAxes) {
	                const chIndex = 0;

	                if ((channel = this.getChannel(chIndex)) !== null) {
	                  fireSaturation = false;
	                  fireEvent = false;

	                  for (let i = 0; i < this.numAccelAxes; i++) {
	                    if (eventData[j].acceleration[i] !== 1e+300) {
	                      if (Math.abs(eventData[j].acceleration[i] - this.data.accelAxisLastTrigger[i]) >= this.data.accelerationChangeTrigger || this.data.accelAxisLastTrigger[i] === 1e+300) fireEvent = true;
	                      if (eventData[j].acceleration[i] > this.data.accelerationMax || eventData[j].acceleration[i] < this.data.accelerationMin) fireSaturation = true;
	                    }
	                  }

	                  if (fireSaturation) {
	                    const bp = new BridgePacket();
	                    bp.set({
	                      name: "0",
	                      type: "d",
	                      value: exports.ErrorEventCode.SATURATION
	                    });
	                    bp.set({
	                      name: "1",
	                      type: "s",
	                      value: "Accelerometer Saturation Detected."
	                    });
	                    channel.sendErrorEvent(bp);
	                  }

	                  if (fireEvent) {
	                    const bp = new BridgePacket();
	                    bp.set({
	                      name: "0",
	                      type: "G",
	                      value: eventData[j].acceleration
	                    });
	                    bp.set({
	                      name: "1",
	                      type: "g",
	                      value: eventData[j].timestamp
	                    });
	                    bp.sendToChannel(channel, 1);

	                    for (let i = 0; i < this.numAccelAxes; i++) this.data.accelAxisLastTrigger[i] = eventData[j].acceleration[i];
	                  }
	                }
	              }

	              if (this.numGyroAxes) {
	                const chIndex = 1;

	                if ((channel = this.getChannel(chIndex)) !== null) {
	                  fireSaturation = false;
	                  fireEvent = false;

	                  for (let i = 0; i < this.numGyroAxes; i++) {
	                    if (eventData[j].angularRate[i] !== 1e+300) {
	                      fireEvent = true;
	                      if (eventData[j].angularRate[i] > this.data.angularRateMax || eventData[j].angularRate[i] < this.data.angularRateMin) fireSaturation = true;
	                    }
	                  }

	                  if (fireSaturation) {
	                    const bp = new BridgePacket();
	                    bp.set({
	                      name: "0",
	                      type: "d",
	                      value: exports.ErrorEventCode.SATURATION
	                    });
	                    bp.set({
	                      name: "1",
	                      type: "s",
	                      value: "Gyroscope Saturation Detected."
	                    });
	                    channel.sendErrorEvent(bp);
	                  }

	                  if (fireEvent) {
	                    const bp = new BridgePacket();
	                    bp.set({
	                      name: "0",
	                      type: "G",
	                      value: eventData[j].angularRate
	                    });
	                    bp.set({
	                      name: "1",
	                      type: "g",
	                      value: eventData[j].timestamp
	                    });
	                    bp.sendToChannel(channel, 2);
	                  }
	                }
	              }

	              if (this.numCompassAxes) {
	                const chIndex = 2;

	                if ((channel = this.getChannel(chIndex)) !== null) {
	                  fireSaturation = false;
	                  fireEvent = false;

	                  for (let i = 0; i < this.numCompassAxes; i++) {
	                    if (eventData[j].magneticField[i] !== 1e+300) {
	                      if (Math.abs(eventData[j].magneticField[i] - this.data.magAxisLastTrigger[i]) >= this.data.magneticFieldChangeTrigger || this.data.magAxisLastTrigger[i] === 1e+300) fireEvent = true;
	                      if (eventData[j].magneticField[i] > this.data.magneticFieldMax || eventData[j].magneticField[i] < this.data.magneticFieldMin) fireSaturation = true;
	                    }
	                  }

	                  if (fireSaturation) {
	                    const bp = new BridgePacket();
	                    bp.set({
	                      name: "0",
	                      type: "d",
	                      value: exports.ErrorEventCode.SATURATION
	                    });
	                    bp.set({
	                      name: "1",
	                      type: "s",
	                      value: "Magnetometer Saturation Detected."
	                    });
	                    channel.sendErrorEvent(bp);
	                  }

	                  if (fireEvent) {
	                    const bp = new BridgePacket();
	                    bp.set({
	                      name: "0",
	                      type: "G",
	                      value: eventData[j].magneticField
	                    });
	                    bp.set({
	                      name: "1",
	                      type: "g",
	                      value: eventData[j].timestamp
	                    });
	                    bp.sendToChannel(channel, 18);

	                    for (let i = 0; i < this.numCompassAxes; i++) this.data.magAxisLastTrigger[i] = eventData[j].magneticField[i];
	                  }
	                }
	              }
	            }

	            this.data.lastEventTime = this.data.latestDataTime;
	          }

	          if (this.timestampDiff(this.data.latestDataTime, this.data.lastTemperatureEventTime) >= this.data.temperatureDataInterval) {
	            if (this.numTempInputs) {
	              const chIndex = 4;

	              if ((channel = this.getChannel(chIndex)) !== null) {
	                fireSaturation = false;
	                fireEvent = false;

	                if (this.data.temperature[0] !== 1e+300) {
	                  if (this.data.temperature[0] > this.data.temperatureMax || this.data.temperature[0] < this.data.temperatureMin) {
	                    fireSaturation = true;
	                    this.data.temperature[0] = 1e+300;
	                  }

	                  if (Math.abs(this.data.temperature[0] - this.data.temperatureLastTrigger) >= this.data.temperatureChangeTrigger || this.data.temperatureLastTrigger === 1e+300) fireEvent = true;
	                }

	                if (fireSaturation) {
	                  const bp = new BridgePacket();
	                  bp.set({
	                    name: "0",
	                    type: "d",
	                    value: exports.ErrorEventCode.SATURATION
	                  });
	                  bp.set({
	                    name: "1",
	                    type: "s",
	                    value: "Temperature Saturation Detected."
	                  });
	                  channel.sendErrorEvent(bp);
	                }

	                if (fireEvent) {
	                  const bp = new BridgePacket();
	                  bp.set({
	                    name: "0",
	                    type: "g",
	                    value: this.data.temperature[0]
	                  });
	                  bp.sendToChannel(channel, 95);
	                  this.data.temperatureLastTrigger = this.data.temperature[0];
	                }
	              }
	            }

	            this.data.lastTemperatureEventTime = this.data.latestDataTime;
	          }

	          if (doneGyroZero) this.data.doZeroGyro = false;
	        }
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	    }
	  }

	  setDataRate(channelHandle, newVal) {
	    if (newVal < this.data.interruptRate) newVal = UpperPowerOfTwo(newVal);else newVal = Math.round(newVal / this.data.interruptRate) * this.data.interruptRate;
	    this.data.dataInterval = newVal;
	    let numChannels = 0;
	    if (this.numAccelAxes > 0) numChannels++;
	    if (this.numGyroAxes > 0) numChannels++;
	    if (this.numCompassAxes > 0) numChannels++;
	    if (this.numSpatialInputs) numChannels++;
	    if (this.numTempInputs) numChannels++;

	    for (let i = 0; i < numChannels; i++) {
	      const channel = this.getChannel(i);

	      if (channel !== null && channel !== channelHandle) {
	        const bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: this.data.dataInterval
	        });
	        bp.sendToChannel(channel, 10);
	      }
	    }
	  }

	  setTemperatureDataRate(newVal) {
	    if (newVal < this.data.interruptRate) newVal = UpperPowerOfTwo(newVal);else newVal = Math.round(newVal / this.data.interruptRate) * this.data.interruptRate;
	    this.data.temperatureDataInterval = newVal;
	  }

	  async zeroGyro() {
	    await this.transferPacket(2, 3, 0);
	  }

	  async zeroAHRS() {
	    await this.transferPacket(2, 5, 0);
	  }

	  async resetAHRS() {
	    await this.transferPacket(2, 7, 0);
	  }

	  async configureAlgorithm() {
	    const buf = new ArrayBuffer(6);
	    const buffer = new DataView(buf);
	    buffer.setUint8(0, this.data.algorithm);
	    buffer.setFloat32(1, this.data.AHRSMagGain, true);
	    await this.transferPacket(2, 6, 0, buffer);
	  }

	  async setPrecision(spatialPrecision) {
	    const buffer = new Uint8Array([spatialPrecision]);
	    await this.transferPacket(2, 2, 0, buffer);
	  }

	  async resetCompassCorrectionParameters() {
	    await this.transferPacket(2, 8, 0);
	  }

	  async saveCompassCorrectionParameters() {
	    await this.transferPacket(2, 9, 0);
	  }

	  async setCompassCorrectionParameters(corrParams) {
	    const buf = new ArrayBuffer(52);
	    const buffer = new DataView(buf);
	    if (corrParams.magField < 0.1 || corrParams.magField > 1000) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "magField must be between 0.1 and 1000.");
	    if (corrParams.offset0 < -5 || corrParams.offset0 > 5) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Offset must be between -5 and 5.");
	    if (corrParams.offset1 < -5 || corrParams.offset1 > 5) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Offset must be between -5 and 5.");
	    if (corrParams.offset2 < -5 || corrParams.offset2 > 5) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Offset must be between -5 and 5.");
	    if (corrParams.gain0 < 0 || corrParams.gain0 > 15) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Gain must be between 0 and 15.");
	    if (corrParams.gain1 < 0 || corrParams.gain1 > 15) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Gain must be between 0 and 15.");
	    if (corrParams.gain2 < 0 || corrParams.gain2 > 15) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Gain must be between 0 and 15.");
	    if (corrParams.T0 < -5 || corrParams.T0 > 5) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "T0 must be between -5 and 5.");
	    if (corrParams.T1 < -5 || corrParams.T1 > 5) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "T1 must be between -5 and 5.");
	    if (corrParams.T2 < -5 || corrParams.T2 > 5) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "T2 must be between -5 and 5.");
	    if (corrParams.T3 < -5 || corrParams.T3 > 5) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "T3 must be between -5 and 5.");
	    if (corrParams.T4 < -5 || corrParams.T4 > 5) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "T4 must be between -5 and 5.");
	    if (corrParams.T5 < -5 || corrParams.T5 > 5) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "T5 must be between -5 and 5.");
	    buffer.setFloat32(0, corrParams.magField, true);
	    buffer.setFloat32(4, corrParams.offset0, true);
	    buffer.setFloat32(8, corrParams.offset1, true);
	    buffer.setFloat32(12, corrParams.offset2, true);
	    buffer.setFloat32(16, corrParams.gain0, true);
	    buffer.setFloat32(20, corrParams.gain1, true);
	    buffer.setFloat32(24, corrParams.gain2, true);
	    buffer.setFloat32(28, corrParams.T0, true);
	    buffer.setFloat32(32, corrParams.T1, true);
	    buffer.setFloat32(36, corrParams.T2, true);
	    buffer.setFloat32(40, corrParams.T3, true);
	    buffer.setFloat32(44, corrParams.T4, true);
	    buffer.setFloat32(48, corrParams.T5, true);
	    await this.transferPacket(2, 16, 0, buffer);
	  }

	}

	class EncoderDevice extends PhidgetUSBDevice {
	  constructor(conn, data, usbDev) {
	    super(conn, data, usbDev);

	    switch (this.devDef.uid) {
	      case 51:
	      case 70:
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }

	    this.data = {
	      inputState: new Array(this.numInputs).fill(2)
	    };
	  }

	  get numEncoders() {
	    return this.devDef.cn[0];
	  }

	  get numInputs() {
	    return this.devDef.cn[1];
	  }

	  async initAfterOpen() {
	    switch (this.devDef.uid) {
	      case 51:
	      case 70:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED, "This Phidget is not yet supported via direct USB connection in JavaScript.");
	    }
	  }

	  dataInput(_buffer) {}

	  async bridgeInput(_ch, _arg1) {}

	}

	class BridgeDevice extends PhidgetUSBDevice {
	  constructor(conn, data, usbDev) {
	    super(conn, data, usbDev);

	    switch (this.devDef.uid) {
	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }

	  get numBridgeInputs() {
	    return this.devDef.cn[0];
	  }

	  async updateBridgeIntervals(ch, bp) {
	    let integerInterval;
	    let interval;
	    const len = 4 * this.numBridgeInputs + 1;
	    const buffer = await this.transferPacket(3, 0, 0, len);

	    for (let i = 0; i < this.numBridgeInputs; i++) {
	      this.data.enabled[i] = (buffer.getUint8(0) & 1 << i) !== 0;
	      interval = buffer.getFloat32(4 * i + 1, true);
	      this.data.dataInterval[i] = interval <= 60000 ? interval : 1e+300;
	    }

	    for (let i = 0; i < this.numBridgeInputs; i++) {
	      interval = this.data.dataInterval[i];
	      if (interval === 1e+300) continue;
	      integerInterval = RoundDouble(interval > 0 ? interval : 1, 0);

	      if (i == ch.index) {
	        if (bp.vpkt === 111) continue;
	        if (bp.vpkt !== 54) bp.add({
	          name: "",
	          type: "g",
	          value: interval
	        });else {
	          bp.remove("0");
	          bp.set({
	            name: "0",
	            type: "u",
	            value: integerInterval
	          });

	          if (bp.entryCount > 1) {
	            bp.remove("1");
	            bp.set({
	              name: "1",
	              type: "g",
	              value: interval
	            });
	          } else {
	            bp.add({
	              name: "",
	              type: "g",
	              value: interval
	            });
	          }
	        }
	      }

	      const channel = this.getChannel(i);

	      if (channel !== null) {
	        const bp_s = new BridgePacket();
	        bp_s.set({
	          name: "0",
	          type: "u",
	          value: integerInterval
	        });
	        bp_s.set({
	          name: "1",
	          type: "g",
	          value: interval
	        });
	        bp_s.sendToChannel(channel, 10);
	      }
	    }
	  }

	  initData() {
	    const data = {
	      voltageRatio: new Array(this.numBridgeInputs).fill(1e+300),
	      dataInterval: new Array(this.numBridgeInputs).fill(1e+300),
	      voltageRatioChangeTrigger: new Array(this.numBridgeInputs).fill(1e+300),
	      enabled: new Array(this.numBridgeInputs).fill(false),
	      gain: new Array(this.numBridgeInputs).fill(2147483647),
	      dataRate: 4294967295,
	      enabledEcho: new Array(this.numBridgeInputs).fill(false),
	      gainEcho: new Array(this.numBridgeInputs).fill(2147483647),
	      bridgeLastTrigger: new Array(this.numBridgeInputs).fill(1e+300),
	      dataRateMin: 1e+300,
	      dataRateMax: 1e+300,
	      bridgeMin: new Array(this.numBridgeInputs).fill(1e+300),
	      bridgeMax: new Array(this.numBridgeInputs).fill(1e+300),
	      outOfRange: new Array(this.numBridgeInputs).fill(false),
	      chEnabledBugNotValid: new Array(this.numBridgeInputs).fill(false),
	      ch0EnableOverride: false
	    };
	    return data;
	  }

	  async initAfterOpen() {
	    let len;
	    let buffer;
	    this.data = this.initData();

	    switch (this.devDef.uid) {
	      case 49:
	        this.data.dataRateMin = 1000;
	        this.data.dataRateMax = 1;
	        len = 4 * this.numBridgeInputs + 1;
	        buffer = await this.transferPacket(3, 0, 0, len);

	        for (let i = 0; i < this.numBridgeInputs; i++) {
	          this.data.bridgeMax[i] = 1.000;
	          this.data.bridgeMin[i] = -1.000;
	          this.data.enabled[i] = (buffer.getUint8(0) & 1 << i) !== 0;
	          const interval = buffer.getFloat32(4 * i + 1, true);
	          this.data.dataInterval[i] = interval <= 60000 ? interval : 1e+300;
	        }

	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected device");
	    }

	    for (let i = 0; i < this.numBridgeInputs; i++) {
	      this.data.voltageRatioChangeTrigger[i] = 0.001;
	    }
	  }

	  dataInput(buffer) {
	    let chIndex;
	    let channel;
	    let bp;

	    switch (this.devDef.uid) {
	      case 49:
	        chIndex = buffer.getUint8(1);

	        switch (buffer.getUint8(0)) {
	          case 27:
	            this.data.voltageRatio[chIndex] = buffer.getFloat32(2, true);
	            channel = this.getChannel(chIndex);

	            if (channel !== null) {
	              if (buffer.byteLength > 6) {
	                switch (buffer.getInt8(6)) {
	                  case 1:
	                    bp = new BridgePacket();
	                    bp.set({
	                      name: "0",
	                      type: "d",
	                      value: exports.ErrorEventCode.OUT_OF_RANGE_HIGH_CONDITION
	                    });
	                    bp.set({
	                      name: "1",
	                      type: "s",
	                      value: "The sensor reading is too high for the selected gain mode."
	                    });
	                    channel.sendErrorEvent(bp);
	                    break;

	                  case -1:
	                    bp = new BridgePacket();
	                    bp.set({
	                      name: "0",
	                      type: "d",
	                      value: exports.ErrorEventCode.OUT_OF_RANGE_LOW_CONDITION
	                    });
	                    bp.set({
	                      name: "1",
	                      type: "s",
	                      value: "The sensor reading is too low for the selected gain mode."
	                    });
	                    channel.sendErrorEvent(bp);
	                    break;

	                  default:
	                    bp = new BridgePacket();
	                    bp.set({
	                      name: "0",
	                      type: "d",
	                      value: exports.ErrorEventCode.OUT_OF_RANGE
	                    });
	                    bp.set({
	                      name: "1",
	                      type: "s",
	                      value: "Value is unknown."
	                    });
	                    channel.sendErrorEvent(bp);
	                    break;
	                }
	              }

	              bp = new BridgePacket();
	              bp.set({
	                name: "0",
	                type: "g",
	                value: this.data.voltageRatio[chIndex]
	              });
	              bp.sendToChannel(channel, 102);
	            }

	            return;

	          default:
	            throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type");
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected device");
	    }
	  }

	  async bridgeInput(ch, bp) {
	    let buffer;

	    switch (this.devDef.uid) {
	      case 49:
	        switch (bp.vpkt) {
	          case 56:
	            buffer = new Uint8Array([bp.getNumber(0) ? 0xFF : 0x00]);
	            await this.transferPacket(0, 30, ch.uniqueIndex, buffer);
	            this.data.enabled[ch.index] = buffer[0] !== 0;
	            await this.updateBridgeIntervals(ch, bp);
	            return;

	          case 54:
	            buffer = new DataView(new ArrayBuffer(4));
	            if (bp.entryCount > 1) buffer.setFloat32(0, bp.getNumber(1), true);else buffer.setFloat32(0, bp.getNumber(0), true);
	            await this.transferPacket(0, 252, ch.uniqueIndex, buffer);
	            buffer = await this.transferPacket(1, 252, ch.uniqueIndex, 4);
	            this.data.dataInterval[ch.index] = buffer.getFloat32(0, true);
	            await this.updateBridgeIntervals(ch, bp);
	            return;

	          case 46:
	            buffer = new DataView(new ArrayBuffer(4));
	            buffer.setUint32(0, bp.getNumber(0) * 0x80000000);
	            await this.transferPacket(0, 26, ch.uniqueIndex, buffer);
	            return;

	          case 45:
	            buffer = new Uint8Array([bp.getNumber(0)]);
	            await this.transferPacket(0, 29, ch.uniqueIndex, buffer);
	            return;

	          case 34:
	          case 111:
	            this.data.enabled[ch.index] = false;
	            await this.transferPacket(0, 250, ch.uniqueIndex);
	            await this.updateBridgeIntervals(ch, bp);
	            return;

	          case 143:
	            await this.updateBridgeIntervals(ch, bp);
	            return;

	          default:
	            throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type.");
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected device");
	    }
	  }

	}

	class DataAdapterDevice extends PhidgetUSBDevice {
	  constructor(conn, data, usbDev) {
	    super(conn, data, usbDev);

	    switch (this.devDef.uid) {
	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }

	  get numDataAdapters() {
	    return this.devDef.cn[0];
	  }

	  get numInputs() {
	    return this.devDef.cn[1];
	  }

	  get numOutputs() {
	    return this.devDef.cn[2];
	  }

	  async initAfterOpen() {
	    switch (this.devDef.uid) {
	      case 100:
	      case 102:
	      case 104:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED, "This Phidget is not yet supported via direct USB connection in JavaScript.");
	    }
	  }

	  dataInput(_buffer) {}

	  async bridgeInput(_ch, _arg1) {}

	}

	class GenericDevice extends PhidgetUSBDevice {
	  constructor(conn, data, usbDev) {
	    super(conn, data, usbDev);

	    switch (this.devDef.uid) {
	      case 229:
	      case 233:
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }

	    this.data = {
	      INPacketLength: [this.pusbParams.maxPacketEP1],
	      OUTPacketLength: [this.pusbParams.ep2type === 0 ? this.pusbParams.maxPacketEP0 : this.pusbParams.maxPacketEP2],
	      CTRPacketLength: [this.pusbParams.maxPacketEP0]
	    };
	  }

	  async initAfterOpen() {}

	  dataInput(_buffer) {}

	  async bridgeInput(_ch, _arg1) {}

	}

	const TEMPSENSOR_MAXSENSORS = 5;
	const PHIDID_1048_GAIN = 80 / 2.2 + 5;
	const PHIDID_1048_OFFSET = 4.096 / 6.36;
	class TemperatureSensorDevice extends PhidgetUSBDevice {
	  constructor(conn, data, usbDev) {
	    super(conn, data, usbDev);

	    switch (this.devDef.uid) {
	      case 53:
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }

	    this.data = this.initData();
	  }

	  get numTempInputs() {
	    return this.devDef.cn[0];
	  }

	  get numVoltageInputs() {
	    return this.devDef.cn[1];
	  }

	  lookup_voltage(tJunc, tcType) {
	    let tcTable;

	    switch (tcType) {
	      case exports.ThermocoupleType.K:
	        tcTable = thermocouple_table_k_type;
	        break;

	      case exports.ThermocoupleType.J:
	        tcTable = thermocouple_table_j_type;
	        break;

	      case exports.ThermocoupleType.E:
	        tcTable = thermocouple_table_e_type;
	        break;

	      case exports.ThermocoupleType.T:
	        tcTable = thermocouple_table_t_type;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	    }

	    const startingTemp = thermocouple_table_range[tcType][0];

	    if (RoundDouble(tJunc, 0) - startingTemp < 0) {
	      return 1e+300;
	    }

	    if (RoundDouble(tJunc, 0) - (startingTemp - 1) >= tcTable.length) {
	      return 1e+300;
	    }

	    const voltage = tcTable[RoundDouble(tJunc, 0) - startingTemp] + (tcTable[RoundDouble(tJunc, 0) - (startingTemp - 1)] - tcTable[RoundDouble(tJunc, 0) - startingTemp]) * (tJunc - RoundDouble(tJunc, 0));
	    return voltage / 1000.0;
	  }

	  lookup_temperature(Vtc, tcType) {
	    let tcTable;
	    let temperature = 1e+300;

	    switch (tcType) {
	      case exports.ThermocoupleType.K:
	        tcTable = thermocouple_table_k_type;
	        break;

	      case exports.ThermocoupleType.J:
	        tcTable = thermocouple_table_j_type;
	        break;

	      case exports.ThermocoupleType.E:
	        tcTable = thermocouple_table_e_type;
	        break;

	      case exports.ThermocoupleType.T:
	        tcTable = thermocouple_table_t_type;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	    }

	    const startingTemp = thermocouple_table_range[tcType][0];
	    Vtc *= 1000.0;

	    if (Vtc < tcTable[0]) {
	      return 1e+300;
	    }

	    for (let i = 0; i < tcTable.length; i++) {
	      if (tcTable[i] > Vtc) {
	        temperature = i + (startingTemp - 1) + (Vtc - tcTable[i - 1]) / (tcTable[i] - tcTable[i - 1]);
	        break;
	      }
	    }

	    return temperature;
	  }

	  initData() {
	    const data = {
	      maxTemperature: new Array(this.numTempInputs).fill(1e+300),
	      minTemperature: new Array(this.numTempInputs).fill(1e+300),
	      temperature: new Array(this.numTempInputs).fill(1e+300),
	      voltage: new Array(this.numVoltageInputs).fill(1e+300),
	      voltageChangeTrigger: new Array(this.numVoltageInputs).fill(0),
	      lastVoltageTrigger: new Array(this.numVoltageInputs).fill(1e+300),
	      potentialMin: RoundDouble((0.23 - PHIDID_1048_OFFSET) / PHIDID_1048_GAIN, 5),
	      potentialMax: RoundDouble((3.846 - PHIDID_1048_OFFSET) / PHIDID_1048_GAIN, 5),
	      voltageDeadline: new Array(this.numTempInputs).fill(0),
	      voltageDataInterval: new Array(this.numTempInputs).fill(1e+300),
	      thermocoupleType: new Array(this.numTempInputs - 1).fill(exports.ThermocoupleType.K),
	      temperatureChangeTrigger: new Array(this.numTempInputs).fill(0),
	      ambientTemperatureIndex: this.numTempInputs - 1,
	      temperatureDeadline: new Array(this.numTempInputs).fill(0),
	      temperatureDataInterval: new Array(this.numTempInputs).fill(1e+300),
	      interruptRate: 32,
	      lastTrigger: new Array(this.numTempInputs).fill(1e+300),
	      lastAmbientTrigger: 1e+300,
	      di_calltm: 0
	    };
	    return data;
	  }

	  async initAfterOpen() {
	    this.data = this.initData();
	    this.data.minTemperature[this.data.ambientTemperatureIndex] = -55;
	    this.data.maxTemperature[this.data.ambientTemperatureIndex] = 150;
	  }

	  dataInput(_buffer) {
	    const temperature = new Array(TEMPSENSOR_MAXSENSORS).fill(0);
	    const potential = new Array(TEMPSENSOR_MAXSENSORS).fill(0);
	    let Vthermocouple, Temp;
	    let badConnectionFlags = 0;
	    let ambientTemperature;
	    let channel;
	    let v;

	    switch (this.devDef.uid) {
	      case 53:
	        ambientTemperature = RoundDouble(_buffer.getFloat32(16, true), 4);
	        badConnectionFlags = _buffer.getUint8(20);

	        for (let i = 0; i < this.numTempInputs - 1; i++) {
	          potential[i] = RoundDouble(_buffer.getFloat32(i * 4, true), 7);
	          Vthermocouple = potential[i] + this.lookup_voltage(ambientTemperature, this.data.thermocoupleType[i]);
	          Temp = this.lookup_temperature(Vthermocouple, this.data.thermocoupleType[i]);

	          if (Temp != 1e+300) {
	            temperature[i] = RoundDouble(Temp, 4);
	          } else {
	            temperature[i] = 1e+300;
	          }
	        }

	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected device");
	    }

	    this.data.di_calltm++;

	    if (ambientTemperature > this.data.maxTemperature[this.data.ambientTemperatureIndex]) {
	      this.data.temperature[this.data.ambientTemperatureIndex] = 1e+300;
	      channel = this.getChannel(this.numTempInputs + this.numVoltageInputs);

	      if (channel !== null) {
	        const errorMsg = "Ambient sensor reported a temperature of ".concat(ambientTemperature.toFixed(4), "C which is over the maximum of ").concat(this.data.maxTemperature[this.data.ambientTemperatureIndex].toFixed(4), "C");
	        const bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: exports.ErrorEventCode.OUT_OF_RANGE
	        });
	        bp.set({
	          name: "1",
	          type: "s",
	          value: errorMsg
	        });
	        channel.sendErrorEvent(bp);
	      }
	    } else if (ambientTemperature < this.data.minTemperature[this.data.ambientTemperatureIndex]) {
	      this.data.temperature[this.data.ambientTemperatureIndex] = 1e+300;
	      channel = this.getChannel(this.numTempInputs + this.numVoltageInputs);

	      if (channel !== null) {
	        const errorMsg = "Ambient sensor reported a temperature of ".concat(ambientTemperature.toFixed(4), "C which is below the minimum of ").concat(this.data.minTemperature[this.data.ambientTemperatureIndex].toFixed(4), "C");
	        const bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: exports.ErrorEventCode.OUT_OF_RANGE
	        });
	        bp.set({
	          name: "1",
	          type: "s",
	          value: errorMsg
	        });
	        channel.sendErrorEvent(bp);
	      }
	    } else {
	      this.data.temperature[this.data.ambientTemperatureIndex] = ambientTemperature;

	      switch (this.devDef.uid) {
	        case 53:
	          for (let i = 0; i < this.numTempInputs - 1; i++) {
	            if (this.data.thermocoupleType[i] === 2147483647) {
	              continue;
	            }

	            v = this.lookup_voltage(thermocouple_useful_range[this.data.thermocoupleType[i]][1] - this.data.temperature[this.data.ambientTemperatureIndex], this.data.thermocoupleType[i]);

	            if (v > this.data.potentialMax) {
	              this.data.maxTemperature[i] = RoundDouble((this.lookup_temperature(this.data.potentialMax, this.data.thermocoupleType[i]) + this.data.temperature[this.data.ambientTemperatureIndex]) / 10, 0) * 10;
	            }

	            v = this.lookup_voltage(thermocouple_useful_range[this.data.thermocoupleType[i]][0] - this.data.temperature[this.data.ambientTemperatureIndex], this.data.thermocoupleType[i]);

	            if (v < this.data.potentialMin) {
	              this.data.minTemperature[i] = RoundDouble((this.lookup_temperature(this.data.potentialMin, this.data.thermocoupleType[i]) + this.data.temperature[this.data.ambientTemperatureIndex]) / 10, 0) * 10;
	            }
	          }

	          break;
	      }
	    }

	    for (let i = 0; i < this.numTempInputs - 1; i++) {
	      channel = this.getChannel(i);

	      if ((badConnectionFlags & 1 << i) !== 0) {
	        this.data.temperature[i] = 1e+300;

	        if (channel !== null) {
	          const bp = new BridgePacket();
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.BAD_CONNECTION_CONDITION
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Input reported a bad connection on this channel.  Check there is a thermocouple attached."
	          });
	          channel.sendErrorEvent(bp);
	        }
	      } else if (this.data.temperature[this.data.ambientTemperatureIndex] === 1e+300) {
	        this.data.temperature[i] = 1e+300;

	        if (channel !== null) {
	          const bp = new BridgePacket();
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.OUT_OF_RANGE
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: "Temperature cannot be calculated because the ambient temperature is unkonwn."
	          });
	          channel.sendErrorEvent(bp);
	        }
	      } else if (temperature[i] === 1e+300) {
	        this.data.temperature[i] = 1e+300;

	        if (this.data.thermocoupleType[i] !== 2147483647) {
	          if (channel !== null) {
	            const bp = new BridgePacket();
	            bp.set({
	              name: "0",
	              type: "d",
	              value: exports.ErrorEventCode.OUT_OF_RANGE
	            });
	            bp.set({
	              name: "1",
	              type: "s",
	              value: "Input reported an undefined temperature. Probably there is no thermocouple plugged in."
	            });
	            channel.sendErrorEvent(bp);
	          }
	        }
	      } else if (temperature[i] > this.data.maxTemperature[i]) {
	        this.data.temperature[i] = 1e+300;

	        if (channel !== null) {
	          const errorMsg = "Input reported a temperature of ".concat(temperature[i].toFixed(4), "C which is over the maximum of ").concat(this.data.maxTemperature[i].toFixed(4), "C");
	          const bp = new BridgePacket();
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.OUT_OF_RANGE
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: errorMsg
	          });
	          channel.sendErrorEvent(bp);
	        }
	      } else if (temperature[i] < this.data.minTemperature[i]) {
	        this.data.temperature[i] = 1e+300;

	        if (channel !== null) {
	          const errorMsg = "Input reported a temperature of ".concat(temperature[i].toFixed(4), "C which is below the minimum of ").concat(this.data.minTemperature[i].toFixed(4), "C");
	          const bp = new BridgePacket();
	          bp.set({
	            name: "0",
	            type: "d",
	            value: exports.ErrorEventCode.OUT_OF_RANGE
	          });
	          bp.set({
	            name: "1",
	            type: "s",
	            value: errorMsg
	          });
	          channel.sendErrorEvent(bp);
	        }
	      } else {
	        this.data.temperature[i] = temperature[i];
	      }

	      switch (this.devDef.uid) {
	        case 53:
	          channel = this.getChannel(i + this.numTempInputs);

	          if ((badConnectionFlags & 1 << i) !== 0) {
	            this.data.voltage[i] = 1e+300;

	            if (channel !== null) {
	              const bp = new BridgePacket();
	              bp.set({
	                name: "0",
	                type: "d",
	                value: exports.ErrorEventCode.BAD_CONNECTION_CONDITION
	              });
	              bp.set({
	                name: "1",
	                type: "s",
	                value: "Input reported a bad connection on this channel."
	              });
	              channel.sendErrorEvent(bp);
	            }
	          } else if (potential[i] > this.data.potentialMax) {
	            this.data.voltage[i] = 1e+300;

	            if (channel !== null) {
	              const errorMsg = "Input reported a potential of ".concat(potential[i].toFixed(4), "mV which is above the maximum of ").concat(this.data.potentialMax.toFixed(4), "mV");
	              const bp = new BridgePacket();
	              bp.set({
	                name: "0",
	                type: "d",
	                value: exports.ErrorEventCode.OUT_OF_RANGE
	              });
	              bp.set({
	                name: "1",
	                type: "s",
	                value: errorMsg
	              });
	              channel.sendErrorEvent(bp);
	            }
	          } else if (potential[i] < this.data.potentialMin) {
	            this.data.voltage[i] = 1e+300;

	            if (channel !== null) {
	              const errorMsg = "Input reported a potential of ".concat(potential[i].toFixed(4), "mV which is below the minimum of ").concat(this.data.potentialMin.toFixed(4), "mV");
	              const bp = new BridgePacket();
	              bp.set({
	                name: "0",
	                type: "d",
	                value: exports.ErrorEventCode.OUT_OF_RANGE
	              });
	              bp.set({
	                name: "1",
	                type: "s",
	                value: errorMsg
	              });
	              channel.sendErrorEvent(bp);
	            }
	          } else {
	            this.data.voltage[i] = potential[i];
	          }

	          break;
	      }
	    }

	    const tm = this.data.interruptRate * this.data.di_calltm;

	    for (let i = 0; i < this.numTempInputs; i++) {
	      if (this.data.temperature[i] === 1e+300) {
	        continue;
	      }

	      if (tm < this.data.temperatureDeadline[i]) {
	        continue;
	      }

	      channel = this.getChannel(i);

	      if (channel === null) {
	        continue;
	      }

	      if (this.data.lastTrigger[i] === 1e+300 || Math.abs(this.data.temperature[i] - this.data.lastTrigger[i]) >= this.data.temperatureChangeTrigger[i]) {
	        const bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.temperature[i]
	        });
	        bp.sendToChannel(channel, 95);
	        this.data.lastTrigger[i] = this.data.temperature[i];
	        this.data.temperatureDeadline[i] = tm + this.data.temperatureDataInterval[i];
	      }
	    }

	    for (let i = 0; i < this.numVoltageInputs; i++) {
	      if (this.data.voltage[i] === 1e+300) {
	        continue;
	      }

	      if (tm < this.data.voltageDeadline[i]) {
	        continue;
	      }

	      channel = this.getChannel(i + this.numTempInputs);

	      if (channel === null) {
	        continue;
	      }

	      if (this.data.lastVoltageTrigger[i] === 1e+300 || Math.abs(this.data.voltage[i] - this.data.lastVoltageTrigger[i]) >= this.data.voltageChangeTrigger[i]) {
	        const bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.voltage[i]
	        });
	        bp.sendToChannel(channel, 101);
	        this.data.lastVoltageTrigger[i] = this.data.voltage[i];
	        this.data.voltageDeadline[i] = tm + this.data.voltageDataInterval[i];
	      }
	    }
	  }

	  async bridgeInput(ch, bp) {
	    switch (ch.class) {
	      case exports.ChannelClass.TEMPERATURE_SENSOR:
	        switch (bp.vpkt) {
	          case 54:
	            this.data.temperatureDataInterval[ch.index] = this._handleDataIntervalPacket(bp, this.data.interruptRate);
	            this.data.temperatureDeadline[ch.index] = 0;
	            return;

	          case 46:
	            this.data.temperatureChangeTrigger[ch.index] = bp.getNumber(0);
	            return;

	          case 84:
	            {
	              const t = bp.getNumber(0);
	              this.data.thermocoupleType[ch.index] = t;
	              this.data.maxTemperature[ch.index] = thermocouple_useful_range[t][1];
	              this.data.minTemperature[ch.index] = thermocouple_useful_range[t][0];

	              if (this.data.temperature[this.data.ambientTemperatureIndex] !== 1e+300) {
	                if (this.lookup_voltage(this.data.maxTemperature[ch.index] - this.data.temperature[this.data.ambientTemperatureIndex], t) > this.data.potentialMax) {
	                  this.data.maxTemperature[ch.index] = RoundDouble((this.lookup_temperature(this.data.potentialMax, t) + this.data.temperature[this.data.ambientTemperatureIndex]) / 10, 0) * 10;
	                }

	                if (this.lookup_voltage(this.data.minTemperature[ch.index] - this.data.temperature[this.data.ambientTemperatureIndex], t) < this.data.potentialMin) {
	                  this.data.minTemperature[ch.index] = RoundDouble((this.lookup_temperature(this.data.potentialMin, t) + this.data.temperature[this.data.ambientTemperatureIndex]) / 10, 0) * 10;
	                }
	              }
	            }
	            return;

	          case 34:
	          case 111:
	            switch (this.devDef.uid) {
	              case 53:
	                if (ch.index !== this.data.ambientTemperatureIndex) {
	                  this.data.thermocoupleType[ch.index] = 2147483647;
	                  this.data.maxTemperature[ch.index] = 1e+300;
	                  this.data.minTemperature[ch.index] = 1e+300;
	                }

	                break;
	            }

	            return;

	          case 143:
	            return;

	          default:
	            throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type");
	        }

	      case exports.ChannelClass.VOLTAGE_INPUT:
	        switch (bp.vpkt) {
	          case 54:
	            this.data.voltageDataInterval[ch.index] = this._handleDataIntervalPacket(bp, this.data.interruptRate);
	            this.data.voltageDeadline[ch.index] = 0;
	            return;

	          case 46:
	            this.data.voltageChangeTrigger[ch.index] = bp.getNumber(0);
	            return;

	          case 34:
	          case 111:
	          case 143:
	            return;

	          default:
	            throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected packet type");
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNEXPECTED, "Unexpected channel class");
	    }
	  }

	}
	const thermocouple_table_range = [[0, 0], [-210, 1200], [-270, 1372], [-270, 1000], [-270, 400]];
	const thermocouple_useful_range = [[0, 0], [0, 750], [-200, 1250], [-200, 900], [-200, 350]];
	const thermocouple_table_e_type = [-9.835, -9.833, -9.831, -9.828, -9.825, -9.821, -9.817, -9.813, -9.808, -9.802, -9.797, -9.790, -9.784, -9.777, -9.770, -9.762, -9.754, -9.746, -9.737, -9.728, -9.718, -9.709, -9.698, -9.688, -9.677, -9.666, -9.654, -9.642, -9.630, -9.617, -9.604, -9.591, -9.577, -9.563, -9.548, -9.534, -9.519, -9.503, -9.487, -9.471, -9.455, -9.438, -9.421, -9.404, -9.386, -9.368, -9.350, -9.331, -9.313, -9.293, -9.274, -9.254, -9.234, -9.214, -9.193, -9.172, -9.151, -9.129, -9.107, -9.085, -9.063, -9.040, -9.017, -8.994, -8.971, -8.947, -8.923, -8.899, -8.874, -8.850, -8.825, -8.799, -8.774, -8.748, -8.722, -8.696, -8.669, -8.643, -8.616, -8.588, -8.561, -8.533, -8.505, -8.477, -8.449, -8.420, -8.391, -8.362, -8.333, -8.303, -8.273, -8.243, -8.213, -8.183, -8.152, -8.121, -8.090, -8.059, -8.027, -7.995, -7.963, -7.931, -7.899, -7.866, -7.833, -7.800, -7.767, -7.733, -7.700, -7.666, -7.632, -7.597, -7.563, -7.528, -7.493, -7.458, -7.423, -7.387, -7.351, -7.315, -7.279, -7.243, -7.206, -7.170, -7.133, -7.096, -7.058, -7.021, -6.983, -6.945, -6.907, -6.869, -6.831, -6.792, -6.753, -6.714, -6.675, -6.636, -6.596, -6.556, -6.516, -6.476, -6.436, -6.396, -6.355, -6.314, -6.273, -6.232, -6.191, -6.149, -6.107, -6.065, -6.023, -5.981, -5.939, -5.896, -5.853, -5.810, -5.767, -5.724, -5.681, -5.637, -5.593, -5.549, -5.505, -5.461, -5.417, -5.372, -5.327, -5.282, -5.237, -5.192, -5.147, -5.101, -5.055, -5.009, -4.963, -4.917, -4.871, -4.824, -4.777, -4.731, -4.684, -4.636, -4.589, -4.542, -4.494, -4.446, -4.398, -4.350, -4.302, -4.254, -4.205, -4.156, -4.107, -4.058, -4.009, -3.960, -3.911, -3.861, -3.811, -3.761, -3.711, -3.661, -3.611, -3.561, -3.510, -3.459, -3.408, -3.357, -3.306, -3.255, -3.204, -3.152, -3.100, -3.048, -2.996, -2.944, -2.892, -2.840, -2.787, -2.735, -2.682, -2.629, -2.576, -2.523, -2.469, -2.416, -2.362, -2.309, -2.255, -2.201, -2.147, -2.093, -2.038, -1.984, -1.929, -1.874, -1.820, -1.765, -1.709, -1.654, -1.599, -1.543, -1.488, -1.432, -1.376, -1.320, -1.264, -1.208, -1.152, -1.095, -1.039, -0.982, -0.925, -0.868, -0.811, -0.754, -0.697, -0.639, -0.582, -0.524, -0.466, -0.408, -0.350, -0.292, -0.234, -0.176, -0.117, -0.059, 0.000, 0.059, 0.118, 0.176, 0.235, 0.294, 0.354, 0.413, 0.472, 0.532, 0.591, 0.651, 0.711, 0.770, 0.830, 0.890, 0.950, 1.010, 1.071, 1.131, 1.192, 1.252, 1.313, 1.373, 1.434, 1.495, 1.556, 1.617, 1.678, 1.740, 1.801, 1.862, 1.924, 1.986, 2.047, 2.109, 2.171, 2.233, 2.295, 2.357, 2.420, 2.482, 2.545, 2.607, 2.670, 2.733, 2.795, 2.858, 2.921, 2.984, 3.048, 3.111, 3.174, 3.238, 3.301, 3.365, 3.429, 3.492, 3.556, 3.620, 3.685, 3.749, 3.813, 3.877, 3.942, 4.006, 4.071, 4.136, 4.200, 4.265, 4.330, 4.395, 4.460, 4.526, 4.591, 4.656, 4.722, 4.788, 4.853, 4.919, 4.985, 5.051, 5.117, 5.183, 5.249, 5.315, 5.382, 5.448, 5.514, 5.581, 5.648, 5.714, 5.781, 5.848, 5.915, 5.982, 6.049, 6.117, 6.184, 6.251, 6.319, 6.386, 6.454, 6.522, 6.590, 6.658, 6.725, 6.794, 6.862, 6.930, 6.998, 7.066, 7.135, 7.203, 7.272, 7.341, 7.409, 7.478, 7.547, 7.616, 7.685, 7.754, 7.823, 7.892, 7.962, 8.031, 8.101, 8.170, 8.240, 8.309, 8.379, 8.449, 8.519, 8.589, 8.659, 8.729, 8.799, 8.869, 8.940, 9.010, 9.081, 9.151, 9.222, 9.292, 9.363, 9.434, 9.505, 9.576, 9.647, 9.718, 9.789, 9.860, 9.931, 10.003, 10.074, 10.145, 10.217, 10.288, 10.360, 10.432, 10.503, 10.575, 10.647, 10.719, 10.791, 10.863, 10.935, 11.007, 11.080, 11.152, 11.224, 11.297, 11.369, 11.442, 11.514, 11.587, 11.660, 11.733, 11.805, 11.878, 11.951, 12.024, 12.097, 12.170, 12.243, 12.317, 12.390, 12.463, 12.537, 12.610, 12.684, 12.757, 12.831, 12.904, 12.978, 13.052, 13.126, 13.199, 13.273, 13.347, 13.421, 13.495, 13.569, 13.644, 13.718, 13.792, 13.866, 13.941, 14.015, 14.090, 14.164, 14.239, 14.313, 14.388, 14.463, 14.537, 14.612, 14.687, 14.762, 14.837, 14.912, 14.987, 15.062, 15.137, 15.212, 15.287, 15.362, 15.438, 15.513, 15.588, 15.664, 15.739, 15.815, 15.890, 15.966, 16.041, 16.117, 16.193, 16.269, 16.344, 16.420, 16.496, 16.572, 16.648, 16.724, 16.800, 16.876, 16.952, 17.028, 17.104, 17.181, 17.257, 17.333, 17.409, 17.486, 17.562, 17.639, 17.715, 17.792, 17.868, 17.945, 18.021, 18.098, 18.175, 18.252, 18.328, 18.405, 18.482, 18.559, 18.636, 18.713, 18.790, 18.867, 18.944, 19.021, 19.098, 19.175, 19.252, 19.330, 19.407, 19.484, 19.561, 19.639, 19.716, 19.794, 19.871, 19.948, 20.026, 20.103, 20.181, 20.259, 20.336, 20.414, 20.492, 20.569, 20.647, 20.725, 20.803, 20.880, 20.958, 21.036, 21.114, 21.192, 21.270, 21.348, 21.426, 21.504, 21.582, 21.660, 21.739, 21.817, 21.895, 21.973, 22.051, 22.130, 22.208, 22.286, 22.365, 22.443, 22.522, 22.600, 22.678, 22.757, 22.835, 22.914, 22.993, 23.071, 23.150, 23.228, 23.307, 23.386, 23.464, 23.543, 23.622, 23.701, 23.780, 23.858, 23.937, 24.016, 24.095, 24.174, 24.253, 24.332, 24.411, 24.490, 24.569, 24.648, 24.727, 24.806, 24.885, 24.964, 25.044, 25.123, 25.202, 25.281, 25.360, 25.440, 25.519, 25.598, 25.678, 25.757, 25.836, 25.916, 25.995, 26.075, 26.154, 26.233, 26.313, 26.392, 26.472, 26.552, 26.631, 26.711, 26.790, 26.870, 26.950, 27.029, 27.109, 27.189, 27.268, 27.348, 27.428, 27.507, 27.587, 27.667, 27.747, 27.827, 27.907, 27.986, 28.066, 28.146, 28.226, 28.306, 28.386, 28.466, 28.546, 28.626, 28.706, 28.786, 28.866, 28.946, 29.026, 29.106, 29.186, 29.266, 29.346, 29.427, 29.507, 29.587, 29.667, 29.747, 29.827, 29.908, 29.988, 30.068, 30.148, 30.229, 30.309, 30.389, 30.470, 30.550, 30.630, 30.711, 30.791, 30.871, 30.952, 31.032, 31.112, 31.193, 31.273, 31.354, 31.434, 31.515, 31.595, 31.676, 31.756, 31.837, 31.917, 31.998, 32.078, 32.159, 32.239, 32.320, 32.400, 32.481, 32.562, 32.642, 32.723, 32.803, 32.884, 32.965, 33.045, 33.126, 33.207, 33.287, 33.368, 33.449, 33.529, 33.610, 33.691, 33.772, 33.852, 33.933, 34.014, 34.095, 34.175, 34.256, 34.337, 34.418, 34.498, 34.579, 34.660, 34.741, 34.822, 34.902, 34.983, 35.064, 35.145, 35.226, 35.307, 35.387, 35.468, 35.549, 35.630, 35.711, 35.792, 35.873, 35.954, 36.034, 36.115, 36.196, 36.277, 36.358, 36.439, 36.520, 36.601, 36.682, 36.763, 36.843, 36.924, 37.005, 37.086, 37.167, 37.248, 37.329, 37.410, 37.491, 37.572, 37.653, 37.734, 37.815, 37.896, 37.977, 38.058, 38.139, 38.220, 38.300, 38.381, 38.462, 38.543, 38.624, 38.705, 38.786, 38.867, 38.948, 39.029, 39.110, 39.191, 39.272, 39.353, 39.434, 39.515, 39.596, 39.677, 39.758, 39.839, 39.920, 40.001, 40.082, 40.163, 40.243, 40.324, 40.405, 40.486, 40.567, 40.648, 40.729, 40.810, 40.891, 40.972, 41.053, 41.134, 41.215, 41.296, 41.377, 41.457, 41.538, 41.619, 41.700, 41.781, 41.862, 41.943, 42.024, 42.105, 42.185, 42.266, 42.347, 42.428, 42.509, 42.590, 42.671, 42.751, 42.832, 42.913, 42.994, 43.075, 43.156, 43.236, 43.317, 43.398, 43.479, 43.560, 43.640, 43.721, 43.802, 43.883, 43.963, 44.044, 44.125, 44.206, 44.286, 44.367, 44.448, 44.529, 44.609, 44.690, 44.771, 44.851, 44.932, 45.013, 45.093, 45.174, 45.255, 45.335, 45.416, 45.497, 45.577, 45.658, 45.738, 45.819, 45.900, 45.980, 46.061, 46.141, 46.222, 46.302, 46.383, 46.463, 46.544, 46.624, 46.705, 46.785, 46.866, 46.946, 47.027, 47.107, 47.188, 47.268, 47.349, 47.429, 47.509, 47.590, 47.670, 47.751, 47.831, 47.911, 47.992, 48.072, 48.152, 48.233, 48.313, 48.393, 48.474, 48.554, 48.634, 48.715, 48.795, 48.875, 48.955, 49.035, 49.116, 49.196, 49.276, 49.356, 49.436, 49.517, 49.597, 49.677, 49.757, 49.837, 49.917, 49.997, 50.077, 50.157, 50.238, 50.318, 50.398, 50.478, 50.558, 50.638, 50.718, 50.798, 50.878, 50.958, 51.038, 51.118, 51.197, 51.277, 51.357, 51.437, 51.517, 51.597, 51.677, 51.757, 51.837, 51.916, 51.996, 52.076, 52.156, 52.236, 52.315, 52.395, 52.475, 52.555, 52.634, 52.714, 52.794, 52.873, 52.953, 53.033, 53.112, 53.192, 53.272, 53.351, 53.431, 53.510, 53.590, 53.670, 53.749, 53.829, 53.908, 53.988, 54.067, 54.147, 54.226, 54.306, 54.385, 54.465, 54.544, 54.624, 54.703, 54.782, 54.862, 54.941, 55.021, 55.100, 55.179, 55.259, 55.338, 55.417, 55.497, 55.576, 55.655, 55.734, 55.814, 55.893, 55.972, 56.051, 56.131, 56.210, 56.289, 56.368, 56.447, 56.526, 56.606, 56.685, 56.764, 56.843, 56.922, 57.001, 57.080, 57.159, 57.238, 57.317, 57.396, 57.475, 57.554, 57.633, 57.712, 57.791, 57.870, 57.949, 58.028, 58.107, 58.186, 58.265, 58.343, 58.422, 58.501, 58.580, 58.659, 58.738, 58.816, 58.895, 58.974, 59.053, 59.131, 59.210, 59.289, 59.367, 59.446, 59.525, 59.604, 59.682, 59.761, 59.839, 59.918, 59.997, 60.075, 60.154, 60.232, 60.311, 60.390, 60.468, 60.547, 60.625, 60.704, 60.782, 60.860, 60.939, 61.017, 61.096, 61.174, 61.253, 61.331, 61.409, 61.488, 61.566, 61.644, 61.723, 61.801, 61.879, 61.958, 62.036, 62.114, 62.192, 62.271, 62.349, 62.427, 62.505, 62.583, 62.662, 62.740, 62.818, 62.896, 62.974, 63.052, 63.130, 63.208, 63.286, 63.364, 63.442, 63.520, 63.598, 63.676, 63.754, 63.832, 63.910, 63.988, 64.066, 64.144, 64.222, 64.300, 64.377, 64.455, 64.533, 64.611, 64.689, 64.766, 64.844, 64.922, 65.000, 65.077, 65.155, 65.233, 65.310, 65.388, 65.465, 65.543, 65.621, 65.698, 65.776, 65.853, 65.931, 66.008, 66.086, 66.163, 66.241, 66.318, 66.396, 66.473, 66.550, 66.628, 66.705, 66.782, 66.860, 66.937, 67.014, 67.092, 67.169, 67.246, 67.323, 67.400, 67.478, 67.555, 67.632, 67.709, 67.786, 67.863, 67.940, 68.017, 68.094, 68.171, 68.248, 68.325, 68.402, 68.479, 68.556, 68.633, 68.710, 68.787, 68.863, 68.940, 69.017, 69.094, 69.171, 69.247, 69.324, 69.401, 69.477, 69.554, 69.631, 69.707, 69.784, 69.860, 69.937, 70.013, 70.090, 70.166, 70.243, 70.319, 70.396, 70.472, 70.548, 70.625, 70.701, 70.777, 70.854, 70.930, 71.006, 71.082, 71.159, 71.235, 71.311, 71.387, 71.463, 71.539, 71.615, 71.692, 71.768, 71.844, 71.920, 71.996, 72.072, 72.147, 72.223, 72.299, 72.375, 72.451, 72.527, 72.603, 72.678, 72.754, 72.830, 72.906, 72.981, 73.057, 73.133, 73.208, 73.284, 73.360, 73.435, 73.511, 73.586, 73.662, 73.738, 73.813, 73.889, 73.964, 74.040, 74.115, 74.190, 74.266, 74.341, 74.417, 74.492, 74.567, 74.643, 74.718, 74.793, 74.869, 74.944, 75.019, 75.095, 75.170, 75.245, 75.320, 75.395, 75.471, 75.546, 75.621, 75.696, 75.771, 75.847, 75.922, 75.997, 76.072, 76.147, 76.223, 76.298, 76.373];
	const thermocouple_table_t_type = [-6.258, -6.256, -6.255, -6.253, -6.251, -6.248, -6.245, -6.242, -6.239, -6.236, -6.232, -6.228, -6.223, -6.219, -6.214, -6.209, -6.204, -6.198, -6.193, -6.187, -6.180, -6.174, -6.167, -6.160, -6.153, -6.146, -6.138, -6.130, -6.122, -6.114, -6.105, -6.096, -6.087, -6.078, -6.068, -6.059, -6.049, -6.038, -6.028, -6.017, -6.007, -5.996, -5.985, -5.973, -5.962, -5.950, -5.938, -5.926, -5.914, -5.901, -5.888, -5.876, -5.863, -5.850, -5.836, -5.823, -5.809, -5.795, -5.782, -5.767, -5.753, -5.739, -5.724, -5.710, -5.695, -5.680, -5.665, -5.650, -5.634, -5.619, -5.603, -5.587, -5.571, -5.555, -5.539, -5.523, -5.506, -5.489, -5.473, -5.456, -5.439, -5.421, -5.404, -5.387, -5.369, -5.351, -5.334, -5.316, -5.297, -5.279, -5.261, -5.242, -5.224, -5.205, -5.186, -5.167, -5.148, -5.128, -5.109, -5.089, -5.070, -5.050, -5.030, -5.010, -4.989, -4.969, -4.949, -4.928, -4.907, -4.886, -4.865, -4.844, -4.823, -4.802, -4.780, -4.759, -4.737, -4.715, -4.693, -4.671, -4.648, -4.626, -4.604, -4.581, -4.558, -4.535, -4.512, -4.489, -4.466, -4.443, -4.419, -4.395, -4.372, -4.348, -4.324, -4.300, -4.275, -4.251, -4.226, -4.202, -4.177, -4.152, -4.127, -4.102, -4.077, -4.052, -4.026, -4.000, -3.975, -3.949, -3.923, -3.897, -3.871, -3.844, -3.818, -3.791, -3.765, -3.738, -3.711, -3.684, -3.657, -3.629, -3.602, -3.574, -3.547, -3.519, -3.491, -3.463, -3.435, -3.407, -3.379, -3.350, -3.322, -3.293, -3.264, -3.235, -3.206, -3.177, -3.148, -3.118, -3.089, -3.059, -3.030, -3.000, -2.970, -2.940, -2.910, -2.879, -2.849, -2.818, -2.788, -2.757, -2.726, -2.695, -2.664, -2.633, -2.602, -2.571, -2.539, -2.507, -2.476, -2.444, -2.412, -2.380, -2.348, -2.316, -2.283, -2.251, -2.218, -2.186, -2.153, -2.120, -2.087, -2.054, -2.021, -1.987, -1.954, -1.920, -1.887, -1.853, -1.819, -1.785, -1.751, -1.717, -1.683, -1.648, -1.614, -1.579, -1.545, -1.510, -1.475, -1.440, -1.405, -1.370, -1.335, -1.299, -1.264, -1.228, -1.192, -1.157, -1.121, -1.085, -1.049, -1.013, -0.976, -0.940, -0.904, -0.867, -0.830, -0.794, -0.757, -0.720, -0.683, -0.646, -0.608, -0.571, -0.534, -0.496, -0.459, -0.421, -0.383, -0.345, -0.307, -0.269, -0.231, -0.193, -0.154, -0.116, -0.077, -0.039, 0.000, 0.039, 0.078, 0.117, 0.156, 0.195, 0.234, 0.273, 0.312, 0.352, 0.391, 0.431, 0.470, 0.510, 0.549, 0.589, 0.629, 0.669, 0.709, 0.749, 0.790, 0.830, 0.870, 0.911, 0.951, 0.992, 1.033, 1.074, 1.114, 1.155, 1.196, 1.238, 1.279, 1.320, 1.362, 1.403, 1.445, 1.486, 1.528, 1.570, 1.612, 1.654, 1.696, 1.738, 1.780, 1.823, 1.865, 1.908, 1.950, 1.993, 2.036, 2.079, 2.122, 2.165, 2.208, 2.251, 2.294, 2.338, 2.381, 2.425, 2.468, 2.512, 2.556, 2.600, 2.643, 2.687, 2.732, 2.776, 2.820, 2.864, 2.909, 2.953, 2.998, 3.043, 3.087, 3.132, 3.177, 3.222, 3.267, 3.312, 3.358, 3.403, 3.448, 3.494, 3.539, 3.585, 3.631, 3.677, 3.722, 3.768, 3.814, 3.860, 3.907, 3.953, 3.999, 4.046, 4.092, 4.138, 4.185, 4.232, 4.279, 4.325, 4.372, 4.419, 4.466, 4.513, 4.561, 4.608, 4.655, 4.702, 4.750, 4.798, 4.845, 4.893, 4.941, 4.988, 5.036, 5.084, 5.132, 5.180, 5.228, 5.277, 5.325, 5.373, 5.422, 5.470, 5.519, 5.567, 5.616, 5.665, 5.714, 5.763, 5.812, 5.861, 5.910, 5.959, 6.008, 6.057, 6.107, 6.156, 6.206, 6.255, 6.305, 6.355, 6.404, 6.454, 6.504, 6.554, 6.604, 6.654, 6.704, 6.754, 6.805, 6.855, 6.905, 6.956, 7.006, 7.057, 7.107, 7.158, 7.209, 7.260, 7.310, 7.361, 7.412, 7.463, 7.515, 7.566, 7.617, 7.668, 7.720, 7.771, 7.823, 7.874, 7.926, 7.977, 8.029, 8.081, 8.133, 8.185, 8.237, 8.289, 8.341, 8.393, 8.445, 8.497, 8.550, 8.602, 8.654, 8.707, 8.759, 8.812, 8.865, 8.917, 8.970, 9.023, 9.076, 9.129, 9.182, 9.235, 9.288, 9.341, 9.395, 9.448, 9.501, 9.555, 9.608, 9.662, 9.715, 9.769, 9.822, 9.876, 9.930, 9.984, 10.038, 10.092, 10.146, 10.200, 10.254, 10.308, 10.362, 10.417, 10.471, 10.525, 10.580, 10.634, 10.689, 10.743, 10.798, 10.853, 10.907, 10.962, 11.017, 11.072, 11.127, 11.182, 11.237, 11.292, 11.347, 11.403, 11.458, 11.513, 11.569, 11.624, 11.680, 11.735, 11.791, 11.846, 11.902, 11.958, 12.013, 12.069, 12.125, 12.181, 12.237, 12.293, 12.349, 12.405, 12.461, 12.518, 12.574, 12.630, 12.687, 12.743, 12.799, 12.856, 12.912, 12.969, 13.026, 13.082, 13.139, 13.196, 13.253, 13.310, 13.366, 13.423, 13.480, 13.537, 13.595, 13.652, 13.709, 13.766, 13.823, 13.881, 13.938, 13.995, 14.053, 14.110, 14.168, 14.226, 14.283, 14.341, 14.399, 14.456, 14.514, 14.572, 14.630, 14.688, 14.746, 14.804, 14.862, 14.920, 14.978, 15.036, 15.095, 15.153, 15.211, 15.270, 15.328, 15.386, 15.445, 15.503, 15.562, 15.621, 15.679, 15.738, 15.797, 15.856, 15.914, 15.973, 16.032, 16.091, 16.150, 16.209, 16.268, 16.327, 16.387, 16.446, 16.505, 16.564, 16.624, 16.683, 16.742, 16.802, 16.861, 16.921, 16.980, 17.040, 17.100, 17.159, 17.219, 17.279, 17.339, 17.399, 17.458, 17.518, 17.578, 17.638, 17.698, 17.759, 17.819, 17.879, 17.939, 17.999, 18.060, 18.120, 18.180, 18.241, 18.301, 18.362, 18.422, 18.483, 18.543, 18.604, 18.665, 18.725, 18.786, 18.847, 18.908, 18.969, 19.030, 19.091, 19.152, 19.213, 19.274, 19.335, 19.396, 19.457, 19.518, 19.579, 19.641, 19.702, 19.763, 19.825, 19.886, 19.947, 20.009, 20.070, 20.132, 20.193, 20.255, 20.317, 20.378, 20.440, 20.502, 20.563, 20.625, 20.687, 20.748, 20.810, 20.872];
	const thermocouple_table_j_type = [-8.095, -8.076, -8.057, -8.037, -8.017, -7.996, -7.976, -7.955, -7.934, -7.912, -7.890, -7.868, -7.846, -7.824, -7.801, -7.778, -7.755, -7.731, -7.707, -7.683, -7.659, -7.634, -7.610, -7.585, -7.559, -7.534, -7.508, -7.482, -7.456, -7.429, -7.403, -7.376, -7.348, -7.321, -7.293, -7.265, -7.237, -7.209, -7.181, -7.152, -7.123, -7.094, -7.064, -7.035, -7.005, -6.975, -6.944, -6.914, -6.883, -6.853, -6.821, -6.790, -6.759, -6.727, -6.695, -6.663, -6.631, -6.598, -6.566, -6.533, -6.500, -6.467, -6.433, -6.400, -6.366, -6.332, -6.298, -6.263, -6.229, -6.194, -6.159, -6.124, -6.089, -6.054, -6.018, -5.982, -5.946, -5.910, -5.874, -5.838, -5.801, -5.764, -5.727, -5.690, -5.653, -5.616, -5.578, -5.541, -5.503, -5.465, -5.426, -5.388, -5.350, -5.311, -5.272, -5.233, -5.194, -5.155, -5.116, -5.076, -5.037, -4.997, -4.957, -4.917, -4.877, -4.836, -4.796, -4.755, -4.714, -4.674, -4.633, -4.591, -4.550, -4.509, -4.467, -4.425, -4.384, -4.342, -4.300, -4.257, -4.215, -4.173, -4.130, -4.088, -4.045, -4.002, -3.959, -3.916, -3.872, -3.829, -3.786, -3.742, -3.698, -3.654, -3.610, -3.566, -3.522, -3.478, -3.434, -3.389, -3.344, -3.300, -3.255, -3.210, -3.165, -3.120, -3.075, -3.029, -2.984, -2.938, -2.893, -2.847, -2.801, -2.755, -2.709, -2.663, -2.617, -2.571, -2.524, -2.478, -2.431, -2.385, -2.338, -2.291, -2.244, -2.197, -2.150, -2.103, -2.055, -2.008, -1.961, -1.913, -1.865, -1.818, -1.770, -1.722, -1.674, -1.626, -1.578, -1.530, -1.482, -1.433, -1.385, -1.336, -1.288, -1.239, -1.190, -1.142, -1.093, -1.044, -0.995, -0.946, -0.896, -0.847, -0.798, -0.749, -0.699, -0.650, -0.600, -0.550, -0.501, -0.451, -0.401, -0.351, -0.301, -0.251, -0.201, -0.151, -0.101, -0.050, 0.000, 0.050, 0.101, 0.151, 0.202, 0.253, 0.303, 0.354, 0.405, 0.456, 0.507, 0.558, 0.609, 0.660, 0.711, 0.762, 0.814, 0.865, 0.916, 0.968, 1.019, 1.071, 1.122, 1.174, 1.226, 1.277, 1.329, 1.381, 1.433, 1.485, 1.537, 1.589, 1.641, 1.693, 1.745, 1.797, 1.849, 1.902, 1.954, 2.006, 2.059, 2.111, 2.164, 2.216, 2.269, 2.322, 2.374, 2.427, 2.480, 2.532, 2.585, 2.638, 2.691, 2.744, 2.797, 2.850, 2.903, 2.956, 3.009, 3.062, 3.116, 3.169, 3.222, 3.275, 3.329, 3.382, 3.436, 3.489, 3.543, 3.596, 3.650, 3.703, 3.757, 3.810, 3.864, 3.918, 3.971, 4.025, 4.079, 4.133, 4.187, 4.240, 4.294, 4.348, 4.402, 4.456, 4.510, 4.564, 4.618, 4.672, 4.726, 4.781, 4.835, 4.889, 4.943, 4.997, 5.052, 5.106, 5.160, 5.215, 5.269, 5.323, 5.378, 5.432, 5.487, 5.541, 5.595, 5.650, 5.705, 5.759, 5.814, 5.868, 5.923, 5.977, 6.032, 6.087, 6.141, 6.196, 6.251, 6.306, 6.360, 6.415, 6.470, 6.525, 6.579, 6.634, 6.689, 6.744, 6.799, 6.854, 6.909, 6.964, 7.019, 7.074, 7.129, 7.184, 7.239, 7.294, 7.349, 7.404, 7.459, 7.514, 7.569, 7.624, 7.679, 7.734, 7.789, 7.844, 7.900, 7.955, 8.010, 8.065, 8.120, 8.175, 8.231, 8.286, 8.341, 8.396, 8.452, 8.507, 8.562, 8.618, 8.673, 8.728, 8.783, 8.839, 8.894, 8.949, 9.005, 9.060, 9.115, 9.171, 9.226, 9.282, 9.337, 9.392, 9.448, 9.503, 9.559, 9.614, 9.669, 9.725, 9.780, 9.836, 9.891, 9.947, 10.002, 10.057, 10.113, 10.168, 10.224, 10.279, 10.335, 10.390, 10.446, 10.501, 10.557, 10.612, 10.668, 10.723, 10.779, 10.834, 10.890, 10.945, 11.001, 11.056, 11.112, 11.167, 11.223, 11.278, 11.334, 11.389, 11.445, 11.501, 11.556, 11.612, 11.667, 11.723, 11.778, 11.834, 11.889, 11.945, 12.000, 12.056, 12.111, 12.167, 12.222, 12.278, 12.334, 12.389, 12.445, 12.500, 12.556, 12.611, 12.667, 12.722, 12.778, 12.833, 12.889, 12.944, 13.000, 13.056, 13.111, 13.167, 13.222, 13.278, 13.333, 13.389, 13.444, 13.500, 13.555, 13.611, 13.666, 13.722, 13.777, 13.833, 13.888, 13.944, 13.999, 14.055, 14.110, 14.166, 14.221, 14.277, 14.332, 14.388, 14.443, 14.499, 14.554, 14.609, 14.665, 14.720, 14.776, 14.831, 14.887, 14.942, 14.998, 15.053, 15.109, 15.164, 15.219, 15.275, 15.330, 15.386, 15.441, 15.496, 15.552, 15.607, 15.663, 15.718, 15.773, 15.829, 15.884, 15.940, 15.995, 16.050, 16.106, 16.161, 16.216, 16.272, 16.327, 16.383, 16.438, 16.493, 16.549, 16.604, 16.659, 16.715, 16.770, 16.825, 16.881, 16.936, 16.991, 17.046, 17.102, 17.157, 17.212, 17.268, 17.323, 17.378, 17.434, 17.489, 17.544, 17.599, 17.655, 17.710, 17.765, 17.820, 17.876, 17.931, 17.986, 18.041, 18.097, 18.152, 18.207, 18.262, 18.318, 18.373, 18.428, 18.483, 18.538, 18.594, 18.649, 18.704, 18.759, 18.814, 18.870, 18.925, 18.980, 19.035, 19.090, 19.146, 19.201, 19.256, 19.311, 19.366, 19.422, 19.477, 19.532, 19.587, 19.642, 19.697, 19.753, 19.808, 19.863, 19.918, 19.973, 20.028, 20.083, 20.139, 20.194, 20.249, 20.304, 20.359, 20.414, 20.469, 20.525, 20.580, 20.635, 20.690, 20.745, 20.800, 20.855, 20.911, 20.966, 21.021, 21.076, 21.131, 21.186, 21.241, 21.297, 21.352, 21.407, 21.462, 21.517, 21.572, 21.627, 21.683, 21.738, 21.793, 21.848, 21.903, 21.958, 22.014, 22.069, 22.124, 22.179, 22.234, 22.289, 22.345, 22.400, 22.455, 22.510, 22.565, 22.620, 22.676, 22.731, 22.786, 22.841, 22.896, 22.952, 23.007, 23.062, 23.117, 23.172, 23.228, 23.283, 23.338, 23.393, 23.449, 23.504, 23.559, 23.614, 23.670, 23.725, 23.780, 23.835, 23.891, 23.946, 24.001, 24.057, 24.112, 24.167, 24.223, 24.278, 24.333, 24.389, 24.444, 24.499, 24.555, 24.610, 24.665, 24.721, 24.776, 24.832, 24.887, 24.943, 24.998, 25.053, 25.109, 25.164, 25.220, 25.275, 25.331, 25.386, 25.442, 25.497, 25.553, 25.608, 25.664, 25.720, 25.775, 25.831, 25.886, 25.942, 25.998, 26.053, 26.109, 26.165, 26.220, 26.276, 26.332, 26.387, 26.443, 26.499, 26.555, 26.610, 26.666, 26.722, 26.778, 26.834, 26.889, 26.945, 27.001, 27.057, 27.113, 27.169, 27.225, 27.281, 27.337, 27.393, 27.449, 27.505, 27.561, 27.617, 27.673, 27.729, 27.785, 27.841, 27.897, 27.953, 28.010, 28.066, 28.122, 28.178, 28.234, 28.291, 28.347, 28.403, 28.460, 28.516, 28.572, 28.629, 28.685, 28.741, 28.798, 28.854, 28.911, 28.967, 29.024, 29.080, 29.137, 29.194, 29.250, 29.307, 29.363, 29.420, 29.477, 29.534, 29.590, 29.647, 29.704, 29.761, 29.818, 29.874, 29.931, 29.988, 30.045, 30.102, 30.159, 30.216, 30.273, 30.330, 30.387, 30.444, 30.502, 30.559, 30.616, 30.673, 30.730, 30.788, 30.845, 30.902, 30.960, 31.017, 31.074, 31.132, 31.189, 31.247, 31.304, 31.362, 31.419, 31.477, 31.535, 31.592, 31.650, 31.708, 31.766, 31.823, 31.881, 31.939, 31.997, 32.055, 32.113, 32.171, 32.229, 32.287, 32.345, 32.403, 32.461, 32.519, 32.577, 32.636, 32.694, 32.752, 32.810, 32.869, 32.927, 32.985, 33.044, 33.102, 33.161, 33.219, 33.278, 33.337, 33.395, 33.454, 33.513, 33.571, 33.630, 33.689, 33.748, 33.807, 33.866, 33.925, 33.984, 34.043, 34.102, 34.161, 34.220, 34.279, 34.338, 34.397, 34.457, 34.516, 34.575, 34.635, 34.694, 34.754, 34.813, 34.873, 34.932, 34.992, 35.051, 35.111, 35.171, 35.230, 35.290, 35.350, 35.410, 35.470, 35.530, 35.590, 35.650, 35.710, 35.770, 35.830, 35.890, 35.950, 36.010, 36.071, 36.131, 36.191, 36.252, 36.312, 36.373, 36.433, 36.494, 36.554, 36.615, 36.675, 36.736, 36.797, 36.858, 36.918, 36.979, 37.040, 37.101, 37.162, 37.223, 37.284, 37.345, 37.406, 37.467, 37.528, 37.590, 37.651, 37.712, 37.773, 37.835, 37.896, 37.958, 38.019, 38.081, 38.142, 38.204, 38.265, 38.327, 38.389, 38.450, 38.512, 38.574, 38.636, 38.698, 38.760, 38.822, 38.884, 38.946, 39.008, 39.070, 39.132, 39.194, 39.256, 39.318, 39.381, 39.443, 39.505, 39.568, 39.630, 39.693, 39.755, 39.818, 39.880, 39.943, 40.005, 40.068, 40.131, 40.193, 40.256, 40.319, 40.382, 40.445, 40.508, 40.570, 40.633, 40.696, 40.759, 40.822, 40.886, 40.949, 41.012, 41.075, 41.138, 41.201, 41.265, 41.328, 41.391, 41.455, 41.518, 41.581, 41.645, 41.708, 41.772, 41.835, 41.899, 41.962, 42.026, 42.090, 42.153, 42.217, 42.281, 42.344, 42.408, 42.472, 42.536, 42.599, 42.663, 42.727, 42.791, 42.855, 42.919, 42.983, 43.047, 43.111, 43.175, 43.239, 43.303, 43.367, 43.431, 43.495, 43.559, 43.624, 43.688, 43.752, 43.817, 43.881, 43.945, 44.010, 44.074, 44.139, 44.203, 44.267, 44.332, 44.396, 44.461, 44.525, 44.590, 44.655, 44.719, 44.784, 44.848, 44.913, 44.977, 45.042, 45.107, 45.171, 45.236, 45.301, 45.365, 45.430, 45.494, 45.559, 45.624, 45.688, 45.753, 45.818, 45.882, 45.947, 46.011, 46.076, 46.141, 46.205, 46.270, 46.334, 46.399, 46.464, 46.528, 46.593, 46.657, 46.722, 46.786, 46.851, 46.915, 46.980, 47.044, 47.109, 47.173, 47.238, 47.302, 47.367, 47.431, 47.495, 47.560, 47.624, 47.688, 47.753, 47.817, 47.881, 47.946, 48.010, 48.074, 48.138, 48.202, 48.267, 48.331, 48.395, 48.459, 48.523, 48.587, 48.651, 48.715, 48.779, 48.843, 48.907, 48.971, 49.034, 49.098, 49.162, 49.226, 49.290, 49.353, 49.417, 49.481, 49.544, 49.608, 49.672, 49.735, 49.799, 49.862, 49.926, 49.989, 50.052, 50.116, 50.179, 50.243, 50.306, 50.369, 50.432, 50.495, 50.559, 50.622, 50.685, 50.748, 50.811, 50.874, 50.937, 51.000, 51.063, 51.126, 51.188, 51.251, 51.314, 51.377, 51.439, 51.502, 51.565, 51.627, 51.690, 51.752, 51.815, 51.877, 51.940, 52.002, 52.064, 52.127, 52.189, 52.251, 52.314, 52.376, 52.438, 52.500, 52.562, 52.624, 52.686, 52.748, 52.810, 52.872, 52.934, 52.996, 53.057, 53.119, 53.181, 53.243, 53.304, 53.366, 53.427, 53.489, 53.550, 53.612, 53.673, 53.735, 53.796, 53.857, 53.919, 53.980, 54.041, 54.102, 54.164, 54.225, 54.286, 54.347, 54.408, 54.469, 54.530, 54.591, 54.652, 54.713, 54.773, 54.834, 54.895, 54.956, 55.016, 55.077, 55.138, 55.198, 55.259, 55.319, 55.380, 55.440, 55.501, 55.561, 55.622, 55.682, 55.742, 55.803, 55.863, 55.923, 55.983, 56.043, 56.104, 56.164, 56.224, 56.284, 56.344, 56.404, 56.464, 56.524, 56.584, 56.643, 56.703, 56.763, 56.823, 56.883, 56.942, 57.002, 57.062, 57.121, 57.181, 57.240, 57.300, 57.360, 57.419, 57.479, 57.538, 57.597, 57.657, 57.716, 57.776, 57.835, 57.894, 57.953, 58.013, 58.072, 58.131, 58.190, 58.249, 58.309, 58.368, 58.427, 58.486, 58.545, 58.604, 58.663, 58.722, 58.781, 58.840, 58.899, 58.957, 59.016, 59.075, 59.134, 59.193, 59.252, 59.310, 59.369, 59.428, 59.487, 59.545, 59.604, 59.663, 59.721, 59.780, 59.838, 59.897, 59.956, 60.014, 60.073, 60.131, 60.190, 60.248, 60.307, 60.365, 60.423, 60.482, 60.540, 60.599, 60.657, 60.715, 60.774, 60.832, 60.890, 60.949, 61.007, 61.065, 61.123, 61.182, 61.240, 61.298, 61.356, 61.415, 61.473, 61.531, 61.589, 61.647, 61.705, 61.763, 61.822, 61.880, 61.938, 61.996, 62.054, 62.112, 62.170, 62.228, 62.286, 62.344, 62.402, 62.460, 62.518, 62.576, 62.634, 62.692, 62.750, 62.808, 62.866, 62.924, 62.982, 63.040, 63.098, 63.156, 63.214, 63.271, 63.329, 63.387, 63.445, 63.503, 63.561, 63.619, 63.677, 63.734, 63.792, 63.850, 63.908, 63.966, 64.024, 64.081, 64.139, 64.197, 64.255, 64.313, 64.370, 64.428, 64.486, 64.544, 64.602, 64.659, 64.717, 64.775, 64.833, 64.890, 64.948, 65.006, 65.064, 65.121, 65.179, 65.237, 65.295, 65.352, 65.410, 65.468, 65.525, 65.583, 65.641, 65.699, 65.756, 65.814, 65.872, 65.929, 65.987, 66.045, 66.102, 66.160, 66.218, 66.275, 66.333, 66.391, 66.448, 66.506, 66.564, 66.621, 66.679, 66.737, 66.794, 66.852, 66.910, 66.967, 67.025, 67.082, 67.140, 67.198, 67.255, 67.313, 67.370, 67.428, 67.486, 67.543, 67.601, 67.658, 67.716, 67.773, 67.831, 67.888, 67.946, 68.003, 68.061, 68.119, 68.176, 68.234, 68.291, 68.348, 68.406, 68.463, 68.521, 68.578, 68.636, 68.693, 68.751, 68.808, 68.865, 68.923, 68.980, 69.037, 69.095, 69.152, 69.209, 69.267, 69.324, 69.381, 69.439, 69.496, 69.553];
	const thermocouple_table_k_type = [-6.458, -6.457, -6.456, -6.455, -6.453, -6.452, -6.450, -6.448, -6.446, -6.444, -6.441, -6.438, -6.435, -6.432, -6.429, -6.425, -6.421, -6.417, -6.413, -6.408, -6.404, -6.399, -6.393, -6.388, -6.382, -6.377, -6.370, -6.364, -6.358, -6.351, -6.344, -6.337, -6.329, -6.322, -6.314, -6.306, -6.297, -6.289, -6.280, -6.271, -6.262, -6.252, -6.243, -6.233, -6.223, -6.213, -6.202, -6.192, -6.181, -6.170, -6.158, -6.147, -6.135, -6.123, -6.111, -6.099, -6.087, -6.074, -6.061, -6.048, -6.035, -6.021, -6.007, -5.994, -5.980, -5.965, -5.951, -5.936, -5.922, -5.907, -5.891, -5.876, -5.861, -5.845, -5.829, -5.813, -5.797, -5.780, -5.763, -5.747, -5.730, -5.713, -5.695, -5.678, -5.660, -5.642, -5.624, -5.606, -5.588, -5.569, -5.550, -5.531, -5.512, -5.493, -5.474, -5.454, -5.435, -5.415, -5.395, -5.374, -5.354, -5.333, -5.313, -5.292, -5.271, -5.250, -5.228, -5.207, -5.185, -5.163, -5.141, -5.119, -5.097, -5.074, -5.052, -5.029, -5.006, -4.983, -4.960, -4.936, -4.913, -4.889, -4.865, -4.841, -4.817, -4.793, -4.768, -4.744, -4.719, -4.694, -4.669, -4.644, -4.618, -4.593, -4.567, -4.542, -4.516, -4.490, -4.463, -4.437, -4.411, -4.384, -4.357, -4.330, -4.303, -4.276, -4.249, -4.221, -4.194, -4.166, -4.138, -4.110, -4.082, -4.054, -4.025, -3.997, -3.968, -3.939, -3.911, -3.882, -3.852, -3.823, -3.794, -3.764, -3.734, -3.705, -3.675, -3.645, -3.614, -3.584, -3.554, -3.523, -3.492, -3.462, -3.431, -3.400, -3.368, -3.337, -3.306, -3.274, -3.243, -3.211, -3.179, -3.147, -3.115, -3.083, -3.050, -3.018, -2.986, -2.953, -2.920, -2.887, -2.854, -2.821, -2.788, -2.755, -2.721, -2.688, -2.654, -2.620, -2.587, -2.553, -2.519, -2.485, -2.450, -2.416, -2.382, -2.347, -2.312, -2.278, -2.243, -2.208, -2.173, -2.138, -2.103, -2.067, -2.032, -1.996, -1.961, -1.925, -1.889, -1.854, -1.818, -1.782, -1.745, -1.709, -1.673, -1.637, -1.600, -1.564, -1.527, -1.490, -1.453, -1.417, -1.380, -1.343, -1.305, -1.268, -1.231, -1.194, -1.156, -1.119, -1.081, -1.043, -1.006, -0.968, -0.930, -0.892, -0.854, -0.816, -0.778, -0.739, -0.701, -0.663, -0.624, -0.586, -0.547, -0.508, -0.470, -0.431, -0.392, -0.353, -0.314, -0.275, -0.236, -0.197, -0.157, -0.118, -0.079, -0.039, 0.000, 0.039, 0.079, 0.119, 0.158, 0.198, 0.238, 0.277, 0.317, 0.357, 0.397, 0.437, 0.477, 0.517, 0.557, 0.597, 0.637, 0.677, 0.718, 0.758, 0.798, 0.838, 0.879, 0.919, 0.960, 1.000, 1.041, 1.081, 1.122, 1.163, 1.203, 1.244, 1.285, 1.326, 1.366, 1.407, 1.448, 1.489, 1.530, 1.571, 1.612, 1.653, 1.694, 1.735, 1.776, 1.817, 1.858, 1.899, 1.941, 1.982, 2.023, 2.064, 2.106, 2.147, 2.188, 2.230, 2.271, 2.312, 2.354, 2.395, 2.436, 2.478, 2.519, 2.561, 2.602, 2.644, 2.685, 2.727, 2.768, 2.810, 2.851, 2.893, 2.934, 2.976, 3.017, 3.059, 3.100, 3.142, 3.184, 3.225, 3.267, 3.308, 3.350, 3.391, 3.433, 3.474, 3.516, 3.557, 3.599, 3.640, 3.682, 3.723, 3.765, 3.806, 3.848, 3.889, 3.931, 3.972, 4.013, 4.055, 4.096, 4.138, 4.179, 4.220, 4.262, 4.303, 4.344, 4.385, 4.427, 4.468, 4.509, 4.550, 4.591, 4.633, 4.674, 4.715, 4.756, 4.797, 4.838, 4.879, 4.920, 4.961, 5.002, 5.043, 5.084, 5.124, 5.165, 5.206, 5.247, 5.288, 5.328, 5.369, 5.410, 5.450, 5.491, 5.532, 5.572, 5.613, 5.653, 5.694, 5.735, 5.775, 5.815, 5.856, 5.896, 5.937, 5.977, 6.017, 6.058, 6.098, 6.138, 6.179, 6.219, 6.259, 6.299, 6.339, 6.380, 6.420, 6.460, 6.500, 6.540, 6.580, 6.620, 6.660, 6.701, 6.741, 6.781, 6.821, 6.861, 6.901, 6.941, 6.981, 7.021, 7.060, 7.100, 7.140, 7.180, 7.220, 7.260, 7.300, 7.340, 7.380, 7.420, 7.460, 7.500, 7.540, 7.579, 7.619, 7.659, 7.699, 7.739, 7.779, 7.819, 7.859, 7.899, 7.939, 7.979, 8.019, 8.059, 8.099, 8.138, 8.178, 8.218, 8.258, 8.298, 8.338, 8.378, 8.418, 8.458, 8.499, 8.539, 8.579, 8.619, 8.659, 8.699, 8.739, 8.779, 8.819, 8.860, 8.900, 8.940, 8.980, 9.020, 9.061, 9.101, 9.141, 9.181, 9.222, 9.262, 9.302, 9.343, 9.383, 9.423, 9.464, 9.504, 9.545, 9.585, 9.626, 9.666, 9.707, 9.747, 9.788, 9.828, 9.869, 9.909, 9.950, 9.991, 10.031, 10.072, 10.113, 10.153, 10.194, 10.235, 10.276, 10.316, 10.357, 10.398, 10.439, 10.480, 10.520, 10.561, 10.602, 10.643, 10.684, 10.725, 10.766, 10.807, 10.848, 10.889, 10.930, 10.971, 11.012, 11.053, 11.094, 11.135, 11.176, 11.217, 11.259, 11.300, 11.341, 11.382, 11.423, 11.465, 11.506, 11.547, 11.588, 11.630, 11.671, 11.712, 11.753, 11.795, 11.836, 11.877, 11.919, 11.960, 12.001, 12.043, 12.084, 12.126, 12.167, 12.209, 12.250, 12.291, 12.333, 12.374, 12.416, 12.457, 12.499, 12.540, 12.582, 12.624, 12.665, 12.707, 12.748, 12.790, 12.831, 12.873, 12.915, 12.956, 12.998, 13.040, 13.081, 13.123, 13.165, 13.206, 13.248, 13.290, 13.331, 13.373, 13.415, 13.457, 13.498, 13.540, 13.582, 13.624, 13.665, 13.707, 13.749, 13.791, 13.833, 13.874, 13.916, 13.958, 14.000, 14.042, 14.084, 14.126, 14.167, 14.209, 14.251, 14.293, 14.335, 14.377, 14.419, 14.461, 14.503, 14.545, 14.587, 14.629, 14.671, 14.713, 14.755, 14.797, 14.839, 14.881, 14.923, 14.965, 15.007, 15.049, 15.091, 15.133, 15.175, 15.217, 15.259, 15.301, 15.343, 15.385, 15.427, 15.469, 15.511, 15.554, 15.596, 15.638, 15.680, 15.722, 15.764, 15.806, 15.849, 15.891, 15.933, 15.975, 16.017, 16.059, 16.102, 16.144, 16.186, 16.228, 16.270, 16.313, 16.355, 16.397, 16.439, 16.482, 16.524, 16.566, 16.608, 16.651, 16.693, 16.735, 16.778, 16.820, 16.862, 16.904, 16.947, 16.989, 17.031, 17.074, 17.116, 17.158, 17.201, 17.243, 17.285, 17.328, 17.370, 17.413, 17.455, 17.497, 17.540, 17.582, 17.624, 17.667, 17.709, 17.752, 17.794, 17.837, 17.879, 17.921, 17.964, 18.006, 18.049, 18.091, 18.134, 18.176, 18.218, 18.261, 18.303, 18.346, 18.388, 18.431, 18.473, 18.516, 18.558, 18.601, 18.643, 18.686, 18.728, 18.771, 18.813, 18.856, 18.898, 18.941, 18.983, 19.026, 19.068, 19.111, 19.154, 19.196, 19.239, 19.281, 19.324, 19.366, 19.409, 19.451, 19.494, 19.537, 19.579, 19.622, 19.664, 19.707, 19.750, 19.792, 19.835, 19.877, 19.920, 19.962, 20.005, 20.048, 20.090, 20.133, 20.175, 20.218, 20.261, 20.303, 20.346, 20.389, 20.431, 20.474, 20.516, 20.559, 20.602, 20.644, 20.687, 20.730, 20.772, 20.815, 20.857, 20.900, 20.943, 20.985, 21.028, 21.071, 21.113, 21.156, 21.199, 21.241, 21.284, 21.326, 21.369, 21.412, 21.454, 21.497, 21.540, 21.582, 21.625, 21.668, 21.710, 21.753, 21.796, 21.838, 21.881, 21.924, 21.966, 22.009, 22.052, 22.094, 22.137, 22.179, 22.222, 22.265, 22.307, 22.350, 22.393, 22.435, 22.478, 22.521, 22.563, 22.606, 22.649, 22.691, 22.734, 22.776, 22.819, 22.862, 22.904, 22.947, 22.990, 23.032, 23.075, 23.117, 23.160, 23.203, 23.245, 23.288, 23.331, 23.373, 23.416, 23.458, 23.501, 23.544, 23.586, 23.629, 23.671, 23.714, 23.757, 23.799, 23.842, 23.884, 23.927, 23.970, 24.012, 24.055, 24.097, 24.140, 24.182, 24.225, 24.267, 24.310, 24.353, 24.395, 24.438, 24.480, 24.523, 24.565, 24.608, 24.650, 24.693, 24.735, 24.778, 24.820, 24.863, 24.905, 24.948, 24.990, 25.033, 25.075, 25.118, 25.160, 25.203, 25.245, 25.288, 25.330, 25.373, 25.415, 25.458, 25.500, 25.543, 25.585, 25.627, 25.670, 25.712, 25.755, 25.797, 25.840, 25.882, 25.924, 25.967, 26.009, 26.052, 26.094, 26.136, 26.179, 26.221, 26.263, 26.306, 26.348, 26.390, 26.433, 26.475, 26.517, 26.560, 26.602, 26.644, 26.687, 26.729, 26.771, 26.814, 26.856, 26.898, 26.940, 26.983, 27.025, 27.067, 27.109, 27.152, 27.194, 27.236, 27.278, 27.320, 27.363, 27.405, 27.447, 27.489, 27.531, 27.574, 27.616, 27.658, 27.700, 27.742, 27.784, 27.826, 27.869, 27.911, 27.953, 27.995, 28.037, 28.079, 28.121, 28.163, 28.205, 28.247, 28.289, 28.332, 28.374, 28.416, 28.458, 28.500, 28.542, 28.584, 28.626, 28.668, 28.710, 28.752, 28.794, 28.835, 28.877, 28.919, 28.961, 29.003, 29.045, 29.087, 29.129, 29.171, 29.213, 29.255, 29.297, 29.338, 29.380, 29.422, 29.464, 29.506, 29.548, 29.589, 29.631, 29.673, 29.715, 29.757, 29.798, 29.840, 29.882, 29.924, 29.965, 30.007, 30.049, 30.090, 30.132, 30.174, 30.216, 30.257, 30.299, 30.341, 30.382, 30.424, 30.466, 30.507, 30.549, 30.590, 30.632, 30.674, 30.715, 30.757, 30.798, 30.840, 30.881, 30.923, 30.964, 31.006, 31.047, 31.089, 31.130, 31.172, 31.213, 31.255, 31.296, 31.338, 31.379, 31.421, 31.462, 31.504, 31.545, 31.586, 31.628, 31.669, 31.710, 31.752, 31.793, 31.834, 31.876, 31.917, 31.958, 32.000, 32.041, 32.082, 32.124, 32.165, 32.206, 32.247, 32.289, 32.330, 32.371, 32.412, 32.453, 32.495, 32.536, 32.577, 32.618, 32.659, 32.700, 32.742, 32.783, 32.824, 32.865, 32.906, 32.947, 32.988, 33.029, 33.070, 33.111, 33.152, 33.193, 33.234, 33.275, 33.316, 33.357, 33.398, 33.439, 33.480, 33.521, 33.562, 33.603, 33.644, 33.685, 33.726, 33.767, 33.808, 33.848, 33.889, 33.930, 33.971, 34.012, 34.053, 34.093, 34.134, 34.175, 34.216, 34.257, 34.297, 34.338, 34.379, 34.420, 34.460, 34.501, 34.542, 34.582, 34.623, 34.664, 34.704, 34.745, 34.786, 34.826, 34.867, 34.908, 34.948, 34.989, 35.029, 35.070, 35.110, 35.151, 35.192, 35.232, 35.273, 35.313, 35.354, 35.394, 35.435, 35.475, 35.516, 35.556, 35.596, 35.637, 35.677, 35.718, 35.758, 35.798, 35.839, 35.879, 35.920, 35.960, 36.000, 36.041, 36.081, 36.121, 36.162, 36.202, 36.242, 36.282, 36.323, 36.363, 36.403, 36.443, 36.484, 36.524, 36.564, 36.604, 36.644, 36.685, 36.725, 36.765, 36.805, 36.845, 36.885, 36.925, 36.965, 37.006, 37.046, 37.086, 37.126, 37.166, 37.206, 37.246, 37.286, 37.326, 37.366, 37.406, 37.446, 37.486, 37.526, 37.566, 37.606, 37.646, 37.686, 37.725, 37.765, 37.805, 37.845, 37.885, 37.925, 37.965, 38.005, 38.044, 38.084, 38.124, 38.164, 38.204, 38.243, 38.283, 38.323, 38.363, 38.402, 38.442, 38.482, 38.522, 38.561, 38.601, 38.641, 38.680, 38.720, 38.760, 38.799, 38.839, 38.878, 38.918, 38.958, 38.997, 39.037, 39.076, 39.116, 39.155, 39.195, 39.235, 39.274, 39.314, 39.353, 39.393, 39.432, 39.471, 39.511, 39.550, 39.590, 39.629, 39.669, 39.708, 39.747, 39.787, 39.826, 39.866, 39.905, 39.944, 39.984, 40.023, 40.062, 40.101, 40.141, 40.180, 40.219, 40.259, 40.298, 40.337, 40.376, 40.415, 40.455, 40.494, 40.533, 40.572, 40.611, 40.651, 40.690, 40.729, 40.768, 40.807, 40.846, 40.885, 40.924, 40.963, 41.002, 41.042, 41.081, 41.120, 41.159, 41.198, 41.237, 41.276, 41.315, 41.354, 41.393, 41.431, 41.470, 41.509, 41.548, 41.587, 41.626, 41.665, 41.704, 41.743, 41.781, 41.820, 41.859, 41.898, 41.937, 41.976, 42.014, 42.053, 42.092, 42.131, 42.169, 42.208, 42.247, 42.286, 42.324, 42.363, 42.402, 42.440, 42.479, 42.518, 42.556, 42.595, 42.633, 42.672, 42.711, 42.749, 42.788, 42.826, 42.865, 42.903, 42.942, 42.980, 43.019, 43.057, 43.096, 43.134, 43.173, 43.211, 43.250, 43.288, 43.327, 43.365, 43.403, 43.442, 43.480, 43.518, 43.557, 43.595, 43.633, 43.672, 43.710, 43.748, 43.787, 43.825, 43.863, 43.901, 43.940, 43.978, 44.016, 44.054, 44.092, 44.130, 44.169, 44.207, 44.245, 44.283, 44.321, 44.359, 44.397, 44.435, 44.473, 44.512, 44.550, 44.588, 44.626, 44.664, 44.702, 44.740, 44.778, 44.816, 44.853, 44.891, 44.929, 44.967, 45.005, 45.043, 45.081, 45.119, 45.157, 45.194, 45.232, 45.270, 45.308, 45.346, 45.383, 45.421, 45.459, 45.497, 45.534, 45.572, 45.610, 45.647, 45.685, 45.723, 45.760, 45.798, 45.836, 45.873, 45.911, 45.948, 45.986, 46.024, 46.061, 46.099, 46.136, 46.174, 46.211, 46.249, 46.286, 46.324, 46.361, 46.398, 46.436, 46.473, 46.511, 46.548, 46.585, 46.623, 46.660, 46.697, 46.735, 46.772, 46.809, 46.847, 46.884, 46.921, 46.958, 46.995, 47.033, 47.070, 47.107, 47.144, 47.181, 47.218, 47.256, 47.293, 47.330, 47.367, 47.404, 47.441, 47.478, 47.515, 47.552, 47.589, 47.626, 47.663, 47.700, 47.737, 47.774, 47.811, 47.848, 47.884, 47.921, 47.958, 47.995, 48.032, 48.069, 48.105, 48.142, 48.179, 48.216, 48.252, 48.289, 48.326, 48.363, 48.399, 48.436, 48.473, 48.509, 48.546, 48.582, 48.619, 48.656, 48.692, 48.729, 48.765, 48.802, 48.838, 48.875, 48.911, 48.948, 48.984, 49.021, 49.057, 49.093, 49.130, 49.166, 49.202, 49.239, 49.275, 49.311, 49.348, 49.384, 49.420, 49.456, 49.493, 49.529, 49.565, 49.601, 49.637, 49.674, 49.710, 49.746, 49.782, 49.818, 49.854, 49.890, 49.926, 49.962, 49.998, 50.034, 50.070, 50.106, 50.142, 50.178, 50.214, 50.250, 50.286, 50.322, 50.358, 50.393, 50.429, 50.465, 50.501, 50.537, 50.572, 50.608, 50.644, 50.680, 50.715, 50.751, 50.787, 50.822, 50.858, 50.894, 50.929, 50.965, 51.000, 51.036, 51.071, 51.107, 51.142, 51.178, 51.213, 51.249, 51.284, 51.320, 51.355, 51.391, 51.426, 51.461, 51.497, 51.532, 51.567, 51.603, 51.638, 51.673, 51.708, 51.744, 51.779, 51.814, 51.849, 51.885, 51.920, 51.955, 51.990, 52.025, 52.060, 52.095, 52.130, 52.165, 52.200, 52.235, 52.270, 52.305, 52.340, 52.375, 52.410, 52.445, 52.480, 52.515, 52.550, 52.585, 52.620, 52.654, 52.689, 52.724, 52.759, 52.794, 52.828, 52.863, 52.898, 52.932, 52.967, 53.002, 53.037, 53.071, 53.106, 53.140, 53.175, 53.210, 53.244, 53.279, 53.313, 53.348, 53.382, 53.417, 53.451, 53.486, 53.520, 53.555, 53.589, 53.623, 53.658, 53.692, 53.727, 53.761, 53.795, 53.830, 53.864, 53.898, 53.932, 53.967, 54.001, 54.035, 54.069, 54.104, 54.138, 54.172, 54.206, 54.240, 54.274, 54.308, 54.343, 54.377, 54.411, 54.445, 54.479, 54.513, 54.547, 54.581, 54.615, 54.649, 54.683, 54.717, 54.751, 54.785, 54.819, 54.852, 54.886];

	class AccelerometerDevice extends PhidgetUSBDevice {
	  constructor(conn, data, usbDev) {
	    super(conn, data, usbDev);

	    switch (this.devDef.uid) {
	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }

	  get numAccelAxes() {
	    return this.devDef.cn[0];
	  }

	  initData() {
	    const data = {
	      timestamp: [0],
	      acceleration: [new Array(this.numAccelAxes).fill(1e+300)],
	      accelerationChangeTrigger: new Array(this.numAccelAxes).fill(1e+300),
	      accelerationMax: 0,
	      accelerationMin: 0,
	      interruptRate: 0,
	      accelDataInterval: [0, 0, 0],
	      accelDeadLine: [0, 0, 0],
	      dataBuffer: [],
	      callcnt: 0,
	      accelerationLastTrigger: new Array(this.numAccelAxes).fill(1e+300)
	    };
	    return data;
	  }

	  async initAfterOpen() {
	    this.data = this.initData();
	    this.data.accelerationMax = 1e+300;
	    this.data.accelerationMin = 1e+300;
	    this.data.interruptRate = 4294967295;
	  }

	  async bridgeInput(ch, bp) {
	    const buf = new DataView(new ArrayBuffer(25));

	    switch (this.devDef.uid) {
	      case 156:
	        switch (ch.chDef.uid) {
	          case 311:
	            switch (bp.vpkt) {
	              case 54:
	                buf.setUint16(0, this._handleDataIntervalPacket(bp, 1));
	                await this.transferPacket(0, 252, ch.uniqueIndex, new Uint8Array(buf.buffer, 0, 2));
	                return;

	              case 46:
	                buf.setFloat32(0, bp.getNumber(0), true);
	                await this.transferPacket(0, 195, ch.uniqueIndex, new Uint8Array(buf.buffer, 0, 4));
	                return;

	              case 34:
	              case 111:
	                await this.transferPacket(0, 250, ch.uniqueIndex);
	                return;

	              case 143:
	                await this.transferPacket(0, 251, ch.uniqueIndex);
	                return;

	              default:
	                throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	            }

	          default:
	            throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	    }
	  }

	  dataInput(buffer) {
	    const axis = new Array(this.numAccelAxes).fill(0);
	    let channel;
	    let timestamp;
	    let dataIndex;

	    switch (this.devDef.uid) {
	      case 156:
	        dataIndex = 0;
	        timestamp = buffer.getUint32(0);
	        dataIndex += 4;

	        for (let i = 0; i < this.numAccelAxes; i++) {
	          axis[i] = buffer.getFloat32(dataIndex + i * 4, true);
	          if (!isNaN(axis[i])) axis[i] = RoundDouble(axis[i], 6);
	        }

	        dataIndex += 12;

	        if ((channel = this.getChannel(0)) !== null) {
	          switch (channel.chDef.uid) {
	            case 311:
	              {
	                if (buffer.byteLength > dataIndex) {
	                  if (buffer.getUint8(dataIndex) & 0x01) {
	                    const bp = new BridgePacket();
	                    bp.set({
	                      name: "0",
	                      type: "d",
	                      value: exports.ErrorEventCode.OUT_OF_RANGE
	                    });
	                    bp.set({
	                      name: "1",
	                      type: "s",
	                      value: "One or more accelerometer readings is out of range."
	                    });
	                    channel.sendErrorEvent(bp);
	                  }
	                }

	                const bp = new BridgePacket();
	                bp.set({
	                  name: "0",
	                  type: "G",
	                  value: axis
	                });
	                bp.set({
	                  name: "1",
	                  type: "g",
	                  value: timestamp
	                });
	                bp.sendToChannel(channel, 1);
	              }
	              break;

	            default:
	              throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	          }
	        }

	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	    }
	  }

	}

	const UNKNOWN_USB_ID = 175;
	async function CreateUSBDevice(conn, usbDevice) {
	  try {
	    await usbDevice.open();
	    const devData = await GetPhidgetUSBData(usbDevice);
	    const find = Object.assign({
	      type: 'USB'
	    }, devData);
	    let devDef;

	    try {
	      devDef = findPhidgetUniqueDevice(find);
	    } catch (err) {
	      logwarn("A USB Phidget (PID: " + find.productID + " Version: " + find.version + ") was found which is not " + "supported by the library. A library upgrade is required to work with this Phidget");
	      find.productID = UNKNOWN_USB_ID;
	      devDef = findPhidgetUniqueDevice(find);
	    }

	    const data = Object.assign(Object.assign({}, devData), {
	      type: 'OTHER',
	      id: devDef.uid + "_" + devData.serialNumber + "_v" + devData.version,
	      devDef: devDef
	    });
	    let phidgetDevice;

	    try {
	      switch (devDef.c) {
	        case exports.DeviceClass.ACCELEROMETER:
	          phidgetDevice = new AccelerometerDevice(conn, data, usbDevice);
	          break;

	        case exports.DeviceClass.BRIDGE:
	          phidgetDevice = new BridgeDevice(conn, data, usbDevice);
	          break;

	        case exports.DeviceClass.DATA_ADAPTER:
	          phidgetDevice = new DataAdapterDevice(conn, data, usbDevice);
	          break;

	        case exports.DeviceClass.ENCODER:
	          phidgetDevice = new EncoderDevice(conn, data, usbDevice);
	          break;

	        case exports.DeviceClass.GENERIC:
	          phidgetDevice = new GenericDevice(conn, data, usbDevice);
	          break;

	        case exports.DeviceClass.HUB:
	          phidgetDevice = new HubDevice(conn, data, usbDevice);
	          break;

	        case exports.DeviceClass.INTERFACE_KIT:
	          phidgetDevice = new InterfaceKitDevice(conn, data, usbDevice);
	          break;

	        case exports.DeviceClass.RFID:
	          phidgetDevice = new RFIDDevice(conn, data, usbDevice);
	          break;

	        case exports.DeviceClass.SPATIAL:
	          phidgetDevice = new SpatialDevice(conn, data, usbDevice);
	          break;

	        case exports.DeviceClass.TEMPERATURE_SENSOR:
	          phidgetDevice = new TemperatureSensorDevice(conn, data, usbDevice);
	          break;

	        default:
	          throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	      }
	    } catch (err) {
	      if (err instanceof PhidgetError && err.errorCode === exports.ErrorCode.UNSUPPORTED) throw new PhidgetError(exports.ErrorCode.UNSUPPORTED, "This USB Phidget is not yet supported in JavaScript: " + devDef.s + " (" + devDef.t + ")");
	      throw err;
	    }

	    if (phidgetDevice.initAfterCreate) await phidgetDevice.initAfterCreate();
	    await usbDevice.close();
	    return phidgetDevice;
	  } finally {
	    try {
	      await usbDevice.close();
	    } catch (_a) {}
	  }
	}

	let USBConnectionCnt = 0;
	class USBConnectionBase extends PhidgetConnection {
	  /** @internal */
	  constructor(webusb, usbtype, opts) {
	    if (USBConnectionCnt >= 1) throw new PhidgetError(exports.ErrorCode.DUPLICATE, "Only one USB Connection may be active at a time.");
	    USBConnectionCnt++;
	    const options = {};

	    if (opts != undefined) {
	      if (opts.onError) options.onError = opts.onError;
	      if (opts.name) options.name = opts.name;else options.name = 'webusb';
	    }

	    super(options);
	    this._type = 0;
	    this._usbType = usbtype;
	    this._webusb = webusb;
	    this._nextScanDelay = 0;
	  }

	  delete() {
	    super.delete();
	    USBConnectionCnt--;
	  }

	  close() {
	    if (this.connected !== true) return;
	    if (this._boundondisconnect) this._webusb.removeEventListener('disconnect', this._boundondisconnect);
	    delete this._boundondisconnect;

	    if (this._scanTimeout != undefined) {
	      clearTimeout(this._scanTimeout);
	      delete this._scanTimeout;
	    }

	    this._detachAllDevices();

	    this.connected = false;
	  }

	  async connect() {
	    if (this.connected === true) return;
	    this.connected = true;
	    this._boundondisconnect = this._ondisconnect.bind(this);

	    this._webusb.addEventListener('disconnect', this._boundondisconnect);

	    this.connected === true;

	    const again = () => {
	      if (this.connected) {
	        logverbose('Next scan in: ' + (250 + this._nextScanDelay));
	        this._scanTimeout = setTimeout(scan, 250 + this._nextScanDelay);
	      }
	    };

	    const scan = () => {
	      delete this._scanTimeout;

	      this._scanWebUSBDevices().then(() => {
	        again();
	      }).catch(err => {
	        logerr("Error during USB scan", err);
	        this._nextScanDelay = Math.random() * 100;
	        again();
	      });
	    };

	    scan();
	  }
	  /** @internal */


	  _getDevice(phid) {
	    return super._getDevice(phid);
	  }
	  /** @internal */


	  async _scanWebUSBDevices() {
	    if (!this.connected) throw new PhidgetError(exports.ErrorCode.NOT_ATTACHED, "Not connected");
	    let usbDevices = await this._webusb.getDevices();
	    usbDevices = usbDevices.filter(device => {
	      var _a;

	      return device.vendorId === USBVID_PHIDGETS && ((_a = device.configuration) === null || _a === void 0 ? void 0 : _a.interfaces[0].alternate.interfaceClass) === 0xFF;
	    });
	    this._nextScanDelay = 0;
	    await promise.all(usbDevices.map(async usbDevice => {
	      const isNewDevice = this._trackUSBDevice(usbDevice);

	      let dev = this._getPUSBDevice(usbDevice);

	      if (dev == undefined) {
	        try {
	          dev = await CreateUSBDevice(this, usbDevice);

	          this._addPUSBDevice(dev);

	          this._attachLocalDevice(dev);
	        } catch (err) {
	          (isNewDevice ? logwarn : logverbose)("Error scanning device", err);
	          this._nextScanDelay = Math.random() * 100;
	          return;
	        }
	      }

	      if (dev instanceof HubDevice) {
	        try {
	          await dev.lock();
	          let opened = false;

	          try {
	            await dev.open(false);
	            opened = true;
	            await dev.scanVINTDevices();
	          } finally {
	            if (opened) await dev.close(false);
	          }

	          dev.scanError = 0;
	        } catch (err) {
	          (dev.scanError == 0 ? logwarn : logverbose)("Error scanning device", err);
	          dev.scanError++;
	          this._nextScanDelay = Math.random() * 100;
	          return;
	        } finally {
	          dev.unlock();
	        }
	      }
	    }));
	  }
	  /** @internal */


	  _ondisconnect(event) {
	    var _context, _context2;

	    var _a;

	    if (event.device.vendorId !== USBVID_PHIDGETS || ((_a = event.device.configuration) === null || _a === void 0 ? void 0 : _a.interfaces[0].alternate.interfaceClass) !== 0xFF) return;
	    logdebug("USB Device disconnect: " + event.device.productName);

	    this._untrackUSBDevice(event.device);

	    const pUsbDevice = this._getPUSBDevice(event.device);

	    if (pUsbDevice == undefined) {
	      logdebug("Device is not known. Moving on.");
	      return;
	    }

	    const dev = Array.from(values(_context = this._devices).call(_context)).find(dev => dev === pUsbDevice && dev.parent == undefined);

	    if (dev == undefined) {
	      logdebug("couldn't find detaching device in Devices list!");
	      return;
	    }

	    const children = Array.from(values(_context2 = this._devices).call(_context2)).filter(d => d.parent === dev);

	    for (const child of children) this._deviceDetach(child);

	    this._deviceDetach(dev);

	    this._deletePUSBDevice(pUsbDevice);
	  }
	  /** @internal */


	  _attachLocalDevice(device) {
	    var _a;

	    this._deviceAttach(device);

	    let channelCnt = 0;

	    for (const chDef of device.devDef.ch) {
	      for (let index = 0; index < ((_a = chDef.n) !== null && _a !== void 0 ? _a : 1); index++, channelCnt++) {
	        const id = chDef.c + '_' + device.serialNumber + '_' + device.hubPort + '_' + channelCnt + '_' + (device.class === exports.DeviceClass.VINT ? '1' : '0') + '_' + (device.isHubPort ? '1' : '0');
	        const chData = {
	          id: id,
	          chDef: chDef,
	          uniqueIndex: channelCnt,
	          index: index + chDef.i
	        };
	        const ch = new LocalChannel(this, device, chData);
	        device.channels[channelCnt] = ch;

	        this._channelAttach(ch);
	      }
	    }
	  }
	  /** @internal */


	  _deviceDetach(dev) {
	    super._deviceDetach(dev);

	    dev.lock().then(() => {
	      return dev.close();
	    }).then(() => {
	      dev.unlock();
	    }).catch(err => {
	      logwarn("Error closing during detach", err);
	      dev.unlock();
	    });
	  }
	  /** @internal */


	  _usbErrorDetach(dev) {
	    var _context3;

	    logwarn("Detaching device because of USB error.");
	    const children = Array.from(values(_context3 = this._devices).call(_context3)).filter(d => d.parent === dev);

	    for (const child of children) this._deviceDetach(child);

	    this._deviceDetach(dev);

	    this._deletePUSBDevice(dev);
	  }

	}

	/**
	 * @public
	 */

	class USBConnection extends USBConnectionBase {
	  /**
	   * Enables direct USB connection to Phidgets in the browser
	   *
	   * @throws {@link PhidgetError} Browser must support WebUSB
	   */
	  constructor(opts) {
	    if (!('navigator' in window) || navigator == undefined || navigator.usb == undefined) throw new PhidgetError(exports.ErrorCode.UNSUPPORTED, "USB Support not detected. Make sure your browser supports WebUSB.");
	    super(navigator.usb, 0, opts);
	    this._usbdevs = new Set();
	    this._pUSBDevices = new Map();
	  }

	  close() {
	    super.close();
	    this._usbdevs = new Set();
	    this._pUSBDevices = new Map();
	  }

	  async requestWebUSBDeviceAccess() {
	    if (!this.connected) throw new PhidgetError(exports.ErrorCode.NOT_ATTACHED, "Not connected");
	    const filter = {
	      vendorId: USBVID_PHIDGETS,
	      classCode: 0xFF
	    };

	    try {
	      await this._webusb.requestDevice({
	        filters: [filter]
	      });
	      await this._scanWebUSBDevices();
	    } catch (err) {}
	  }
	  /** @internal */


	  _trackUSBDevice(dev) {
	    if (this._usbdevs.has(dev)) return false;

	    this._usbdevs.add(dev);

	    return true;
	  }
	  /** @internal */


	  _untrackUSBDevice(dev) {
	    this._usbdevs.delete(dev);
	  }
	  /** @internal */


	  _getPUSBDevice(dev) {
	    return this._pUSBDevices.get(dev);
	  }
	  /** @internal */


	  _addPUSBDevice(dev) {
	    this._pUSBDevices.set(dev['usbDevice'], dev);
	  }
	  /** @internal */


	  _deletePUSBDevice(dev) {
	    this._pUSBDevices.delete(dev['usbDevice']);
	  }
	  /** @internal */


	  _setEpTimeout(_dev, _ep, _timeout) {}

	}

	class VoltageRatioInputBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onVoltageRatioChange = null;
	    this.onSensorChange = null;
	    this._class = exports.ChannelClass.VOLTAGE_RATIO_INPUT;
	    this.name = "VoltageRatioInput";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 56:
	        this.data.bridgeEnabled = bp.entries[0].v;

	        this._FIREPropertyChange('BridgeEnabled', bp);

	        break;

	      case 45:
	        this.data.bridgeGain = bp.entries[0].v;

	        this._FIREPropertyChange('BridgeGain', bp);

	        break;

	      case 54:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.entries[1].v;else this.data.dataInterval = bp.entries[0].v;

	        this._FIREPropertyChange('DataInterval', bp);

	        this._FIREPropertyChange('DataRate', bp);

	        break;

	      case 79:
	        this.data.sensorType = bp.entries[0].v;

	        this._FIREPropertyChange('SensorType', bp);

	        break;

	      case 122:
	        this.data.sensorValueChangeTrigger = bp.entries[0].v;

	        this._FIREPropertyChange('SensorValueChangeTrigger', bp);

	        break;

	      case 46:
	        this.data.voltageRatioChangeTrigger = bp.entries[0].v;

	        this._FIREPropertyChange('VoltageRatioChangeTrigger', bp);

	        break;

	      case 115:
	        {
	          this.data.sensorValue = bp.entries[0].v;
	          const sensorUnit = {
	            unit: bp.entries["UnitInfo.unit"].v,
	            name: bp.entries["UnitInfo.name"].v,
	            symbol: bp.entries["UnitInfo.symbol"].v
	          };
	          this.data.sensorUnit = sensorUnit;

	          if (this._isAttachedDone && this.onSensorChange) {
	            try {
	              this.onSensorChange(this.data.sensorValue, this.data.sensorUnit);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      bridgeEnabled: 2,
	      bridgeGain: 2147483647,
	      dataInterval: 1e+300,
	      minDataInterval: 4294967295,
	      maxDataInterval: 4294967295,
	      minDataRate: 1e+300,
	      maxDataRate: 1e+300,
	      sensorType: 2147483647,
	      sensorUnit: null,
	      sensorValue: 1e+300,
	      voltageRatio: 1e+300,
	      minVoltageRatio: 1e+300,
	      maxVoltageRatio: 1e+300,
	      voltageRatioChangeTrigger: 1e+300,
	      minVoltageRatioChangeTrigger: 1e+300,
	      maxVoltageRatioChangeTrigger: 1e+300,
	      sensorValueChangeTrigger: 1e+300
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 46:
	        this.data.dataInterval = 256;
	        this.data.minDataInterval = 1;
	        this.data.maxDataInterval = 1000;
	        this.data.minDataRate = 1;
	        this.data.maxDataRate = 1000;
	        this.data.sensorType = exports.VoltageRatioSensorType.VOLTAGE_RATIO;
	        this.data.voltageRatio = this._ch.parent.data.voltageRatio[this._ch.index];
	        this.data.minVoltageRatio = 0;
	        this.data.maxVoltageRatio = 1;
	        this.data.voltageRatioChangeTrigger = 0;
	        this.data.minVoltageRatioChangeTrigger = 0;
	        this.data.maxVoltageRatioChangeTrigger = 1;
	        this.data.sensorValueChangeTrigger = 0;
	        break;

	      case 194:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 1;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 1000;
	        this.data.sensorType = exports.VoltageRatioSensorType.VOLTAGE_RATIO;
	        this.data.minVoltageRatio = 0;
	        this.data.maxVoltageRatio = 1;
	        this.data.voltageRatioChangeTrigger = 0;
	        this.data.minVoltageRatioChangeTrigger = 0;
	        this.data.maxVoltageRatioChangeTrigger = 1;
	        this.data.sensorValueChangeTrigger = 0;
	        break;

	      case 215:
	      case 217:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 20;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 50;
	        this.data.sensorType = exports.VoltageRatioSensorType.VOLTAGE_RATIO;
	        this.data.minVoltageRatio = 0;
	        this.data.maxVoltageRatio = 1;
	        this.data.voltageRatioChangeTrigger = 0;
	        this.data.minVoltageRatioChangeTrigger = 0;
	        this.data.maxVoltageRatioChangeTrigger = 1;
	        this.data.sensorValueChangeTrigger = 0;
	        break;

	      case 240:
	        this.data.bridgeEnabled = 1;
	        this.data.bridgeGain = exports.BridgeGain.GAIN_128X;
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 20;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 50;
	        this.data.minVoltageRatio = -0.5;
	        this.data.maxVoltageRatio = 0.5;
	        this.data.voltageRatioChangeTrigger = 0;
	        this.data.minVoltageRatioChangeTrigger = 0;
	        this.data.maxVoltageRatioChangeTrigger = 0.5;
	        break;

	      case 244:
	      case 249:
	      case 255:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 100;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.sensorType = exports.VoltageRatioSensorType.VOLTAGE_RATIO;
	        this.data.minVoltageRatio = 0;
	        this.data.maxVoltageRatio = 1;
	        this.data.voltageRatioChangeTrigger = 0;
	        this.data.minVoltageRatioChangeTrigger = 0;
	        this.data.maxVoltageRatioChangeTrigger = 1;
	        this.data.sensorValueChangeTrigger = 0;
	        break;

	      case 299:
	        this.data.dataInterval = 100;
	        this.data.minDataInterval = 20;
	        this.data.maxDataInterval = 1000;
	        this.data.minDataRate = 1;
	        this.data.maxDataRate = 50;
	        this.data.sensorType = exports.VoltageRatioSensorType.VOLTAGE_RATIO;
	        this.data.minVoltageRatio = -1;
	        this.data.maxVoltageRatio = 1;
	        this.data.voltageRatioChangeTrigger = 0;
	        this.data.minVoltageRatioChangeTrigger = 0;
	        this.data.maxVoltageRatioChangeTrigger = 2;
	        break;

	      case 308:
	        this.data.dataInterval = 100;
	        this.data.minDataInterval = 100;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.sensorType = exports.VoltageRatioSensorType.VOLTAGE_RATIO;
	        this.data.minVoltageRatio = 0;
	        this.data.maxVoltageRatio = 1;
	        this.data.voltageRatioChangeTrigger = 0;
	        this.data.minVoltageRatioChangeTrigger = 0;
	        this.data.maxVoltageRatioChangeTrigger = 1;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    let bp;

	    switch (this._ch.chDef.uid) {
	      case 46:
	      case 194:
	      case 215:
	      case 217:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.sensorType
	        });
	        await bp.send(this._ch, 79);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.voltageRatioChangeTrigger
	        });
	        await bp.send(this._ch, 46);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.sensorValueChangeTrigger
	        });
	        await bp.send(this._ch, 122);
	        break;

	      case 240:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.bridgeEnabled
	        });
	        await bp.send(this._ch, 56);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.bridgeGain
	        });
	        await bp.send(this._ch, 45);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.voltageRatioChangeTrigger
	        });
	        await bp.send(this._ch, 46);
	        break;

	      case 244:
	      case 249:
	      case 255:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.sensorType
	        });
	        await bp.send(this._ch, 79);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.sensorValueChangeTrigger
	        });
	        await bp.send(this._ch, 122);
	        break;

	      case 299:
	      case 308:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.voltageRatioChangeTrigger
	        });
	        await bp.send(this._ch, 46);
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {}
	  /**
	   * Enable power to the input and start collecting data by setting `bridgeEnabled` to true.
	   * @throws {@link PhidgetError}
	   */


	  get bridgeEnabled() {
	    return this.getBridgeEnabled();
	  }
	  /**
	   * Choose a `bridgeGain` that best suits your application.
	   *
	   * *   For more information about the range and accuracy of each `bridgeGain` to decide which best suits your application, see your device's User Guide.
	   * @throws {@link PhidgetError}
	   */


	  get bridgeGain() {
	    return this.getBridgeGain();
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between events can also be affected by the change trigger.
	   * @throws {@link PhidgetError}
	   */


	  get dataInterval() {
	    return this.getDataInterval();
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataInterval() {
	    return this.getMinDataInterval();
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataInterval() {
	    return this.getMaxDataInterval();
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   */


	  get dataRate() {
	    return this.getDataRate();
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataRate() {
	    return this.getMinDataRate();
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataRate() {
	    return this.getMaxDataRate();
	  }
	  /**
	   * We sell a variety of analog sensors that do not have their own API, they simply output a voltage that can be converted to a digital value using a specific formula. By matching the `sensorType` to your analog sensor, the correct formula will automatically be applied to data when you get the `sensorValue` or subscribe to the `SensorChange` event.
	   *
	   * *   The `SensorChange` event has its own change trigger associated with it: `sensorValueChangeTrigger`.
	   * *   Any data from getting the `sensorValue` or subscribing to the `SensorChange` event will have a `sensorUnit` associated with it.
	   *
	   * **Note:** Unlike other properties such as `Phidget.deviceSerialNumber` or `Phidget.channel`, `sensorType` is set after the device is opened, not before.
	   * @throws {@link PhidgetError}
	   */


	  get sensorType() {
	    return this.getSensorType();
	  }
	  /**
	   * The unit of measurement that applies to the sensor values of the `sensorType` that has been selected.
	   *
	   * *   Helps keep track of the type of information being calculated from the voltage ratio input.
	   * @throws {@link PhidgetError}
	   */


	  get sensorUnit() {
	    return this.getSensorUnit();
	  }
	  /**
	   * The most recent sensor value that the channel has reported.
	   *
	   * *   Use `sensorUnit` to get the measurement units that are associated with the `sensorValue`
	   * @throws {@link PhidgetError}
	   */


	  get sensorValue() {
	    return this.getSensorValue();
	  }
	  /**
	   * The channel will not issue a `SensorChange` event until the sensor value has changed by the amount specified by the `sensorValueChangeTrigger`.
	   *
	   * *   Setting the `sensorValueChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   */


	  get sensorValueChangeTrigger() {
	    return this.getSensorValueChangeTrigger();
	  }
	  /**
	   * The most recent voltage ratio value that the channel has reported.
	   *
	   * *   This value will always be between `minVoltageRatio` and `maxVoltageRatio`.
	   * @throws {@link PhidgetError}
	   */


	  get voltageRatio() {
	    return this.getVoltageRatio();
	  }
	  /**
	   * The minimum value the `VoltageRatioChange` event will report.
	   * @throws {@link PhidgetError}
	   */


	  get minVoltageRatio() {
	    return this.getMinVoltageRatio();
	  }
	  /**
	   * The maximum value the `VoltageRatioChange` event will report.
	   * @throws {@link PhidgetError}
	   */


	  get maxVoltageRatio() {
	    return this.getMaxVoltageRatio();
	  }
	  /**
	   * The channel will not issue a `VoltageRatioChange` event until the voltage ratio value has changed by the amount specified by the `voltageRatioChangeTrigger`.
	   *
	   * *   Setting the `voltageRatioChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   */


	  get voltageRatioChangeTrigger() {
	    return this.getVoltageRatioChangeTrigger();
	  }
	  /**
	   * The minimum value that `voltageRatioChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minVoltageRatioChangeTrigger() {
	    return this.getMinVoltageRatioChangeTrigger();
	  }
	  /**
	   * The maximum value that `voltageRatioChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxVoltageRatioChangeTrigger() {
	    return this.getMaxVoltageRatioChangeTrigger();
	  }
	  /**
	   * Enable power to the input and start collecting data by setting `bridgeEnabled` to true.
	   * @returns The enabled value
	   * @throws {@link PhidgetError}
	   */


	  getBridgeEnabled() {
	    this._assertOpen();

	    if (this.data.bridgeEnabled === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.bridgeEnabled;
	  }
	  /**
	   * Enable power to the input and start collecting data by setting `bridgeEnabled` to true.
	   * @throws {@link PhidgetError}
	   * @param bridgeEnabled - The enabled value
	   */


	  async setBridgeEnabled(bridgeEnabled) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (bridgeEnabled !== false && bridgeEnabled !== true) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be a boolean.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: bridgeEnabled ? 1 : 0
	    });
	    await bp.send(this._ch, 56);
	  }
	  /**
	   * Choose a `bridgeGain` that best suits your application.
	   *
	   * *   For more information about the range and accuracy of each `bridgeGain` to decide which best suits your application, see your device's User Guide.
	   * @returns The bridge gain value
	   * @throws {@link PhidgetError}
	   */


	  getBridgeGain() {
	    this._assertOpen();

	    if (this.data.bridgeGain === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.bridgeGain;
	  }
	  /**
	   * Choose a `bridgeGain` that best suits your application.
	   *
	   * *   For more information about the range and accuracy of each `bridgeGain` to decide which best suits your application, see your device's User Guide.
	   * @throws {@link PhidgetError}
	   * @param bridgeGain - The bridge gain value
	   */


	  async setBridgeGain(bridgeGain) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedBridgeGain(this._ch, bridgeGain)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified BridgeGain is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: bridgeGain
	    });
	    await bp.send(this._ch, 45);
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between events can also be affected by the change trigger.
	   * @returns The data interval for the channel
	   * @throws {@link PhidgetError}
	   */


	  getDataInterval() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dataInterval;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between events can also be affected by the change trigger.
	   * @throws {@link PhidgetError}
	   * @param dataInterval - The data interval for the channel
	   */


	  async setDataInterval(dataInterval) {
	    this._assertOpen();

	    if (dataInterval < this.data.minDataInterval || dataInterval > this.data.maxDataInterval) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataInterval + " - " + this.data.maxDataInterval + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: dataInterval
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataInterval() {
	    this._assertOpen();

	    if (this.data.minDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataInterval;
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataInterval() {
	    this._assertOpen();

	    if (this.data.maxDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @returns The data rate for the channel
	   * @throws {@link PhidgetError}
	   */


	  getDataRate() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return 1000.0 / this.data.dataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   * @param dataRate - The data rate for the channel
	   */


	  async setDataRate(dataRate) {
	    this._assertOpen();

	    if (dataRate < this.data.minDataRate || dataRate > this.data.maxDataRate) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataRate + " - " + this.data.maxDataRate + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: Math.round(1000.0 / dataRate)
	    });
	    bp.set({
	      name: "1",
	      type: "g",
	      value: 1000.0 / dataRate
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataRate() {
	    this._assertOpen();

	    if (this.data.minDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataRate;
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataRate() {
	    this._assertOpen();

	    if (this.data.maxDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataRate;
	  }
	  /**
	   * We sell a variety of analog sensors that do not have their own API, they simply output a voltage that can be converted to a digital value using a specific formula. By matching the `sensorType` to your analog sensor, the correct formula will automatically be applied to data when you get the `sensorValue` or subscribe to the `SensorChange` event.
	   *
	   * *   The `SensorChange` event has its own change trigger associated with it: `sensorValueChangeTrigger`.
	   * *   Any data from getting the `sensorValue` or subscribing to the `SensorChange` event will have a `sensorUnit` associated with it.
	   *
	   * **Note:** Unlike other properties such as `Phidget.deviceSerialNumber` or `Phidget.channel`, `sensorType` is set after the device is opened, not before.
	   * @returns The sensor type value
	   * @throws {@link PhidgetError}
	   */


	  getSensorType() {
	    this._assertOpen();

	    if (this.data.sensorType === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.sensorType;
	  }
	  /**
	   * We sell a variety of analog sensors that do not have their own API, they simply output a voltage that can be converted to a digital value using a specific formula. By matching the `sensorType` to your analog sensor, the correct formula will automatically be applied to data when you get the `sensorValue` or subscribe to the `SensorChange` event.
	   *
	   * *   The `SensorChange` event has its own change trigger associated with it: `sensorValueChangeTrigger`.
	   * *   Any data from getting the `sensorValue` or subscribing to the `SensorChange` event will have a `sensorUnit` associated with it.
	   *
	   * **Note:** Unlike other properties such as `Phidget.deviceSerialNumber` or `Phidget.channel`, `sensorType` is set after the device is opened, not before.
	   * @throws {@link PhidgetError}
	   * @param sensorType - The sensor type value
	   */


	  async setSensorType(sensorType) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedVoltageRatioSensorType(this._ch, sensorType)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified VoltageRatioSensorType is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: sensorType
	    });
	    await bp.send(this._ch, 79);
	  }
	  /**
	   * The unit of measurement that applies to the sensor values of the `sensorType` that has been selected.
	   *
	   * *   Helps keep track of the type of information being calculated from the voltage ratio input.
	   * @returns The sensor unit information corresponding to the `sensorValue`.
	   * @throws {@link PhidgetError}
	   */


	  getSensorUnit() {
	    this._assertOpen();

	    if (this.data.sensorUnit === null) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.sensorUnit;
	  }
	  /**
	   * The most recent sensor value that the channel has reported.
	   *
	   * *   Use `sensorUnit` to get the measurement units that are associated with the `sensorValue`
	   * @returns The sensor value
	   * @throws {@link PhidgetError}
	   */


	  getSensorValue() {
	    this._assertOpen();

	    if (this.data.sensorValue === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.sensorValue;
	  }
	  /**
	   * The channel will not issue a `SensorChange` event until the sensor value has changed by the amount specified by the `sensorValueChangeTrigger`.
	   *
	   * *   Setting the `sensorValueChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getSensorValueChangeTrigger() {
	    this._assertOpen();

	    if (this.data.sensorValueChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.sensorValueChangeTrigger;
	  }
	  /**
	   * The channel will not issue a `SensorChange` event until the sensor value has changed by the amount specified by the `sensorValueChangeTrigger`.
	   *
	   * *   Setting the `sensorValueChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   * @param sensorValueChangeTrigger - The change trigger value
	   */


	  async setSensorValueChangeTrigger(sensorValueChangeTrigger) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: sensorValueChangeTrigger
	    });
	    await bp.send(this._ch, 122);
	  }
	  /**
	   * The most recent voltage ratio value that the channel has reported.
	   *
	   * *   This value will always be between `minVoltageRatio` and `maxVoltageRatio`.
	   * @returns The voltage ratio value
	   * @throws {@link PhidgetError}
	   */


	  getVoltageRatio() {
	    this._assertOpen();

	    if (this.data.voltageRatio === 1e+300 || Number.isNaN(this.data.voltageRatio)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    if (this.data.voltageRatio > this.data.maxVoltageRatio) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE_HIGH);
	    if (this.data.voltageRatio < this.data.minVoltageRatio) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE_LOW);
	    return this.data.voltageRatio;
	  }
	  /**
	   * The minimum value the `VoltageRatioChange` event will report.
	   * @returns The voltage ratio value
	   * @throws {@link PhidgetError}
	   */


	  getMinVoltageRatio() {
	    this._assertOpen();

	    if (this.data.minVoltageRatio === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minVoltageRatio;
	  }
	  /**
	   * The maximum value the `VoltageRatioChange` event will report.
	   * @returns The voltage ratio value
	   * @throws {@link PhidgetError}
	   */


	  getMaxVoltageRatio() {
	    this._assertOpen();

	    if (this.data.maxVoltageRatio === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxVoltageRatio;
	  }
	  /**
	   * The channel will not issue a `VoltageRatioChange` event until the voltage ratio value has changed by the amount specified by the `voltageRatioChangeTrigger`.
	   *
	   * *   Setting the `voltageRatioChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getVoltageRatioChangeTrigger() {
	    this._assertOpen();

	    if (this.data.voltageRatioChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.voltageRatioChangeTrigger;
	  }
	  /**
	   * The channel will not issue a `VoltageRatioChange` event until the voltage ratio value has changed by the amount specified by the `voltageRatioChangeTrigger`.
	   *
	   * *   Setting the `voltageRatioChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   * @param voltageRatioChangeTrigger - The change trigger value
	   */


	  async setVoltageRatioChangeTrigger(voltageRatioChangeTrigger) {
	    this._assertOpen();

	    if (voltageRatioChangeTrigger < this.data.minVoltageRatioChangeTrigger || voltageRatioChangeTrigger > this.data.maxVoltageRatioChangeTrigger) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minVoltageRatioChangeTrigger + " - " + this.data.maxVoltageRatioChangeTrigger + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: voltageRatioChangeTrigger
	    });
	    await bp.send(this._ch, 46);
	  }
	  /**
	   * The minimum value that `voltageRatioChangeTrigger` can be set to.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMinVoltageRatioChangeTrigger() {
	    this._assertOpen();

	    if (this.data.minVoltageRatioChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minVoltageRatioChangeTrigger;
	  }
	  /**
	   * The maximum value that `voltageRatioChangeTrigger` can be set to.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMaxVoltageRatioChangeTrigger() {
	    this._assertOpen();

	    if (this.data.maxVoltageRatioChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxVoltageRatioChangeTrigger;
	  }

	}

	const Units = [{
	  unit: exports.Unit.NONE,
	  name: "none",
	  symbol: ""
	}, {
	  unit: exports.Unit.BOOLEAN,
	  name: "boolean",
	  symbol: ""
	}, {
	  unit: exports.Unit.PERCENT,
	  name: "percent",
	  symbol: "%"
	}, {
	  unit: exports.Unit.DECIBEL,
	  name: "decibel",
	  symbol: "dB"
	}, {
	  unit: exports.Unit.MILLIMETER,
	  name: "millimeter",
	  symbol: "mm"
	}, {
	  unit: exports.Unit.CENTIMETER,
	  name: "centimeter",
	  symbol: "cm"
	}, {
	  unit: exports.Unit.METER,
	  name: "meter",
	  symbol: "m"
	}, {
	  unit: exports.Unit.GRAM,
	  name: "gram",
	  symbol: "g"
	}, {
	  unit: exports.Unit.KILOGRAM,
	  name: "kilogram",
	  symbol: "kg"
	}, {
	  unit: exports.Unit.MILLIAMPERE,
	  name: "milliampere",
	  symbol: "mA"
	}, {
	  unit: exports.Unit.AMPERE,
	  name: "ampere",
	  symbol: "A"
	}, {
	  unit: exports.Unit.KILOPASCAL,
	  name: "kilopascal",
	  symbol: "kPa"
	}, {
	  unit: exports.Unit.VOLT,
	  name: "volt",
	  symbol: "V"
	}, {
	  unit: exports.Unit.DEGREE_CELCIUS,
	  name: "degree Celsius",
	  symbol: "\xB0C"
	}, {
	  unit: exports.Unit.LUX,
	  name: "lux",
	  symbol: "lx"
	}, {
	  unit: exports.Unit.GAUSS,
	  name: "gauss",
	  symbol: "G"
	}, {
	  unit: exports.Unit.PH,
	  name: "pH",
	  symbol: ""
	}, {
	  unit: exports.Unit.WATT,
	  name: "watt",
	  symbol: "W"
	}];

	/** @public */

	class VoltageRatioInput extends VoltageRatioInputBase {
	  /** @internal */
	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 10:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.getNumber(1);else this.data.dataInterval = bp.getNumber(0);

	        this._FIREPropertyChange('DataInterval');

	        this._FIREPropertyChange('DataRate');

	        break;

	      case 27:
	        this.data.minDataInterval = bp.getNumber(0);

	        this._FIREPropertyChange('MinDataInterval');

	        break;

	      case 79:
	        super._bridgeInput(bp);

	        this._bangSensorVoltage();

	        break;

	      case 102:
	        {
	          this.data.voltageRatio = bp.getNumber('0');

	          const sentSensorEvent = this._bangSensorVoltage(true);

	          if (sentSensorEvent && this._ch.conn._isRemote) throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	          break;
	        }

	      default:
	        super._bridgeInput(bp);

	        break;
	    }
	  }
	  /** @internal */


	  _errorHandler(code) {
	    switch (code) {
	      case exports.ErrorEventCode.SATURATION:
	        this.data.voltageRatio = 1e+300;
	        this.data.sensorValue = 1e+300;
	        this._gotVoltageRatioChangeErrorEvent = true;
	        break;
	    }
	  }
	  /** @internal */


	  _initAfterOpen() {
	    super._initAfterOpen();

	    if (this.data.sensorType === 2147483647) this.data.sensorType = exports.VoltageRatioSensorType.VOLTAGE_RATIO;
	    this.data.sensorUnit = this._getVoltageRatioSensorUnit(this.data.sensorType);
	    this.data.sensorValue = this._getVoltageRatioSensorValue(this.data.voltageRatio, this.data.sensorType);
	  }
	  /** @internal */


	  _hasInitialState() {
	    if (this.data.voltageRatio == 1e+300 && !this._gotVoltageRatioChangeErrorEvent) return false;
	    return super._hasInitialState();
	  }
	  /** @internal */


	  _fireInitialEvents() {
	    if (this.data.sensorType != exports.VoltageRatioSensorType.VOLTAGE_RATIO) {
	      if (this.data.sensorValue != 1e+300 && this.data.sensorUnit != null) if (this.onSensorChange) {
	        try {
	          this.onSensorChange(this.data.sensorValue, this.data.sensorUnit);
	        } catch (err) {
	          logEventException(err);
	        }
	      }
	    } else {
	      if (this.data.voltageRatio != 1e+300) if (this.onVoltageRatioChange) {
	        try {
	          this.onVoltageRatioChange(this.data.voltageRatio);
	        } catch (err) {
	          logEventException(err);
	        }
	      }
	    }

	    super._fireInitialEvents();
	  }
	  /** @internal */


	  _bangSensorVoltage() {
	    let includeVoltage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	    let sensorValue;
	    let unitInfo;
	    let sentSensorEvent = false;
	    const bp = new BridgePacket();

	    if (this._ch.supportedBridgePacket(115) && this._ch.conn._isLocal && this.data.sensorType !== exports.VoltageRatioSensorType.VOLTAGE_RATIO) {
	      sensorValue = this._getVoltageRatioSensorValue(this.data.voltageRatio, this.data.sensorType);

	      if (!this._getSensorValueInRange(sensorValue, this.data.sensorType)) {
	        this.data.sensorValue = 1e+300;

	        if (this._isAttachedDone) {
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.OUT_OF_RANGE
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Sensor value is ouside the valid range for this sensor.'
	          });

	          this._ch.sendErrorEvent(bp);
	        }
	      } else if (this.data.sensorValue === 1e+300 || Math.abs(sensorValue - this.data.sensorValue) >= this.data.sensorValueChangeTrigger) {
	        this.data.sensorValue = sensorValue;

	        if (this._isAttachedDone) {
	          unitInfo = this._getVoltageRatioSensorUnit(this.data.sensorType);
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: sensorValue
	          });
	          bp.set({
	            name: 'UnitInfo.unit',
	            type: 'g',
	            value: unitInfo.unit
	          });
	          bp.set({
	            name: 'UnitInfo.name',
	            type: 's',
	            value: unitInfo.name
	          });
	          bp.set({
	            name: 'UnitInfo.symbol',
	            type: 's',
	            value: unitInfo.symbol
	          });
	          bp.sendToChannel(this._ch, 115);
	        }
	      }

	      sentSensorEvent = true;
	    } else if (includeVoltage) {
	      this.data.sensorUnit = this._getVoltageRatioSensorUnit(this.data.sensorType);
	      this.data.sensorValue = this._getVoltageRatioSensorValue(this.data.voltageRatio, this.data.sensorType);

	      if (this._isAttachedDone && this.onVoltageRatioChange) {
	        try {
	          this.onVoltageRatioChange(this.data.voltageRatio);
	        } catch (err) {
	          logEventException(err);
	        }
	      }
	    }

	    return sentSensorEvent;
	  }
	  /** @internal */


	  _getVoltageRatioSensorValue(voltageRatio, sensorType) {
	    if (voltageRatio === 1e+300) {
	      return 1e+300;
	    }

	    switch (sensorType) {
	      case exports.VoltageRatioSensorType.PN_1101_SHARP2D120X:
	      case exports.VoltageRatioSensorType.PN_3520:
	        return RoundDouble(2.076 / (voltageRatio - 0.011), 2);

	      case exports.VoltageRatioSensorType.PN_1101_SHARP2Y0A21:
	      case exports.VoltageRatioSensorType.PN_3521:
	        return RoundDouble(4.8 / (voltageRatio - 0.02), 2);

	      case exports.VoltageRatioSensorType.PN_1101_SHARP2Y0A02:
	      case exports.VoltageRatioSensorType.PN_3522:
	        return RoundDouble(9.462 / (voltageRatio - 0.01692), 2);

	      case exports.VoltageRatioSensorType.PN_1102:
	        return voltageRatio < 0.4 ? 1 : 0;

	      case exports.VoltageRatioSensorType.PN_1103:
	        return voltageRatio < 0.1 ? 1 : 0;

	      case exports.VoltageRatioSensorType.PN_1104:
	        return RoundDouble(voltageRatio * 2 - 1, 5);

	      case exports.VoltageRatioSensorType.PN_1105:
	        return voltageRatio;

	      case exports.VoltageRatioSensorType.PN_1106:
	        return voltageRatio;

	      case exports.VoltageRatioSensorType.PN_1107:
	        return RoundDouble(voltageRatio * 190.6 - 40.2, 3);

	      case exports.VoltageRatioSensorType.PN_1108:
	        return RoundDouble((0.5 - voltageRatio) * 1000, 2);

	      case exports.VoltageRatioSensorType.PN_1109:
	        return voltageRatio;

	      case exports.VoltageRatioSensorType.PN_1110:
	        return voltageRatio < 0.5 ? 1 : 0;

	      case exports.VoltageRatioSensorType.PN_1111:
	        return RoundDouble(voltageRatio * 2 - 1, 5);

	      case exports.VoltageRatioSensorType.PN_1112:
	        return voltageRatio;

	      case exports.VoltageRatioSensorType.PN_1113:
	        return RoundDouble(voltageRatio * 2 - 1, 5);

	      case exports.VoltageRatioSensorType.PN_1115:
	        return RoundDouble(voltageRatio / 0.004 + 10, 3);

	      case exports.VoltageRatioSensorType.PN_1116:
	        return voltageRatio;

	      case exports.VoltageRatioSensorType.PN_1118_AC:
	        return RoundDouble(voltageRatio * 69.38, 3);

	      case exports.VoltageRatioSensorType.PN_1118_DC:
	        return RoundDouble(voltageRatio / 0.008 - 62.5, 3);

	      case exports.VoltageRatioSensorType.PN_1119_AC:
	        return RoundDouble(voltageRatio * 27.75, 4);

	      case exports.VoltageRatioSensorType.PN_1119_DC:
	        return RoundDouble(voltageRatio / 0.02 - 25, 4);

	      case exports.VoltageRatioSensorType.PN_1120:
	        return voltageRatio;

	      case exports.VoltageRatioSensorType.PN_1121:
	        return voltageRatio;

	      case exports.VoltageRatioSensorType.PN_1122_AC:
	        return RoundDouble(voltageRatio * 42.04, 3);

	      case exports.VoltageRatioSensorType.PN_1122_DC:
	        return RoundDouble(voltageRatio / 0.0132 - 37.8787, 3);

	      case exports.VoltageRatioSensorType.PN_1124:
	      case exports.VoltageRatioSensorType.PN_1125_TEMPERATURE:
	        return RoundDouble(voltageRatio * 222.2 - 61.111, 3);

	      case exports.VoltageRatioSensorType.PN_1125_HUMIDITY:
	        return RoundDouble(voltageRatio * 190.6 - 40.2, 3);

	      case exports.VoltageRatioSensorType.PN_1126:
	        return RoundDouble(voltageRatio / 0.018 - 27.7777, 3);

	      case exports.VoltageRatioSensorType.PN_1128:
	        return RoundDouble(voltageRatio * 1296, 2);

	      case exports.VoltageRatioSensorType.PN_1129:
	        return voltageRatio > 0.5 ? 1 : 0;

	      case exports.VoltageRatioSensorType.PN_1131:
	        return RoundDouble(15.311 * Math.exp(voltageRatio * 5.199), 2);

	      case exports.VoltageRatioSensorType.PN_1134:
	        return voltageRatio;

	      case exports.VoltageRatioSensorType.PN_1136:
	        return RoundDouble(voltageRatio / 0.2 - 2.5, 4);

	      case exports.VoltageRatioSensorType.PN_1137:
	        return RoundDouble(voltageRatio / 0.057143 - 8.75, 4);

	      case exports.VoltageRatioSensorType.PN_1138:
	        return RoundDouble(voltageRatio / 0.018 - 2.222, 3);

	      case exports.VoltageRatioSensorType.PN_1139:
	        return RoundDouble(voltageRatio / 0.009 - 4.444, 3);

	      case exports.VoltageRatioSensorType.PN_1140:
	        return RoundDouble(voltageRatio / 0.002421 + 3.478, 2);

	      case exports.VoltageRatioSensorType.PN_1141:
	        return RoundDouble(voltageRatio / 0.0092 + 10.652, 2);

	      case exports.VoltageRatioSensorType.PN_1146:
	        return RoundDouble(1.3927 * Math.exp(1.967 * voltageRatio), 2);

	      case exports.VoltageRatioSensorType.PN_3120:
	        return RoundDouble(voltageRatio / 0.15432 - 0.647989, 4);

	      case exports.VoltageRatioSensorType.PN_3121:
	        return RoundDouble(voltageRatio / 0.0617295 - 1.619971, 4);

	      case exports.VoltageRatioSensorType.PN_3122:
	        return RoundDouble(voltageRatio / 0.0308647 - 3.239943, 3);

	      case exports.VoltageRatioSensorType.PN_3123:
	        return RoundDouble(voltageRatio / 0.0154324 - 6.479886, 3);

	      case exports.VoltageRatioSensorType.PN_3130:
	        return RoundDouble(voltageRatio * 190.6 - 40.2, 3);

	      case exports.VoltageRatioSensorType.VOLTAGE_RATIO:
	      default:
	        return voltageRatio;
	    }
	  }
	  /** @internal */


	  _getSensorValueInRange(sensorValue, sensorType) {
	    if (sensorValue === 1e+300) {
	      return false;
	    }

	    switch (sensorType) {
	      case exports.VoltageRatioSensorType.PN_1101_SHARP2D120X:
	      case exports.VoltageRatioSensorType.PN_3520:
	        return sensorValue >= 4.0 && sensorValue <= 30.0;

	      case exports.VoltageRatioSensorType.PN_1101_SHARP2Y0A21:
	      case exports.VoltageRatioSensorType.PN_3521:
	        return sensorValue >= 10.0 && sensorValue <= 80.0;

	      case exports.VoltageRatioSensorType.PN_1101_SHARP2Y0A02:
	      case exports.VoltageRatioSensorType.PN_3522:
	        return sensorValue >= 20.0 && sensorValue <= 150.0;

	      case exports.VoltageRatioSensorType.PN_1102:
	        return true;

	      case exports.VoltageRatioSensorType.PN_1103:
	        return true;

	      case exports.VoltageRatioSensorType.PN_1104:
	        return true;

	      case exports.VoltageRatioSensorType.PN_1105:
	        return true;

	      case exports.VoltageRatioSensorType.PN_1106:
	        return true;

	      case exports.VoltageRatioSensorType.PN_1107:
	        return sensorValue >= 0.0 && sensorValue <= 100.0;

	      case exports.VoltageRatioSensorType.PN_1108:
	        return sensorValue >= -500.0 && sensorValue <= 500.0;

	      case exports.VoltageRatioSensorType.PN_1109:
	        return true;

	      case exports.VoltageRatioSensorType.PN_1110:
	        return true;

	      case exports.VoltageRatioSensorType.PN_1111:
	        return true;

	      case exports.VoltageRatioSensorType.PN_1112:
	        return true;

	      case exports.VoltageRatioSensorType.PN_1113:
	        return sensorValue >= -1.0 && sensorValue <= 1.0;

	      case exports.VoltageRatioSensorType.PN_1115:
	        return sensorValue >= 20.0 && sensorValue <= 250.0;

	      case exports.VoltageRatioSensorType.PN_1116:
	        return true;

	      case exports.VoltageRatioSensorType.PN_1118_AC:
	        return sensorValue >= 0.0 && sensorValue <= 50.0;

	      case exports.VoltageRatioSensorType.PN_1118_DC:
	        return sensorValue >= -50.0 && sensorValue <= 50.0;

	      case exports.VoltageRatioSensorType.PN_1119_AC:
	        return sensorValue >= 0.0 && sensorValue <= 20.0;

	      case exports.VoltageRatioSensorType.PN_1119_DC:
	        return sensorValue >= -20.0 && sensorValue <= 20.0;

	      case exports.VoltageRatioSensorType.PN_1120:
	        return true;

	      case exports.VoltageRatioSensorType.PN_1121:
	        return true;

	      case exports.VoltageRatioSensorType.PN_1122_AC:
	        return sensorValue >= 0.0 && sensorValue <= 30.0;

	      case exports.VoltageRatioSensorType.PN_1122_DC:
	        return sensorValue >= -30.0 && sensorValue <= 30.0;

	      case exports.VoltageRatioSensorType.PN_1124:
	      case exports.VoltageRatioSensorType.PN_1125_TEMPERATURE:
	        return sensorValue >= -50.0 && sensorValue <= 150.0;

	      case exports.VoltageRatioSensorType.PN_1125_HUMIDITY:
	        return sensorValue >= 0.0 && sensorValue <= 100.0;

	      case exports.VoltageRatioSensorType.PN_1126:
	        return sensorValue >= -25.0 && sensorValue <= 25.0;

	      case exports.VoltageRatioSensorType.PN_1128:
	        return sensorValue >= 15.24 && sensorValue <= 6500.0;

	      case exports.VoltageRatioSensorType.PN_1129:
	        return true;

	      case exports.VoltageRatioSensorType.PN_1131:
	        return sensorValue >= 0.0 && sensorValue <= 2000.0;

	      case exports.VoltageRatioSensorType.PN_1134:
	        return true;

	      case exports.VoltageRatioSensorType.PN_1136:
	        return sensorValue >= -2.0 && sensorValue <= 2.0;

	      case exports.VoltageRatioSensorType.PN_1137:
	        return sensorValue >= -7.0 && sensorValue <= 7.0;

	      case exports.VoltageRatioSensorType.PN_1138:
	        return sensorValue >= 0.0 && sensorValue <= 50.0;

	      case exports.VoltageRatioSensorType.PN_1139:
	        return sensorValue >= 0.0 && sensorValue <= 100.0;

	      case exports.VoltageRatioSensorType.PN_1140:
	        return sensorValue >= 20.0 && sensorValue <= 400.0;

	      case exports.VoltageRatioSensorType.PN_1141:
	        return sensorValue >= 15.0 && sensorValue <= 115.0;

	      case exports.VoltageRatioSensorType.PN_1146:
	        return sensorValue >= 1.5 && sensorValue <= 4.0;

	      case exports.VoltageRatioSensorType.PN_3120:
	        return sensorValue >= 0.0 && sensorValue <= 4.5;

	      case exports.VoltageRatioSensorType.PN_3121:
	        return sensorValue >= 0.0 && sensorValue <= 11.3;

	      case exports.VoltageRatioSensorType.PN_3122:
	        return sensorValue >= 0.0 && sensorValue <= 22.7;

	      case exports.VoltageRatioSensorType.PN_3123:
	        return sensorValue >= 0.0 && sensorValue <= 45.3;

	      case exports.VoltageRatioSensorType.PN_3130:
	        return sensorValue >= 0.0 && sensorValue <= 100.0;

	      case exports.VoltageRatioSensorType.VOLTAGE_RATIO:
	        return true;

	      default:
	        return true;
	    }
	  }
	  /** @internal */


	  _getVoltageRatioSensorUnit(sensorType) {
	    switch (sensorType) {
	      case exports.VoltageRatioSensorType.PN_1146:
	        return Units[exports.Unit.MILLIMETER];

	      case exports.VoltageRatioSensorType.PN_1101_SHARP2D120X:
	      case exports.VoltageRatioSensorType.PN_1101_SHARP2Y0A21:
	      case exports.VoltageRatioSensorType.PN_1101_SHARP2Y0A02:
	      case exports.VoltageRatioSensorType.PN_1128:
	      case exports.VoltageRatioSensorType.PN_3520:
	      case exports.VoltageRatioSensorType.PN_3521:
	      case exports.VoltageRatioSensorType.PN_3522:
	        return Units[exports.Unit.CENTIMETER];

	      case exports.VoltageRatioSensorType.PN_1102:
	      case exports.VoltageRatioSensorType.PN_1103:
	      case exports.VoltageRatioSensorType.PN_1110:
	      case exports.VoltageRatioSensorType.PN_1129:
	        return Units[exports.Unit.BOOLEAN];

	      case exports.VoltageRatioSensorType.PN_1107:
	      case exports.VoltageRatioSensorType.PN_1125_HUMIDITY:
	      case exports.VoltageRatioSensorType.PN_3130:
	        return Units[exports.Unit.PERCENT];

	      case exports.VoltageRatioSensorType.PN_1108:
	        return Units[exports.Unit.GAUSS];

	      case exports.VoltageRatioSensorType.PN_1115:
	      case exports.VoltageRatioSensorType.PN_1126:
	      case exports.VoltageRatioSensorType.PN_1136:
	      case exports.VoltageRatioSensorType.PN_1137:
	      case exports.VoltageRatioSensorType.PN_1138:
	      case exports.VoltageRatioSensorType.PN_1139:
	      case exports.VoltageRatioSensorType.PN_1140:
	      case exports.VoltageRatioSensorType.PN_1141:
	        return Units[exports.Unit.KILOPASCAL];

	      case exports.VoltageRatioSensorType.PN_1118_AC:
	      case exports.VoltageRatioSensorType.PN_1119_AC:
	      case exports.VoltageRatioSensorType.PN_1122_AC:
	      case exports.VoltageRatioSensorType.PN_1118_DC:
	      case exports.VoltageRatioSensorType.PN_1119_DC:
	      case exports.VoltageRatioSensorType.PN_1122_DC:
	        return Units[exports.Unit.AMPERE];

	      case exports.VoltageRatioSensorType.PN_1124:
	      case exports.VoltageRatioSensorType.PN_1125_TEMPERATURE:
	        return Units[exports.Unit.DEGREE_CELCIUS];

	      case exports.VoltageRatioSensorType.PN_1131:
	        return Units[exports.Unit.GRAM];

	      case exports.VoltageRatioSensorType.PN_3120:
	      case exports.VoltageRatioSensorType.PN_3121:
	      case exports.VoltageRatioSensorType.PN_3122:
	      case exports.VoltageRatioSensorType.PN_3123:
	        return Units[exports.Unit.KILOGRAM];

	      case exports.VoltageRatioSensorType.VOLTAGE_RATIO:
	      case exports.VoltageRatioSensorType.PN_1104:
	      case exports.VoltageRatioSensorType.PN_1111:
	      case exports.VoltageRatioSensorType.PN_1113:
	      case exports.VoltageRatioSensorType.PN_1105:
	      case exports.VoltageRatioSensorType.PN_1106:
	      case exports.VoltageRatioSensorType.PN_1109:
	      case exports.VoltageRatioSensorType.PN_1112:
	      case exports.VoltageRatioSensorType.PN_1116:
	      case exports.VoltageRatioSensorType.PN_1120:
	      case exports.VoltageRatioSensorType.PN_1121:
	      case exports.VoltageRatioSensorType.PN_1134:
	      default:
	        return Units[exports.Unit.NONE];
	    }
	  }

	}

	class DigitalInputBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onStateChange = null;
	    this._class = exports.ChannelClass.DIGITAL_INPUT;
	    this.name = "DigitalInput";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 64:
	        this.data.inputMode = bp.entries[0].v;

	        this._FIREPropertyChange('InputMode', bp);

	        break;

	      case 74:
	        this.data.powerSupply = bp.entries[0].v;

	        this._FIREPropertyChange('PowerSupply', bp);

	        break;

	      case 90:
	        {
	          this.data.state = bp.entries[0].v;

	          if (this._isAttachedDone && this.onStateChange) {
	            try {
	              this.onStateChange(!!this.data.state);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      state: 2,
	      powerSupply: 2147483647,
	      inputMode: 2147483647
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 47:
	        this.data.state = this._ch.parent.data.inputState[this._ch.index];
	        break;

	      case 101:
	        this.data.state = this._ch.parent.data.inputState[this._ch.index];
	        break;

	      case 189:
	      case 226:
	      case 230:
	      case 231:
	      case 295:
	      case 300:
	        break;

	      case 234:
	      case 238:
	        this.data.powerSupply = exports.PowerSupply.VOLTS_12;
	        this.data.inputMode = exports.InputMode.NPN;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    let bp;

	    switch (this._ch.chDef.uid) {
	      case 47:
	      case 101:
	      case 189:
	      case 226:
	      case 230:
	      case 231:
	      case 295:
	      case 300:
	        break;

	      case 234:
	      case 238:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.powerSupply
	        });
	        await bp.send(this._ch, 74);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.inputMode
	        });
	        await bp.send(this._ch, 64);
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    if (this.data.state == 2 && !this._gotStateChangeErrorEvent) return false;
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {
	    if (this.data.state != 2) if (this.onStateChange) try {
	      this.onStateChange(!!this.data.state);
	    } catch (err) {
	      logEventException(err);
	    }
	  }
	  /**
	   * The input polarity mode for your channel.
	   *
	   * *   See your device's User Guide for more information about what value to chooose for the `InputMode`
	   * @throws {@link PhidgetError}
	   */


	  get inputMode() {
	    return this.getInputMode();
	  }
	  /**
	   * Choose the power supply voltage.
	   *
	   * *   Set this to the voltage specified in the attached sensor's data sheet to power it.
	   *
	   * *   Set to `phidget22.PowerSupply.OFF` to turn off the supply to save power.
	   * @throws {@link PhidgetError}
	   */


	  get powerSupply() {
	    return this.getPowerSupply();
	  }
	  /**
	   * The most recent state value that the channel has reported.
	   * @throws {@link PhidgetError}
	   */


	  get state() {
	    return this.getState();
	  }
	  /**
	   * The input polarity mode for your channel.
	   *
	   * *   See your device's User Guide for more information about what value to chooose for the `InputMode`
	   * @returns The input mode value
	   * @throws {@link PhidgetError}
	   */


	  getInputMode() {
	    this._assertOpen();

	    if (this.data.inputMode === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.inputMode;
	  }
	  /**
	   * The input polarity mode for your channel.
	   *
	   * *   See your device's User Guide for more information about what value to chooose for the `InputMode`
	   * @throws {@link PhidgetError}
	   * @param inputMode - The input mode value
	   */


	  async setInputMode(inputMode) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedInputMode(this._ch, inputMode)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified InputMode is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: inputMode
	    });
	    await bp.send(this._ch, 64);
	  }
	  /**
	   * Choose the power supply voltage.
	   *
	   * *   Set this to the voltage specified in the attached sensor's data sheet to power it.
	   *
	   * *   Set to `phidget22.PowerSupply.OFF` to turn off the supply to save power.
	   * @returns The power supply value
	   * @throws {@link PhidgetError}
	   */


	  getPowerSupply() {
	    this._assertOpen();

	    if (this.data.powerSupply === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.powerSupply;
	  }
	  /**
	   * Choose the power supply voltage.
	   *
	   * *   Set this to the voltage specified in the attached sensor's data sheet to power it.
	   *
	   * *   Set to `phidget22.PowerSupply.OFF` to turn off the supply to save power.
	   * @throws {@link PhidgetError}
	   * @param powerSupply - The power supply value
	   */


	  async setPowerSupply(powerSupply) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedPowerSupply(this._ch, powerSupply)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified PowerSupply is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: powerSupply
	    });
	    await bp.send(this._ch, 74);
	  }
	  /**
	   * The most recent state value that the channel has reported.
	   * @returns The state value
	   * @throws {@link PhidgetError}
	   */


	  getState() {
	    this._assertOpen();

	    if (this.data.state === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.state;
	  }

	}

	/** @public */

	class DigitalInput extends DigitalInputBase {}

	class DigitalOutputBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this._class = exports.ChannelClass.DIGITAL_OUTPUT;
	    this.name = "DigitalOutput";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 55:
	        this.data.dutyCycle = bp.entries[0].v;

	        this._FIREPropertyChange('DutyCycle', bp);

	        break;

	      case 146:
	        break;

	      case 156:
	        this.data.frequency = bp.entries[0].v;

	        this._FIREPropertyChange('Frequency', bp);

	        break;

	      case 67:
	        this.data.LEDCurrentLimit = bp.entries[0].v;

	        this._FIREPropertyChange('LEDCurrentLimit', bp);

	        break;

	      case 68:
	        this.data.LEDForwardVoltage = bp.entries[0].v;

	        this._FIREPropertyChange('LEDForwardVoltage', bp);

	        break;

	      case 147:
	        break;

	      case 82:
	        this.data.state = bp.entries[0].v;

	        this._FIREPropertyChange('State', bp);

	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      dutyCycle: 1e+300,
	      maxDutyCycle: 1e+300,
	      minDutyCycle: 1e+300,
	      LEDCurrentLimit: 1e+300,
	      minLEDCurrentLimit: 1e+300,
	      maxLEDCurrentLimit: 1e+300,
	      LEDForwardVoltage: 2147483647,
	      state: 2,
	      maxFailsafeTime: 4294967295,
	      minFailsafeTime: 4294967295,
	      frequency: 1e+300,
	      maxFrequency: 1e+300,
	      minFrequency: 1e+300
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 34:
	      case 35:
	      case 39:
	      case 40:
	      case 228:
	      case 351:
	      case 353:
	      case 356:
	      case 358:
	        this.data.dutyCycle = 0;
	        this.data.maxDutyCycle = 1;
	        this.data.minDutyCycle = 0;
	        this.data.state = 0;
	        this.data.maxFailsafeTime = 30000;
	        this.data.minFailsafeTime = 500;
	        break;

	      case 48:
	      case 190:
	      case 227:
	      case 350:
	      case 352:
	      case 355:
	        this.data.dutyCycle = 0;
	        this.data.maxDutyCycle = 1;
	        this.data.minDutyCycle = 0;
	        this.data.state = 0;
	        break;

	      case 191:
	        this.data.dutyCycle = 0;
	        this.data.maxDutyCycle = 1;
	        this.data.minDutyCycle = 0;
	        this.data.state = 0;
	        this.data.maxFailsafeTime = 60000;
	        this.data.minFailsafeTime = 100;
	        break;

	      case 229:
	      case 354:
	        this.data.dutyCycle = 0;
	        this.data.maxDutyCycle = 1;
	        this.data.minDutyCycle = 0;
	        this.data.state = 0;
	        this.data.maxFailsafeTime = 30000;
	        this.data.minFailsafeTime = 500;
	        this.data.frequency = 15625;
	        this.data.maxFrequency = 20000;
	        this.data.minFrequency = 100;
	        break;

	      case 306:
	        this.data.dutyCycle = 0;
	        this.data.maxDutyCycle = 1;
	        this.data.minDutyCycle = 0;
	        this.data.LEDCurrentLimit = 0.02;
	        this.data.minLEDCurrentLimit = 0;
	        this.data.maxLEDCurrentLimit = 0.04;
	        this.data.LEDForwardVoltage = exports.LEDForwardVoltage.VOLTS_3_2;
	        this.data.state = 0;
	        break;

	      case 357:
	        this.data.dutyCycle = 0;
	        this.data.maxDutyCycle = 1;
	        this.data.minDutyCycle = 0;
	        this.data.state = 0;
	        this.data.maxFailsafeTime = 30000;
	        this.data.minFailsafeTime = 500;
	        this.data.frequency = 20000;
	        this.data.maxFrequency = 20000;
	        this.data.minFrequency = 100;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    switch (this._ch.chDef.uid) {
	      case 34:
	      case 35:
	      case 39:
	      case 40:
	      case 48:
	      case 190:
	      case 191:
	      case 227:
	      case 228:
	      case 229:
	      case 306:
	      case 350:
	      case 351:
	      case 352:
	      case 353:
	      case 354:
	      case 355:
	      case 356:
	      case 357:
	      case 358:
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {}
	  /**
	   * The `dutyCycle` represents the fraction of time the output is on (high).
	   *
	   * *   A `dutyCycle` of 1.0 translates to a high output, a `dutyCycle` of 0 translates to a low output.
	   * *   A `dutyCycle` of 0.5 translates to an output that is high half the time, which results in an average output voltage of (output voltage x 0.5)
	   * *   You can use the `dutyCycle` to create a dimming effect on LEDs.
	   * @throws {@link PhidgetError}
	   */


	  get dutyCycle() {
	    return this.getDutyCycle();
	  }
	  /**
	   * The minimum value that `dutyCycle` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDutyCycle() {
	    return this.getMinDutyCycle();
	  }
	  /**
	   * The maximum value that `dutyCycle` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDutyCycle() {
	    return this.getMaxDutyCycle();
	  }
	  /**
	   * The minimum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @throws {@link PhidgetError}
	   */


	  get minFailsafeTime() {
	    return this.getMinFailsafeTime();
	  }
	  /**
	   * The maximum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @throws {@link PhidgetError}
	   */


	  get maxFailsafeTime() {
	    return this.getMaxFailsafeTime();
	  }
	  /**
	   * The `frequency` parameter sets the PWM frequency for all frequency-settable PWM outputs on the board.
	   * @throws {@link PhidgetError}
	   */


	  get frequency() {
	    return this.getFrequency();
	  }
	  /**
	   * The minimum value that `frequency` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minFrequency() {
	    return this.getMinFrequency();
	  }
	  /**
	   * The maximum value that `frequency` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxFrequency() {
	    return this.getMaxFrequency();
	  }
	  /**
	   * The `LEDCurrentLimit` is the maximum amount of current that the controller will provide to the output.
	   *
	   * *   Reference the data sheet of the LED you are using before setting this value.
	   * @throws {@link PhidgetError}
	   */


	  get LEDCurrentLimit() {
	    return this.getLEDCurrentLimit();
	  }
	  /**
	   * The minimum value that `LEDCurrentLimit` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minLEDCurrentLimit() {
	    return this.getMinLEDCurrentLimit();
	  }
	  /**
	   * The maximum value that `LEDCurrentLimit` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxLEDCurrentLimit() {
	    return this.getMaxLEDCurrentLimit();
	  }
	  /**
	   * The `LEDForwardVoltage` is the voltage that will be available to your LED.
	   *
	   * *   Reference the data sheet of the LED you are using before setting this value. Choose the `LEDForwardVoltage` that is closest to the forward voltage specified in the data sheet.
	   * *   This forward voltage is shared for all channels on this device. Setting the LEDForwardVoltage on any channel will set the LEDForwardVoltage for all channels on the device.
	   * @throws {@link PhidgetError}
	   */


	  get LEDForwardVoltage() {
	    return this.getLEDForwardVoltage();
	  }
	  /**
	   * The `state` will indicate whether the output is high (TRUE) or low (FALSE).
	   *
	   * *   If a `dutyCycle` has been set, the state will return as TRUE if the DutyCycle is above 0.5, or FALSE otherwise.
	   * @throws {@link PhidgetError}
	   */


	  get state() {
	    return this.getState();
	  }
	  /**
	   * The `dutyCycle` represents the fraction of time the output is on (high).
	   *
	   * *   A `dutyCycle` of 1.0 translates to a high output, a `dutyCycle` of 0 translates to a low output.
	   * *   A `dutyCycle` of 0.5 translates to an output that is high half the time, which results in an average output voltage of (output voltage x 0.5)
	   * *   You can use the `dutyCycle` to create a dimming effect on LEDs.
	   * @returns The duty cycle value
	   * @throws {@link PhidgetError}
	   */


	  getDutyCycle() {
	    this._assertOpen();

	    if (this.data.dutyCycle === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dutyCycle;
	  }
	  /**
	   * The `dutyCycle` represents the fraction of time the output is on (high).
	   *
	   * *   A `dutyCycle` of 1.0 translates to a high output, a `dutyCycle` of 0 translates to a low output.
	   * *   A `dutyCycle` of 0.5 translates to an output that is high half the time, which results in an average output voltage of (output voltage x 0.5)
	   * *   You can use the `dutyCycle` to create a dimming effect on LEDs.
	   * @throws {@link PhidgetError}
	   * @param dutyCycle - The duty cycle value
	   */


	  async setDutyCycle(dutyCycle) {
	    this._assertOpen();

	    if (dutyCycle < this.data.minDutyCycle || dutyCycle > this.data.maxDutyCycle) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDutyCycle + " - " + this.data.maxDutyCycle + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: dutyCycle
	    });
	    await bp.send(this._ch, 55);
	  }
	  /**
	   * The minimum value that `dutyCycle` can be set to.
	   * @returns The duty cycle value
	   * @throws {@link PhidgetError}
	   */


	  getMinDutyCycle() {
	    this._assertOpen();

	    if (this.data.minDutyCycle === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDutyCycle;
	  }
	  /**
	   * The maximum value that `dutyCycle` can be set to.
	   * @returns The duty cycle value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDutyCycle() {
	    this._assertOpen();

	    if (this.data.maxDutyCycle === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDutyCycle;
	  }
	  /**
	   * Enables the **failsafe** feature for the channel, with a given **failsafe time**.
	   *
	   * The **failsafe** feature is intended for use in applications where it is important for the channel to enter a known _safe state_ if the program controlling it locks up or crashes. If you do not enable the failsafe feature, the channel will carry out whatever instructions it was last given until it is explicitly told to stop.
	   *
	   * Enabling the failsafe feature starts a recurring **failsafe timer** for the channel. Once the failsafe timer is enabled, it must be reset within the specified time or the channel will enter a **failsafe state**. The failsafe timer may be reset by sending any valid command to the device\*. Resetting the failsafe timer will reload the timer with the specified _failsafe time_, starting when the message to reset the timer is received by the Phidget.
	   *
	   * _\*(**get** requests do not typically send commands and won't reset the failsafe timer)_
	   *
	   * For example: if the failsafe is enabled with a **failsafe time** of 1000ms, you will have 1000ms to reset the failsafe timer. Every time the failsafe timer is reset, you will have 1000ms from that time to reset the failsafe again.
	   *
	   * If the failsafe timer is not reset before it runs out, the channel will enter a **failsafe state**. For Digital Output channels, this will set the output State to FALSE. Once the channel enters the **failsafe state**, it will reject any further input until the channel is reopened.
	   *
	   * To prevent the channel from falsely entering the failsafe state, we recommend resetting the failsafe timer as frequently as is practical for your application. A good rule of thumb is to not let more than a third of the failsafe time pass before resetting the timer.
	   *
	   * Once the failsafe timer has been set, it cannot be disabled by any means other than closing and reopening the channel.
	   * @throws {@link PhidgetError}
	   * @param failsafeTime - Failsafe timeout in milliseconds
	   */


	  async enableFailsafe(failsafeTime) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: failsafeTime
	    });
	    await bp.send(this._ch, 146);
	  }
	  /**
	   * The minimum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @returns The failsafe time
	   * @throws {@link PhidgetError}
	   */


	  getMinFailsafeTime() {
	    this._assertOpen();

	    if (this.data.minFailsafeTime === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minFailsafeTime;
	  }
	  /**
	   * The maximum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @returns The failsafe time
	   * @throws {@link PhidgetError}
	   */


	  getMaxFailsafeTime() {
	    this._assertOpen();

	    if (this.data.maxFailsafeTime === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxFailsafeTime;
	  }
	  /**
	   * The `frequency` parameter sets the PWM frequency for all frequency-settable PWM outputs on the board.
	   * @returns The PWM frequency
	   * @throws {@link PhidgetError}
	   */


	  getFrequency() {
	    this._assertOpen();

	    if (this.data.frequency === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.frequency;
	  }
	  /**
	   * The `frequency` parameter sets the PWM frequency for all frequency-settable PWM outputs on the board.
	   * @throws {@link PhidgetError}
	   * @param frequency - The PWM frequency
	   */


	  async setFrequency(frequency) {
	    this._assertOpen();

	    if (frequency < this.data.minFrequency || frequency > this.data.maxFrequency) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minFrequency + " - " + this.data.maxFrequency + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: frequency
	    });
	    await bp.send(this._ch, 156);
	  }
	  /**
	   * The minimum value that `frequency` can be set to.
	   * @returns The frequency
	   * @throws {@link PhidgetError}
	   */


	  getMinFrequency() {
	    this._assertOpen();

	    if (this.data.minFrequency === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minFrequency;
	  }
	  /**
	   * The maximum value that `frequency` can be set to.
	   * @returns The frequency
	   * @throws {@link PhidgetError}
	   */


	  getMaxFrequency() {
	    this._assertOpen();

	    if (this.data.maxFrequency === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxFrequency;
	  }
	  /**
	   * The `LEDCurrentLimit` is the maximum amount of current that the controller will provide to the output.
	   *
	   * *   Reference the data sheet of the LED you are using before setting this value.
	   * @returns The current limit value
	   * @throws {@link PhidgetError}
	   */


	  getLEDCurrentLimit() {
	    this._assertOpen();

	    if (this.data.LEDCurrentLimit === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.LEDCurrentLimit;
	  }
	  /**
	   * The `LEDCurrentLimit` is the maximum amount of current that the controller will provide to the output.
	   *
	   * *   Reference the data sheet of the LED you are using before setting this value.
	   * @throws {@link PhidgetError}
	   * @param LEDCurrentLimit - The current limit value
	   */


	  async setLEDCurrentLimit(LEDCurrentLimit) {
	    this._assertOpen();

	    if (LEDCurrentLimit < this.data.minLEDCurrentLimit || LEDCurrentLimit > this.data.maxLEDCurrentLimit) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minLEDCurrentLimit + " - " + this.data.maxLEDCurrentLimit + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: LEDCurrentLimit
	    });
	    await bp.send(this._ch, 67);
	  }
	  /**
	   * The minimum value that `LEDCurrentLimit` can be set to.
	   * @returns The current limit value
	   * @throws {@link PhidgetError}
	   */


	  getMinLEDCurrentLimit() {
	    this._assertOpen();

	    if (this.data.minLEDCurrentLimit === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minLEDCurrentLimit;
	  }
	  /**
	   * The maximum value that `LEDCurrentLimit` can be set to.
	   * @returns The current limit value
	   * @throws {@link PhidgetError}
	   */


	  getMaxLEDCurrentLimit() {
	    this._assertOpen();

	    if (this.data.maxLEDCurrentLimit === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxLEDCurrentLimit;
	  }
	  /**
	   * The `LEDForwardVoltage` is the voltage that will be available to your LED.
	   *
	   * *   Reference the data sheet of the LED you are using before setting this value. Choose the `LEDForwardVoltage` that is closest to the forward voltage specified in the data sheet.
	   * *   This forward voltage is shared for all channels on this device. Setting the LEDForwardVoltage on any channel will set the LEDForwardVoltage for all channels on the device.
	   * @returns The forward voltage value
	   * @throws {@link PhidgetError}
	   */


	  getLEDForwardVoltage() {
	    this._assertOpen();

	    if (this.data.LEDForwardVoltage === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.LEDForwardVoltage;
	  }
	  /**
	   * The `LEDForwardVoltage` is the voltage that will be available to your LED.
	   *
	   * *   Reference the data sheet of the LED you are using before setting this value. Choose the `LEDForwardVoltage` that is closest to the forward voltage specified in the data sheet.
	   * *   This forward voltage is shared for all channels on this device. Setting the LEDForwardVoltage on any channel will set the LEDForwardVoltage for all channels on the device.
	   * @throws {@link PhidgetError}
	   * @param LEDForwardVoltage - The forward voltage value
	   */


	  async setLEDForwardVoltage(LEDForwardVoltage) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedLEDForwardVoltage(this._ch, LEDForwardVoltage)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified LEDForwardVoltage is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: LEDForwardVoltage
	    });
	    await bp.send(this._ch, 68);
	  }
	  /**
	   * Resets the failsafe timer, if one has been set. See `enableFailsafe()` for details.
	   *
	   * This function will fail if no failsafe timer has been set for the channel.
	   * @throws {@link PhidgetError}
	   */


	  async resetFailsafe() {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    await bp.send(this._ch, 147);
	  }
	  /**
	   * The `state` will indicate whether the output is high (TRUE) or low (FALSE).
	   *
	   * *   If a `dutyCycle` has been set, the state will return as TRUE if the DutyCycle is above 0.5, or FALSE otherwise.
	   * @returns The state value
	   * @throws {@link PhidgetError}
	   */


	  getState() {
	    this._assertOpen();

	    if (this.data.state === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.state;
	  }
	  /**
	   * The `state` will dictate whether the output is constantly high (TRUE) or low (FALSE).
	   *
	   * *   This will override any `dutyCycle` that may have been set on the channel.
	   * *   Setting the `state` to TRUE is the same as setting `dutyCycle` to 1.0, and setting the `state` to FALSE is the same as setting a `dutyCycle` of 0.0.
	   * @throws {@link PhidgetError}
	   * @param state - The state value
	   */


	  async setState(state) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (state !== false && state !== true) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be a boolean.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: state ? 1 : 0
	    });
	    await bp.send(this._ch, 82);
	  }

	}

	/** @public */

	class DigitalOutput extends DigitalOutputBase {
	  /** @internal */
	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 55:
	        this.data.state = bp.getNumber(0) ? 1 : 0;

	        super._bridgeInput(bp);

	        break;

	      case 82:
	        this.data.dutyCycle = bp.getBoolean(0) ? 1 : 0;

	        super._bridgeInput(bp);

	        break;

	      default:
	        super._bridgeInput(bp);

	        break;
	    }
	  }
	  /** @internal */


	  _errorHandler(code) {
	    switch (code) {
	      case exports.ErrorEventCode.FAILSAFE_CONDITION:
	        this.data.state = 0;
	        this.data.dutyCycle = 0;
	        break;

	      case exports.ErrorEventCode.INVALID_STATE_CONDITION:
	        this.data.state = 2;
	        this.data.dutyCycle = 1e+300;
	        break;
	    }
	  }

	}

	class RCServoBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onPositionChange = null;
	    this.onVelocityChange = null;
	    this.onTargetPositionReached = null;
	    this._class = exports.ChannelClass.RC_SERVO;
	    this.name = "RCServo";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 40:
	        this.data.acceleration = bp.entries[0].v;

	        this._FIREPropertyChange('Acceleration', bp);

	        break;

	      case 54:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.entries[1].v;else this.data.dataInterval = bp.entries[0].v;

	        this._FIREPropertyChange('DataInterval', bp);

	        this._FIREPropertyChange('DataRate', bp);

	        break;

	      case 57:
	        this.data.engaged = bp.entries[0].v;

	        this._FIREPropertyChange('Engaged', bp);

	        break;

	      case 146:
	        break;

	      case 70:
	        this.data.minPulseWidth = bp.entries[0].v;

	        this._FIREPropertyChange('MinPulseWidth', bp);

	        break;

	      case 69:
	        this.data.maxPulseWidth = bp.entries[0].v;

	        this._FIREPropertyChange('MaxPulseWidth', bp);

	        break;

	      case 147:
	        break;

	      case 81:
	        this.data.speedRampingState = bp.entries[0].v;

	        this._FIREPropertyChange('SpeedRampingState', bp);

	        break;

	      case 83:
	        this.data.targetPosition = bp.entries[0].v;

	        this._FIREPropertyChange('TargetPosition', bp);

	        break;

	      case 55:
	        this.data.torque = bp.entries[0].v;

	        this._FIREPropertyChange('Torque', bp);

	        break;

	      case 85:
	        this.data.velocityLimit = bp.entries[0].v;

	        this._FIREPropertyChange('VelocityLimit', bp);

	        break;

	      case 86:
	        this.data.voltage = bp.entries[0].v;

	        this._FIREPropertyChange('Voltage', bp);

	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      maxPulseWidthLimit: 1e+300,
	      maxPulseWidth: 1e+300,
	      maxPosition: 1e+300,
	      maxVelocityLimit: 1e+300,
	      maxAcceleration: 1e+300,
	      maxTorque: 1e+300,
	      minTorque: 1e+300,
	      minPulseWidthLimit: 1e+300,
	      minPulseWidth: 1e+300,
	      minPosition: 1e+300,
	      minVelocityLimit: 1e+300,
	      minAcceleration: 1e+300,
	      position: 1e+300,
	      targetPosition: 1e+300,
	      velocityLimit: 1e+300,
	      velocity: 1e+300,
	      acceleration: 1e+300,
	      torque: 1e+300,
	      isMoving: 2,
	      engaged: 2,
	      speedRampingState: 2,
	      voltage: 2147483647,
	      dataInterval: 1e+300,
	      maxDataInterval: 4294967295,
	      minDataInterval: 4294967295,
	      minDataRate: 1e+300,
	      maxDataRate: 1e+300,
	      maxFailsafeTime: 4294967295,
	      minFailsafeTime: 4294967295
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 347:
	        this.data.maxPulseWidthLimit = 4000;
	        this.data.maxPulseWidth = 2450;
	        this.data.maxPosition = 180;
	        this.data.maxVelocityLimit = 781250;
	        this.data.maxAcceleration = 3906250;
	        this.data.minPulseWidthLimit = 0.063;
	        this.data.minPulseWidth = 550;
	        this.data.minPosition = 0;
	        this.data.minVelocityLimit = 0;
	        this.data.minAcceleration = 156.25;
	        this.data.velocityLimit = 1900;
	        this.data.acceleration = 3800;
	        this.data.engaged = 0;
	        this.data.speedRampingState = 1;
	        this.data.voltage = exports.RCServoVoltage.VOLTS_5_0;
	        break;

	      case 348:
	        this.data.maxPulseWidthLimit = 4000;
	        this.data.maxPulseWidth = 2450;
	        this.data.maxPosition = 180;
	        this.data.maxVelocityLimit = 781250;
	        this.data.maxAcceleration = 3906250;
	        this.data.minPulseWidthLimit = 0.063;
	        this.data.minPulseWidth = 550;
	        this.data.minPosition = 0;
	        this.data.minVelocityLimit = 0;
	        this.data.minAcceleration = 156.25;
	        this.data.velocityLimit = 1900;
	        this.data.acceleration = 3800;
	        this.data.engaged = 0;
	        this.data.speedRampingState = 1;
	        this.data.voltage = exports.RCServoVoltage.VOLTS_5_0;
	        this.data.maxFailsafeTime = 30000;
	        this.data.minFailsafeTime = 500;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    switch (this._ch.chDef.uid) {
	      case 347:
	      case 348:
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {}
	  /**
	   * When changing velocity, the RC servo motor will accelerate/decelerate at this rate.
	   *
	   * *   The acceleration is bounded by `maxAcceleration` and `minAcceleration`.
	   *
	   * *   Using the **default settings** this acceleration will correspond acceleration of servo arm in **degrees/s2**, for many standard RC servos.
	   *
	   * *   `speedRampingState` controls whether or not the acceleration value is actually applied when trying to reach a target position.
	   * *   There is a practical limit on how fast your RC servo motor can accelerate. This is based on the load and physical design of the motor.
	   * *   The units for `targetPosition`, `velocityLimit`, and `acceleration` are configured by scaling the internal timing (set with `minPulseWidth` and `maxPulseWidth`) to a user specified range with `minPosition` and `maxPosition`.
	   *
	   *
	   *
	   * See `targetPosition` for a deeper explanation of how the settings of your RC Servo controller interact to move your servo.
	   * @throws {@link PhidgetError}
	   */


	  get acceleration() {
	    return this.getAcceleration();
	  }
	  /**
	   * The minimum value that `acceleration` can be set to.
	   *
	   * *   This value depends on `minPosition`/`maxPosition` and `minPulseWidth`/`maxPulseWidth`
	   * .
	   *
	   *
	   *
	   * See `targetPosition` for a deeper explanation of how the settings of your RC Servo controller interact to move your servo.
	   * @throws {@link PhidgetError}
	   */


	  get minAcceleration() {
	    return this.getMinAcceleration();
	  }
	  /**
	   * The maximum acceleration that `acceleration` can be set to.
	   *
	   * *   This value depends on `minPosition`/`maxPosition` and `minPulseWidth`/`maxPulseWidth`.
	   *
	   *
	   *
	   * See `targetPosition` for a deeper explanation of how the settings of your RC Servo controller interact to move your servo.
	   * @throws {@link PhidgetError}
	   */


	  get maxAcceleration() {
	    return this.getMaxAcceleration();
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `PositionChange` / `VelocityChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * @throws {@link PhidgetError}
	   */


	  get dataInterval() {
	    return this.getDataInterval();
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataInterval() {
	    return this.getMinDataInterval();
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataInterval() {
	    return this.getMaxDataInterval();
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   */


	  get dataRate() {
	    return this.getDataRate();
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataRate() {
	    return this.getMinDataRate();
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataRate() {
	    return this.getMaxDataRate();
	  }
	  /**
	   * When engaged, a RC servo motor has the ability to be positioned. When disengaged, no commands are sent to the RC servo motor.
	   *
	   * *   There is no position feedback to the controller, so the RC servo motor will immediately snap to the `targetPosition` after being engaged from a disengaged state.
	   * *   This property is useful for relaxing a servo once it has reached a given position.
	   * *   If you are concerned about tracking position accurately, you should not disengage the motor while `isMoving` is true.
	   * @throws {@link PhidgetError}
	   */


	  get engaged() {
	    return this.getEngaged();
	  }
	  /**
	   * The minimum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @throws {@link PhidgetError}
	   */


	  get minFailsafeTime() {
	    return this.getMinFailsafeTime();
	  }
	  /**
	   * The maximum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @throws {@link PhidgetError}
	   */


	  get maxFailsafeTime() {
	    return this.getMaxFailsafeTime();
	  }
	  /**
	   * `isMoving` returns true if the RC servo motor is currently in motion.
	   *
	   * *   The controller cannot know if the RC servo motor is physically moving. When `isMoving` is false, it simply means there are no commands in the pipeline to the RC servo motor.
	   * @throws {@link PhidgetError}
	   */


	  get isMoving() {
	    return this.getIsMoving();
	  }
	  /**
	   * The most recent position of the RC servo motor that the controller has reported.
	   *
	   * *   This value will always be between `minPosition` and `maxPosition`.
	   *
	   * *   Using the **default settings** this position will correspond to the rotation of the servo arm in **degrees**, for many standard RC servos.
	   *
	   *
	   *
	   * See `targetPosition` for a deeper explanation of how the settings of your RC Servo controller interact to move your servo.
	   * @throws {@link PhidgetError}
	   */


	  get position() {
	    return this.getPosition();
	  }
	  /**
	   * The minimum position that `targetPosition` can be set to.
	   *
	   * *   The units for `targetPosition`, `velocityLimit`, and `acceleration` are configured by scaling the internal timing (set with `minPulseWidth` and `maxPulseWidth`) to a user specified range with `minPosition` and `maxPosition`.
	   *
	   *
	   *
	   * See `targetPosition` for a deeper explanation of how the settings of your RC Servo controller interact to move your servo.
	   * @throws {@link PhidgetError}
	   */


	  get minPosition() {
	    return this.getMinPosition();
	  }

	  set minPosition(minPosition) {
	    this.setMinPosition(minPosition);
	  }
	  /**
	   * The maximum position `targetPosition` can be set to.
	   *
	   * *   The units for `targetPosition`, `velocityLimit`, and `acceleration` are configured by scaling the internal timing (set with `minPulseWidth` and `maxPulseWidth`) to a user specified range with `minPosition` and `maxPosition`.
	   *
	   *
	   *
	   * See `targetPosition` for a deeper explanation of how the settings of your RC Servo controller interact to move your servo.
	   * @throws {@link PhidgetError}
	   */


	  get maxPosition() {
	    return this.getMaxPosition();
	  }

	  set maxPosition(maxPosition) {
	    this.setMaxPosition(maxPosition);
	  }
	  /**
	   * The `minPulseWidth` represents the minimum pulse width that your RC servo motor specifies.
	   *
	   * *   This value can be found in the data sheet of most RC servo motors.
	   * *   The units for `targetPosition`, `velocityLimit`, and `acceleration` are configured by scaling the internal timing (set with `minPulseWidth` and `maxPulseWidth`) to a user specified range with `minPosition` and `maxPosition`.
	   *
	   *
	   *
	   * See `targetPosition` for a deeper explanation of how the settings of your RC Servo controller interact to move your servo.
	   * @throws {@link PhidgetError}
	   */


	  get minPulseWidth() {
	    return this.getMinPulseWidth();
	  }
	  /**
	   * The `maxPulseWidth` represents the maximum pulse width that your RC servo motor specifies.
	   *
	   * *   This value can be found in the data sheet of most RC servo motors.
	   * *   The units for `targetPosition`, `velocityLimit`, and `acceleration` are configured by scaling the internal timing (set with `minPulseWidth` and `maxPulseWidth`) to a user specified range with `minPosition` and `maxPosition`.
	   *
	   *
	   *
	   * See `targetPosition` for a deeper explanation of how the settings of your RC Servo controller interact to move your servo.
	   * @throws {@link PhidgetError}
	   */


	  get maxPulseWidth() {
	    return this.getMaxPulseWidth();
	  }
	  /**
	   * The minimum pulse width that `minPulseWidth` can be set to.
	   *
	   * See `targetPosition` for a deeper explanation of how the settings of your RC Servo controller interact to move your servo.
	   * @throws {@link PhidgetError}
	   */


	  get minPulseWidthLimit() {
	    return this.getMinPulseWidthLimit();
	  }
	  /**
	   * The maximum pulse width that `maxPulseWidth` can be set to.
	   *
	   * See `targetPosition` for a deeper explanation of how the settings of your RC Servo controller interact to move your servo.
	   * @throws {@link PhidgetError}
	   */


	  get maxPulseWidthLimit() {
	    return this.getMaxPulseWidthLimit();
	  }
	  /**
	   * When speed ramping state is enabled, the controller will take the `acceleration` and `velocityLimit` properties into account when moving the RC servo motor, usually resulting in smooth motion. If speed ramping state is not enabled, the controller will simply set the RC servo motor to the requested position.
	   * @throws {@link PhidgetError}
	   */


	  get speedRampingState() {
	    return this.getSpeedRampingState();
	  }
	  /**
	   * If the RC servo motor is configured and `targetPosition` is set, the controller will continuously try to reach targeted position.
	   *
	   * *   The target position is bounded by `minPosition` and `maxPosition`.
	   *
	   * *   Using the **default settings** this position will correspond to the rotation of the servo arm in **degrees**, for many standard RC servos.
	   *
	   * *   If the RC servo motor is not engaged, then the position cannot be read.
	   * *   The position can still be set while the RC servo motor is not engaged. Once engaged, the RC servo motor will snap to position, assuming it is not there already.
	   * *   The units for `targetPosition`, `velocityLimit`, and `acceleration` are configured by scaling the internal timing (set with `minPulseWidth` and `maxPulseWidth`) to a user specified range with `minPosition` and `maxPosition`.
	   *
	   * ### Position and Pulse Width
	   *
	   * *   An RC servo motor's position is controlled using a type of **Pulse Width Modulation**, sending voltage pulses of a given time span, or **Pulse Width** to the servo.
	   * *   The servo translates the **Pulse Width** of the control signal to a corresponding position of the servo arm.
	   * *   Knowing this, a servo's range of motion can be thought of in terms of a `minPulseWidth` and a `maxPulseWidth` corresponding to range of pulse widths that produce the servo arm's full **range of movement**.
	   *
	   * *   In Phidget22, you can adjust the `minPulseWidth` and `maxPulseWidth` stored by the library to match the desired **range of movement** you expect from your servo.
	   *
	   * *   Since directly setting the timing of RC servo pulse widths is not very intuitive for most purpses, we map these pulse widths to a user-defied _**Minimum**_ and _**Maximum**_ **Position**.This allows you to define the servo's position in terms best suited to your application, such as degrees, fractions of a rotation, or even some measure of speed for a continuous-rotation servo.
	   * *   By setting the servo's `targetPosition` to `maxPosition`, the controller will send pulses of `maxPulseWidth` to the servo.
	   *     *   Similarly, `minPosition` will send pulses of `minPulseWidth` to the servo
	   *     *   `maxPosition` can be set smaller than `minPosition` to invert movement of the servo, if it helps your application.
	   * *   Setting a `targetPosition` will transate the position between `minPosition` and `maxPosition` to a corresponding **Pulse Width** between `minPulseWidth` and `maxPulseWidth`, in turn sending the servo arm to the desired position.
	   * *   Setting `velocityLimit` and `acceleration` for your servo will limit the rate of change of the servo's position in terms of one _**UserUnit**_ per second (or /s2). Here, a _**UserUnit**_ is whatever distance is maked by the change of the `targetPosition` by **1.0**
	   *
	   * ### Adjusting the Servo's Limits
	   *
	   * *   **To tune your program to a specific servo:**
	   *
	   * 1.  First adjust the servo's range of motion by setting the `maxPulseWidth` and `minPulseWidth`. You can use the default values for these _(or the ones on your servo's datasheet)_ as a starting point.
	   * 2.  Send the servo to `maxPosition` and `minPosition` to check the results. Repeat steps 1 and 2 as nessesarry.
	   * 3.  Set the `maxPosition` and `minPosition` to match whatever numbers you find best suited to your application.
	   * @throws {@link PhidgetError}
	   */


	  get targetPosition() {
	    return this.getTargetPosition();
	  }
	  /**
	   * The `torque` is a ratio of the maximum available torque.
	   *
	   * *   The torque is bounded by `minTorque` and `maxTorque`
	   * *   Increasing the torque will increase the speed and power consumption of the RC servo motor.
	   * @throws {@link PhidgetError}
	   */


	  get torque() {
	    return this.getTorque();
	  }
	  /**
	   * The minimum value that `torque` can be set to.
	   *
	   * *   `torque` is a ratio of the maximum available torque, therefore the minimum torque is a unitless constant.
	   * @throws {@link PhidgetError}
	   */


	  get minTorque() {
	    return this.getMinTorque();
	  }
	  /**
	   * The maximum value that `torque` can be set to.
	   *
	   * *   `torque` is a ratio of the maximum available torque, therefore the minimum torque is a unitless constant.
	   * @throws {@link PhidgetError}
	   */


	  get maxTorque() {
	    return this.getMaxTorque();
	  }
	  /**
	   * The velocity that the RC servo motor is being driven at.
	   *
	   * *   A negative value means the RC servo motor is moving towards a lower position.
	   * *   The velocity range of the RC servo motor will be from -`velocityLimit` to +`velocityLimit`, depending on direction.
	   * *   This is not the actual physical velocity of the RC servo motor.
	   *
	   *
	   *
	   * See `targetPosition` for a deeper explanation of how the settings of your RC Servo controller interact to move your servo.
	   * @throws {@link PhidgetError}
	   */


	  get velocity() {
	    return this.getVelocity();
	  }
	  /**
	   * When moving, the RC servo motor velocity will be limited by this value.*   The velocity limit is bounded by `minVelocityLimit` and `maxVelocityLimit`.
	   *
	   * *   Using the **default settings** this velocity will correspond to the maximum speed of rotation of servo arm in **degrees/s**, for many standard RC servos.
	   *
	   * *   `speedRampingState` controls whether or not the velocity limit value is actually applied when trying to reach a target position.
	   * *   The velocity range of the RC servo motor will be from -`velocityLimit` to +`velocityLimit`, depending on direction.
	   * *   Note that when this value is set to 0, the RC servo motor will not move.
	   * *   There is a practical limit on how fast your servo can rotate, based on the physical design of the motor.
	   * *   The units for `targetPosition`, `velocityLimit`, and `acceleration` are configured by scaling the internal timing (set with `minPulseWidth` and `maxPulseWidth`) to a user specified range with `minPosition` and `maxPosition`.
	   *
	   *
	   * See `targetPosition` for a deeper explanation of how the settings of your RC Servo controller interact to move your servo.
	   * @throws {@link PhidgetError}
	   */


	  get velocityLimit() {
	    return this.getVelocityLimit();
	  }
	  /**
	   * The minimum velocity `velocityLimit` can be set to.
	   *
	   * See `targetPosition` for a deeper explanation of how the settings of your RC Servo controller interact to move your servo.
	   * @throws {@link PhidgetError}
	   */


	  get minVelocityLimit() {
	    return this.getMinVelocityLimit();
	  }
	  /**
	   * The maximum velocity `velocityLimit` can be set to. This value depends on `minPosition`/`maxPosition` and `minPulseWidth`/`maxPulseWidth`.
	   *
	   * See `targetPosition` for a deeper explanation of how the settings of your RC Servo controller interact to move your servo.
	   * @throws {@link PhidgetError}
	   */


	  get maxVelocityLimit() {
	    return this.getMaxVelocityLimit();
	  }
	  /**
	   * The supply voltage for the RC servo motor.
	   *
	   * *   If your controller supports multiple RC servo motors, every motor will have the same supply voltage. It is not possible to set individual supply voltages.
	   * @throws {@link PhidgetError}
	   */


	  get voltage() {
	    return this.getVoltage();
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `PositionChange` / `VelocityChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getDataInterval() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dataInterval;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `PositionChange` / `VelocityChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * @throws {@link PhidgetError}
	   * @param dataInterval - The data interval value
	   */


	  async setDataInterval(dataInterval) {
	    this._assertOpen();

	    if (dataInterval < this.data.minDataInterval || dataInterval > this.data.maxDataInterval) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataInterval + " - " + this.data.maxDataInterval + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: dataInterval
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataInterval() {
	    this._assertOpen();

	    if (this.data.minDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataInterval;
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataInterval() {
	    this._assertOpen();

	    if (this.data.maxDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @returns The data rate for the channel
	   * @throws {@link PhidgetError}
	   */


	  getDataRate() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return 1000.0 / this.data.dataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   * @param dataRate - The data rate for the channel
	   */


	  async setDataRate(dataRate) {
	    this._assertOpen();

	    if (dataRate < this.data.minDataRate || dataRate > this.data.maxDataRate) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataRate + " - " + this.data.maxDataRate + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: Math.round(1000.0 / dataRate)
	    });
	    bp.set({
	      name: "1",
	      type: "g",
	      value: 1000.0 / dataRate
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataRate() {
	    this._assertOpen();

	    if (this.data.minDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataRate;
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataRate() {
	    this._assertOpen();

	    if (this.data.maxDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataRate;
	  }
	  /**
	   * When engaged, a RC servo motor has the ability to be positioned. When disengaged, no commands are sent to the RC servo motor.
	   *
	   * *   There is no position feedback to the controller, so the RC servo motor will immediately snap to the `targetPosition` after being engaged from a disengaged state.
	   * *   This property is useful for relaxing a servo once it has reached a given position.
	   * *   If you are concerned about tracking position accurately, you should not disengage the motor while `isMoving` is true.
	   * @returns The engaged value
	   * @throws {@link PhidgetError}
	   */


	  getEngaged() {
	    this._assertOpen();

	    if (this.data.engaged === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.engaged;
	  }
	  /**
	   * When engaged, a RC servo motor has the ability to be positioned. When disengaged, no commands are sent to the RC servo motor.
	   *
	   * *   There is no position feedback to the controller, so the RC servo motor will immediately snap to the `targetPosition` after being engaged from a disengaged state.
	   * *   This property is useful for relaxing a servo once it has reached a given position.
	   * *   If you are concerned about tracking position accurately, you should not disengage the motor while `isMoving` is true.
	   * @throws {@link PhidgetError}
	   * @param engaged - The engaged value
	   */


	  async setEngaged(engaged) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (engaged !== false && engaged !== true) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be a boolean.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: engaged ? 1 : 0
	    });
	    await bp.send(this._ch, 57);
	  }
	  /**
	   * Enables the **failsafe** feature for the channel, with a given **failsafe time**.
	   *
	   * The **failsafe** feature is intended for use in applications where it is important for the channel to enter a known _safe state_ if the program controlling it locks up or crashes. If you do not enable the failsafe feature, the channel will carry out whatever instructions it was last given until it is explicitly told to stop.
	   *
	   * Enabling the failsafe feature starts a recurring **failsafe timer** for the channel. Once the failsafe timer is enabled, it must be reset within the specified time or the channel will enter a **failsafe state**. The failsafe timer may be reset by sending any valid command to the device\*. Resetting the failsafe timer will reload the timer with the specified _failsafe time_, starting when the message to reset the timer is received by the Phidget.
	   *
	   * _\*(**get** requests do not typically send commands and won't reset the failsafe timer)_
	   *
	   * For example: if the failsafe is enabled with a **failsafe time** of 1000ms, you will have 1000ms to reset the failsafe timer. Every time the failsafe timer is reset, you will have 1000ms from that time to reset the failsafe again.
	   *
	   * If the failsafe timer is not reset before it runs out, the channel will enter a **failsafe state**. For RC Servo channels, this will disengage the servo. Once the channel enters the **failsafe state**, it will reject any further input until the channel is reopened.
	   *
	   * To prevent the channel from falsely entering the failsafe state, we recommend resetting the failsafe timer as frequently as is practical for your application. A good rule of thumb is to not let more than a third of the failsafe time pass before resetting the timer.
	   *
	   * Once the failsafe timer has been set, it cannot be disabled by any means other than closing and reopening the channel.
	   * @throws {@link PhidgetError}
	   * @param failsafeTime - Failsafe timeout in milliseconds
	   */


	  async enableFailsafe(failsafeTime) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: failsafeTime
	    });
	    await bp.send(this._ch, 146);
	  }
	  /**
	   * The minimum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @returns The failsafe time
	   * @throws {@link PhidgetError}
	   */


	  getMinFailsafeTime() {
	    this._assertOpen();

	    if (this.data.minFailsafeTime === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minFailsafeTime;
	  }
	  /**
	   * The maximum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @returns The failsafe time
	   * @throws {@link PhidgetError}
	   */


	  getMaxFailsafeTime() {
	    this._assertOpen();

	    if (this.data.maxFailsafeTime === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxFailsafeTime;
	  }
	  /**
	   * `isMoving` returns true if the RC servo motor is currently in motion.
	   *
	   * *   The controller cannot know if the RC servo motor is physically moving. When `isMoving` is false, it simply means there are no commands in the pipeline to the RC servo motor.
	   * @returns The moving value
	   * @throws {@link PhidgetError}
	   */


	  getIsMoving() {
	    this._assertOpen();

	    if (this.data.isMoving === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.isMoving;
	  }
	  /**
	   * The minimum position that `targetPosition` can be set to.
	   *
	   * *   The units for `targetPosition`, `velocityLimit`, and `acceleration` are configured by scaling the internal timing (set with `minPulseWidth` and `maxPulseWidth`) to a user specified range with `minPosition` and `maxPosition`.
	   *
	   *
	   *
	   * See `targetPosition` for a deeper explanation of how the settings of your RC Servo controller interact to move your servo.
	   * @returns The position value
	   * @throws {@link PhidgetError}
	   */


	  getMinPosition() {
	    this._assertOpen();

	    if (this.data.minPosition === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minPosition;
	  }
	  /**
	   * The maximum position `targetPosition` can be set to.
	   *
	   * *   The units for `targetPosition`, `velocityLimit`, and `acceleration` are configured by scaling the internal timing (set with `minPulseWidth` and `maxPulseWidth`) to a user specified range with `minPosition` and `maxPosition`.
	   *
	   *
	   *
	   * See `targetPosition` for a deeper explanation of how the settings of your RC Servo controller interact to move your servo.
	   * @returns The position value
	   * @throws {@link PhidgetError}
	   */


	  getMaxPosition() {
	    this._assertOpen();

	    if (this.data.maxPosition === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxPosition;
	  }
	  /**
	   * The `minPulseWidth` represents the minimum pulse width that your RC servo motor specifies.
	   *
	   * *   This value can be found in the data sheet of most RC servo motors.
	   * *   The units for `targetPosition`, `velocityLimit`, and `acceleration` are configured by scaling the internal timing (set with `minPulseWidth` and `maxPulseWidth`) to a user specified range with `minPosition` and `maxPosition`.
	   *
	   *
	   *
	   * See `targetPosition` for a deeper explanation of how the settings of your RC Servo controller interact to move your servo.
	   * @throws {@link PhidgetError}
	   * @param minPulseWidth - The pulse width value
	   */


	  async setMinPulseWidth(minPulseWidth) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: minPulseWidth
	    });
	    await bp.send(this._ch, 70);
	  }
	  /**
	   * The `minPulseWidth` represents the minimum pulse width that your RC servo motor specifies.
	   *
	   * *   This value can be found in the data sheet of most RC servo motors.
	   * *   The units for `targetPosition`, `velocityLimit`, and `acceleration` are configured by scaling the internal timing (set with `minPulseWidth` and `maxPulseWidth`) to a user specified range with `minPosition` and `maxPosition`.
	   *
	   *
	   *
	   * See `targetPosition` for a deeper explanation of how the settings of your RC Servo controller interact to move your servo.
	   * @returns The pulse width value
	   * @throws {@link PhidgetError}
	   */


	  getMinPulseWidth() {
	    this._assertOpen();

	    if (this.data.minPulseWidth === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minPulseWidth;
	  }
	  /**
	   * The `maxPulseWidth` represents the maximum pulse width that your RC servo motor specifies.
	   *
	   * *   This value can be found in the data sheet of most RC servo motors.
	   * *   The units for `targetPosition`, `velocityLimit`, and `acceleration` are configured by scaling the internal timing (set with `minPulseWidth` and `maxPulseWidth`) to a user specified range with `minPosition` and `maxPosition`.
	   *
	   *
	   *
	   * See `targetPosition` for a deeper explanation of how the settings of your RC Servo controller interact to move your servo.
	   * @throws {@link PhidgetError}
	   * @param maxPulseWidth - The pulse width value
	   */


	  async setMaxPulseWidth(maxPulseWidth) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: maxPulseWidth
	    });
	    await bp.send(this._ch, 69);
	  }
	  /**
	   * The `maxPulseWidth` represents the maximum pulse width that your RC servo motor specifies.
	   *
	   * *   This value can be found in the data sheet of most RC servo motors.
	   * *   The units for `targetPosition`, `velocityLimit`, and `acceleration` are configured by scaling the internal timing (set with `minPulseWidth` and `maxPulseWidth`) to a user specified range with `minPosition` and `maxPosition`.
	   *
	   *
	   *
	   * See `targetPosition` for a deeper explanation of how the settings of your RC Servo controller interact to move your servo.
	   * @returns The pulse width value
	   * @throws {@link PhidgetError}
	   */


	  getMaxPulseWidth() {
	    this._assertOpen();

	    if (this.data.maxPulseWidth === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxPulseWidth;
	  }
	  /**
	   * The minimum pulse width that `minPulseWidth` can be set to.
	   *
	   * See `targetPosition` for a deeper explanation of how the settings of your RC Servo controller interact to move your servo.
	   * @returns The pulse width value
	   * @throws {@link PhidgetError}
	   */


	  getMinPulseWidthLimit() {
	    this._assertOpen();

	    if (this.data.minPulseWidthLimit === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minPulseWidthLimit;
	  }
	  /**
	   * The maximum pulse width that `maxPulseWidth` can be set to.
	   *
	   * See `targetPosition` for a deeper explanation of how the settings of your RC Servo controller interact to move your servo.
	   * @returns The pulse width value
	   * @throws {@link PhidgetError}
	   */


	  getMaxPulseWidthLimit() {
	    this._assertOpen();

	    if (this.data.maxPulseWidthLimit === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxPulseWidthLimit;
	  }
	  /**
	   * Resets the failsafe timer, if one has been set. See `enableFailsafe()` for details.
	   *
	   * This function will fail if no failsafe timer has been set for the channel.
	   * @throws {@link PhidgetError}
	   */


	  async resetFailsafe() {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    await bp.send(this._ch, 147);
	  }
	  /**
	   * When speed ramping state is enabled, the controller will take the `acceleration` and `velocityLimit` properties into account when moving the RC servo motor, usually resulting in smooth motion. If speed ramping state is not enabled, the controller will simply set the RC servo motor to the requested position.
	   * @returns The speed ramping state value
	   * @throws {@link PhidgetError}
	   */


	  getSpeedRampingState() {
	    this._assertOpen();

	    if (this.data.speedRampingState === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.speedRampingState;
	  }
	  /**
	   * When speed ramping state is enabled, the controller will take the `acceleration` and `velocityLimit` properties into account when moving the RC servo motor, usually resulting in smooth motion. If speed ramping state is not enabled, the controller will simply set the RC servo motor to the requested position.
	   * @throws {@link PhidgetError}
	   * @param speedRampingState - The speed ramping state value
	   */


	  async setSpeedRampingState(speedRampingState) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (speedRampingState !== false && speedRampingState !== true) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be a boolean.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: speedRampingState ? 1 : 0
	    });
	    await bp.send(this._ch, 81);
	  }
	  /**
	   * The `torque` is a ratio of the maximum available torque.
	   *
	   * *   The torque is bounded by `minTorque` and `maxTorque`
	   * *   Increasing the torque will increase the speed and power consumption of the RC servo motor.
	   * @returns The torque value.
	   * @throws {@link PhidgetError}
	   */


	  getTorque() {
	    this._assertOpen();

	    if (this.data.torque === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.torque;
	  }
	  /**
	   * The `torque` is a ratio of the maximum available torque.
	   *
	   * *   The torque is bounded by `minTorque` and `maxTorque`
	   * *   Increasing the torque will increase the speed and power consumption of the RC servo motor.
	   * @throws {@link PhidgetError}
	   * @param torque - The torque value.
	   */


	  async setTorque(torque) {
	    this._assertOpen();

	    if (torque < this.data.minTorque || torque > this.data.maxTorque) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minTorque + " - " + this.data.maxTorque + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: torque
	    });
	    await bp.send(this._ch, 55);
	  }
	  /**
	   * The minimum value that `torque` can be set to.
	   *
	   * *   `torque` is a ratio of the maximum available torque, therefore the minimum torque is a unitless constant.
	   * @returns The torque value
	   * @throws {@link PhidgetError}
	   */


	  getMinTorque() {
	    this._assertOpen();

	    if (this.data.minTorque === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minTorque;
	  }
	  /**
	   * The maximum value that `torque` can be set to.
	   *
	   * *   `torque` is a ratio of the maximum available torque, therefore the minimum torque is a unitless constant.
	   * @returns The torque value
	   * @throws {@link PhidgetError}
	   */


	  getMaxTorque() {
	    this._assertOpen();

	    if (this.data.maxTorque === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxTorque;
	  }
	  /**
	   * The supply voltage for the RC servo motor.
	   *
	   * *   If your controller supports multiple RC servo motors, every motor will have the same supply voltage. It is not possible to set individual supply voltages.
	   * @returns The voltage value
	   * @throws {@link PhidgetError}
	   */


	  getVoltage() {
	    this._assertOpen();

	    if (this.data.voltage === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.voltage;
	  }
	  /**
	   * The supply voltage for the RC servo motor.
	   *
	   * *   If your controller supports multiple RC servo motors, every motor will have the same supply voltage. It is not possible to set individual supply voltages.
	   * @throws {@link PhidgetError}
	   * @param voltage - The voltage value
	   */


	  async setVoltage(voltage) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedRCServoVoltage(this._ch, voltage)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified RCServoVoltage is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: voltage
	    });
	    await bp.send(this._ch, 86);
	  }

	}

	/** @public */

	class RCServo extends RCServoBase {
	  /** @internal */
	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 57:
	        if (bp.getBoolean(0) === true && this.data.velocityLimit !== 0 && this.data.position !== this.data.targetPosition) this.data.isMoving = 1;

	        super._bridgeInput(bp);

	        break;

	      case 85:
	        if (this.data.engaged && bp.getNumber(0) !== 0 && this.data.position !== this.data.targetPosition) this.data.isMoving = 1;

	        super._bridgeInput(bp);

	        break;

	      case 83:
	        if (this.data.engaged && this.data.velocityLimit !== 0 && this.data.position !== bp.getNumber(0)) this.data.isMoving = 1;

	        super._bridgeInput(bp);

	        break;

	      case 29:
	        this.data.position = bp.getNumber(0);

	        if (this._isAttachedDone && this.onPositionChange) {
	          try {
	            this.onPositionChange(this._positionUser(this.data.position));
	          } catch (err) {
	            logEventException(err);
	          }
	        }

	        break;

	      case 100:
	        this.data.velocity = bp.getNumber(0);

	        if (this._isAttachedDone && this.onVelocityChange) {
	          try {
	            this.onVelocityChange(this._velocityUser(this.data.velocity));
	          } catch (err) {
	            logEventException(err);
	          }
	        }

	        break;

	      case 94:
	        this.data.position = bp.getNumber(0);
	        this.data.isMoving = 0;

	        if (this._isAttachedDone && this.onTargetPositionReached) {
	          try {
	            this.onTargetPositionReached(this._positionUser(this.data.position));
	          } catch (err) {
	            logEventException(err);
	          }
	        }

	        break;

	      default:
	        super._bridgeInput(bp);

	        break;
	    }
	  }
	  /** @internal */


	  _positionUser(position_us) {
	    return this.data.minPosition + (position_us - this.data.minPulseWidth) / (this.data.maxPulseWidth - this.data.minPulseWidth) * this.data.maxPosition - this.data.minPosition;
	  }
	  /** @internal */


	  _positionUS(position_user) {
	    if (this.data.maxPosition > this.data.minPosition) return this.data.minPulseWidth + (this.data.maxPulseWidth - this.data.minPulseWidth) * (position_user - this.data.minPosition) / (this.data.maxPosition - this.data.minPosition);
	    return this.data.maxPulseWidth + (this.data.maxPulseWidth - this.data.minPulseWidth) * (position_user - this.data.maxPosition) / (this.data.maxPosition - this.data.minPosition);
	  }
	  /** @internal */


	  _velocityUser(velocity_us) {
	    return Math.abs(this.data.maxPosition - this.data.minPosition) * velocity_us / (this.data.maxPulseWidth - this.data.minPulseWidth);
	  }
	  /** @internal */


	  _velocityUS(velocity_user) {
	    return (this.data.maxPulseWidth - this.data.minPulseWidth) * velocity_user / Math.abs(this.data.maxPosition - this.data.minPosition);
	  }
	  /** @internal */


	  _accelUser(accel_us) {
	    return Math.abs(this.data.maxPosition - this.data.minPosition) * accel_us / (this.data.maxPulseWidth - this.data.minPulseWidth);
	  }
	  /** @internal */


	  _accelUS(accel_user) {
	    return (this.data.maxPulseWidth - this.data.minPulseWidth) * accel_user / Math.abs(this.data.maxPosition - this.data.minPosition);
	  }

	  getAcceleration() {
	    this._assertOpen();

	    if (this.data.acceleration === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this._accelUser(this.data.acceleration);
	  }

	  getMinAcceleration() {
	    this._assertOpen();

	    if (this.data.minAcceleration === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this._accelUser(this.data.minAcceleration);
	  }

	  getMaxAcceleration() {
	    this._assertOpen();

	    if (this.data.maxAcceleration === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this._accelUser(this.data.maxAcceleration);
	  }

	  getPosition() {
	    this._assertOpen();

	    if (this.data.position === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this._positionUser(this.data.position);
	  }

	  setMaxPosition(maxPosition) {
	    this._assertOpen();

	    this.data.maxPosition = maxPosition;
	  }

	  setMinPosition(minPosition) {
	    this._assertOpen();

	    this.data.minPosition = minPosition;
	  }

	  getTargetPosition() {
	    this._assertOpen();

	    if (this.data.targetPosition === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this._positionUser(this.data.targetPosition);
	  }

	  getVelocity() {
	    this._assertOpen();

	    if (this.data.velocity === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this._velocityUser(this.data.velocity);
	  }

	  getVelocityLimit() {
	    this._assertOpen();

	    if (this.data.velocityLimit === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this._velocityUser(this.data.velocityLimit);
	  }

	  getMinVelocityLimit() {
	    this._assertOpen();

	    if (this.data.minVelocityLimit === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this._velocityUser(this.data.minVelocityLimit);
	  }

	  getMaxVelocityLimit() {
	    this._assertOpen();

	    if (this.data.maxVelocityLimit === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this._velocityUser(this.data.maxVelocityLimit);
	  }

	  async setAcceleration(acceleration) {
	    this._assertOpen();

	    acceleration = this._accelUS(acceleration);
	    if (acceleration < this.data.minAcceleration || acceleration > this.data.maxAcceleration) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.minAcceleration + " - " + this.maxAcceleration + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: acceleration
	    });
	    await bp.send(this._ch, 40);
	  }

	  async setTargetPosition(targetPosition) {
	    this._assertOpen();

	    targetPosition = this._positionUS(targetPosition);
	    if (targetPosition < this.data.minPulseWidth || targetPosition > this.data.maxPulseWidth) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.minPosition + " - " + this.maxPosition + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: targetPosition
	    });
	    await bp.send(this._ch, 83);
	  }

	  async setVelocityLimit(velocityLimit) {
	    this._assertOpen();

	    velocityLimit = this._velocityUS(velocityLimit);
	    if (velocityLimit < this.data.minVelocityLimit || velocityLimit > this.data.maxVelocityLimit) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.minVelocityLimit + " - " + this.maxVelocityLimit + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: velocityLimit
	    });
	    await bp.send(this._ch, 85);
	  }

	}

	class VoltageOutputBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this._class = exports.ChannelClass.VOLTAGE_OUTPUT;
	    this.name = "VoltageOutput";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 56:
	        this.data.enabled = bp.entries[0].v;

	        this._FIREPropertyChange('Enabled', bp);

	        break;

	      case 146:
	        break;

	      case 147:
	        break;

	      case 86:
	        this.data.voltage = bp.entries[0].v;

	        this._FIREPropertyChange('Voltage', bp);

	        break;

	      case 87:
	        this.data.voltageOutputRange = bp.entries[0].v;

	        this._FIREPropertyChange('VoltageOutputRange', bp);

	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      enabled: 2,
	      maxVoltage: 1e+300,
	      minVoltage: 1e+300,
	      voltage: 1e+300,
	      voltageOutputRange: 2147483647,
	      maxFailsafeTime: 4294967295,
	      minFailsafeTime: 4294967295
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 219:
	        this.data.enabled = 1;
	        this.data.maxVoltage = 4.2;
	        this.data.minVoltage = 0;
	        this.data.voltage = 0;
	        break;

	      case 220:
	        this.data.enabled = 1;
	        this.data.maxVoltage = 4.2;
	        this.data.minVoltage = 0;
	        this.data.voltage = 0;
	        this.data.maxFailsafeTime = 30000;
	        this.data.minFailsafeTime = 500;
	        break;

	      case 221:
	      case 223:
	        this.data.enabled = 1;
	        this.data.voltage = 0;
	        this.data.voltageOutputRange = exports.VoltageOutputRange.VOLTS_10;
	        break;

	      case 222:
	      case 224:
	        this.data.enabled = 1;
	        this.data.voltage = 0;
	        this.data.voltageOutputRange = exports.VoltageOutputRange.VOLTS_10;
	        this.data.maxFailsafeTime = 30000;
	        this.data.minFailsafeTime = 500;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    let bp;

	    switch (this._ch.chDef.uid) {
	      case 219:
	      case 220:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.enabled
	        });
	        await bp.send(this._ch, 56);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.voltage
	        });
	        await bp.send(this._ch, 86);
	        break;

	      case 221:
	      case 222:
	      case 223:
	      case 224:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.voltageOutputRange
	        });
	        await bp.send(this._ch, 87);
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {}
	  /**
	   * Enable the output voltage by setting `enabled` to true.
	   *
	   * *   Disable the output by seting `enabled` to false to save power.
	   * @throws {@link PhidgetError}
	   */


	  get enabled() {
	    return this.getEnabled();
	  }
	  /**
	   * The minimum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @throws {@link PhidgetError}
	   */


	  get minFailsafeTime() {
	    return this.getMinFailsafeTime();
	  }
	  /**
	   * The maximum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @throws {@link PhidgetError}
	   */


	  get maxFailsafeTime() {
	    return this.getMaxFailsafeTime();
	  }
	  /**
	   * The voltage value that the channel will output.
	   *
	   * *   The `voltage` value is bounded by `minVoltage` and `maxVoltage`.
	   * *   The voltage value will not be output until `enabled` is set to true.
	   * @throws {@link PhidgetError}
	   */


	  get voltage() {
	    return this.getVoltage();
	  }
	  /**
	   * The minimum value that `voltage` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minVoltage() {
	    return this.getMinVoltage();
	  }
	  /**
	   * The maximum value that `voltage` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxVoltage() {
	    return this.getMaxVoltage();
	  }
	  /**
	   * Choose a `voltageOutputRange` that best suits your application.
	   *
	   * *   Changing the `voltageOutputRange` will also affect the `minVoltage` and `maxVoltage` values.
	   * @throws {@link PhidgetError}
	   */


	  get voltageOutputRange() {
	    return this.getVoltageOutputRange();
	  }
	  /**
	   * Enable the output voltage by setting `enabled` to true.
	   *
	   * *   Disable the output by seting `enabled` to false to save power.
	   * @throws {@link PhidgetError}
	   * @param enabled - The enabled value
	   */


	  async setEnabled(enabled) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (enabled !== false && enabled !== true) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be a boolean.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: enabled ? 1 : 0
	    });
	    await bp.send(this._ch, 56);
	  }
	  /**
	   * Enable the output voltage by setting `enabled` to true.
	   *
	   * *   Disable the output by seting `enabled` to false to save power.
	   * @returns The enabled value
	   * @throws {@link PhidgetError}
	   */


	  getEnabled() {
	    this._assertOpen();

	    if (this.data.enabled === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.enabled;
	  }
	  /**
	   * Enables the **failsafe** feature for the channel, with a given **failsafe time**.
	   *
	   * The **failsafe** feature is intended for use in applications where it is important for the channel to enter a known _safe state_ if the program controlling it locks up or crashes. If you do not enable the failsafe feature, the channel will carry out whatever instructions it was last given until it is explicitly told to stop.
	   *
	   * Enabling the failsafe feature starts a recurring **failsafe timer** for the channel. Once the failsafe timer is enabled, it must be reset within the specified time or the channel will enter a **failsafe state**. The failsafe timer may be reset by sending any valid command to the device\*. Resetting the failsafe timer will reload the timer with the specified _failsafe time_, starting when the message to reset the timer is received by the Phidget.
	   *
	   * _\*(**get** requests do not typically send commands and won't reset the failsafe timer)_
	   *
	   * For example: if the failsafe is enabled with a **failsafe time** of 1000ms, you will have 1000ms to reset the failsafe timer. Every time the failsafe timer is reset, you will have 1000ms from that time to reset the failsafe again.
	   *
	   * If the failsafe timer is not reset before it runs out, the channel will enter a **failsafe state**. For Voltage Output channels, this will set the output voltage to 0V. Once the channel enters the **failsafe state**, it will reject any further input until the channel is reopened.
	   *
	   * To prevent the channel from falsely entering the failsafe state, we recommend resetting the failsafe timer as frequently as is practical for your application. A good rule of thumb is to not let more than a third of the failsafe time pass before resetting the timer.
	   *
	   * Once the failsafe timer has been set, it cannot be disabled by any means other than closing and reopening the channel.
	   * @throws {@link PhidgetError}
	   * @param failsafeTime - Failsafe timeout in milliseconds
	   */


	  async enableFailsafe(failsafeTime) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: failsafeTime
	    });
	    await bp.send(this._ch, 146);
	  }
	  /**
	   * The minimum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @returns The failsafe time
	   * @throws {@link PhidgetError}
	   */


	  getMinFailsafeTime() {
	    this._assertOpen();

	    if (this.data.minFailsafeTime === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minFailsafeTime;
	  }
	  /**
	   * The maximum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @returns The failsafe time
	   * @throws {@link PhidgetError}
	   */


	  getMaxFailsafeTime() {
	    this._assertOpen();

	    if (this.data.maxFailsafeTime === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxFailsafeTime;
	  }
	  /**
	   * Resets the failsafe timer, if one has been set. See `enableFailsafe()` for details.
	   *
	   * This function will fail if no failsafe timer has been set for the channel.
	   * @throws {@link PhidgetError}
	   */


	  async resetFailsafe() {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    await bp.send(this._ch, 147);
	  }
	  /**
	   * The voltage value that the channel will output.
	   *
	   * *   The `voltage` value is bounded by `minVoltage` and `maxVoltage`.
	   * *   The voltage value will not be output until `enabled` is set to true.
	   * @returns The voltage value
	   * @throws {@link PhidgetError}
	   */


	  getVoltage() {
	    this._assertOpen();

	    if (this.data.voltage === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.voltage;
	  }
	  /**
	   * The voltage value that the channel will output.
	   *
	   * *   The `voltage` value is bounded by `minVoltage` and `maxVoltage`.
	   * *   The voltage value will not be output until `enabled` is set to true.
	   * @throws {@link PhidgetError}
	   * @param voltage - The voltage value
	   */


	  async setVoltage(voltage) {
	    this._assertOpen();

	    if (voltage < this.data.minVoltage || voltage > this.data.maxVoltage) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minVoltage + " - " + this.data.maxVoltage + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: voltage
	    });
	    await bp.send(this._ch, 86);
	  }
	  /**
	   * The minimum value that `voltage` can be set to.
	   * @returns The voltage value
	   * @throws {@link PhidgetError}
	   */


	  getMinVoltage() {
	    this._assertOpen();

	    if (this.data.minVoltage === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minVoltage;
	  }
	  /**
	   * The maximum value that `voltage` can be set to.
	   * @returns The voltage value
	   * @throws {@link PhidgetError}
	   */


	  getMaxVoltage() {
	    this._assertOpen();

	    if (this.data.maxVoltage === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxVoltage;
	  }
	  /**
	   * Choose a `voltageOutputRange` that best suits your application.
	   *
	   * *   Changing the `voltageOutputRange` will also affect the `minVoltage` and `maxVoltage` values.
	   * @returns The output range value
	   * @throws {@link PhidgetError}
	   */


	  getVoltageOutputRange() {
	    this._assertOpen();

	    if (this.data.voltageOutputRange === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.voltageOutputRange;
	  }
	  /**
	   * Choose a `voltageOutputRange` that best suits your application.
	   *
	   * *   Changing the `voltageOutputRange` will also affect the `minVoltage` and `maxVoltage` values.
	   * @throws {@link PhidgetError}
	   * @param voltageOutputRange - The output range value
	   */


	  async setVoltageOutputRange(voltageOutputRange) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedVoltageOutputRange(this._ch, voltageOutputRange)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified VoltageOutputRange is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: voltageOutputRange
	    });
	    await bp.send(this._ch, 87);
	  }

	}

	/** @public */

	class VoltageOutput extends VoltageOutputBase {
	  /** @internal */
	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 87:
	        switch (bp.getNumber(0)) {
	          case exports.VoltageOutputRange.VOLTS_10:
	            this.data.minVoltage = -10;
	            this.data.maxVoltage = 10;
	            break;

	          case exports.VoltageOutputRange.VOLTS_5:
	            this.data.minVoltage = 0;
	            this.data.maxVoltage = 5;
	            break;
	        }

	        super._bridgeInput(bp);

	        break;

	      default:
	        super._bridgeInput(bp);

	        break;
	    }
	  }

	}

	class AccelerometerBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onAccelerationChange = null;
	    this._class = exports.ChannelClass.ACCELEROMETER;
	    this.name = "Accelerometer";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 46:
	        this.data.accelerationChangeTrigger = bp.entries[0].v;

	        this._FIREPropertyChange('AccelerationChangeTrigger', bp);

	        break;

	      case 54:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.entries[1].v;else this.data.dataInterval = bp.entries[0].v;

	        this._FIREPropertyChange('DataInterval', bp);

	        this._FIREPropertyChange('DataRate', bp);

	        break;

	      case 170:
	        this.data.heatingEnabled = bp.entries[0].v;

	        this._FIREPropertyChange('HeatingEnabled', bp);

	        break;

	      case 145:
	        this.data.precision = bp.entries[0].v;

	        this._FIREPropertyChange('Precision', bp);

	        break;

	      case 1:
	        {
	          this.data.acceleration = bp.entries[0].v;
	          this.data.timestamp = bp.entries[1].v;

	          if (this._isAttachedDone && this.onAccelerationChange) {
	            try {
	              this.onAccelerationChange(this.data.acceleration, this.data.timestamp);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      dataInterval: 1e+300,
	      timestamp: 1e+300,
	      maxDataInterval: 4294967295,
	      minDataRate: 1e+300,
	      maxDataRate: 1e+300,
	      maxAcceleration: [1e+300, 1e+300, 1e+300],
	      maxAccelerationChangeTrigger: 1e+300,
	      minDataInterval: 4294967295,
	      minAcceleration: [1e+300, 1e+300, 1e+300],
	      minAccelerationChangeTrigger: 1e+300,
	      acceleration: [1e+300, 1e+300, 1e+300],
	      accelerationChangeTrigger: 1e+300,
	      axisCount: 2147483647,
	      precision: 2147483647,
	      heatingEnabled: 2
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 310:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 100;
	        this.data.maxAcceleration = [8, 8, 8];
	        this.data.maxAccelerationChangeTrigger = 16;
	        this.data.minDataInterval = 10;
	        this.data.minAcceleration = [-8, -8, -8];
	        this.data.minAccelerationChangeTrigger = 0;
	        this.data.accelerationChangeTrigger = 0;
	        this.data.axisCount = 3;
	        break;

	      case 313:
	      case 318:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 50;
	        this.data.maxAcceleration = [8, 8, 8];
	        this.data.maxAccelerationChangeTrigger = 16;
	        this.data.minDataInterval = 20;
	        this.data.minAcceleration = [-8, -8, -8];
	        this.data.minAccelerationChangeTrigger = 0;
	        this.data.accelerationChangeTrigger = 0;
	        this.data.axisCount = 3;
	        this.data.precision = exports.SpatialPrecision.LOW;
	        break;

	      case 331:
	        this.data.dataInterval = 256;
	        this.data.timestamp = this._ch.parent.data.timestamp[this._ch.index];
	        this.data.maxDataInterval = 1000;
	        this.data.minDataRate = 1;
	        this.data.maxDataRate = 250;
	        this.data.maxAcceleration = [8, 8, 8];
	        this.data.maxAccelerationChangeTrigger = 16;
	        this.data.minDataInterval = 4;
	        this.data.minAcceleration = [-8, -8, -8];
	        this.data.minAccelerationChangeTrigger = 0;
	        this.data.acceleration = this._ch.parent.data.acceleration[this._ch.index];
	        this.data.accelerationChangeTrigger = 0;
	        this.data.axisCount = 3;
	        this.data.precision = exports.SpatialPrecision.HYBRID;
	        this.data.heatingEnabled = 0;
	        break;

	      case 336:
	        this.data.dataInterval = 250;
	        this.data.timestamp = this._ch.parent.data.timestamp[this._ch.index];
	        this.data.maxDataInterval = 1000;
	        this.data.minDataRate = 1;
	        this.data.maxDataRate = 1000;
	        this.data.maxAcceleration = [16, 16, 16];
	        this.data.maxAccelerationChangeTrigger = 16;
	        this.data.minDataInterval = 1;
	        this.data.minAcceleration = [-16, -16, -16];
	        this.data.minAccelerationChangeTrigger = 0;
	        this.data.acceleration = this._ch.parent.data.acceleration[this._ch.index];
	        this.data.accelerationChangeTrigger = 0;
	        this.data.axisCount = 3;
	        this.data.precision = exports.SpatialPrecision.HIGH;
	        this.data.heatingEnabled = 0;
	        break;

	      case 341:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 1000;
	        this.data.minDataRate = 1;
	        this.data.maxDataRate = 1000;
	        this.data.maxAcceleration = [16, 16, 16];
	        this.data.maxAccelerationChangeTrigger = 16;
	        this.data.minDataInterval = 1;
	        this.data.minAcceleration = [-16, -16, -16];
	        this.data.minAccelerationChangeTrigger = 0;
	        this.data.accelerationChangeTrigger = 0;
	        this.data.axisCount = 3;
	        this.data.precision = exports.SpatialPrecision.HIGH;
	        this.data.heatingEnabled = 0;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    let bp;

	    switch (this._ch.chDef.uid) {
	      case 310:
	      case 313:
	      case 318:
	      case 331:
	      case 336:
	      case 341:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.accelerationChangeTrigger
	        });
	        await bp.send(this._ch, 46);
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    if ((this.data.acceleration.includes(1e+300) || this.data.timestamp == 1e+300) && !this._gotAccelerationChangeErrorEvent) return false;
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {
	    if (!this.data.acceleration.includes(1e+300) && this.data.timestamp != 1e+300) if (this.onAccelerationChange) try {
	      this.onAccelerationChange(this.data.acceleration, this.data.timestamp);
	    } catch (err) {
	      logEventException(err);
	    }
	  }
	  /**
	   * The most recent acceleration value that the channel has reported.
	   *
	   * *   This value will always be between `minAcceleration` and `maxAcceleration`.
	   * @throws {@link PhidgetError}
	   */


	  get acceleration() {
	    return this.getAcceleration();
	  }
	  /**
	   * The minimum value the `AccelerationChange` event will report.
	   * @throws {@link PhidgetError}
	   */


	  get minAcceleration() {
	    return this.getMinAcceleration();
	  }
	  /**
	   * The maximum value the `AccelerationChange` event will report.
	   * @throws {@link PhidgetError}
	   */


	  get maxAcceleration() {
	    return this.getMaxAcceleration();
	  }
	  /**
	   * The channel will not issue a `AccelerationChange` event until the acceleration value has changed by the amount specified by the `accelerationChangeTrigger`.
	   *
	   * *   Setting the `accelerationChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   */


	  get accelerationChangeTrigger() {
	    return this.getAccelerationChangeTrigger();
	  }
	  /**
	   * The minimum value that `accelerationChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minAccelerationChangeTrigger() {
	    return this.getMinAccelerationChangeTrigger();
	  }
	  /**
	   * The maximum value that `accelerationChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxAccelerationChangeTrigger() {
	    return this.getMaxAccelerationChangeTrigger();
	  }
	  /**
	   * The number of axes the channel can measure acceleration on.
	   *
	   * *   See your device's User Guide for more information about the number of axes and their orientation.
	   * @throws {@link PhidgetError}
	   */


	  get axisCount() {
	    return this.getAxisCount();
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `AccelerationChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `AccelerationChange` events can also be affected by the `accelerationChangeTrigger`.
	   * @throws {@link PhidgetError}
	   */


	  get dataInterval() {
	    return this.getDataInterval();
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataInterval() {
	    return this.getMinDataInterval();
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataInterval() {
	    return this.getMaxDataInterval();
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   */


	  get dataRate() {
	    return this.getDataRate();
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataRate() {
	    return this.getMinDataRate();
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataRate() {
	    return this.getMaxDataRate();
	  }
	  /**
	   * Set to TRUE to enable the temperature stabilization feature of this device. This enables onboard heating elements to bring the board up to a known temperature to minimize ambient temerature effects on the sensor's reading. You can leave this setting FALSE to conserve power consumption.
	   *
	   * If you enable heating, it is strongly recommended to keep the board in its enclosure to keep it insulated from moving air.
	   *
	   * This property is shared by any and all spatial-related objects on this device (Accelerometer, Gyroscope, Magnetometer, Spatial)
	   * @throws {@link PhidgetError}
	   */


	  get heatingEnabled() {
	    return this.getHeatingEnabled();
	  }
	  /**
	   * Selects between high/low precision sensing chips.
	   * @throws {@link PhidgetError}
	   * @internal
	   */


	  get precision() {
	    return this.getPrecision();
	  }
	  /**
	   * The most recent timestamp value that the channel has reported. This is an extremely accurate time measurement streamed from the device.
	   *
	   * *   If your application requires a time measurement, you should use this value over a local software timestamp.
	   * @throws {@link PhidgetError}
	   */


	  get timestamp() {
	    return this.getTimestamp();
	  }
	  /**
	   * The most recent acceleration value that the channel has reported.
	   *
	   * *   This value will always be between `minAcceleration` and `maxAcceleration`.
	   * @returns The acceleration values
	   * @throws {@link PhidgetError}
	   */


	  getAcceleration() {
	    this._assertOpen();

	    if (this.data.acceleration.includes(1e+300)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.acceleration;
	  }
	  /**
	   * The minimum value the `AccelerationChange` event will report.
	   * @returns The minimum acceleration value
	   * @throws {@link PhidgetError}
	   */


	  getMinAcceleration() {
	    this._assertOpen();

	    if (this.data.minAcceleration.includes(1e+300)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minAcceleration;
	  }
	  /**
	   * The maximum value the `AccelerationChange` event will report.
	   * @returns The maximum acceleration values
	   * @throws {@link PhidgetError}
	   */


	  getMaxAcceleration() {
	    this._assertOpen();

	    if (this.data.maxAcceleration.includes(1e+300)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxAcceleration;
	  }
	  /**
	   * The channel will not issue a `AccelerationChange` event until the acceleration value has changed by the amount specified by the `accelerationChangeTrigger`.
	   *
	   * *   Setting the `accelerationChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getAccelerationChangeTrigger() {
	    this._assertOpen();

	    if (this.data.accelerationChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.accelerationChangeTrigger;
	  }
	  /**
	   * The channel will not issue a `AccelerationChange` event until the acceleration value has changed by the amount specified by the `accelerationChangeTrigger`.
	   *
	   * *   Setting the `accelerationChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   * @param accelerationChangeTrigger - The change trigger value
	   */


	  async setAccelerationChangeTrigger(accelerationChangeTrigger) {
	    this._assertOpen();

	    if (accelerationChangeTrigger < this.data.minAccelerationChangeTrigger || accelerationChangeTrigger > this.data.maxAccelerationChangeTrigger) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minAccelerationChangeTrigger + " - " + this.data.maxAccelerationChangeTrigger + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: accelerationChangeTrigger
	    });
	    await bp.send(this._ch, 46);
	  }
	  /**
	   * The minimum value that `accelerationChangeTrigger` can be set to.
	   * @returns The minimum change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMinAccelerationChangeTrigger() {
	    this._assertOpen();

	    if (this.data.minAccelerationChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minAccelerationChangeTrigger;
	  }
	  /**
	   * The maximum value that `accelerationChangeTrigger` can be set to.
	   * @returns The maximum change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMaxAccelerationChangeTrigger() {
	    this._assertOpen();

	    if (this.data.maxAccelerationChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxAccelerationChangeTrigger;
	  }
	  /**
	   * The number of axes the channel can measure acceleration on.
	   *
	   * *   See your device's User Guide for more information about the number of axes and their orientation.
	   * @returns The number of axes
	   * @throws {@link PhidgetError}
	   */


	  getAxisCount() {
	    this._assertOpen();

	    if (this.data.axisCount === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.axisCount;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `AccelerationChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `AccelerationChange` events can also be affected by the `accelerationChangeTrigger`.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getDataInterval() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dataInterval;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `AccelerationChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `AccelerationChange` events can also be affected by the `accelerationChangeTrigger`.
	   * @throws {@link PhidgetError}
	   * @param dataInterval - The data interval value
	   */


	  async setDataInterval(dataInterval) {
	    this._assertOpen();

	    if (dataInterval < this.data.minDataInterval || dataInterval > this.data.maxDataInterval) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataInterval + " - " + this.data.maxDataInterval + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: dataInterval
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @returns The minimum data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataInterval() {
	    this._assertOpen();

	    if (this.data.minDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataInterval;
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataInterval() {
	    this._assertOpen();

	    if (this.data.maxDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @returns The data rate for the channel
	   * @throws {@link PhidgetError}
	   */


	  getDataRate() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return 1000.0 / this.data.dataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   * @param dataRate - The data rate for the channel
	   */


	  async setDataRate(dataRate) {
	    this._assertOpen();

	    if (dataRate < this.data.minDataRate || dataRate > this.data.maxDataRate) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataRate + " - " + this.data.maxDataRate + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: Math.round(1000.0 / dataRate)
	    });
	    bp.set({
	      name: "1",
	      type: "g",
	      value: 1000.0 / dataRate
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataRate() {
	    this._assertOpen();

	    if (this.data.minDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataRate;
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataRate() {
	    this._assertOpen();

	    if (this.data.maxDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataRate;
	  }
	  /**
	   * Set to TRUE to enable the temperature stabilization feature of this device. This enables onboard heating elements to bring the board up to a known temperature to minimize ambient temerature effects on the sensor's reading. You can leave this setting FALSE to conserve power consumption.
	   *
	   * If you enable heating, it is strongly recommended to keep the board in its enclosure to keep it insulated from moving air.
	   *
	   * This property is shared by any and all spatial-related objects on this device (Accelerometer, Gyroscope, Magnetometer, Spatial)
	   * @returns Whether self-heating temperature stabilization is enabled
	   * @throws {@link PhidgetError}
	   */


	  getHeatingEnabled() {
	    this._assertOpen();

	    if (this.data.heatingEnabled === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.heatingEnabled;
	  }
	  /**
	   * Set to TRUE to enable the temperature stabilization feature of this device. This enables onboard heating elements to bring the board up to a known temperature to minimize ambient temerature effects on the sensor's reading. You can leave this setting FALSE to conserve power consumption.
	   *
	   * If you enable heating, it is strongly recommended to keep the board in its enclosure to keep it insulated from moving air.
	   *
	   * This property is shared by any and all spatial-related objects on this device (Accelerometer, Gyroscope, Magnetometer, Spatial)
	   * @throws {@link PhidgetError}
	   * @param heatingEnabled - Whether self-heating temperature stabilization is enabled
	   */


	  async setHeatingEnabled(heatingEnabled) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (heatingEnabled !== false && heatingEnabled !== true) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be a boolean.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: heatingEnabled ? 1 : 0
	    });
	    await bp.send(this._ch, 170);
	  }
	  /**
	   * Selects between high/low precision sensing chips.
	   * @returns The sensor precision value
	   * @throws {@link PhidgetError}
	   * @internal
	   */


	  getPrecision() {
	    this._assertOpen();

	    if (this.data.precision === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.precision;
	  }
	  /**
	   * Selects between high/low precision sensing chips.
	   * @throws {@link PhidgetError}
	   * @param precision - The sensor precision value
	   * @internal
	   */


	  async setPrecision(precision) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedSpatialPrecision(this._ch, precision)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified SpatialPrecision is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: precision
	    });
	    await bp.send(this._ch, 145);
	  }
	  /**
	   * The most recent timestamp value that the channel has reported. This is an extremely accurate time measurement streamed from the device.
	   *
	   * *   If your application requires a time measurement, you should use this value over a local software timestamp.
	   * @returns The timestamp value
	   * @throws {@link PhidgetError}
	   */


	  getTimestamp() {
	    this._assertOpen();

	    if (this.data.timestamp === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.timestamp;
	  }

	}

	/** @public */

	class Accelerometer extends AccelerometerBase {
	  /** @internal */
	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 10:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.getNumber(1);else this.data.dataInterval = bp.getNumber(0);

	        this._FIREPropertyChange('DataInterval');

	        this._FIREPropertyChange('DataRate');

	        break;

	      default:
	        super._bridgeInput(bp);

	        break;
	    }
	  }
	  /** @internal */


	  _errorHandler(code) {
	    switch (code) {
	      case exports.ErrorEventCode.SATURATION:
	        this.data.acceleration = [1e+300, 1e+300, 1e+300];
	        this.data.timestamp = 1e+300;
	        this._gotAccelerationChangeErrorEvent = true;
	        break;
	    }
	  }

	}

	var global$1 = global$D;
	var aCallable = aCallable$8;
	var toObject = toObject$3;
	var IndexedObject = indexedObject;
	var lengthOfArrayLike = lengthOfArrayLike$3;
	var TypeError$1 = global$1.TypeError;
	var createMethod$1 = function (IS_RIGHT) {
	  return function (that, callbackfn, argumentsLength, memo) {
	    aCallable(callbackfn);
	    var O = toObject(that);
	    var self = IndexedObject(O);
	    var length = lengthOfArrayLike(O);
	    var index = IS_RIGHT ? length - 1 : 0;
	    var i = IS_RIGHT ? -1 : 1;
	    if (argumentsLength < 2) while (true) {
	      if (index in self) {
	        memo = self[index];
	        index += i;
	        break;
	      }
	      index += i;
	      if (IS_RIGHT ? index < 0 : length <= index) {
	        throw TypeError$1('Reduce of empty array with no initial value');
	      }
	    }
	    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
	      memo = callbackfn(memo, self[index], index, O);
	    }
	    return memo;
	  };
	};
	var arrayReduce = {
	  left: createMethod$1(false),
	  right: createMethod$1(true)
	};

	var fails$1 = fails$f;
	var arrayMethodIsStrict$1 = function (METHOD_NAME, argument) {
	  var method = [][METHOD_NAME];
	  return !!method && fails$1(function () {
	    method.call(null, argument || function () { return 1; }, 1);
	  });
	};

	var $$1 = _export;
	var $reduce = arrayReduce.left;
	var arrayMethodIsStrict = arrayMethodIsStrict$1;
	var CHROME_VERSION = engineV8Version;
	var IS_NODE = engineIsNode;
	var STRICT_METHOD = arrayMethodIsStrict('reduce');
	var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
	$$1({ target: 'Array', proto: true, forced: !STRICT_METHOD || CHROME_BUG }, {
	  reduce: function reduce(callbackfn ) {
	    var length = arguments.length;
	    return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);
	  }
	});

	var entryVirtual$1 = entryVirtual$4;
	var reduce$3 = entryVirtual$1('Array').reduce;

	var isPrototypeOf$1 = objectIsPrototypeOf;
	var method$1 = reduce$3;
	var ArrayPrototype = Array.prototype;
	var reduce$2 = function (it) {
	  var own = it.reduce;
	  return it === ArrayPrototype || (isPrototypeOf$1(ArrayPrototype, it) && own === ArrayPrototype.reduce) ? method$1 : own;
	};

	var parent$1 = reduce$2;
	var reduce$1 = parent$1;

	var reduce = reduce$1;

	class VoltageInputBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onVoltageChange = null;
	    this.onSensorChange = null;
	    this._class = exports.ChannelClass.VOLTAGE_INPUT;
	    this.name = "VoltageInput";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 54:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.entries[1].v;else this.data.dataInterval = bp.entries[0].v;

	        this._FIREPropertyChange('DataInterval', bp);

	        this._FIREPropertyChange('DataRate', bp);

	        break;

	      case 74:
	        this.data.powerSupply = bp.entries[0].v;

	        this._FIREPropertyChange('PowerSupply', bp);

	        break;

	      case 79:
	        this.data.sensorType = bp.entries[0].v;

	        this._FIREPropertyChange('SensorType', bp);

	        break;

	      case 122:
	        this.data.sensorValueChangeTrigger = bp.entries[0].v;

	        this._FIREPropertyChange('SensorValueChangeTrigger', bp);

	        break;

	      case 46:
	        this.data.voltageChangeTrigger = bp.entries[0].v;

	        this._FIREPropertyChange('VoltageChangeTrigger', bp);

	        break;

	      case 87:
	        this.data.voltageRange = bp.entries[0].v;

	        this._FIREPropertyChange('VoltageRange', bp);

	        break;

	      case 115:
	        {
	          this.data.sensorValue = bp.entries[0].v;
	          const sensorUnit = {
	            unit: bp.entries["UnitInfo.unit"].v,
	            name: bp.entries["UnitInfo.name"].v,
	            symbol: bp.entries["UnitInfo.symbol"].v
	          };
	          this.data.sensorUnit = sensorUnit;

	          if (this._isAttachedDone && this.onSensorChange) {
	            try {
	              this.onSensorChange(this.data.sensorValue, this.data.sensorUnit);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      dataInterval: 1e+300,
	      minDataInterval: 4294967295,
	      maxDataInterval: 4294967295,
	      minDataRate: 1e+300,
	      maxDataRate: 1e+300,
	      powerSupply: 2147483647,
	      sensorType: 2147483647,
	      sensorUnit: null,
	      sensorValue: 1e+300,
	      voltage: 1e+300,
	      minVoltage: 1e+300,
	      maxVoltage: 1e+300,
	      voltageChangeTrigger: 1e+300,
	      minVoltageChangeTrigger: 1e+300,
	      maxVoltageChangeTrigger: 1e+300,
	      voltageRange: 2147483647,
	      sensorValueChangeTrigger: 1e+300
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 45:
	        this.data.dataInterval = 256;
	        this.data.minDataInterval = 1;
	        this.data.maxDataInterval = 1000;
	        this.data.minDataRate = 1;
	        this.data.maxDataRate = 1000;
	        this.data.sensorType = exports.VoltageSensorType.VOLTAGE;
	        this.data.voltage = this._ch.parent.data.voltage[this._ch.index];
	        this.data.minVoltage = 0;
	        this.data.maxVoltage = 5;
	        this.data.voltageChangeTrigger = 0;
	        this.data.minVoltageChangeTrigger = 0;
	        this.data.maxVoltageChangeTrigger = 5;
	        this.data.sensorValueChangeTrigger = 0;
	        break;

	      case 107:
	        this.data.dataInterval = 256;
	        this.data.minDataInterval = 32;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 31.25;
	        this.data.voltage = this._ch.parent.data.voltage[this._ch.index];
	        this.data.minVoltage = -0.01001;
	        this.data.maxVoltage = 0.07741;
	        this.data.voltageChangeTrigger = 0;
	        this.data.minVoltageChangeTrigger = 0;
	        this.data.maxVoltageChangeTrigger = 0.08742;
	        break;

	      case 192:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 1;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 1000;
	        this.data.sensorType = exports.VoltageSensorType.VOLTAGE;
	        this.data.minVoltage = 0;
	        this.data.maxVoltage = 5;
	        this.data.voltageChangeTrigger = 0;
	        this.data.minVoltageChangeTrigger = 0;
	        this.data.maxVoltageChangeTrigger = 5;
	        this.data.sensorValueChangeTrigger = 0;
	        break;

	      case 193:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 1;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 1000;
	        this.data.sensorType = exports.VoltageSensorType.VOLTAGE;
	        this.data.minVoltage = 0;
	        this.data.maxVoltage = 5.25;
	        this.data.voltageChangeTrigger = 0;
	        this.data.minVoltageChangeTrigger = 0;
	        this.data.maxVoltageChangeTrigger = 5;
	        this.data.sensorValueChangeTrigger = 0;
	        break;

	      case 196:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 50;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 20;
	        this.data.sensorType = exports.VoltageSensorType.VOLTAGE;
	        this.data.minVoltage = -2;
	        this.data.maxVoltage = 2;
	        this.data.voltageChangeTrigger = 0;
	        this.data.minVoltageChangeTrigger = 0;
	        this.data.maxVoltageChangeTrigger = 4;
	        this.data.voltageRange = exports.VoltageRange.MILLIVOLTS_400;
	        this.data.sensorValueChangeTrigger = 0;
	        break;

	      case 216:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 20;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 50;
	        this.data.sensorType = exports.VoltageSensorType.VOLTAGE;
	        this.data.minVoltage = 0;
	        this.data.maxVoltage = 5;
	        this.data.voltageChangeTrigger = 0;
	        this.data.minVoltageChangeTrigger = 0;
	        this.data.maxVoltageChangeTrigger = 5;
	        this.data.sensorValueChangeTrigger = 0;
	        break;

	      case 218:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 20;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 50;
	        this.data.sensorType = exports.VoltageSensorType.VOLTAGE;
	        this.data.minVoltage = 0;
	        this.data.maxVoltage = 5.25;
	        this.data.voltageChangeTrigger = 0;
	        this.data.minVoltageChangeTrigger = 0;
	        this.data.maxVoltageChangeTrigger = 5;
	        this.data.sensorValueChangeTrigger = 0;
	        break;

	      case 232:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 20;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 50;
	        this.data.powerSupply = exports.PowerSupply.VOLTS_12;
	        this.data.sensorType = exports.VoltageSensorType.VOLTAGE;
	        this.data.minVoltage = 0;
	        this.data.maxVoltage = 5;
	        this.data.voltageChangeTrigger = 0;
	        this.data.minVoltageChangeTrigger = 0;
	        this.data.maxVoltageChangeTrigger = 5;
	        this.data.sensorValueChangeTrigger = 0;
	        break;

	      case 236:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 20;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 50;
	        this.data.powerSupply = exports.PowerSupply.VOLTS_12;
	        this.data.sensorType = exports.VoltageSensorType.VOLTAGE;
	        this.data.minVoltage = 0;
	        this.data.maxVoltage = 5.25;
	        this.data.voltageChangeTrigger = 0;
	        this.data.minVoltageChangeTrigger = 0;
	        this.data.maxVoltageChangeTrigger = 5;
	        this.data.sensorValueChangeTrigger = 0;
	        break;

	      case 361:
	      case 364:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 100;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.minVoltage = 8;
	        this.data.maxVoltage = 40;
	        this.data.voltageChangeTrigger = 0;
	        this.data.minVoltageChangeTrigger = 0;
	        this.data.maxVoltageChangeTrigger = 32;
	        break;

	      case 376:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 100;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.minVoltage = 0;
	        this.data.maxVoltage = 40;
	        this.data.voltageChangeTrigger = 0;
	        this.data.minVoltageChangeTrigger = 0;
	        this.data.maxVoltageChangeTrigger = 20;
	        break;

	      case 383:
	      case 386:
	      case 389:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 20;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 50;
	        this.data.minVoltage = -0.011;
	        this.data.maxVoltage = 0.079;
	        this.data.voltageChangeTrigger = 0;
	        this.data.minVoltageChangeTrigger = 0;
	        this.data.maxVoltageChangeTrigger = 0.09;
	        break;

	      case 397:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 100;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.voltageChangeTrigger = 0;
	        this.data.minVoltageChangeTrigger = 0;
	        this.data.maxVoltageChangeTrigger = 80;
	        this.data.voltageRange = exports.VoltageRange.VOLTS_40;
	        break;

	      case 398:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 40;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 25;
	        this.data.voltageChangeTrigger = 0;
	        this.data.minVoltageChangeTrigger = 0;
	        this.data.maxVoltageChangeTrigger = 80;
	        this.data.voltageRange = exports.VoltageRange.AUTO;
	        break;

	      case 399:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 12;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 83.33333333333333;
	        this.data.voltageChangeTrigger = 0;
	        this.data.minVoltageChangeTrigger = 0;
	        this.data.maxVoltageChangeTrigger = 80;
	        this.data.voltageRange = exports.VoltageRange.AUTO;
	        break;

	      case 400:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 40;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 25;
	        this.data.voltageChangeTrigger = 0;
	        this.data.minVoltageChangeTrigger = 0;
	        this.data.maxVoltageChangeTrigger = 2;
	        this.data.voltageRange = exports.VoltageRange.AUTO;
	        break;

	      case 401:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 12;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 83.33333333333333;
	        this.data.voltageChangeTrigger = 0;
	        this.data.minVoltageChangeTrigger = 0;
	        this.data.maxVoltageChangeTrigger = 2;
	        this.data.voltageRange = exports.VoltageRange.AUTO;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    let bp;

	    switch (this._ch.chDef.uid) {
	      case 45:
	      case 192:
	      case 193:
	      case 216:
	      case 218:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.sensorType
	        });
	        await bp.send(this._ch, 79);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.voltageChangeTrigger
	        });
	        await bp.send(this._ch, 46);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.sensorValueChangeTrigger
	        });
	        await bp.send(this._ch, 122);
	        break;

	      case 107:
	      case 361:
	      case 364:
	      case 376:
	      case 383:
	      case 386:
	      case 389:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.voltageChangeTrigger
	        });
	        await bp.send(this._ch, 46);
	        break;

	      case 196:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.sensorType
	        });
	        await bp.send(this._ch, 79);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.voltageChangeTrigger
	        });
	        await bp.send(this._ch, 46);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.voltageRange
	        });
	        await bp.send(this._ch, 87);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.sensorValueChangeTrigger
	        });
	        await bp.send(this._ch, 122);
	        break;

	      case 232:
	      case 236:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.powerSupply
	        });
	        await bp.send(this._ch, 74);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.sensorType
	        });
	        await bp.send(this._ch, 79);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.voltageChangeTrigger
	        });
	        await bp.send(this._ch, 46);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.sensorValueChangeTrigger
	        });
	        await bp.send(this._ch, 122);
	        break;

	      case 397:
	      case 398:
	      case 399:
	      case 400:
	      case 401:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.voltageChangeTrigger
	        });
	        await bp.send(this._ch, 46);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.voltageRange
	        });
	        await bp.send(this._ch, 87);
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {}
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between events can also be affected by the change trigger.
	   * @throws {@link PhidgetError}
	   */


	  get dataInterval() {
	    return this.getDataInterval();
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataInterval() {
	    return this.getMinDataInterval();
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataInterval() {
	    return this.getMaxDataInterval();
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   */


	  get dataRate() {
	    return this.getDataRate();
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataRate() {
	    return this.getMinDataRate();
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataRate() {
	    return this.getMaxDataRate();
	  }
	  /**
	   * Choose the power supply voltage.
	   *
	   * *   Set this to the voltage specified in the attached sensor's data sheet to power it.
	   *
	   * *   Set to `phidget22.PowerSupply.OFF` to turn off the supply to save power.
	   * @throws {@link PhidgetError}
	   */


	  get powerSupply() {
	    return this.getPowerSupply();
	  }
	  /**
	   * We sell a variety of analog sensors that do not have their own API, they simply output a voltage that can be converted to a digital value using a specific formula. By matching the `sensorType` to your analog sensor, the correct formula will automatically be applied to data when you get the `sensorValue` or subscribe to the `SensorChange` event.
	   *
	   * *   The `SensorChange` event has its own change trigger associated with it: `sensorValueChangeTrigger`.
	   * *   Any data from getting the `sensorValue` or subscribing to the `SensorChange` event will have a `sensorUnit` associated with it.
	   *
	   * **Note:** Unlike other properties such as `Phidget.deviceSerialNumber` or `Phidget.channel`, `sensorType` is set after the device is opened, not before.
	   * @throws {@link PhidgetError}
	   */


	  get sensorType() {
	    return this.getSensorType();
	  }
	  /**
	   * The unit of measurement that applies to the sensor values of the `sensorType` that has been selected.
	   *
	   * *   Helps keep track of the type of information being calculated from the voltage input.
	   * @throws {@link PhidgetError}
	   */


	  get sensorUnit() {
	    return this.getSensorUnit();
	  }
	  /**
	   * The most recent sensor value that the channel has reported.
	   *
	   * *   Use `sensorUnit` to get the measurement units that are associated with the `sensorValue`
	   * @throws {@link PhidgetError}
	   */


	  get sensorValue() {
	    return this.getSensorValue();
	  }
	  /**
	   * The channel will not issue a `SensorChange` event until the sensor value has changed by the amount specified by the `sensorValueChangeTrigger`.
	   *
	   * *   Setting the `sensorValueChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   */


	  get sensorValueChangeTrigger() {
	    return this.getSensorValueChangeTrigger();
	  }
	  /**
	   * The most recent voltage value that the channel has reported.
	   *
	   * *   This value will always be between `minVoltage` and `maxVoltage`.
	   * @throws {@link PhidgetError}
	   */


	  get voltage() {
	    return this.getVoltage();
	  }
	  /**
	   * The minimum value the `VoltageChange` event will report.
	   * @throws {@link PhidgetError}
	   */


	  get minVoltage() {
	    return this.getMinVoltage();
	  }
	  /**
	   * The maximum value the `VoltageChange` event will report.
	   * @throws {@link PhidgetError}
	   */


	  get maxVoltage() {
	    return this.getMaxVoltage();
	  }
	  /**
	   * The channel will not issue a `VoltageChange` event until the voltage value has changed by the amount specified by the `voltageChangeTrigger`.
	   *
	   * *   Setting the `voltageChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   */


	  get voltageChangeTrigger() {
	    return this.getVoltageChangeTrigger();
	  }
	  /**
	   * The minimum value that `voltageChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minVoltageChangeTrigger() {
	    return this.getMinVoltageChangeTrigger();
	  }
	  /**
	   * The maximum value that `voltageChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxVoltageChangeTrigger() {
	    return this.getMaxVoltageChangeTrigger();
	  }
	  /**
	   * The voltage range you choose should allow you to measure the full range of your input signal.
	   *
	   * *   A larger `voltageRange` equates to less resolution.
	   * *   If a `Saturation` event occurs, increase the voltage range.
	   * @throws {@link PhidgetError}
	   */


	  get voltageRange() {
	    return this.getVoltageRange();
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between events can also be affected by the change trigger.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getDataInterval() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dataInterval;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between events can also be affected by the change trigger.
	   * @throws {@link PhidgetError}
	   * @param dataInterval - The data interval value
	   */


	  async setDataInterval(dataInterval) {
	    this._assertOpen();

	    if (dataInterval < this.data.minDataInterval || dataInterval > this.data.maxDataInterval) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataInterval + " - " + this.data.maxDataInterval + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: dataInterval
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataInterval() {
	    this._assertOpen();

	    if (this.data.minDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataInterval;
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataInterval() {
	    this._assertOpen();

	    if (this.data.maxDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @returns The data rate for the channel
	   * @throws {@link PhidgetError}
	   */


	  getDataRate() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return 1000.0 / this.data.dataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   * @param dataRate - The data rate for the channel
	   */


	  async setDataRate(dataRate) {
	    this._assertOpen();

	    if (dataRate < this.data.minDataRate || dataRate > this.data.maxDataRate) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataRate + " - " + this.data.maxDataRate + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: Math.round(1000.0 / dataRate)
	    });
	    bp.set({
	      name: "1",
	      type: "g",
	      value: 1000.0 / dataRate
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataRate() {
	    this._assertOpen();

	    if (this.data.minDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataRate;
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataRate() {
	    this._assertOpen();

	    if (this.data.maxDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataRate;
	  }
	  /**
	   * Choose the power supply voltage.
	   *
	   * *   Set this to the voltage specified in the attached sensor's data sheet to power it.
	   *
	   * *   Set to `phidget22.PowerSupply.OFF` to turn off the supply to save power.
	   * @returns The power supply value
	   * @throws {@link PhidgetError}
	   */


	  getPowerSupply() {
	    this._assertOpen();

	    if (this.data.powerSupply === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.powerSupply;
	  }
	  /**
	   * Choose the power supply voltage.
	   *
	   * *   Set this to the voltage specified in the attached sensor's data sheet to power it.
	   *
	   * *   Set to `phidget22.PowerSupply.OFF` to turn off the supply to save power.
	   * @throws {@link PhidgetError}
	   * @param powerSupply - The power supply value
	   */


	  async setPowerSupply(powerSupply) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedPowerSupply(this._ch, powerSupply)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified PowerSupply is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: powerSupply
	    });
	    await bp.send(this._ch, 74);
	  }
	  /**
	   * We sell a variety of analog sensors that do not have their own API, they simply output a voltage that can be converted to a digital value using a specific formula. By matching the `sensorType` to your analog sensor, the correct formula will automatically be applied to data when you get the `sensorValue` or subscribe to the `SensorChange` event.
	   *
	   * *   The `SensorChange` event has its own change trigger associated with it: `sensorValueChangeTrigger`.
	   * *   Any data from getting the `sensorValue` or subscribing to the `SensorChange` event will have a `sensorUnit` associated with it.
	   *
	   * **Note:** Unlike other properties such as `Phidget.deviceSerialNumber` or `Phidget.channel`, `sensorType` is set after the device is opened, not before.
	   * @returns The sensor type value
	   * @throws {@link PhidgetError}
	   */


	  getSensorType() {
	    this._assertOpen();

	    if (this.data.sensorType === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.sensorType;
	  }
	  /**
	   * We sell a variety of analog sensors that do not have their own API, they simply output a voltage that can be converted to a digital value using a specific formula. By matching the `sensorType` to your analog sensor, the correct formula will automatically be applied to data when you get the `sensorValue` or subscribe to the `SensorChange` event.
	   *
	   * *   The `SensorChange` event has its own change trigger associated with it: `sensorValueChangeTrigger`.
	   * *   Any data from getting the `sensorValue` or subscribing to the `SensorChange` event will have a `sensorUnit` associated with it.
	   *
	   * **Note:** Unlike other properties such as `Phidget.deviceSerialNumber` or `Phidget.channel`, `sensorType` is set after the device is opened, not before.
	   * @throws {@link PhidgetError}
	   * @param sensorType - The sensor type value
	   */


	  async setSensorType(sensorType) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedVoltageSensorType(this._ch, sensorType)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified VoltageSensorType is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: sensorType
	    });
	    await bp.send(this._ch, 79);
	  }
	  /**
	   * The unit of measurement that applies to the sensor values of the `sensorType` that has been selected.
	   *
	   * *   Helps keep track of the type of information being calculated from the voltage input.
	   * @returns The sensor unit information corresponding to the `sensorValue`.
	   * @throws {@link PhidgetError}
	   */


	  getSensorUnit() {
	    this._assertOpen();

	    if (this.data.sensorUnit === null) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.sensorUnit;
	  }
	  /**
	   * The most recent sensor value that the channel has reported.
	   *
	   * *   Use `sensorUnit` to get the measurement units that are associated with the `sensorValue`
	   * @returns The sensor value
	   * @throws {@link PhidgetError}
	   */


	  getSensorValue() {
	    this._assertOpen();

	    if (this.data.sensorValue === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.sensorValue;
	  }
	  /**
	   * The channel will not issue a `SensorChange` event until the sensor value has changed by the amount specified by the `sensorValueChangeTrigger`.
	   *
	   * *   Setting the `sensorValueChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getSensorValueChangeTrigger() {
	    this._assertOpen();

	    if (this.data.sensorValueChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.sensorValueChangeTrigger;
	  }
	  /**
	   * The channel will not issue a `SensorChange` event until the sensor value has changed by the amount specified by the `sensorValueChangeTrigger`.
	   *
	   * *   Setting the `sensorValueChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   * @param sensorValueChangeTrigger - The change trigger value
	   */


	  async setSensorValueChangeTrigger(sensorValueChangeTrigger) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: sensorValueChangeTrigger
	    });
	    await bp.send(this._ch, 122);
	  }
	  /**
	   * The most recent voltage value that the channel has reported.
	   *
	   * *   This value will always be between `minVoltage` and `maxVoltage`.
	   * @returns The voltage value
	   * @throws {@link PhidgetError}
	   */


	  getVoltage() {
	    this._assertOpen();

	    if (this.data.voltage === 1e+300 || Number.isNaN(this.data.voltage)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    if (this.data.voltage > this.data.maxVoltage) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE_HIGH);
	    if (this.data.voltage < this.data.minVoltage) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE_LOW);
	    return this.data.voltage;
	  }
	  /**
	   * The minimum value the `VoltageChange` event will report.
	   * @returns The voltage value
	   * @throws {@link PhidgetError}
	   */


	  getMinVoltage() {
	    this._assertOpen();

	    if (this.data.minVoltage === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minVoltage;
	  }
	  /**
	   * The maximum value the `VoltageChange` event will report.
	   * @returns The voltage value
	   * @throws {@link PhidgetError}
	   */


	  getMaxVoltage() {
	    this._assertOpen();

	    if (this.data.maxVoltage === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxVoltage;
	  }
	  /**
	   * The channel will not issue a `VoltageChange` event until the voltage value has changed by the amount specified by the `voltageChangeTrigger`.
	   *
	   * *   Setting the `voltageChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getVoltageChangeTrigger() {
	    this._assertOpen();

	    if (this.data.voltageChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.voltageChangeTrigger;
	  }
	  /**
	   * The channel will not issue a `VoltageChange` event until the voltage value has changed by the amount specified by the `voltageChangeTrigger`.
	   *
	   * *   Setting the `voltageChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   * @param voltageChangeTrigger - The change trigger value
	   */


	  async setVoltageChangeTrigger(voltageChangeTrigger) {
	    this._assertOpen();

	    if (voltageChangeTrigger < this.data.minVoltageChangeTrigger || voltageChangeTrigger > this.data.maxVoltageChangeTrigger) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minVoltageChangeTrigger + " - " + this.data.maxVoltageChangeTrigger + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: voltageChangeTrigger
	    });
	    await bp.send(this._ch, 46);
	  }
	  /**
	   * The minimum value that `voltageChangeTrigger` can be set to.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMinVoltageChangeTrigger() {
	    this._assertOpen();

	    if (this.data.minVoltageChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minVoltageChangeTrigger;
	  }
	  /**
	   * The maximum value that `voltageChangeTrigger` can be set to.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMaxVoltageChangeTrigger() {
	    this._assertOpen();

	    if (this.data.maxVoltageChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxVoltageChangeTrigger;
	  }
	  /**
	   * The voltage range you choose should allow you to measure the full range of your input signal.
	   *
	   * *   A larger `voltageRange` equates to less resolution.
	   * *   If a `Saturation` event occurs, increase the voltage range.
	   * @returns The voltage range value
	   * @throws {@link PhidgetError}
	   */


	  getVoltageRange() {
	    this._assertOpen();

	    if (this.data.voltageRange === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.voltageRange;
	  }
	  /**
	   * The voltage range you choose should allow you to measure the full range of your input signal.
	   *
	   * *   A larger `voltageRange` equates to less resolution.
	   * *   If a `Saturation` event occurs, increase the voltage range.
	   * @throws {@link PhidgetError}
	   * @param voltageRange - The voltage range value
	   */


	  async setVoltageRange(voltageRange) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedVoltageRange(this._ch, voltageRange)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified VoltageRange is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: voltageRange
	    });
	    await bp.send(this._ch, 87);
	  }

	}

	/** @public */

	class VoltageInput extends VoltageInputBase {
	  constructor(ch) {
	    super(ch);
	    this._private = {
	      voltageBuffer: [],
	      voltageBufferIndex: 0,
	      voltageBufferReady: false,
	      motionSensorCountdown: 0,
	      motionSensorBaseline: 1e+300,
	      VOLTAGE_BUFFER_LEN: 25
	    };
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 10:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.getNumber(1);else this.data.dataInterval = bp.getNumber(0);

	        this._FIREPropertyChange('DataInterval', bp);

	        this._FIREPropertyChange('DataRate', bp);

	        break;

	      case 27:
	        this.data.minDataInterval = bp.getNumber(0);

	        this._FIREPropertyChange('MinDataInterval', bp);

	        break;

	      case 79:
	        super._bridgeInput(bp);

	        this._bangSensorVoltage();

	        switch (this.data.sensorType) {
	          case exports.VoltageSensorType.PN_MOT2002_LOW:
	          case exports.VoltageSensorType.PN_MOT2002_MED:
	          case exports.VoltageSensorType.PN_MOT2002_HIGH:
	            {
	              const subbp = new BridgePacket();
	              subbp.set({
	                name: '0',
	                type: 'u',
	                value: 200
	              });
	              subbp.sendToChannel(this._ch, 54);
	              break;
	            }
	        }

	        break;

	      case 101:
	        {
	          this.data.voltage = bp.getNumber('0');

	          this._updateVoltageBuffer(this.data.voltage);

	          const sentSensorEvent = this._bangSensorVoltage(true);

	          if (sentSensorEvent && this._ch.conn._isRemote) throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	          break;
	        }

	      default:
	        super._bridgeInput(bp);

	        break;
	    }
	  }
	  /** @internal */


	  _errorHandler(code) {
	    switch (code) {
	      case exports.ErrorEventCode.SATURATION:
	        this.data.voltage = 1e+300;
	        this.data.sensorValue = 1e+300;
	        this._gotVoltageChangeErrorEvent = true;
	        break;
	    }
	  }
	  /** @internal */


	  _initAfterOpen() {
	    super._initAfterOpen();

	    this._private = {
	      voltageBuffer: [],
	      voltageBufferIndex: 0,
	      voltageBufferReady: false,
	      motionSensorCountdown: 0,
	      motionSensorBaseline: 1e+300,
	      VOLTAGE_BUFFER_LEN: 25
	    };
	    if (this.data.sensorType === 2147483647) this.data.sensorType = exports.VoltageSensorType.VOLTAGE;
	    this.data.sensorUnit = this._getVoltageSensorUnit(this.data.sensorType);
	    this.data.sensorValue = this._getVoltageSensorValue(this.data.voltage, this.data.sensorType);
	  }
	  /** @internal */


	  _hasInitialState() {
	    if (this.data.voltage == 1e+300 && !this._gotVoltageChangeErrorEvent) return false;
	    return super._hasInitialState();
	  }
	  /** @internal */


	  _fireInitialEvents() {
	    if (this.data.sensorType != exports.VoltageSensorType.VOLTAGE) {
	      if (this.data.sensorValue != 1e+300 && this.data.sensorUnit != null) if (this.onSensorChange) {
	        try {
	          this.onSensorChange(this.data.sensorValue, this.data.sensorUnit);
	        } catch (err) {
	          logEventException(err);
	        }
	      }
	    } else {
	      if (this.data.voltage != 1e+300) if (this.onVoltageChange) {
	        try {
	          this.onVoltageChange(this.data.voltage);
	        } catch (err) {
	          logEventException(err);
	        }
	      }
	    }

	    super._fireInitialEvents();
	  }
	  /** @internal */


	  _bangSensorVoltage() {
	    let includeVoltage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	    let sensorValue;
	    let unitInfo;
	    let sentSensorEvent = false;

	    if (this._ch.supportedBridgePacket(115) && this._ch.conn._isLocal && this.data.sensorType !== exports.VoltageSensorType.VOLTAGE) {
	      sensorValue = this._getVoltageSensorValue(this.data.voltage, this.data.sensorType);

	      if (!this._getSensorValueInRange(sensorValue, this.data.sensorType)) {
	        this.data.sensorValue = 1e+300;

	        if (this._isAttachedDone) {
	          const bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'd',
	            value: exports.ErrorEventCode.OUT_OF_RANGE
	          });
	          bp.set({
	            name: '1',
	            type: 's',
	            value: 'Sensor value is outside the valid range for this sensor.'
	          });

	          this._ch.sendErrorEvent(bp);
	        }
	      } else if (this.data.sensorValue === 1e+300 || Math.abs(sensorValue - this.data.sensorValue) >= this.data.sensorValueChangeTrigger) {
	        this.data.sensorValue = sensorValue;

	        if (this._isAttachedDone) {
	          unitInfo = this._getVoltageSensorUnit(this.data.sensorType);
	          const bp = new BridgePacket();
	          bp.set({
	            name: '0',
	            type: 'g',
	            value: sensorValue
	          });
	          bp.set({
	            name: 'UnitInfo.unit',
	            type: 'g',
	            value: unitInfo.unit
	          });
	          bp.set({
	            name: 'UnitInfo.name',
	            type: 's',
	            value: unitInfo.name
	          });
	          bp.set({
	            name: 'UnitInfo.symbol',
	            type: 's',
	            value: unitInfo.symbol
	          });
	          bp.sendToChannel(this._ch, 115);
	        }
	      }

	      sentSensorEvent = true;
	    } else if (includeVoltage) {
	      this.data.sensorUnit = this._getVoltageSensorUnit(this.data.sensorType);
	      this.data.sensorValue = this._getVoltageSensorValue(this.data.voltage, this.data.sensorType);

	      if (this._isAttachedDone && this.onVoltageChange) {
	        try {
	          this.onVoltageChange(this.data.voltage);
	        } catch (err) {
	          logEventException(err);
	        }
	      }
	    }

	    return sentSensorEvent;
	  }
	  /** @internal */


	  _updateVoltageBuffer(voltage) {
	    this._private.voltageBuffer.push(voltage);

	    if (this._private.voltageBuffer.length >= this._private.VOLTAGE_BUFFER_LEN) {
	      this._private.voltageBufferReady = true;
	      if (this._private.voltageBuffer.length > this._private.VOLTAGE_BUFFER_LEN) this._private.voltageBuffer.shift();
	    }
	  }
	  /** @internal */


	  _getVoltageSensorValue(voltage, sensorType) {
	    if (voltage === 1e+300) return 1e+300;

	    switch (sensorType) {
	      case exports.VoltageSensorType.PN_1114:
	        return RoundDouble(voltage / 0.02 - 50, 3);

	      case exports.VoltageSensorType.PN_1117:
	        return RoundDouble(voltage * 12 - 30, 3);

	      case exports.VoltageSensorType.PN_1123:
	        return RoundDouble(voltage * 12 - 30, 3);

	      case exports.VoltageSensorType.PN_1127:
	        return RoundDouble(voltage * 200, 2);

	      case exports.VoltageSensorType.PN_1130_PH:
	        return RoundDouble(voltage * 3.56 - 1.889, 4);

	      case exports.VoltageSensorType.PN_1130_ORP:
	        return RoundDouble((2.5 - voltage) / 1.037, 5);

	      case exports.VoltageSensorType.PN_1132:
	        return RoundDouble(voltage / 0.225, 4);

	      case exports.VoltageSensorType.PN_1133:
	        return RoundDouble(16.801 * Math.log(voltage * 200) + 9.872, 4);

	      case exports.VoltageSensorType.PN_1135:
	        return RoundDouble((voltage - 2.5) / 0.0681, 3);

	      case exports.VoltageSensorType.PN_1142:
	        return RoundDouble(voltage * 295.7554 + 33.67076, 2);

	      case exports.VoltageSensorType.PN_1143:
	        return RoundDouble(Math.exp(voltage * 4.77 - 0.56905), 4);

	      case exports.VoltageSensorType.PN_3500:
	        return RoundDouble(voltage / 0.5, 4);

	      case exports.VoltageSensorType.PN_3501:
	        return RoundDouble(voltage / 0.2, 4);

	      case exports.VoltageSensorType.PN_3502:
	        return RoundDouble(voltage / 0.1, 4);

	      case exports.VoltageSensorType.PN_3503:
	        return RoundDouble(voltage / 0.05, 3);

	      case exports.VoltageSensorType.PN_3507:
	        return RoundDouble(voltage * 50, 3);

	      case exports.VoltageSensorType.PN_3508:
	        return RoundDouble(voltage * 50, 3);

	      case exports.VoltageSensorType.PN_3509:
	        return RoundDouble(voltage * 40, 3);

	      case exports.VoltageSensorType.PN_3510:
	        return RoundDouble(voltage * 15, 4);

	      case exports.VoltageSensorType.PN_3511:
	        return RoundDouble(voltage * 2, 4);

	      case exports.VoltageSensorType.PN_3512:
	        return RoundDouble(voltage * 20, 3);

	      case exports.VoltageSensorType.PN_3513:
	        return RoundDouble(voltage * 200, 2);

	      case exports.VoltageSensorType.PN_3514:
	        return RoundDouble(voltage * 1500, 1);

	      case exports.VoltageSensorType.PN_3515:
	        return RoundDouble(voltage * 1500, 1);

	      case exports.VoltageSensorType.PN_3516:
	        return RoundDouble(voltage * 250, 2);

	      case exports.VoltageSensorType.PN_3517:
	        return RoundDouble(voltage * 250, 2);

	      case exports.VoltageSensorType.PN_3518:
	        return RoundDouble(voltage * 110, 3);

	      case exports.VoltageSensorType.PN_3519:
	        return RoundDouble(voltage * 330, 2);

	      case exports.VoltageSensorType.PN_3584:
	        return RoundDouble(voltage * 10, 4);

	      case exports.VoltageSensorType.PN_3585:
	        return RoundDouble(voltage * 20, 3);

	      case exports.VoltageSensorType.PN_3586:
	        return RoundDouble(voltage * 50, 3);

	      case exports.VoltageSensorType.PN_3587:
	        return RoundDouble(voltage * 20 - 50, 3);

	      case exports.VoltageSensorType.PN_3588:
	        return RoundDouble(voltage * 40 - 100, 3);

	      case exports.VoltageSensorType.PN_3589:
	        return RoundDouble(voltage * 100 - 250, 3);

	      case exports.VoltageSensorType.PN_MOT2002_LOW:
	        return this._doMotionSensorCalculations(0.8) ? 1 : 0;

	      case exports.VoltageSensorType.PN_MOT2002_MED:
	        return this._doMotionSensorCalculations(0.4) ? 1 : 0;

	      case exports.VoltageSensorType.PN_MOT2002_HIGH:
	        return this._doMotionSensorCalculations(0.04) ? 1 : 0;

	      case exports.VoltageSensorType.PN_VCP4114:
	        return RoundDouble((voltage - 2.5) / 0.0625, 3);

	      case exports.VoltageSensorType.VOLTAGE:
	      default:
	        return voltage;
	    }
	  }
	  /** @internal */


	  _getSensorValueInRange(sensorValue, sensorType) {
	    if (sensorValue === 1e+300) {
	      return false;
	    }

	    switch (sensorType) {
	      case exports.VoltageSensorType.PN_1114:
	        return sensorValue >= -40.0 && sensorValue <= 125.0;

	      case exports.VoltageSensorType.PN_1117:
	        return sensorValue >= -30.0 && sensorValue <= 30.0;

	      case exports.VoltageSensorType.PN_1123:
	        return sensorValue >= -30.0 && sensorValue <= 30.0;

	      case exports.VoltageSensorType.PN_1127:
	        return sensorValue >= 0.0 && sensorValue <= 1000.0;

	      case exports.VoltageSensorType.PN_1130_PH:
	        return sensorValue >= 0.0 && sensorValue <= 14.0;

	      case exports.VoltageSensorType.PN_1130_ORP:
	        return sensorValue >= -2.0 && sensorValue <= 2.0;

	      case exports.VoltageSensorType.PN_1132:
	        return sensorValue >= 4.0 && sensorValue <= 20.0;

	      case exports.VoltageSensorType.PN_1133:
	        return sensorValue >= 50.0 && sensorValue <= 100.0;

	      case exports.VoltageSensorType.PN_1135:
	        return sensorValue >= -30.0 && sensorValue <= 30.0;

	      case exports.VoltageSensorType.PN_1142:
	        return sensorValue >= 0.0 && sensorValue <= 1000.0;

	      case exports.VoltageSensorType.PN_1143:
	        return sensorValue >= 0.0 && sensorValue <= 70000.0;

	      case exports.VoltageSensorType.PN_3500:
	        return sensorValue >= 0.0 && sensorValue <= 10.0;

	      case exports.VoltageSensorType.PN_3501:
	        return sensorValue >= 0.0 && sensorValue <= 25.0;

	      case exports.VoltageSensorType.PN_3502:
	        return sensorValue >= 0.0 && sensorValue <= 50.0;

	      case exports.VoltageSensorType.PN_3503:
	        return sensorValue >= 0.0 && sensorValue <= 100.0;

	      case exports.VoltageSensorType.PN_3507:
	        return sensorValue >= 0.0 && sensorValue <= 250.0;

	      case exports.VoltageSensorType.PN_3508:
	        return sensorValue >= 0.0 && sensorValue <= 250.0;

	      case exports.VoltageSensorType.PN_3509:
	        return sensorValue >= 0.0 && sensorValue <= 200.0;

	      case exports.VoltageSensorType.PN_3510:
	        return sensorValue >= 0.0 && sensorValue <= 75.0;

	      case exports.VoltageSensorType.PN_3511:
	        return sensorValue >= 0.0 && sensorValue <= 10.0;

	      case exports.VoltageSensorType.PN_3512:
	        return sensorValue >= 0.0 && sensorValue <= 100.0;

	      case exports.VoltageSensorType.PN_3513:
	        return sensorValue >= 0.0 && sensorValue <= 1000.0;

	      case exports.VoltageSensorType.PN_3514:
	        return sensorValue >= 0.0 && sensorValue <= 7500.0;

	      case exports.VoltageSensorType.PN_3515:
	        return sensorValue >= 0.0 && sensorValue <= 7500.0;

	      case exports.VoltageSensorType.PN_3516:
	        return sensorValue >= 0.0 && sensorValue <= 1250.0;

	      case exports.VoltageSensorType.PN_3517:
	        return sensorValue >= 0.0 && sensorValue <= 1250.0;

	      case exports.VoltageSensorType.PN_3518:
	        return sensorValue >= 0.0 && sensorValue <= 550.0;

	      case exports.VoltageSensorType.PN_3519:
	        return sensorValue >= 0.0 && sensorValue <= 1650.0;

	      case exports.VoltageSensorType.PN_3584:
	        return sensorValue >= 0.0 && sensorValue <= 50.0;

	      case exports.VoltageSensorType.PN_3585:
	        return sensorValue >= 0.0 && sensorValue <= 100.0;

	      case exports.VoltageSensorType.PN_3586:
	        return sensorValue >= 0.0 && sensorValue <= 250.0;

	      case exports.VoltageSensorType.PN_3587:
	        return sensorValue >= -50.0 && sensorValue <= 50.0;

	      case exports.VoltageSensorType.PN_3588:
	        return sensorValue >= -100.0 && sensorValue <= 100.0;

	      case exports.VoltageSensorType.PN_3589:
	        return sensorValue >= -250.0 && sensorValue <= 250.0;

	      case exports.VoltageSensorType.PN_MOT2002_LOW:
	      case exports.VoltageSensorType.PN_MOT2002_MED:
	      case exports.VoltageSensorType.PN_MOT2002_HIGH:
	        return this._private.motionSensorBaseline !== 1e+300;

	      case exports.VoltageSensorType.PN_VCP4114:
	        return sensorValue >= -25.0 && sensorValue <= 25.0;

	      case exports.VoltageSensorType.VOLTAGE:
	      default:
	        return true;
	    }
	  }
	  /** @internal */


	  _getVoltageSensorUnit(sensorType) {
	    switch (sensorType) {
	      case exports.VoltageSensorType.PN_1130_PH:
	        return Units[exports.Unit.PH];

	      case exports.VoltageSensorType.PN_1114:
	        return Units[exports.Unit.DEGREE_CELCIUS];

	      case exports.VoltageSensorType.PN_1127:
	      case exports.VoltageSensorType.PN_1142:
	      case exports.VoltageSensorType.PN_1143:
	        return Units[exports.Unit.LUX];

	      case exports.VoltageSensorType.PN_1132:
	      case exports.VoltageSensorType.PN_3511:
	      case exports.VoltageSensorType.PN_3512:
	      case exports.VoltageSensorType.PN_3513:
	        return Units[exports.Unit.MILLIAMPERE];

	      case exports.VoltageSensorType.PN_1133:
	        return Units[exports.Unit.DECIBEL];

	      case exports.VoltageSensorType.PN_3500:
	      case exports.VoltageSensorType.PN_3501:
	      case exports.VoltageSensorType.PN_3502:
	      case exports.VoltageSensorType.PN_3503:
	      case exports.VoltageSensorType.PN_3584:
	      case exports.VoltageSensorType.PN_3585:
	      case exports.VoltageSensorType.PN_3586:
	      case exports.VoltageSensorType.PN_3587:
	      case exports.VoltageSensorType.PN_3588:
	      case exports.VoltageSensorType.PN_3589:
	      case exports.VoltageSensorType.PN_VCP4114:
	        return Units[exports.Unit.AMPERE];

	      case exports.VoltageSensorType.PN_3514:
	      case exports.VoltageSensorType.PN_3515:
	      case exports.VoltageSensorType.PN_3516:
	      case exports.VoltageSensorType.PN_3517:
	      case exports.VoltageSensorType.PN_3518:
	      case exports.VoltageSensorType.PN_3519:
	        return Units[exports.Unit.WATT];

	      case exports.VoltageSensorType.PN_MOT2002_LOW:
	      case exports.VoltageSensorType.PN_MOT2002_MED:
	      case exports.VoltageSensorType.PN_MOT2002_HIGH:
	        return Units[exports.Unit.BOOLEAN];

	      case exports.VoltageSensorType.PN_1117:
	      case exports.VoltageSensorType.PN_1123:
	      case exports.VoltageSensorType.PN_1130_ORP:
	      case exports.VoltageSensorType.PN_1135:
	      case exports.VoltageSensorType.PN_3507:
	      case exports.VoltageSensorType.PN_3508:
	      case exports.VoltageSensorType.PN_3509:
	      case exports.VoltageSensorType.PN_3510:
	      case exports.VoltageSensorType.VOLTAGE:
	      default:
	        return Units[exports.Unit.VOLT];
	    }
	  }
	  /** @internal */


	  _doMotionSensorCalculations(threshold) {
	    const p = this._private;
	    const voltageBuffer = p.voltageBuffer;
	    const index = p.voltageBufferIndex;
	    let startAvgDiff = 0;
	    let endAvgDiff = 0;
	    let longTermAvg = 0;
	    let longTermDiff = 0;
	    let triggered = false;

	    if (p.voltageBufferReady) {
	      longTermAvg = reduce(voltageBuffer).call(voltageBuffer, (prev, curr) => prev + curr) / p.VOLTAGE_BUFFER_LEN;
	      longTermDiff = reduce(voltageBuffer).call(voltageBuffer, (prev, curr) => prev + Math.abs(curr - longTermAvg), 0) / p.VOLTAGE_BUFFER_LEN;

	      if (longTermDiff < 0.1) {
	        p.motionSensorBaseline = longTermAvg;
	      } else if (p.motionSensorBaseline === 1e+300) {
	        return 2;
	      }

	      for (let i = 0; i < 5; i++) {
	        startAvgDiff += Math.abs(voltageBuffer[(index + p.VOLTAGE_BUFFER_LEN - (i + 5)) % p.VOLTAGE_BUFFER_LEN] - p.motionSensorBaseline);
	        endAvgDiff += Math.abs(voltageBuffer[(index + p.VOLTAGE_BUFFER_LEN - i) % p.VOLTAGE_BUFFER_LEN] - p.motionSensorBaseline);
	      }

	      startAvgDiff /= 5;
	      endAvgDiff /= 5;

	      if (p.motionSensorCountdown !== 0) {
	        p.motionSensorCountdown--;
	        triggered = true;
	      }

	      if (startAvgDiff > threshold && endAvgDiff > threshold) {
	        p.motionSensorCountdown = 10;
	        triggered = true;
	      }

	      return triggered;
	    }

	    return 2;
	  }

	}

	class CapacitiveTouchBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onTouch = null;
	    this.onTouchEnd = null;
	    this._class = exports.ChannelClass.CAPACITIVE_TOUCH;
	    this.name = "CapacitiveTouch";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 54:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.entries[1].v;else this.data.dataInterval = bp.entries[0].v;

	        this._FIREPropertyChange('DataInterval', bp);

	        this._FIREPropertyChange('DataRate', bp);

	        break;

	      case 66:
	        this.data.sensitivity = bp.entries[0].v;

	        this._FIREPropertyChange('Sensitivity', bp);

	        break;

	      case 46:
	        this.data.touchValueChangeTrigger = bp.entries[0].v;

	        this._FIREPropertyChange('TouchValueChangeTrigger', bp);

	        break;

	      case 96:
	        {
	          this.data.touchValue = bp.entries[0].v;

	          if (this._isAttachedDone && this.onTouch) {
	            try {
	              this.onTouch(this.data.touchValue);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      case 137:
	        {
	          if (this._isAttachedDone && this.onTouchEnd) {
	            try {
	              this.onTouchEnd();
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      touchValueChangeTrigger: 1e+300,
	      minTouchValueChangeTrigger: 1e+300,
	      maxTouchValueChangeTrigger: 1e+300,
	      dataInterval: 1e+300,
	      minDataInterval: 4294967295,
	      maxDataInterval: 4294967295,
	      minDataRate: 1e+300,
	      maxDataRate: 1e+300,
	      sensitivity: 1e+300,
	      minSensitivity: 1e+300,
	      maxSensitivity: 1e+300,
	      maxTouchValue: 1e+300,
	      minTouchValue: 1e+300,
	      touchValue: 1e+300,
	      isTouched: 2
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 296:
	        this.data.touchValueChangeTrigger = 0;
	        this.data.minTouchValueChangeTrigger = 0;
	        this.data.maxTouchValueChangeTrigger = 1;
	        this.data.dataInterval = 25;
	        this.data.minDataInterval = 25;
	        this.data.maxDataInterval = 1000;
	        this.data.minDataRate = 1;
	        this.data.maxDataRate = 40;
	        this.data.sensitivity = 0.2;
	        this.data.minSensitivity = 0;
	        this.data.maxSensitivity = 1;
	        this.data.maxTouchValue = 1;
	        this.data.minTouchValue = 0;
	        break;

	      case 297:
	        this.data.touchValueChangeTrigger = 0;
	        this.data.minTouchValueChangeTrigger = 0;
	        this.data.maxTouchValueChangeTrigger = 0.5;
	        this.data.dataInterval = 20;
	        this.data.minDataInterval = 20;
	        this.data.maxDataInterval = 250;
	        this.data.minDataRate = 4;
	        this.data.maxDataRate = 50;
	        this.data.sensitivity = 0.5;
	        this.data.minSensitivity = 0;
	        this.data.maxSensitivity = 1;
	        this.data.maxTouchValue = 1;
	        this.data.minTouchValue = 0;
	        break;

	      case 298:
	        this.data.touchValueChangeTrigger = 0;
	        this.data.minTouchValueChangeTrigger = 0;
	        this.data.maxTouchValueChangeTrigger = 0.5;
	        this.data.dataInterval = 20;
	        this.data.minDataInterval = 20;
	        this.data.maxDataInterval = 250;
	        this.data.minDataRate = 4;
	        this.data.maxDataRate = 50;
	        this.data.sensitivity = 0.7;
	        this.data.minSensitivity = 0;
	        this.data.maxSensitivity = 1;
	        this.data.maxTouchValue = 1;
	        this.data.minTouchValue = 0;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    let bp;

	    switch (this._ch.chDef.uid) {
	      case 296:
	      case 297:
	      case 298:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.touchValueChangeTrigger
	        });
	        await bp.send(this._ch, 46);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.sensitivity
	        });
	        await bp.send(this._ch, 66);
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    if (this.data.touchValue == 1e+300 && !this._gotTouchErrorEvent) return false;
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {
	    if (this.data.touchValue != 1e+300) if (this.onTouch) try {
	      this.onTouch(this.data.touchValue);
	    } catch (err) {
	      logEventException(err);
	    }
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `Touch` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `Touch` events can also be affected by the `touchValueChangeTrigger`.
	   * @throws {@link PhidgetError}
	   */


	  get dataInterval() {
	    return this.getDataInterval();
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataInterval() {
	    return this.getMinDataInterval();
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataInterval() {
	    return this.getMaxDataInterval();
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   */


	  get dataRate() {
	    return this.getDataRate();
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataRate() {
	    return this.getMinDataRate();
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataRate() {
	    return this.getMaxDataRate();
	  }
	  /**
	   * Determines the sensitivity of all capacitive regions on the device.
	   *
	   * *   Higher values result in greater touch sensitivity.
	   * *   The sensitivity value is bounded by `minSensitivity` and `maxSensitivity`.
	   * @throws {@link PhidgetError}
	   */


	  get sensitivity() {
	    return this.getSensitivity();
	  }
	  /**
	   * The minimum value that `sensitivity` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minSensitivity() {
	    return this.getMinSensitivity();
	  }
	  /**
	   * The maximum value that `sensitivity` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxSensitivity() {
	    return this.getMaxSensitivity();
	  }
	  /**
	   * The most recent touch state that the channel has reported.
	   *
	   * *   This will be 0 or 1
	   *
	   * *   0 is not touched
	   * *   1 is touched
	   * @throws {@link PhidgetError}
	   */


	  get isTouched() {
	    return this.getIsTouched();
	  }
	  /**
	   * The most recent touch value that the channel has reported.
	   *
	   * *   This will be 0 or 1 for button-type inputs, or a ratio between 0-1 for axis-type inputs.
	   * *   This value is bounded by `minTouchValue` and `maxTouchValue`
	   * *   The value is not reset when the touch ends
	   * @throws {@link PhidgetError}
	   */


	  get touchValue() {
	    return this.getTouchValue();
	  }
	  /**
	   * The minimum value the `Touch` event will report.
	   * @throws {@link PhidgetError}
	   */


	  get minTouchValue() {
	    return this.getMinTouchValue();
	  }
	  /**
	   * The maximum value the `Touch` event will report.
	   * @throws {@link PhidgetError}
	   */


	  get maxTouchValue() {
	    return this.getMaxTouchValue();
	  }
	  /**
	   * The channel will not issue a `Touch` event until the touch value has changed by the amount specified by the `touchValueChangeTrigger`.
	   *
	   * *   Setting the `touchValueChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   */


	  get touchValueChangeTrigger() {
	    return this.getTouchValueChangeTrigger();
	  }
	  /**
	   * The minimum value that `touchValueChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minTouchValueChangeTrigger() {
	    return this.getMinTouchValueChangeTrigger();
	  }
	  /**
	   * The maximum value that `touchValueChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxTouchValueChangeTrigger() {
	    return this.getMaxTouchValueChangeTrigger();
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `Touch` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `Touch` events can also be affected by the `touchValueChangeTrigger`.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getDataInterval() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dataInterval;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `Touch` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `Touch` events can also be affected by the `touchValueChangeTrigger`.
	   * @throws {@link PhidgetError}
	   * @param dataInterval - The data interval value
	   */


	  async setDataInterval(dataInterval) {
	    this._assertOpen();

	    if (dataInterval < this.data.minDataInterval || dataInterval > this.data.maxDataInterval) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataInterval + " - " + this.data.maxDataInterval + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: dataInterval
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @returns The minimum data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataInterval() {
	    this._assertOpen();

	    if (this.data.minDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataInterval;
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @returns The maximum data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataInterval() {
	    this._assertOpen();

	    if (this.data.maxDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @returns The data rate for the channel
	   * @throws {@link PhidgetError}
	   */


	  getDataRate() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return 1000.0 / this.data.dataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   * @param dataRate - The data rate for the channel
	   */


	  async setDataRate(dataRate) {
	    this._assertOpen();

	    if (dataRate < this.data.minDataRate || dataRate > this.data.maxDataRate) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataRate + " - " + this.data.maxDataRate + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: Math.round(1000.0 / dataRate)
	    });
	    bp.set({
	      name: "1",
	      type: "g",
	      value: 1000.0 / dataRate
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataRate() {
	    this._assertOpen();

	    if (this.data.minDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataRate;
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataRate() {
	    this._assertOpen();

	    if (this.data.maxDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataRate;
	  }
	  /**
	   * The most recent touch state that the channel has reported.
	   *
	   * *   This will be 0 or 1
	   *
	   * *   0 is not touched
	   * *   1 is touched
	   * @returns The touched state
	   * @throws {@link PhidgetError}
	   */


	  getIsTouched() {
	    this._assertOpen();

	    if (this.data.isTouched === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.isTouched;
	  }
	  /**
	   * Determines the sensitivity of all capacitive regions on the device.
	   *
	   * *   Higher values result in greater touch sensitivity.
	   * *   The sensitivity value is bounded by `minSensitivity` and `maxSensitivity`.
	   * @returns The sensitivity value
	   * @throws {@link PhidgetError}
	   */


	  getSensitivity() {
	    this._assertOpen();

	    if (this.data.sensitivity === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.sensitivity;
	  }
	  /**
	   * Determines the sensitivity of all capacitive regions on the device.
	   *
	   * *   Higher values result in greater touch sensitivity.
	   * *   The sensitivity value is bounded by `minSensitivity` and `maxSensitivity`.
	   * @throws {@link PhidgetError}
	   * @param sensitivity - The sensitivity value
	   */


	  async setSensitivity(sensitivity) {
	    this._assertOpen();

	    if (sensitivity < this.data.minSensitivity || sensitivity > this.data.maxSensitivity) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minSensitivity + " - " + this.data.maxSensitivity + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: sensitivity
	    });
	    await bp.send(this._ch, 66);
	  }
	  /**
	   * The minimum value that `sensitivity` can be set to.
	   * @returns The minimum sensitivity value
	   * @throws {@link PhidgetError}
	   */


	  getMinSensitivity() {
	    this._assertOpen();

	    if (this.data.minSensitivity === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minSensitivity;
	  }
	  /**
	   * The maximum value that `sensitivity` can be set to.
	   * @returns The maximum sensitivity value
	   * @throws {@link PhidgetError}
	   */


	  getMaxSensitivity() {
	    this._assertOpen();

	    if (this.data.maxSensitivity === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxSensitivity;
	  }
	  /**
	   * The most recent touch value that the channel has reported.
	   *
	   * *   This will be 0 or 1 for button-type inputs, or a ratio between 0-1 for axis-type inputs.
	   * *   This value is bounded by `minTouchValue` and `maxTouchValue`
	   * *   The value is not reset when the touch ends
	   * @returns The touch input value
	   * @throws {@link PhidgetError}
	   */


	  getTouchValue() {
	    this._assertOpen();

	    if (this.data.touchValue === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.touchValue;
	  }
	  /**
	   * The minimum value the `Touch` event will report.
	   * @returns The minimum touch input value
	   * @throws {@link PhidgetError}
	   */


	  getMinTouchValue() {
	    this._assertOpen();

	    if (this.data.minTouchValue === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minTouchValue;
	  }
	  /**
	   * The maximum value the `Touch` event will report.
	   * @returns The maximum touch input value
	   * @throws {@link PhidgetError}
	   */


	  getMaxTouchValue() {
	    this._assertOpen();

	    if (this.data.maxTouchValue === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxTouchValue;
	  }
	  /**
	   * The channel will not issue a `Touch` event until the touch value has changed by the amount specified by the `touchValueChangeTrigger`.
	   *
	   * *   Setting the `touchValueChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getTouchValueChangeTrigger() {
	    this._assertOpen();

	    if (this.data.touchValueChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.touchValueChangeTrigger;
	  }
	  /**
	   * The channel will not issue a `Touch` event until the touch value has changed by the amount specified by the `touchValueChangeTrigger`.
	   *
	   * *   Setting the `touchValueChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   * @param touchValueChangeTrigger - The change trigger value
	   */


	  async setTouchValueChangeTrigger(touchValueChangeTrigger) {
	    this._assertOpen();

	    if (touchValueChangeTrigger < this.data.minTouchValueChangeTrigger || touchValueChangeTrigger > this.data.maxTouchValueChangeTrigger) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minTouchValueChangeTrigger + " - " + this.data.maxTouchValueChangeTrigger + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: touchValueChangeTrigger
	    });
	    await bp.send(this._ch, 46);
	  }
	  /**
	   * The minimum value that `touchValueChangeTrigger` can be set to.
	   * @returns The minimum change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMinTouchValueChangeTrigger() {
	    this._assertOpen();

	    if (this.data.minTouchValueChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minTouchValueChangeTrigger;
	  }
	  /**
	   * The maximum value that `touchValueChangeTrigger` can be set to.
	   * @returns The maximum change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMaxTouchValueChangeTrigger() {
	    this._assertOpen();

	    if (this.data.maxTouchValueChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxTouchValueChangeTrigger;
	  }

	}

	/** @public */

	class CapacitiveTouch extends CapacitiveTouchBase {
	  /** @internal */
	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 96:
	        this.data.isTouched = 1;

	        super._bridgeInput(bp);

	        break;

	      case 137:
	        this.data.isTouched = 0;

	        super._bridgeInput(bp);

	        break;

	      default:
	        super._bridgeInput(bp);

	        break;
	    }
	  }

	}

	class RFIDBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onTag = null;
	    this.onTagLost = null;
	    this._class = exports.ChannelClass.RFID;
	    this.name = "RFID";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 41:
	        this.data.antennaEnabled = bp.entries[0].v;

	        this._FIREPropertyChange('AntennaEnabled', bp);

	        break;

	      case 103:
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      lastTagString: null,
	      lastTagProtocol: 0,
	      antennaEnabled: 2,
	      tagPresent: 2
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	  }
	  /** @internal */


	  async _setDefaults() {
	    throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	  }
	  /** @internal */


	  _hasInitialState() {
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {}
	  /**
	   * The on/off state of the antenna.
	   *
	   * *   You can turn the antenna off to save power.
	   * *   You must turn the antenna on in order to detect and read RFID tags.
	   * @throws {@link PhidgetError}
	   */


	  get antennaEnabled() {
	    return this.getAntennaEnabled();
	  }
	  /**
	   * This property is true if a compatibile RFID tag is being read by the reader.
	   *
	   * *   `TagPresent` will remain true until the tag is out of range and can no longer be read.
	   * @throws {@link PhidgetError}
	   */


	  get tagPresent() {
	    return this.getTagPresent();
	  }
	  /**
	   * The on/off state of the antenna.
	   *
	   * *   You can turn the antenna off to save power.
	   * *   You must turn the antenna on in order to detect and read RFID tags.
	   * @returns The state of the antenna
	   * @throws {@link PhidgetError}
	   */


	  getAntennaEnabled() {
	    this._assertOpen();

	    if (this.data.antennaEnabled === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.antennaEnabled;
	  }
	  /**
	   * The on/off state of the antenna.
	   *
	   * *   You can turn the antenna off to save power.
	   * *   You must turn the antenna on in order to detect and read RFID tags.
	   * @throws {@link PhidgetError}
	   * @param antennaEnabled - The state of the antenna
	   */


	  async setAntennaEnabled(antennaEnabled) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (antennaEnabled !== false && antennaEnabled !== true) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be a boolean.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: antennaEnabled ? 1 : 0
	    });
	    await bp.send(this._ch, 41);
	  }
	  /**
	   * This property is true if a compatibile RFID tag is being read by the reader.
	   *
	   * *   `TagPresent` will remain true until the tag is out of range and can no longer be read.
	   * @returns Tag is in range
	   * @throws {@link PhidgetError}
	   */


	  getTagPresent() {
	    this._assertOpen();

	    if (this.data.tagPresent === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.tagPresent;
	  }
	  /**
	   * Writes data to the tag being currently read by the reader.
	   *
	   * *   You cannot write to a read-only or locked tag.
	   * @throws {@link PhidgetError}
	   * @param tagString - The data to write to the tag
	   * @param protocol - The communication protocol to use
	   * @param lockTag - If true, permanently locks the tag so that it cannot be re-written after this write.
	   */


	  async write(tagString, protocol, lockTag) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "s",
	      value: tagString
	    });
	    if (!supportedRFIDProtocol(this._ch, protocol)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified RFIDProtocol is unsupported by this device.");
	    bp.set({
	      name: "1",
	      type: "d",
	      value: protocol
	    });
	    if (lockTag !== false && lockTag !== true) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be a boolean.");
	    bp.set({
	      name: "2",
	      type: "d",
	      value: lockTag ? 1 : 0
	    });
	    await bp.send(this._ch, 103);
	  }

	}

	/** @public */

	class RFID extends RFIDBase {
	  constructor(ch) {
	    super(ch);
	    this._transactionLock = new PhidgetLock();
	    this._private = {
	      latestTagString: ''
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    super._initAfterOpen();

	    this._private = {
	      latestTagString: ''
	    };
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 92:
	        {
	          this.data.tagPresent = 1;
	          const tag = bp.getString(0);
	          const protocol = bp.getNumber(1);

	          if (this._isAttachedDone && this.onTag) {
	            try {
	              this.onTag(tag, protocol);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          this.data.lastTagString = tag;
	          this.data.lastTagProtocol = protocol;
	          break;
	        }

	      case 93:
	        {
	          this.data.tagPresent = 0;
	          const tag = bp.getString(0);
	          const protocol = bp.getNumber(1);

	          if (this._isAttachedDone && this.onTagLost) {
	            try {
	              this.onTagLost(tag, protocol);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      case 41:
	        if (this.data.tagPresent === 2) this.data.tagPresent = 0;

	        super._bridgeInput(bp);

	        break;

	      default:
	        super._bridgeInput(bp);

	        break;
	    }
	  }

	  getLastTag() {
	    this._assertOpen();

	    if (!this.data.lastTagString) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return {
	      tagString: this.data.lastTagString,
	      protocol: this.data.lastTagProtocol
	    };
	  }
	  /** @internal */


	  _setLatestTagString(tagString) {
	    this._private.latestTagString = tagString;
	    if (this._private.resolveLatestTag) this._private.resolveLatestTag(tagString);
	  }
	  /** @internal */


	  async _waitForTag(expectedString, timeout) {
	    await new promise((resolve, reject) => {
	      const timer = setTimeout(reject, timeout);

	      this._private.resolveLatestTag = function (tagString) {
	        if (expectedString && expectedString === tagString) {
	          clearTimeout(timer);
	          resolve();
	        }
	      };
	    });
	  }

	}

	class GPSBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onPositionChange = null;
	    this.onHeadingChange = null;
	    this.onPositionFixStateChange = null;
	    this._class = exports.ChannelClass.GPS;
	    this.name = "GPS";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 110:
	        {
	          this.data.heading = bp.entries[0].v;
	          this.data.velocity = bp.entries[1].v;

	          if (this._isAttachedDone && this.onHeadingChange) {
	            try {
	              this.onHeadingChange(this.data.heading, this.data.velocity);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      case 29:
	        {
	          this.data.latitude = bp.entries[0].v;
	          this.data.longitude = bp.entries[1].v;
	          this.data.altitude = bp.entries[2].v;

	          if (this._isAttachedDone && this.onPositionChange) {
	            try {
	              this.onPositionChange(this.data.latitude, this.data.longitude, this.data.altitude);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      case 30:
	        {
	          this.data.positionFixState = bp.entries[0].v;

	          if (this._isAttachedDone && this.onPositionFixStateChange) {
	            try {
	              this.onPositionFixStateChange(!!this.data.positionFixState);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      altitude: 1e+300,
	      date: null,
	      heading: 1e+300,
	      latitude: 1e+300,
	      longitude: 1e+300,
	      NMEAData: null,
	      positionFixState: 2,
	      time: null,
	      velocity: 1e+300
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	  }
	  /** @internal */


	  async _setDefaults() {
	    throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	  }
	  /** @internal */


	  _hasInitialState() {
	    if ((this.data.heading == 1e+300 || this.data.velocity == 1e+300) && !this._gotHeadingChangeErrorEvent) return false;
	    if ((this.data.latitude == 1e+300 || this.data.longitude == 1e+300 || this.data.altitude == 1e+300) && !this._gotPositionChangeErrorEvent) return false;
	    if (this.data.positionFixState == 2 && !this._gotPositionFixStateChangeErrorEvent) return false;
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {
	    if (this.data.heading != 1e+300 && this.data.velocity != 1e+300) if (this.onHeadingChange) try {
	      this.onHeadingChange(this.data.heading, this.data.velocity);
	    } catch (err) {
	      logEventException(err);
	    }
	    if (this.data.latitude != 1e+300 && this.data.longitude != 1e+300 && this.data.altitude != 1e+300) if (this.onPositionChange) try {
	      this.onPositionChange(this.data.latitude, this.data.longitude, this.data.altitude);
	    } catch (err) {
	      logEventException(err);
	    }
	    if (this.data.positionFixState != 2) if (this.onPositionFixStateChange) try {
	      this.onPositionFixStateChange(!!this.data.positionFixState);
	    } catch (err) {
	      logEventException(err);
	    }
	  }
	  /**
	   * The altitude above mean sea level in meters.
	   * @throws {@link PhidgetError}
	   */


	  get altitude() {
	    return this.getAltitude();
	  }
	  /**
	   * The UTC date of the last received position.
	   * @throws {@link PhidgetError}
	   */


	  get date() {
	    return this.getDate();
	  }
	  /**
	   * The current date and time in UTC
	   * @throws {@link PhidgetError}
	   */


	  get dateAndTime() {
	    return this.getDateAndTime();
	  }
	  /**
	   * The current true course over ground of the GPS
	   * @throws {@link PhidgetError}
	   */


	  get heading() {
	    return this.getHeading();
	  }
	  /**
	   * The latitude of the GPS in degrees
	   * @throws {@link PhidgetError}
	   */


	  get latitude() {
	    return this.getLatitude();
	  }
	  /**
	   * The longitude of the GPS.
	   * @throws {@link PhidgetError}
	   */


	  get longitude() {
	    return this.getLongitude();
	  }
	  /**
	   * The NMEA data structure.
	   * @throws {@link PhidgetError}
	   */


	  get NMEAData() {
	    return this.getNMEAData();
	  }
	  /**
	   * The status of the position fix
	   *
	   * *   True if a fix is available and latitude, longitude, and altitude can be read. False if the fix is not available.
	   * @throws {@link PhidgetError}
	   */


	  get positionFixState() {
	    return this.getPositionFixState();
	  }
	  /**
	   * The current UTC time of the GPS
	   * @throws {@link PhidgetError}
	   */


	  get time() {
	    return this.getTime();
	  }
	  /**
	   * The current speed over ground of the GPS.
	   * @throws {@link PhidgetError}
	   */


	  get velocity() {
	    return this.getVelocity();
	  }
	  /**
	   * The altitude above mean sea level in meters.
	   * @returns Altitude of the GPS
	   * @throws {@link PhidgetError}
	   */


	  getAltitude() {
	    this._assertOpen();

	    if (this.data.altitude === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.altitude;
	  }
	  /**
	   * The UTC date of the last received position.
	   * @returns Date of last position
	   * @throws {@link PhidgetError}
	   */


	  getDate() {
	    this._assertOpen();

	    if (this.data.date === null) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.date;
	  }
	  /**
	   * The current true course over ground of the GPS
	   * @returns Heading of the GPS
	   * @throws {@link PhidgetError}
	   */


	  getHeading() {
	    this._assertOpen();

	    if (this.data.heading === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.heading;
	  }
	  /**
	   * The latitude of the GPS in degrees
	   * @returns Latitude of the GPS
	   * @throws {@link PhidgetError}
	   */


	  getLatitude() {
	    this._assertOpen();

	    if (this.data.latitude === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.latitude;
	  }
	  /**
	   * The longitude of the GPS.
	   * @returns Longtidue of the GPS
	   * @throws {@link PhidgetError}
	   */


	  getLongitude() {
	    this._assertOpen();

	    if (this.data.longitude === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.longitude;
	  }
	  /**
	   * The NMEA data structure.
	   * @returns NMEA Data structure
	   * @throws {@link PhidgetError}
	   */


	  getNMEAData() {
	    this._assertOpen();

	    if (this.data.NMEAData === null) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.NMEAData;
	  }
	  /**
	   * The status of the position fix
	   *
	   * *   True if a fix is available and latitude, longitude, and altitude can be read. False if the fix is not available.
	   * @returns Status of the position fix
	   * @throws {@link PhidgetError}
	   */


	  getPositionFixState() {
	    this._assertOpen();

	    if (this.data.positionFixState === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.positionFixState;
	  }
	  /**
	   * The current UTC time of the GPS
	   * @returns Current time
	   * @throws {@link PhidgetError}
	   */


	  getTime() {
	    this._assertOpen();

	    if (this.data.time === null) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.time;
	  }
	  /**
	   * The current speed over ground of the GPS.
	   * @returns Velocity of the GPS
	   * @throws {@link PhidgetError}
	   */


	  getVelocity() {
	    this._assertOpen();

	    if (this.data.velocity === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.velocity;
	  }

	}

	function readGPGGA(bp) {
	  return {
	    latitude: bp.getNumber("GPGGA.latitude"),
	    longitude: bp.getNumber("GPGGA.longitude"),
	    fixQuality: bp.getNumber("GPGGA.fixQuality"),
	    numSatellites: bp.getNumber("GPGGA.numSatellites"),
	    horizontalDilution: bp.getNumber("GPGGA.horizontalDilution"),
	    altitude: bp.getNumber("GPGGA.altitude"),
	    heightOfGeoid: bp.getNumber("GPGGA.heightOfGeoid")
	  };
	}

	function readGPGSA(bp) {
	  return {
	    mode: String.fromCharCode(bp.getNumber("GPGSA.mode")),
	    fixType: bp.getNumber("GPGSA.fixType"),
	    satUsed: bp.getArray("GPGSA.satUsed"),
	    posnDilution: bp.getNumber("GPGSA.posnDilution"),
	    horizDilution: bp.getNumber("GPGSA.horizDilution"),
	    vertDilution: bp.getNumber("GPGSA.vertDilution")
	  };
	}

	function readGPRMC(bp) {
	  return {
	    status: String.fromCharCode(bp.getNumber("GPRMC.status")),
	    latitude: bp.getNumber("GPRMC.latitude"),
	    longitude: bp.getNumber("GPRMC.longitude"),
	    speedKnots: bp.getNumber("GPRMC.speedKnots"),
	    heading: bp.getNumber("GPRMC.heading"),
	    magneticVariation: bp.getNumber("GPRMC.magneticVariation"),
	    mode: String.fromCharCode(bp.getNumber("GPRMC.mode"))
	  };
	}

	function readGPVTG(bp) {
	  return {
	    trueHeading: bp.getNumber("GPVTG.trueHeading"),
	    magneticHeading: bp.getNumber("GPVTG.magneticHeading"),
	    speedKnots: bp.getNumber("GPVTG.speedKnots"),
	    speed: bp.getNumber("GPVTG.speed"),
	    mode: String.fromCharCode(bp.getNumber("GPVTG.mode"))
	  };
	}

	function readNMEAData(bp) {
	  return {
	    GGA: readGPGGA(bp),
	    GSA: readGPGSA(bp),
	    RMC: readGPRMC(bp),
	    VTG: readGPVTG(bp)
	  };
	}
	/** @public */


	class GPS extends GPSBase {
	  /** @internal */
	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 9:
	        this.data.NMEAData = readNMEAData(bp);
	        break;

	      case 108:
	        this.data.time = {
	          tm_ms: bp.getNumber("GPSTime.tm_ms"),
	          tm_sec: bp.getNumber("GPSTime.tm_sec"),
	          tm_min: bp.getNumber("GPSTime.tm_min"),
	          tm_hour: bp.getNumber("GPSTime.tm_hour")
	        };
	        break;

	      case 109:
	        this.data.date = {
	          tm_mday: bp.getNumber("GPSDate.tm_mday"),
	          tm_mon: bp.getNumber("GPSDate.tm_mon"),
	          tm_year: bp.getNumber("GPSDate.tm_year")
	        };
	        break;

	      default:
	        super._bridgeInput(bp);

	        break;
	    }
	  }

	  getDateAndTime() {
	    this._assertOpen();

	    if (this.data.time === null) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    if (this.data.date === null) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    const date = new Date(Date.UTC(this.data.date.tm_year, this.data.date.tm_mon, this.data.date.tm_mday, this.data.time.tm_hour, this.data.time.tm_min, this.data.time.tm_sec, this.data.time.tm_ms));
	    return date;
	  }

	}

	class GyroscopeBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onAngularRateUpdate = null;
	    this._class = exports.ChannelClass.GYROSCOPE;
	    this.name = "Gyroscope";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 54:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.entries[1].v;else this.data.dataInterval = bp.entries[0].v;

	        this._FIREPropertyChange('DataInterval', bp);

	        this._FIREPropertyChange('DataRate', bp);

	        break;

	      case 170:
	        this.data.heatingEnabled = bp.entries[0].v;

	        this._FIREPropertyChange('HeatingEnabled', bp);

	        break;

	      case 145:
	        this.data.precision = bp.entries[0].v;

	        this._FIREPropertyChange('Precision', bp);

	        break;

	      case 106:
	        break;

	      case 2:
	        {
	          this.data.angularRate = bp.entries[0].v;
	          this.data.timestamp = bp.entries[1].v;

	          if (this._isAttachedDone && this.onAngularRateUpdate) {
	            try {
	              this.onAngularRateUpdate(this.data.angularRate, this.data.timestamp);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      dataInterval: 1e+300,
	      maxDataInterval: 4294967295,
	      minDataRate: 1e+300,
	      maxDataRate: 1e+300,
	      maxAngularRate: [1e+300, 1e+300, 1e+300],
	      minDataInterval: 4294967295,
	      minAngularRate: [1e+300, 1e+300, 1e+300],
	      angularRate: [1e+300, 1e+300, 1e+300],
	      axisCount: 2147483647,
	      timestamp: 1e+300,
	      precision: 2147483647,
	      heatingEnabled: 2
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 314:
	      case 319:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 50;
	        this.data.maxAngularRate = [2000, 2000, 2000];
	        this.data.minDataInterval = 20;
	        this.data.minAngularRate = [-2000, -2000, -2000];
	        this.data.axisCount = 3;
	        this.data.precision = exports.SpatialPrecision.LOW;
	        break;

	      case 332:
	        this.data.dataInterval = 256;
	        this.data.maxDataInterval = 1000;
	        this.data.minDataRate = 1;
	        this.data.maxDataRate = 250;
	        this.data.maxAngularRate = [2000, 2000, 2000];
	        this.data.minDataInterval = 4;
	        this.data.minAngularRate = [-2000, -2000, -2000];
	        this.data.angularRate = this._ch.parent.data.angularRate[this._ch.index];
	        this.data.axisCount = 3;
	        this.data.timestamp = this._ch.parent.data.timestamp[this._ch.index];
	        this.data.precision = exports.SpatialPrecision.HYBRID;
	        this.data.heatingEnabled = 0;
	        break;

	      case 337:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 1000;
	        this.data.minDataRate = 1;
	        this.data.maxDataRate = 1000;
	        this.data.maxAngularRate = [2000, 2000, 2000];
	        this.data.minDataInterval = 1;
	        this.data.minAngularRate = [-2000, -2000, -2000];
	        this.data.angularRate = this._ch.parent.data.angularRate[this._ch.index];
	        this.data.axisCount = 3;
	        this.data.timestamp = this._ch.parent.data.timestamp[this._ch.index];
	        this.data.precision = exports.SpatialPrecision.HIGH;
	        this.data.heatingEnabled = 0;
	        break;

	      case 342:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 1000;
	        this.data.minDataRate = 1;
	        this.data.maxDataRate = 1000;
	        this.data.maxAngularRate = [2000, 2000, 2000];
	        this.data.minDataInterval = 1;
	        this.data.minAngularRate = [-2000, -2000, -2000];
	        this.data.axisCount = 3;
	        this.data.precision = exports.SpatialPrecision.HIGH;
	        this.data.heatingEnabled = 0;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    let bp;

	    switch (this._ch.chDef.uid) {
	      case 314:
	      case 319:
	      case 332:
	      case 337:
	      case 342:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    if ((this.data.angularRate.includes(1e+300) || this.data.timestamp == 1e+300) && !this._gotAngularRateUpdateErrorEvent) return false;
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {
	    if (!this.data.angularRate.includes(1e+300) && this.data.timestamp != 1e+300) if (this.onAngularRateUpdate) try {
	      this.onAngularRateUpdate(this.data.angularRate, this.data.timestamp);
	    } catch (err) {
	      logEventException(err);
	    }
	  }
	  /**
	   * The most recent angular rate value that the channel has reported.
	   *
	   * *   This value will always be between `minAngularRate` and `maxAngularRate`.
	   * @throws {@link PhidgetError}
	   */


	  get angularRate() {
	    return this.getAngularRate();
	  }
	  /**
	   * The minimum value the `AngularRateUpdate` event will report.
	   * @throws {@link PhidgetError}
	   */


	  get minAngularRate() {
	    return this.getMinAngularRate();
	  }
	  /**
	   * The maximum value the `AngularRateUpdate` event will report.
	   * @throws {@link PhidgetError}
	   */


	  get maxAngularRate() {
	    return this.getMaxAngularRate();
	  }
	  /**
	   * The number of axes the channel can measure angular rate on.
	   *
	   * *   See your device's User Guide for more information about the number of axes and their orientation.
	   * @throws {@link PhidgetError}
	   */


	  get axisCount() {
	    return this.getAxisCount();
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `AngularRateUpdate` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * @throws {@link PhidgetError}
	   */


	  get dataInterval() {
	    return this.getDataInterval();
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataInterval() {
	    return this.getMinDataInterval();
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataInterval() {
	    return this.getMaxDataInterval();
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   */


	  get dataRate() {
	    return this.getDataRate();
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataRate() {
	    return this.getMinDataRate();
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataRate() {
	    return this.getMaxDataRate();
	  }
	  /**
	   * Set to TRUE to enable the temperature stabilization feature of this device. This enables onboard heating elements to bring the board up to a known temperature to minimize ambient temerature effects on the sensor's reading. You can leave this setting FALSE to conserve power consumption.
	   *
	   * If you enable heating, it is strongly recommended to keep the board in its enclosure to keep it insulated from moving air.
	   *
	   * This property is shared by any and all spatial-related objects on this device (Accelerometer, Gyroscope, Magnetometer, Spatial)
	   * @throws {@link PhidgetError}
	   */


	  get heatingEnabled() {
	    return this.getHeatingEnabled();
	  }
	  /**
	   * Selects between high/low precision sensing chips.
	   * @throws {@link PhidgetError}
	   * @internal
	   */


	  get precision() {
	    return this.getPrecision();
	  }
	  /**
	   * The most recent timestamp value that the channel has reported. This is an extremely accurate time measurement streamed from the device.
	   *
	   * *   If your application requires a time measurement, you should use this value over a local software timestamp.
	   * @throws {@link PhidgetError}
	   */


	  get timestamp() {
	    return this.getTimestamp();
	  }
	  /**
	   * The most recent angular rate value that the channel has reported.
	   *
	   * *   This value will always be between `minAngularRate` and `maxAngularRate`.
	   * @returns The last reported angular rate
	   * @throws {@link PhidgetError}
	   */


	  getAngularRate() {
	    this._assertOpen();

	    if (this.data.angularRate.includes(1e+300)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.angularRate;
	  }
	  /**
	   * The minimum value the `AngularRateUpdate` event will report.
	   * @returns The angular rate values
	   * @throws {@link PhidgetError}
	   */


	  getMinAngularRate() {
	    this._assertOpen();

	    if (this.data.minAngularRate.includes(1e+300)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minAngularRate;
	  }
	  /**
	   * The maximum value the `AngularRateUpdate` event will report.
	   * @returns The angular rate values
	   * @throws {@link PhidgetError}
	   */


	  getMaxAngularRate() {
	    this._assertOpen();

	    if (this.data.maxAngularRate.includes(1e+300)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxAngularRate;
	  }
	  /**
	   * The number of axes the channel can measure angular rate on.
	   *
	   * *   See your device's User Guide for more information about the number of axes and their orientation.
	   * @returns Axis count value
	   * @throws {@link PhidgetError}
	   */


	  getAxisCount() {
	    this._assertOpen();

	    if (this.data.axisCount === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.axisCount;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `AngularRateUpdate` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getDataInterval() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dataInterval;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `AngularRateUpdate` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * @throws {@link PhidgetError}
	   * @param dataInterval - The data interval value
	   */


	  async setDataInterval(dataInterval) {
	    this._assertOpen();

	    if (dataInterval < this.data.minDataInterval || dataInterval > this.data.maxDataInterval) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataInterval + " - " + this.data.maxDataInterval + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: dataInterval
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataInterval() {
	    this._assertOpen();

	    if (this.data.minDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataInterval;
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataInterval() {
	    this._assertOpen();

	    if (this.data.maxDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @returns The data rate for the channel
	   * @throws {@link PhidgetError}
	   */


	  getDataRate() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return 1000.0 / this.data.dataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   * @param dataRate - The data rate for the channel
	   */


	  async setDataRate(dataRate) {
	    this._assertOpen();

	    if (dataRate < this.data.minDataRate || dataRate > this.data.maxDataRate) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataRate + " - " + this.data.maxDataRate + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: Math.round(1000.0 / dataRate)
	    });
	    bp.set({
	      name: "1",
	      type: "g",
	      value: 1000.0 / dataRate
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataRate() {
	    this._assertOpen();

	    if (this.data.minDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataRate;
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataRate() {
	    this._assertOpen();

	    if (this.data.maxDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataRate;
	  }
	  /**
	   * Set to TRUE to enable the temperature stabilization feature of this device. This enables onboard heating elements to bring the board up to a known temperature to minimize ambient temerature effects on the sensor's reading. You can leave this setting FALSE to conserve power consumption.
	   *
	   * If you enable heating, it is strongly recommended to keep the board in its enclosure to keep it insulated from moving air.
	   *
	   * This property is shared by any and all spatial-related objects on this device (Accelerometer, Gyroscope, Magnetometer, Spatial)
	   * @returns Whether self-heating temperature stabilization is enabled
	   * @throws {@link PhidgetError}
	   */


	  getHeatingEnabled() {
	    this._assertOpen();

	    if (this.data.heatingEnabled === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.heatingEnabled;
	  }
	  /**
	   * Set to TRUE to enable the temperature stabilization feature of this device. This enables onboard heating elements to bring the board up to a known temperature to minimize ambient temerature effects on the sensor's reading. You can leave this setting FALSE to conserve power consumption.
	   *
	   * If you enable heating, it is strongly recommended to keep the board in its enclosure to keep it insulated from moving air.
	   *
	   * This property is shared by any and all spatial-related objects on this device (Accelerometer, Gyroscope, Magnetometer, Spatial)
	   * @throws {@link PhidgetError}
	   * @param heatingEnabled - Whether self-heating temperature stabilization is enabled
	   */


	  async setHeatingEnabled(heatingEnabled) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (heatingEnabled !== false && heatingEnabled !== true) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be a boolean.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: heatingEnabled ? 1 : 0
	    });
	    await bp.send(this._ch, 170);
	  }
	  /**
	   * Selects between high/low precision sensing chips.
	   * @returns The sensor precision value
	   * @throws {@link PhidgetError}
	   * @internal
	   */


	  getPrecision() {
	    this._assertOpen();

	    if (this.data.precision === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.precision;
	  }
	  /**
	   * Selects between high/low precision sensing chips.
	   * @throws {@link PhidgetError}
	   * @param precision - The sensor precision value
	   * @internal
	   */


	  async setPrecision(precision) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedSpatialPrecision(this._ch, precision)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified SpatialPrecision is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: precision
	    });
	    await bp.send(this._ch, 145);
	  }
	  /**
	   * The most recent timestamp value that the channel has reported. This is an extremely accurate time measurement streamed from the device.
	   *
	   * *   If your application requires a time measurement, you should use this value over a local software timestamp.
	   * @returns The timestamp value
	   * @throws {@link PhidgetError}
	   */


	  getTimestamp() {
	    this._assertOpen();

	    if (this.data.timestamp === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.timestamp;
	  }
	  /**
	   * Re-zeros the gyroscope in 1-2 seconds.
	   *
	   * *   The device must be stationary when zeroing.
	   * *   The angular rate will be reported as 0.0Â°/s while zeroing.
	   * *   Zeroing the gyroscope is a method of compensating for the drift that is inherent to all gyroscopes. See your device's User Guide for more information on dealing with drift.
	   * @throws {@link PhidgetError}
	   */


	  async zero() {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    await bp.send(this._ch, 106);
	  }

	}

	/** @public */

	class Gyroscope extends GyroscopeBase {
	  /** @internal */
	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 10:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.getNumber(1);else this.data.dataInterval = bp.getNumber(0);

	        this._FIREPropertyChange('DataInterval');

	        this._FIREPropertyChange('DataRate');

	        break;

	      default:
	        super._bridgeInput(bp);

	        break;
	    }
	  }
	  /** @internal */


	  _errorHandler(code) {
	    switch (code) {
	      case exports.ErrorEventCode.SATURATION:
	        this.data.angularRate = [1e+300, 1e+300, 1e+300];
	        this.data.timestamp = 1e+300;
	        this._gotAngularRateUpdateErrorEvent = true;
	        break;
	    }
	  }

	}

	class MagnetometerBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onMagneticFieldChange = null;
	    this._class = exports.ChannelClass.MAGNETOMETER;
	    this.name = "Magnetometer";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 50:
	        break;

	      case 54:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.entries[1].v;else this.data.dataInterval = bp.entries[0].v;

	        this._FIREPropertyChange('DataInterval', bp);

	        this._FIREPropertyChange('DataRate', bp);

	        break;

	      case 170:
	        this.data.heatingEnabled = bp.entries[0].v;

	        this._FIREPropertyChange('HeatingEnabled', bp);

	        break;

	      case 46:
	        this.data.magneticFieldChangeTrigger = bp.entries[0].v;

	        this._FIREPropertyChange('MagneticFieldChangeTrigger', bp);

	        break;

	      case 35:
	        break;

	      case 37:
	        break;

	      case 18:
	        {
	          this.data.magneticField = bp.entries[0].v;
	          this.data.timestamp = bp.entries[1].v;

	          if (this._isAttachedDone && this.onMagneticFieldChange) {
	            try {
	              this.onMagneticFieldChange(this.data.magneticField, this.data.timestamp);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      dataInterval: 1e+300,
	      maxDataInterval: 4294967295,
	      minDataRate: 1e+300,
	      maxDataRate: 1e+300,
	      maxMagneticField: [1e+300, 1e+300, 1e+300],
	      maxMagneticFieldChangeTrigger: 1e+300,
	      minDataInterval: 4294967295,
	      minMagneticField: [1e+300, 1e+300, 1e+300],
	      minMagneticFieldChangeTrigger: 1e+300,
	      magneticField: [1e+300, 1e+300, 1e+300],
	      magneticFieldChangeTrigger: 1e+300,
	      axisCount: 2147483647,
	      timestamp: 1e+300,
	      heatingEnabled: 2
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 315:
	      case 320:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 50;
	        this.data.maxMagneticField = [8, 8, 8];
	        this.data.maxMagneticFieldChangeTrigger = 8;
	        this.data.minDataInterval = 20;
	        this.data.minMagneticField = [-8, -8, -8];
	        this.data.minMagneticFieldChangeTrigger = 0;
	        this.data.magneticFieldChangeTrigger = 0;
	        this.data.axisCount = 3;
	        break;

	      case 333:
	        this.data.dataInterval = 256;
	        this.data.maxDataInterval = 1000;
	        this.data.minDataRate = 1;
	        this.data.maxDataRate = 250;
	        this.data.maxMagneticField = [50, 50, 50];
	        this.data.maxMagneticFieldChangeTrigger = 100;
	        this.data.minDataInterval = 4;
	        this.data.minMagneticField = [-50, -50, -50];
	        this.data.minMagneticFieldChangeTrigger = 0;
	        this.data.magneticField = this._ch.parent.data.magneticField[this._ch.index];
	        this.data.magneticFieldChangeTrigger = 0;
	        this.data.axisCount = 3;
	        this.data.timestamp = this._ch.parent.data.timestamp[this._ch.index];
	        this.data.heatingEnabled = 0;
	        break;

	      case 338:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 1000;
	        this.data.minDataRate = 1;
	        this.data.maxDataRate = 100;
	        this.data.maxMagneticField = [8, 8, 8];
	        this.data.maxMagneticFieldChangeTrigger = 16;
	        this.data.minDataInterval = 10;
	        this.data.minMagneticField = [-8, -8, -8];
	        this.data.minMagneticFieldChangeTrigger = 0;
	        this.data.magneticField = this._ch.parent.data.magneticField[this._ch.index];
	        this.data.magneticFieldChangeTrigger = 0;
	        this.data.axisCount = 3;
	        this.data.timestamp = this._ch.parent.data.timestamp[this._ch.index];
	        this.data.heatingEnabled = 0;
	        break;

	      case 343:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 1000;
	        this.data.minDataRate = 1;
	        this.data.maxDataRate = 100;
	        this.data.maxMagneticField = [8, 8, 8];
	        this.data.maxMagneticFieldChangeTrigger = 16;
	        this.data.minDataInterval = 10;
	        this.data.minMagneticField = [-8, -8, -8];
	        this.data.minMagneticFieldChangeTrigger = 0;
	        this.data.magneticFieldChangeTrigger = 0;
	        this.data.axisCount = 3;
	        this.data.heatingEnabled = 0;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    let bp;

	    switch (this._ch.chDef.uid) {
	      case 315:
	      case 320:
	      case 333:
	      case 338:
	      case 343:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.magneticFieldChangeTrigger
	        });
	        await bp.send(this._ch, 46);
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    if ((this.data.magneticField.includes(1e+300) || this.data.timestamp == 1e+300) && !this._gotMagneticFieldChangeErrorEvent) return false;
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {
	    if (!this.data.magneticField.includes(1e+300) && this.data.timestamp != 1e+300) if (this.onMagneticFieldChange) try {
	      this.onMagneticFieldChange(this.data.magneticField, this.data.timestamp);
	    } catch (err) {
	      logEventException(err);
	    }
	  }
	  /**
	   * The number of axes the channel can measure field strength on.
	   *
	   * *   See your device's User Guide for more information about the number of axes and their orientation.
	   * @throws {@link PhidgetError}
	   */


	  get axisCount() {
	    return this.getAxisCount();
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `MagneticFieldChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `MagneticFieldChange` events can also be affected by the `magneticFieldChangeTrigger`.
	   * @throws {@link PhidgetError}
	   */


	  get dataInterval() {
	    return this.getDataInterval();
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataInterval() {
	    return this.getMinDataInterval();
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataInterval() {
	    return this.getMaxDataInterval();
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   */


	  get dataRate() {
	    return this.getDataRate();
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataRate() {
	    return this.getMinDataRate();
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataRate() {
	    return this.getMaxDataRate();
	  }
	  /**
	   * Set to TRUE to enable the temperature stabilization feature of this device. This enables onboard heating elements to bring the board up to a known temperature to minimize ambient temerature effects on the sensor's reading. You can leave this setting FALSE to conserve power consumption.
	   *
	   * If you enable heating, it is strongly recommended to keep the board in its enclosure to keep it insulated from moving air.
	   *
	   * This property is shared by any and all spatial-related objects on this device (Accelerometer, Gyroscope, Magnetometer, Spatial)
	   * @throws {@link PhidgetError}
	   */


	  get heatingEnabled() {
	    return this.getHeatingEnabled();
	  }
	  /**
	   * The most recent field strength value that the channel has reported.
	   *
	   * *   This value will always be between `minMagneticField` and `maxMagneticField`.
	   * @throws {@link PhidgetError}
	   */


	  get magneticField() {
	    return this.getMagneticField();
	  }
	  /**
	   * The minimum value the `MagneticFieldChange` event will report.Any readings outside this range will result in a `Saturation` event. This check is done after calibration values have been applied, which will affect your magnetometer's range accordingly.
	   * @throws {@link PhidgetError}
	   */


	  get minMagneticField() {
	    return this.getMinMagneticField();
	  }
	  /**
	   * The maximum value the `MagneticFieldChange` event will report.Any readings outside this range will result in a `Saturation` event. This check is done after calibration values have been applied, which will affect your magnetometer's range accordingly.
	   * @throws {@link PhidgetError}
	   */


	  get maxMagneticField() {
	    return this.getMaxMagneticField();
	  }
	  /**
	   * The channel will not issue a `MagneticFieldChange` event until the field strength value has changed by the amount specified by the `magneticFieldChangeTrigger`.
	   *
	   * *   Setting the `magneticFieldChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   */


	  get magneticFieldChangeTrigger() {
	    return this.getMagneticFieldChangeTrigger();
	  }
	  /**
	   * The minimum value that `magneticFieldChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minMagneticFieldChangeTrigger() {
	    return this.getMinMagneticFieldChangeTrigger();
	  }
	  /**
	   * The maximum value that `magneticFieldChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxMagneticFieldChangeTrigger() {
	    return this.getMaxMagneticFieldChangeTrigger();
	  }
	  /**
	   * The most recent timestamp value that the channel has reported. This is an extremely accurate time measurement streamed from the device.
	   *
	   * *   If your application requires a time measurement, you should use this value over a local software timestamp.
	   * @throws {@link PhidgetError}
	   */


	  get timestamp() {
	    return this.getTimestamp();
	  }
	  /**
	   * The number of axes the channel can measure field strength on.
	   *
	   * *   See your device's User Guide for more information about the number of axes and their orientation.
	   * @returns The axis count value
	   * @throws {@link PhidgetError}
	   */


	  getAxisCount() {
	    this._assertOpen();

	    if (this.data.axisCount === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.axisCount;
	  }
	  /**
	   * Calibrate your device for the environment it will be used in.
	   *
	   * *   Due to physical location, hard and soft iron offsets, and even bias errors, your device should be calibrated. We have created a calibration program that will provide you with the `MagnetometerCorrectionParameters` for your specific situation. See your device's User Guide for more information.
	   * @throws {@link PhidgetError}
	   * @param magneticField - Ambient magnetic field value.
	   * @param offset0 - Provided by calibration program.
	   * @param offset1 - Provided by calibration program.
	   * @param offset2 - Provided by calibration program.
	   * @param gain0 - Provided by calibration program.
	   * @param gain1 - Provided by calibration program.
	   * @param gain2 - Provided by calibration program.
	   * @param T0 - Provided by calibration program.
	   * @param T1 - Provided by calibration program.
	   * @param T2 - Provided by calibration program.
	   * @param T3 - Provided by calibration program.
	   * @param T4 - Provided by calibration program.
	   * @param T5 - Provided by calibration program.
	   */


	  async setCorrectionParameters(magneticField, offset0, offset1, offset2, gain0, gain1, gain2, T0, T1, T2, T3, T4, T5) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: magneticField
	    });
	    bp.set({
	      name: "1",
	      type: "g",
	      value: offset0
	    });
	    bp.set({
	      name: "2",
	      type: "g",
	      value: offset1
	    });
	    bp.set({
	      name: "3",
	      type: "g",
	      value: offset2
	    });
	    bp.set({
	      name: "4",
	      type: "g",
	      value: gain0
	    });
	    bp.set({
	      name: "5",
	      type: "g",
	      value: gain1
	    });
	    bp.set({
	      name: "6",
	      type: "g",
	      value: gain2
	    });
	    bp.set({
	      name: "7",
	      type: "g",
	      value: T0
	    });
	    bp.set({
	      name: "8",
	      type: "g",
	      value: T1
	    });
	    bp.set({
	      name: "9",
	      type: "g",
	      value: T2
	    });
	    bp.set({
	      name: "10",
	      type: "g",
	      value: T3
	    });
	    bp.set({
	      name: "11",
	      type: "g",
	      value: T4
	    });
	    bp.set({
	      name: "12",
	      type: "g",
	      value: T5
	    });
	    await bp.send(this._ch, 50);
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `MagneticFieldChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `MagneticFieldChange` events can also be affected by the `magneticFieldChangeTrigger`.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getDataInterval() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dataInterval;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `MagneticFieldChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `MagneticFieldChange` events can also be affected by the `magneticFieldChangeTrigger`.
	   * @throws {@link PhidgetError}
	   * @param dataInterval - The data interval value
	   */


	  async setDataInterval(dataInterval) {
	    this._assertOpen();

	    if (dataInterval < this.data.minDataInterval || dataInterval > this.data.maxDataInterval) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataInterval + " - " + this.data.maxDataInterval + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: dataInterval
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataInterval() {
	    this._assertOpen();

	    if (this.data.minDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataInterval;
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataInterval() {
	    this._assertOpen();

	    if (this.data.maxDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @returns The data rate for the channel
	   * @throws {@link PhidgetError}
	   */


	  getDataRate() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return 1000.0 / this.data.dataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   * @param dataRate - The data rate for the channel
	   */


	  async setDataRate(dataRate) {
	    this._assertOpen();

	    if (dataRate < this.data.minDataRate || dataRate > this.data.maxDataRate) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataRate + " - " + this.data.maxDataRate + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: Math.round(1000.0 / dataRate)
	    });
	    bp.set({
	      name: "1",
	      type: "g",
	      value: 1000.0 / dataRate
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataRate() {
	    this._assertOpen();

	    if (this.data.minDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataRate;
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataRate() {
	    this._assertOpen();

	    if (this.data.maxDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataRate;
	  }
	  /**
	   * Set to TRUE to enable the temperature stabilization feature of this device. This enables onboard heating elements to bring the board up to a known temperature to minimize ambient temerature effects on the sensor's reading. You can leave this setting FALSE to conserve power consumption.
	   *
	   * If you enable heating, it is strongly recommended to keep the board in its enclosure to keep it insulated from moving air.
	   *
	   * This property is shared by any and all spatial-related objects on this device (Accelerometer, Gyroscope, Magnetometer, Spatial)
	   * @returns Whether self-heating temperature stabilization is enabled
	   * @throws {@link PhidgetError}
	   */


	  getHeatingEnabled() {
	    this._assertOpen();

	    if (this.data.heatingEnabled === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.heatingEnabled;
	  }
	  /**
	   * Set to TRUE to enable the temperature stabilization feature of this device. This enables onboard heating elements to bring the board up to a known temperature to minimize ambient temerature effects on the sensor's reading. You can leave this setting FALSE to conserve power consumption.
	   *
	   * If you enable heating, it is strongly recommended to keep the board in its enclosure to keep it insulated from moving air.
	   *
	   * This property is shared by any and all spatial-related objects on this device (Accelerometer, Gyroscope, Magnetometer, Spatial)
	   * @throws {@link PhidgetError}
	   * @param heatingEnabled - Whether self-heating temperature stabilization is enabled
	   */


	  async setHeatingEnabled(heatingEnabled) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (heatingEnabled !== false && heatingEnabled !== true) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be a boolean.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: heatingEnabled ? 1 : 0
	    });
	    await bp.send(this._ch, 170);
	  }
	  /**
	   * The most recent field strength value that the channel has reported.
	   *
	   * *   This value will always be between `minMagneticField` and `maxMagneticField`.
	   * @returns The channel's measured MagneticField
	   * @throws {@link PhidgetError}
	   */


	  getMagneticField() {
	    this._assertOpen();

	    if (this.data.magneticField.includes(1e+300)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.magneticField;
	  }
	  /**
	   * The minimum value the `MagneticFieldChange` event will report.Any readings outside this range will result in a `Saturation` event. This check is done after calibration values have been applied, which will affect your magnetometer's range accordingly.
	   * @returns The field strength value
	   * @throws {@link PhidgetError}
	   */


	  getMinMagneticField() {
	    this._assertOpen();

	    if (this.data.minMagneticField.includes(1e+300)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minMagneticField;
	  }
	  /**
	   * The maximum value the `MagneticFieldChange` event will report.Any readings outside this range will result in a `Saturation` event. This check is done after calibration values have been applied, which will affect your magnetometer's range accordingly.
	   * @returns The field strength value
	   * @throws {@link PhidgetError}
	   */


	  getMaxMagneticField() {
	    this._assertOpen();

	    if (this.data.maxMagneticField.includes(1e+300)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxMagneticField;
	  }
	  /**
	   * The channel will not issue a `MagneticFieldChange` event until the field strength value has changed by the amount specified by the `magneticFieldChangeTrigger`.
	   *
	   * *   Setting the `magneticFieldChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMagneticFieldChangeTrigger() {
	    this._assertOpen();

	    if (this.data.magneticFieldChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.magneticFieldChangeTrigger;
	  }
	  /**
	   * The channel will not issue a `MagneticFieldChange` event until the field strength value has changed by the amount specified by the `magneticFieldChangeTrigger`.
	   *
	   * *   Setting the `magneticFieldChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   * @param magneticFieldChangeTrigger - The change trigger value
	   */


	  async setMagneticFieldChangeTrigger(magneticFieldChangeTrigger) {
	    this._assertOpen();

	    if (magneticFieldChangeTrigger < this.data.minMagneticFieldChangeTrigger || magneticFieldChangeTrigger > this.data.maxMagneticFieldChangeTrigger) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minMagneticFieldChangeTrigger + " - " + this.data.maxMagneticFieldChangeTrigger + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: magneticFieldChangeTrigger
	    });
	    await bp.send(this._ch, 46);
	  }
	  /**
	   * The minimum value that `magneticFieldChangeTrigger` can be set to.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMinMagneticFieldChangeTrigger() {
	    this._assertOpen();

	    if (this.data.minMagneticFieldChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minMagneticFieldChangeTrigger;
	  }
	  /**
	   * The maximum value that `magneticFieldChangeTrigger` can be set to.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMaxMagneticFieldChangeTrigger() {
	    this._assertOpen();

	    if (this.data.maxMagneticFieldChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxMagneticFieldChangeTrigger;
	  }
	  /**
	   * Resets the `MagnetometerCorrectionParameters` to their default values.
	   *
	   * *   Due to physical location, hard and soft iron offsets, and even bias errors, your device should be calibrated. We have created a calibration program that will provide you with the `MagnetometerCorrectionParameters` for your specific situation. See your device's User Guide for more information.
	   * @throws {@link PhidgetError}
	   */


	  async resetCorrectionParameters() {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    await bp.send(this._ch, 35);
	  }
	  /**
	   * Saves the `MagnetometerCorrectionParameters`.
	   *
	   * *   Due to physical location, hard and soft iron offsets, and even bias errors, your device should be calibrated. We have created a calibration program that will provide you with the `MagnetometerCorrectionParameters` for your specific situation. See your device's User Guide for more information.
	   * @throws {@link PhidgetError}
	   */


	  async saveCorrectionParameters() {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    await bp.send(this._ch, 37);
	  }
	  /**
	   * The most recent timestamp value that the channel has reported. This is an extremely accurate time measurement streamed from the device.
	   *
	   * *   If your application requires a time measurement, you should use this value over a local software timestamp.
	   * @returns The timestamp value
	   * @throws {@link PhidgetError}
	   */


	  getTimestamp() {
	    this._assertOpen();

	    if (this.data.timestamp === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.timestamp;
	  }

	}

	/** @public */

	class Magnetometer extends MagnetometerBase {
	  constructor(ch) {
	    super(ch);
	    this.transactionLock = new PhidgetLock();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 10:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.getNumber(1);else this.data.dataInterval = bp.getNumber(0);

	        this._FIREPropertyChange('DataInterval');

	        this._FIREPropertyChange('DataRate');

	        break;

	      default:
	        super._bridgeInput(bp);

	        break;
	    }
	  }
	  /** @internal */


	  _errorHandler(code) {
	    switch (code) {
	      case exports.ErrorEventCode.SATURATION:
	        this.data.magneticField = [1e+300, 1e+300, 1e+300];
	        this.data.timestamp = 1e+300;
	        this._gotMagneticFieldChangeErrorEvent = true;
	        break;
	    }
	  }

	}

	class SpatialBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onSpatialData = null;
	    this.onAlgorithmData = null;
	    this._class = exports.ChannelClass.SPATIAL;
	    this.name = "Spatial";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 174:
	        break;

	      case 149:
	        this.data.algorithm = bp.entries[0].v;

	        this._FIREPropertyChange('Algorithm', bp);

	        break;

	      case 151:
	        this.data.algorithmMagnetometerGain = bp.entries[0].v;

	        this._FIREPropertyChange('AlgorithmMagnetometerGain', bp);

	        break;

	      case 54:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.entries[1].v;else this.data.dataInterval = bp.entries[0].v;

	        this._FIREPropertyChange('DataInterval', bp);

	        this._FIREPropertyChange('DataRate', bp);

	        break;

	      case 170:
	        this.data.heatingEnabled = bp.entries[0].v;

	        this._FIREPropertyChange('HeatingEnabled', bp);

	        break;

	      case 50:
	        break;

	      case 145:
	        this.data.precision = bp.entries[0].v;

	        this._FIREPropertyChange('Precision', bp);

	        break;

	      case 35:
	        break;

	      case 37:
	        break;

	      case 150:
	        break;

	      case 106:
	        break;

	      case 89:
	        {
	          if (this._isAttachedDone && this.onSpatialData) {
	            try {
	              this.onSpatialData(bp.entries[0].v, bp.entries[1].v, bp.entries[2].v, bp.entries[3].v);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      dataInterval: 1e+300,
	      maxDataInterval: 4294967295,
	      minDataInterval: 4294967295,
	      minDataRate: 1e+300,
	      maxDataRate: 1e+300,
	      precision: 2147483647,
	      algorithm: 2147483647,
	      algorithmMagnetometerGain: 1e+300,
	      maxAcceleration: [1e+300, 1e+300, 1e+300],
	      minAcceleration: [1e+300, 1e+300, 1e+300],
	      maxAngularRate: [1e+300, 1e+300, 1e+300],
	      minAngularRate: [1e+300, 1e+300, 1e+300],
	      maxMagneticField: [1e+300, 1e+300, 1e+300],
	      minMagneticField: [1e+300, 1e+300, 1e+300],
	      heatingEnabled: 2,
	      quaternion: null,
	      eulerAngles: null
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 316:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataInterval = 20;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 50;
	        this.data.precision = exports.SpatialPrecision.LOW;
	        this.data.algorithm = exports.SpatialAlgorithm.NONE;
	        this.data.maxAcceleration = [8, 8, 8];
	        this.data.minAcceleration = [-8, -8, -8];
	        this.data.maxAngularRate = [2000, 2000, 2000];
	        this.data.minAngularRate = [-2000, -2000, -2000];
	        this.data.maxMagneticField = [8, 8, 8];
	        this.data.minMagneticField = [-8, -8, -8];
	        break;

	      case 321:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataInterval = 20;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 50;
	        this.data.precision = exports.SpatialPrecision.LOW;
	        this.data.algorithm = exports.SpatialAlgorithm.AHRS;
	        this.data.algorithmMagnetometerGain = 0.005;
	        this.data.maxAcceleration = [8, 8, 8];
	        this.data.minAcceleration = [-8, -8, -8];
	        this.data.maxAngularRate = [2000, 2000, 2000];
	        this.data.minAngularRate = [-2000, -2000, -2000];
	        this.data.maxMagneticField = [8, 8, 8];
	        this.data.minMagneticField = [-8, -8, -8];
	        break;

	      case 334:
	        this.data.dataInterval = 256;
	        this.data.maxDataInterval = 1000;
	        this.data.minDataInterval = 4;
	        this.data.minDataRate = 1;
	        this.data.maxDataRate = 250;
	        this.data.precision = exports.SpatialPrecision.HYBRID;
	        this.data.algorithm = exports.SpatialAlgorithm.AHRS;
	        this.data.algorithmMagnetometerGain = 0.005;
	        this.data.maxAcceleration = [8, 8, 8];
	        this.data.minAcceleration = [-8, -8, -8];
	        this.data.maxAngularRate = [2000, 2000, 2000];
	        this.data.minAngularRate = [-2000, -2000, -2000];
	        this.data.maxMagneticField = [50, 50, 50];
	        this.data.minMagneticField = [-50, -50, -50];
	        this.data.heatingEnabled = 0;
	        this.data.quaternion = this._ch.parent.data.quaternion[this._ch.index];
	        break;

	      case 339:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 1000;
	        this.data.minDataInterval = 1;
	        this.data.minDataRate = 1;
	        this.data.maxDataRate = 1000;
	        this.data.precision = exports.SpatialPrecision.HIGH;
	        this.data.algorithm = exports.SpatialAlgorithm.AHRS;
	        this.data.maxAcceleration = [16, 16, 16];
	        this.data.minAcceleration = [-16, -16, -16];
	        this.data.maxAngularRate = [2000, 2000, 2000];
	        this.data.minAngularRate = [-2000, -2000, -2000];
	        this.data.maxMagneticField = [8, 8, 8];
	        this.data.minMagneticField = [-8, -8, -8];
	        this.data.heatingEnabled = 0;
	        this.data.quaternion = this._ch.parent.data.quaternion[this._ch.index];
	        break;

	      case 344:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 1000;
	        this.data.minDataInterval = 2;
	        this.data.minDataRate = 1;
	        this.data.maxDataRate = 500;
	        this.data.precision = exports.SpatialPrecision.HIGH;
	        this.data.algorithm = exports.SpatialAlgorithm.AHRS;
	        this.data.maxAcceleration = [16, 16, 16];
	        this.data.minAcceleration = [-16, -16, -16];
	        this.data.maxAngularRate = [2000, 2000, 2000];
	        this.data.minAngularRate = [-2000, -2000, -2000];
	        this.data.maxMagneticField = [8, 8, 8];
	        this.data.minMagneticField = [-8, -8, -8];
	        this.data.heatingEnabled = 0;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    let bp;

	    switch (this._ch.chDef.uid) {
	      case 316:
	      case 339:
	      case 344:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        break;

	      case 321:
	      case 334:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.algorithmMagnetometerGain
	        });
	        await bp.send(this._ch, 151);
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {}
	  /**
	   * The minimum acceleration the sensor will measure.
	   * @throws {@link PhidgetError}
	   */


	  get minAcceleration() {
	    return this.getMinAcceleration();
	  }
	  /**
	   * The maximum acceleration the sensor will measure.
	   * @throws {@link PhidgetError}
	   */


	  get maxAcceleration() {
	    return this.getMaxAcceleration();
	  }
	  /**
	   * Selects the IMU/AHRS algorithm.
	   * @throws {@link PhidgetError}
	   */


	  get algorithm() {
	    return this.getAlgorithm();
	  }
	  /**
	   * Sets the gain for the magnetometer in the AHRS algorithm. Lower gains reduce sensor noise while slowing response time.
	   * @throws {@link PhidgetError}
	   */


	  get algorithmMagnetometerGain() {
	    return this.getAlgorithmMagnetometerGain();
	  }
	  /**
	   * The minimum angular rate the sensor will measure.
	   * @throws {@link PhidgetError}
	   */


	  get minAngularRate() {
	    return this.getMinAngularRate();
	  }
	  /**
	   * The maximum angular rate the sensor will measure.
	   * @throws {@link PhidgetError}
	   */


	  get maxAngularRate() {
	    return this.getMaxAngularRate();
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `SpatialData` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * @throws {@link PhidgetError}
	   */


	  get dataInterval() {
	    return this.getDataInterval();
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataInterval() {
	    return this.getMinDataInterval();
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataInterval() {
	    return this.getMaxDataInterval();
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   */


	  get dataRate() {
	    return this.getDataRate();
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataRate() {
	    return this.getMinDataRate();
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataRate() {
	    return this.getMaxDataRate();
	  }
	  /**
	   * Gets the latest device orientation in the form of Euler angles. (Pitch, roll, and yaw)
	   * @throws {@link PhidgetError}
	   */


	  get eulerAngles() {
	    return this.getEulerAngles();
	  }
	  /**
	   * Set to TRUE to enable the temperature stabilization feature of this device. This enables on-board heating elements to bring the board up to a known temperature to minimize ambient temperature effects on the sensor's reading. You can leave this setting FALSE to conserve power consumption.
	   *
	   * If you enable heating, it is strongly recommended to keep the board in its enclosure to keep it insulated from moving air.
	   *
	   * This property is shared by any and all spatial-related objects on this device (Accelerometer, Gyroscope, Magnetometer, Spatial)
	   * @throws {@link PhidgetError}
	   */


	  get heatingEnabled() {
	    return this.getHeatingEnabled();
	  }
	  /**
	   * The minimum field strength the sensor will measure.
	   * @throws {@link PhidgetError}
	   */


	  get minMagneticField() {
	    return this.getMinMagneticField();
	  }
	  /**
	   * The maximum field strength the sensor will measure.
	   * @throws {@link PhidgetError}
	   */


	  get maxMagneticField() {
	    return this.getMaxMagneticField();
	  }
	  /**
	   * Selects between high/low precision sensing chips.
	   * @throws {@link PhidgetError}
	   * @internal
	   */


	  get precision() {
	    return this.getPrecision();
	  }
	  /**
	   * Gets the latest AHRS/IMU quaternion sent from the device.
	   * @throws {@link PhidgetError}
	   */


	  get quaternion() {
	    return this.getQuaternion();
	  }
	  /**
	   * The minimum acceleration the sensor will measure.
	   * @returns The minimum acceleration value
	   * @throws {@link PhidgetError}
	   */


	  getMinAcceleration() {
	    this._assertOpen();

	    if (this.data.minAcceleration.includes(1e+300)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minAcceleration;
	  }
	  /**
	   * The maximum acceleration the sensor will measure.
	   * @returns The maximum acceleration values
	   * @throws {@link PhidgetError}
	   */


	  getMaxAcceleration() {
	    this._assertOpen();

	    if (this.data.maxAcceleration.includes(1e+300)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxAcceleration;
	  }
	  /**
	   * Calibrate your device for the environment it will be used in.
	   *
	   * *   Setting these parameters will allow you to tune the AHRS algorithm on the device to your specific application.
	   * @throws {@link PhidgetError}
	   * @param angularVelocityThreshold - The maximum angular velocity reading where the device is assumed to be "at rest"
	   * @param angularVelocityDeltaThreshold - The acceptable amount of change in angular velocity between measurements before movement is assumed.
	   * @param accelerationThreshold - The maximum acceleration applied to the device (minus gravity) where it is assumed to be "at rest". This is also the maximum acceleration allowable before the device stops correcting to the acceleration vector.
	   * @param magTime - The time it will take to correct the heading 95% of the way to aligning with the compass (in seconds),up to 15 degrees of error. Beyond 15 degrees, this is the time it will take for the bearing to move 45 degrees towards the compass reading. Remember you can zero the algorithm at any time to instantly realign the spatial with acceleration and magnetic field vectors regardless of magnitude.
	   * @param accelTime - The time it will take to correct the pitch and roll 95% of the way to aligning with the accelerometer (in seconds).
	   * @param biasTime - The time it will take to have the gyro biases settle to within 95% of the measured steady state (in seconds).
	   */


	  async setAHRSParameters(angularVelocityThreshold, angularVelocityDeltaThreshold, accelerationThreshold, magTime, accelTime, biasTime) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: angularVelocityThreshold
	    });
	    bp.set({
	      name: "1",
	      type: "g",
	      value: angularVelocityDeltaThreshold
	    });
	    bp.set({
	      name: "2",
	      type: "g",
	      value: accelerationThreshold
	    });
	    bp.set({
	      name: "3",
	      type: "g",
	      value: magTime
	    });
	    bp.set({
	      name: "4",
	      type: "g",
	      value: accelTime
	    });
	    bp.set({
	      name: "5",
	      type: "g",
	      value: biasTime
	    });
	    await bp.send(this._ch, 174);
	  }
	  /**
	   * Selects the IMU/AHRS algorithm.
	   * @returns The sensor algorithm
	   * @throws {@link PhidgetError}
	   */


	  getAlgorithm() {
	    this._assertOpen();

	    if (this.data.algorithm === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.algorithm;
	  }
	  /**
	   * Selects the IMU/AHRS algorithm.
	   * @throws {@link PhidgetError}
	   * @param algorithm - The sensor algorithm
	   */


	  async setAlgorithm(algorithm) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedSpatialAlgorithm(this._ch, algorithm)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified SpatialAlgorithm is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: algorithm
	    });
	    await bp.send(this._ch, 149);
	  }
	  /**
	   * Sets the gain for the magnetometer in the AHRS algorithm. Lower gains reduce sensor noise while slowing response time.
	   * @returns The AHRS algorithm magnetometer gain
	   * @throws {@link PhidgetError}
	   */


	  getAlgorithmMagnetometerGain() {
	    this._assertOpen();

	    if (this.data.algorithmMagnetometerGain === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.algorithmMagnetometerGain;
	  }
	  /**
	   * Sets the gain for the magnetometer in the AHRS algorithm. Lower gains reduce sensor noise while slowing response time.
	   * @throws {@link PhidgetError}
	   * @param algorithmMagnetometerGain - The AHRS algorithm magnetometer gain
	   */


	  async setAlgorithmMagnetometerGain(algorithmMagnetometerGain) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: algorithmMagnetometerGain
	    });
	    await bp.send(this._ch, 151);
	  }
	  /**
	   * The minimum angular rate the sensor will measure.
	   * @returns The angular rate values
	   * @throws {@link PhidgetError}
	   */


	  getMinAngularRate() {
	    this._assertOpen();

	    if (this.data.minAngularRate.includes(1e+300)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minAngularRate;
	  }
	  /**
	   * The maximum angular rate the sensor will measure.
	   * @returns The angular rate values
	   * @throws {@link PhidgetError}
	   */


	  getMaxAngularRate() {
	    this._assertOpen();

	    if (this.data.maxAngularRate.includes(1e+300)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxAngularRate;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `SpatialData` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getDataInterval() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dataInterval;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `SpatialData` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * @throws {@link PhidgetError}
	   * @param dataInterval - The data interval value
	   */


	  async setDataInterval(dataInterval) {
	    this._assertOpen();

	    if (dataInterval < this.data.minDataInterval || dataInterval > this.data.maxDataInterval) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataInterval + " - " + this.data.maxDataInterval + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: dataInterval
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataInterval() {
	    this._assertOpen();

	    if (this.data.minDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataInterval;
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataInterval() {
	    this._assertOpen();

	    if (this.data.maxDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @returns The data rate for the channel
	   * @throws {@link PhidgetError}
	   */


	  getDataRate() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return 1000.0 / this.data.dataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   * @param dataRate - The data rate for the channel
	   */


	  async setDataRate(dataRate) {
	    this._assertOpen();

	    if (dataRate < this.data.minDataRate || dataRate > this.data.maxDataRate) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataRate + " - " + this.data.maxDataRate + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: Math.round(1000.0 / dataRate)
	    });
	    bp.set({
	      name: "1",
	      type: "g",
	      value: 1000.0 / dataRate
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataRate() {
	    this._assertOpen();

	    if (this.data.minDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataRate;
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataRate() {
	    this._assertOpen();

	    if (this.data.maxDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataRate;
	  }
	  /**
	   * Set to TRUE to enable the temperature stabilization feature of this device. This enables on-board heating elements to bring the board up to a known temperature to minimize ambient temperature effects on the sensor's reading. You can leave this setting FALSE to conserve power consumption.
	   *
	   * If you enable heating, it is strongly recommended to keep the board in its enclosure to keep it insulated from moving air.
	   *
	   * This property is shared by any and all spatial-related objects on this device (Accelerometer, Gyroscope, Magnetometer, Spatial)
	   * @returns Whether self-heating temperature stabilization is enabled
	   * @throws {@link PhidgetError}
	   */


	  getHeatingEnabled() {
	    this._assertOpen();

	    if (this.data.heatingEnabled === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.heatingEnabled;
	  }
	  /**
	   * Set to TRUE to enable the temperature stabilization feature of this device. This enables on-board heating elements to bring the board up to a known temperature to minimize ambient temperature effects on the sensor's reading. You can leave this setting FALSE to conserve power consumption.
	   *
	   * If you enable heating, it is strongly recommended to keep the board in its enclosure to keep it insulated from moving air.
	   *
	   * This property is shared by any and all spatial-related objects on this device (Accelerometer, Gyroscope, Magnetometer, Spatial)
	   * @throws {@link PhidgetError}
	   * @param heatingEnabled - Whether self-heating temperature stabilization is enabled
	   */


	  async setHeatingEnabled(heatingEnabled) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (heatingEnabled !== false && heatingEnabled !== true) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be a boolean.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: heatingEnabled ? 1 : 0
	    });
	    await bp.send(this._ch, 170);
	  }
	  /**
	   * The minimum field strength the sensor will measure.
	   * @returns The field strength value
	   * @throws {@link PhidgetError}
	   */


	  getMinMagneticField() {
	    this._assertOpen();

	    if (this.data.minMagneticField.includes(1e+300)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minMagneticField;
	  }
	  /**
	   * The maximum field strength the sensor will measure.
	   * @returns The field strength value
	   * @throws {@link PhidgetError}
	   */


	  getMaxMagneticField() {
	    this._assertOpen();

	    if (this.data.maxMagneticField.includes(1e+300)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxMagneticField;
	  }
	  /**
	   * Calibrate your device for the environment it will be used in.
	   *
	   * *   Due to physical location, hard and soft iron offsets, and even bias errors, your device should be calibrated. We have created a calibration program that will provide you with the `MagnetometerCorrectionParameters` for your specific situation. See your device's User Guide for more information.
	   * @throws {@link PhidgetError}
	   * @param magneticField - Ambient magnetic field value.
	   * @param offset0 - Provided by calibration program.
	   * @param offset1 - Provided by calibration program.
	   * @param offset2 - Provided by calibration program.
	   * @param gain0 - Provided by calibration program.
	   * @param gain1 - Provided by calibration program.
	   * @param gain2 - Provided by calibration program.
	   * @param T0 - Provided by calibration program.
	   * @param T1 - Provided by calibration program.
	   * @param T2 - Provided by calibration program.
	   * @param T3 - Provided by calibration program.
	   * @param T4 - Provided by calibration program.
	   * @param T5 - Provided by calibration program.
	   */


	  async setMagnetometerCorrectionParameters(magneticField, offset0, offset1, offset2, gain0, gain1, gain2, T0, T1, T2, T3, T4, T5) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: magneticField
	    });
	    bp.set({
	      name: "1",
	      type: "g",
	      value: offset0
	    });
	    bp.set({
	      name: "2",
	      type: "g",
	      value: offset1
	    });
	    bp.set({
	      name: "3",
	      type: "g",
	      value: offset2
	    });
	    bp.set({
	      name: "4",
	      type: "g",
	      value: gain0
	    });
	    bp.set({
	      name: "5",
	      type: "g",
	      value: gain1
	    });
	    bp.set({
	      name: "6",
	      type: "g",
	      value: gain2
	    });
	    bp.set({
	      name: "7",
	      type: "g",
	      value: T0
	    });
	    bp.set({
	      name: "8",
	      type: "g",
	      value: T1
	    });
	    bp.set({
	      name: "9",
	      type: "g",
	      value: T2
	    });
	    bp.set({
	      name: "10",
	      type: "g",
	      value: T3
	    });
	    bp.set({
	      name: "11",
	      type: "g",
	      value: T4
	    });
	    bp.set({
	      name: "12",
	      type: "g",
	      value: T5
	    });
	    await bp.send(this._ch, 50);
	  }
	  /**
	   * Selects between high/low precision sensing chips.
	   * @returns The sensor precision value
	   * @throws {@link PhidgetError}
	   * @internal
	   */


	  getPrecision() {
	    this._assertOpen();

	    if (this.data.precision === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.precision;
	  }
	  /**
	   * Selects between high/low precision sensing chips.
	   * @throws {@link PhidgetError}
	   * @param precision - The sensor precision value
	   * @internal
	   */


	  async setPrecision(precision) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedSpatialPrecision(this._ch, precision)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified SpatialPrecision is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: precision
	    });
	    await bp.send(this._ch, 145);
	  }
	  /**
	   * Resets the `MagnetometerCorrectionParameters` to their default values.
	   *
	   * *   Due to physical location, hard and soft iron offsets, and even bias errors, your device should be calibrated. We have created a calibration program that will provide you with the `MagnetometerCorrectionParameters` for your specific situation. See your device's User Guide for more information.
	   * @throws {@link PhidgetError}
	   */


	  async resetMagnetometerCorrectionParameters() {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    await bp.send(this._ch, 35);
	  }
	  /**
	   * Saves the `MagnetometerCorrectionParameters`.
	   *
	   * *   Due to physical location, hard and soft iron offsets, and even bias errors, your device should be calibrated. We have created a calibration program that will provide you with the `MagnetometerCorrectionParameters` for your specific situation. See your device's User Guide for more information.
	   * @throws {@link PhidgetError}
	   */


	  async saveMagnetometerCorrectionParameters() {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    await bp.send(this._ch, 37);
	  }
	  /**
	   * Zeros the AHRS algorithm.
	   * @throws {@link PhidgetError}
	   */


	  async zeroAlgorithm() {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    await bp.send(this._ch, 150);
	  }
	  /**
	   * Re-zeros the gyroscope in 1-2 seconds.
	   *
	   * *   The device must be stationary when zeroing.
	   * *   The angular rate will be reported as 0.0Â°/s while zeroing.
	   * *   Zeroing the gyroscope is a method of compensating for the drift that is inherent to all gyroscopes. See your device's User Guide for more information on dealing with drift.
	   * @throws {@link PhidgetError}
	   */


	  async zeroGyro() {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    await bp.send(this._ch, 106);
	  }

	}

	/** @public */

	class Spatial extends SpatialBase {
	  constructor(ch) {
	    super(ch);
	    this._transactionLock = new PhidgetLock();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 10:
	        {
	          if (bp.entryCount > 1) this.data.dataInterval = bp.getNumber(1);else this.data.dataInterval = bp.getNumber(0);

	          this._FIREPropertyChange('DataInterval');

	          this._FIREPropertyChange('DataRate');

	          break;
	        }

	      case 148:
	        {
	          const quaternion = bp.getArray(0);
	          const timestamp = bp.getNumber(1);
	          this.data.quaternion = {
	            x: quaternion[0],
	            y: quaternion[1],
	            z: quaternion[2],
	            w: quaternion[3]
	          };

	          if (this._isAttachedDone && this.onAlgorithmData) {
	            try {
	              this.onAlgorithmData(quaternion, timestamp);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        super._bridgeInput(bp);

	        break;
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    if (this.data.quaternion === null) return false;
	    return true;
	  }

	  getQuaternion() {
	    this._assertOpen();

	    if (this.data.quaternion === null) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.quaternion;
	  }

	  getEulerAngles() {
	    this._assertOpen();

	    if (this.data.quaternion === null) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    const roll_rad = Math.atan2(2.0 * (this.data.quaternion.x * this.data.quaternion.w + this.data.quaternion.y * this.data.quaternion.z), 1 - 2.0 * (this.data.quaternion.x * this.data.quaternion.x + this.data.quaternion.y * this.data.quaternion.y));
	    const pitch_rad = Math.asin(2.0 * (this.data.quaternion.w * this.data.quaternion.y - this.data.quaternion.z * this.data.quaternion.x));
	    const heading_rad = Math.atan2(2.0 * (this.data.quaternion.w * this.data.quaternion.z + this.data.quaternion.x * this.data.quaternion.y), 1 - 2.0 * (this.data.quaternion.y * this.data.quaternion.y + this.data.quaternion.z * this.data.quaternion.z));
	    const eulerAngles = {
	      heading: heading_rad * 180.0 / Math.PI,
	      pitch: pitch_rad * 180.0 / Math.PI,
	      roll: roll_rad * 180.0 / Math.PI
	    };
	    return eulerAngles;
	  }

	}

	class TemperatureSensorBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onTemperatureChange = null;
	    this._class = exports.ChannelClass.TEMPERATURE_SENSOR;
	    this.name = "TemperatureSensor";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 54:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.entries[1].v;else this.data.dataInterval = bp.entries[0].v;

	        this._FIREPropertyChange('DataInterval', bp);

	        this._FIREPropertyChange('DataRate', bp);

	        break;

	      case 76:
	        this.data.RTDType = bp.entries[0].v;

	        this._FIREPropertyChange('RTDType', bp);

	        break;

	      case 77:
	        this.data.RTDWireSetup = bp.entries[0].v;

	        this._FIREPropertyChange('RTDWireSetup', bp);

	        break;

	      case 46:
	        this.data.temperatureChangeTrigger = bp.entries[0].v;

	        this._FIREPropertyChange('TemperatureChangeTrigger', bp);

	        break;

	      case 84:
	        this.data.thermocoupleType = bp.entries[0].v;

	        this._FIREPropertyChange('ThermocoupleType', bp);

	        break;

	      case 95:
	        {
	          this.data.temperature = bp.entries[0].v;

	          if (this._isAttachedDone && this.onTemperatureChange) {
	            try {
	              this.onTemperatureChange(this.data.temperature);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      dataInterval: 1e+300,
	      maxDataInterval: 4294967295,
	      minDataRate: 1e+300,
	      maxDataRate: 1e+300,
	      maxTemperature: 1e+300,
	      maxTemperatureChangeTrigger: 1e+300,
	      minDataInterval: 4294967295,
	      minTemperature: 1e+300,
	      minTemperatureChangeTrigger: 1e+300,
	      temperature: 1e+300,
	      temperatureChangeTrigger: 1e+300,
	      RTDType: 2147483647,
	      RTDWireSetup: 2147483647,
	      thermocoupleType: 2147483647
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 105:
	        this.data.dataInterval = 256;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 31.25;
	        this.data.maxTemperature = this._ch.parent.data.maxTemperature[this._ch.index];
	        this.data.maxTemperatureChangeTrigger = 1000;
	        this.data.minDataInterval = 32;
	        this.data.minTemperature = this._ch.parent.data.minTemperature[this._ch.index];
	        this.data.minTemperatureChangeTrigger = 0;
	        this.data.temperature = this._ch.parent.data.temperature[this._ch.index];
	        this.data.temperatureChangeTrigger = 0;
	        this.data.thermocoupleType = exports.ThermocoupleType.K;
	        break;

	      case 106:
	        this.data.dataInterval = 256;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 31.25;
	        this.data.maxTemperature = 150;
	        this.data.maxTemperatureChangeTrigger = 100;
	        this.data.minDataInterval = 32;
	        this.data.minTemperature = -55;
	        this.data.minTemperatureChangeTrigger = 0;
	        this.data.temperature = this._ch.parent.data.temperature[this._ch.index];
	        this.data.temperatureChangeTrigger = 0;
	        break;

	      case 245:
	      case 250:
	      case 256:
	        this.data.dataInterval = 500;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 2;
	        this.data.maxTemperature = 125;
	        this.data.maxTemperatureChangeTrigger = 165;
	        this.data.minDataInterval = 500;
	        this.data.minTemperature = -40;
	        this.data.minTemperatureChangeTrigger = 0;
	        this.data.temperatureChangeTrigger = 0;
	        break;

	      case 284:
	      case 287:
	      case 362:
	      case 365:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.maxTemperature = 125;
	        this.data.maxTemperatureChangeTrigger = 165;
	        this.data.minDataInterval = 100;
	        this.data.minTemperature = -40;
	        this.data.minTemperatureChangeTrigger = 0;
	        this.data.temperatureChangeTrigger = 0;
	        break;

	      case 302:
	      case 380:
	        this.data.dataInterval = 500;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 2;
	        this.data.maxTemperature = 85;
	        this.data.maxTemperatureChangeTrigger = 125;
	        this.data.minDataInterval = 500;
	        this.data.minTemperature = -40;
	        this.data.minTemperatureChangeTrigger = 0;
	        this.data.temperatureChangeTrigger = 0;
	        break;

	      case 304:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 20;
	        this.data.maxTemperature = 85;
	        this.data.maxTemperatureChangeTrigger = 125;
	        this.data.minDataInterval = 50;
	        this.data.minTemperature = -40;
	        this.data.minTemperatureChangeTrigger = 0;
	        this.data.temperatureChangeTrigger = 0;
	        break;

	      case 335:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.maxTemperature = 85;
	        this.data.maxTemperatureChangeTrigger = 125;
	        this.data.minDataInterval = 100;
	        this.data.minTemperature = -40;
	        this.data.minTemperatureChangeTrigger = 0;
	        this.data.temperature = this._ch.parent.data.temperature[this._ch.index];
	        this.data.temperatureChangeTrigger = 0;
	        break;

	      case 340:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 100;
	        this.data.maxTemperature = 85;
	        this.data.maxTemperatureChangeTrigger = 125;
	        this.data.minDataInterval = 10;
	        this.data.minTemperature = -40;
	        this.data.minTemperatureChangeTrigger = 0;
	        this.data.temperature = this._ch.parent.data.temperature[this._ch.index];
	        this.data.temperatureChangeTrigger = 0;
	        break;

	      case 345:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 100;
	        this.data.maxTemperature = 85;
	        this.data.maxTemperatureChangeTrigger = 125;
	        this.data.minDataInterval = 10;
	        this.data.minTemperature = -40;
	        this.data.minTemperatureChangeTrigger = 0;
	        this.data.temperatureChangeTrigger = 0;
	        break;

	      case 381:
	      case 384:
	      case 387:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 50;
	        this.data.maxTemperature = 1370;
	        this.data.maxTemperatureChangeTrigger = 1640;
	        this.data.minDataInterval = 20;
	        this.data.minTemperature = -270;
	        this.data.minTemperatureChangeTrigger = 0;
	        this.data.temperatureChangeTrigger = 0;
	        this.data.thermocoupleType = exports.ThermocoupleType.K;
	        break;

	      case 382:
	      case 385:
	      case 388:
	        this.data.dataInterval = 500;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 3.3333333333333335;
	        this.data.maxTemperature = 85;
	        this.data.maxTemperatureChangeTrigger = 125;
	        this.data.minDataInterval = 300;
	        this.data.minTemperature = -40;
	        this.data.minTemperatureChangeTrigger = 0;
	        this.data.temperatureChangeTrigger = 0;
	        break;

	      case 390:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 4;
	        this.data.maxTemperature = 850;
	        this.data.maxTemperatureChangeTrigger = 1050;
	        this.data.minDataInterval = 250;
	        this.data.minTemperature = -200;
	        this.data.minTemperatureChangeTrigger = 0;
	        this.data.temperatureChangeTrigger = 0;
	        this.data.RTDType = exports.RTDType.PT1000_3850;
	        this.data.RTDWireSetup = exports.RTDWireSetup.WIRES_4;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    let bp;

	    switch (this._ch.chDef.uid) {
	      case 105:
	      case 381:
	      case 384:
	      case 387:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.temperatureChangeTrigger
	        });
	        await bp.send(this._ch, 46);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.thermocoupleType
	        });
	        await bp.send(this._ch, 84);
	        break;

	      case 106:
	      case 284:
	      case 287:
	      case 302:
	      case 304:
	      case 335:
	      case 340:
	      case 345:
	      case 362:
	      case 365:
	      case 382:
	      case 385:
	      case 388:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.temperatureChangeTrigger
	        });
	        await bp.send(this._ch, 46);
	        break;

	      case 245:
	      case 250:
	      case 256:
	      case 380:
	        break;

	      case 390:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.temperatureChangeTrigger
	        });
	        await bp.send(this._ch, 46);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.RTDType
	        });
	        await bp.send(this._ch, 76);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.RTDWireSetup
	        });
	        await bp.send(this._ch, 77);
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    if (this.data.temperature == 1e+300 && !this._gotTemperatureChangeErrorEvent) return false;
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {
	    if (this.data.temperature != 1e+300) if (this.onTemperatureChange) try {
	      this.onTemperatureChange(this.data.temperature);
	    } catch (err) {
	      logEventException(err);
	    }
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `TemperatureChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `TemperatureChange` events can also be affected by the `temperatureChangeTrigger`.
	   * @throws {@link PhidgetError}
	   */


	  get dataInterval() {
	    return this.getDataInterval();
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataInterval() {
	    return this.getMinDataInterval();
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataInterval() {
	    return this.getMaxDataInterval();
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   */


	  get dataRate() {
	    return this.getDataRate();
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataRate() {
	    return this.getMinDataRate();
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataRate() {
	    return this.getMaxDataRate();
	  }
	  /**
	   * The `RTDType` must correspond to the RTD type you are using in your application.
	   *
	   * *   If you are unsure which `RTDType` to use, visit your device's User Guide for more information.
	   * @throws {@link PhidgetError}
	   */


	  get RTDType() {
	    return this.getRTDType();
	  }
	  /**
	   * The `RTDWireSetup` must correspond to the wire configuration you are using in your application.
	   *
	   * *   If you are unsure which `RTDWireSetup` to use, visit your device's User Guide for more information.
	   * @throws {@link PhidgetError}
	   */


	  get RTDWireSetup() {
	    return this.getRTDWireSetup();
	  }
	  /**
	   * The most recent temperature value that the channel has reported.
	   *
	   * *   This value will always be between `minTemperature` and `maxTemperature`.
	   * @throws {@link PhidgetError}
	   */


	  get temperature() {
	    return this.getTemperature();
	  }
	  /**
	   * The minimum value the `TemperatureChange` event will report.
	   * @throws {@link PhidgetError}
	   */


	  get minTemperature() {
	    return this.getMinTemperature();
	  }
	  /**
	   * The maximum value the `TemperatureChange` event will report.
	   * @throws {@link PhidgetError}
	   */


	  get maxTemperature() {
	    return this.getMaxTemperature();
	  }
	  /**
	   * The channel will not issue a `TemperatureChange` event until the temperature value has changed by the amount specified by the `temperatureChangeTrigger`.
	   *
	   * *   Setting the `temperatureChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   */


	  get temperatureChangeTrigger() {
	    return this.getTemperatureChangeTrigger();
	  }
	  /**
	   * The minimum value that `temperatureChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minTemperatureChangeTrigger() {
	    return this.getMinTemperatureChangeTrigger();
	  }
	  /**
	   * The maximum value that `temperatureChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxTemperatureChangeTrigger() {
	    return this.getMaxTemperatureChangeTrigger();
	  }
	  /**
	   * The `thermocoupleType` must correspond to the thermocouple type you are using in your application.
	   *
	   * *   If you are unsure which `thermocoupleType` to use, visit the [Thermocouple Primer](https://www.phidgets.com/docs/Thermocouple_Primer) for more information.
	   * @throws {@link PhidgetError}
	   */


	  get thermocoupleType() {
	    return this.getThermocoupleType();
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `TemperatureChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `TemperatureChange` events can also be affected by the `temperatureChangeTrigger`.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getDataInterval() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dataInterval;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `TemperatureChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `TemperatureChange` events can also be affected by the `temperatureChangeTrigger`.
	   * @throws {@link PhidgetError}
	   * @param dataInterval - The data interval value
	   */


	  async setDataInterval(dataInterval) {
	    this._assertOpen();

	    if (dataInterval < this.data.minDataInterval || dataInterval > this.data.maxDataInterval) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataInterval + " - " + this.data.maxDataInterval + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: dataInterval
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataInterval() {
	    this._assertOpen();

	    if (this.data.minDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataInterval;
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataInterval() {
	    this._assertOpen();

	    if (this.data.maxDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @returns The data rate for the channel
	   * @throws {@link PhidgetError}
	   */


	  getDataRate() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return 1000.0 / this.data.dataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   * @param dataRate - The data rate for the channel
	   */


	  async setDataRate(dataRate) {
	    this._assertOpen();

	    if (dataRate < this.data.minDataRate || dataRate > this.data.maxDataRate) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataRate + " - " + this.data.maxDataRate + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: Math.round(1000.0 / dataRate)
	    });
	    bp.set({
	      name: "1",
	      type: "g",
	      value: 1000.0 / dataRate
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataRate() {
	    this._assertOpen();

	    if (this.data.minDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataRate;
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataRate() {
	    this._assertOpen();

	    if (this.data.maxDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataRate;
	  }
	  /**
	   * The `RTDType` must correspond to the RTD type you are using in your application.
	   *
	   * *   If you are unsure which `RTDType` to use, visit your device's User Guide for more information.
	   * @returns The RTD type
	   * @throws {@link PhidgetError}
	   */


	  getRTDType() {
	    this._assertOpen();

	    if (this.data.RTDType === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.RTDType;
	  }
	  /**
	   * The `RTDType` must correspond to the RTD type you are using in your application.
	   *
	   * *   If you are unsure which `RTDType` to use, visit your device's User Guide for more information.
	   * @throws {@link PhidgetError}
	   * @param RTDType - The RTD type
	   */


	  async setRTDType(RTDType) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedRTDType(this._ch, RTDType)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified RTDType is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: RTDType
	    });
	    await bp.send(this._ch, 76);
	  }
	  /**
	   * The `RTDWireSetup` must correspond to the wire configuration you are using in your application.
	   *
	   * *   If you are unsure which `RTDWireSetup` to use, visit your device's User Guide for more information.
	   * @returns The RTD wire setup
	   * @throws {@link PhidgetError}
	   */


	  getRTDWireSetup() {
	    this._assertOpen();

	    if (this.data.RTDWireSetup === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.RTDWireSetup;
	  }
	  /**
	   * The `RTDWireSetup` must correspond to the wire configuration you are using in your application.
	   *
	   * *   If you are unsure which `RTDWireSetup` to use, visit your device's User Guide for more information.
	   * @throws {@link PhidgetError}
	   * @param RTDWireSetup - The RTD wire setup
	   */


	  async setRTDWireSetup(RTDWireSetup) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedRTDWireSetup(this._ch, RTDWireSetup)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified RTDWireSetup is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: RTDWireSetup
	    });
	    await bp.send(this._ch, 77);
	  }
	  /**
	   * The most recent temperature value that the channel has reported.
	   *
	   * *   This value will always be between `minTemperature` and `maxTemperature`.
	   * @returns The temperature value
	   * @throws {@link PhidgetError}
	   */


	  getTemperature() {
	    this._assertOpen();

	    if (this.data.temperature === 1e+300 || Number.isNaN(this.data.temperature)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    if (this.data.temperature > this.data.maxTemperature) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE_HIGH);
	    if (this.data.temperature < this.data.minTemperature) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE_LOW);
	    return this.data.temperature;
	  }
	  /**
	   * The minimum value the `TemperatureChange` event will report.
	   * @returns The temperature value
	   * @throws {@link PhidgetError}
	   */


	  getMinTemperature() {
	    this._assertOpen();

	    if (this.data.minTemperature === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minTemperature;
	  }
	  /**
	   * The maximum value the `TemperatureChange` event will report.
	   * @returns The temperature value
	   * @throws {@link PhidgetError}
	   */


	  getMaxTemperature() {
	    this._assertOpen();

	    if (this.data.maxTemperature === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxTemperature;
	  }
	  /**
	   * The channel will not issue a `TemperatureChange` event until the temperature value has changed by the amount specified by the `temperatureChangeTrigger`.
	   *
	   * *   Setting the `temperatureChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getTemperatureChangeTrigger() {
	    this._assertOpen();

	    if (this.data.temperatureChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.temperatureChangeTrigger;
	  }
	  /**
	   * The channel will not issue a `TemperatureChange` event until the temperature value has changed by the amount specified by the `temperatureChangeTrigger`.
	   *
	   * *   Setting the `temperatureChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   * @param temperatureChangeTrigger - The change trigger value
	   */


	  async setTemperatureChangeTrigger(temperatureChangeTrigger) {
	    this._assertOpen();

	    if (temperatureChangeTrigger < this.data.minTemperatureChangeTrigger || temperatureChangeTrigger > this.data.maxTemperatureChangeTrigger) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minTemperatureChangeTrigger + " - " + this.data.maxTemperatureChangeTrigger + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: temperatureChangeTrigger
	    });
	    await bp.send(this._ch, 46);
	  }
	  /**
	   * The minimum value that `temperatureChangeTrigger` can be set to.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMinTemperatureChangeTrigger() {
	    this._assertOpen();

	    if (this.data.minTemperatureChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minTemperatureChangeTrigger;
	  }
	  /**
	   * The maximum value that `temperatureChangeTrigger` can be set to.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMaxTemperatureChangeTrigger() {
	    this._assertOpen();

	    if (this.data.maxTemperatureChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxTemperatureChangeTrigger;
	  }
	  /**
	   * The `thermocoupleType` must correspond to the thermocouple type you are using in your application.
	   *
	   * *   If you are unsure which `thermocoupleType` to use, visit the [Thermocouple Primer](https://www.phidgets.com/docs/Thermocouple_Primer) for more information.
	   * @returns The thermocouple type
	   * @throws {@link PhidgetError}
	   */


	  getThermocoupleType() {
	    this._assertOpen();

	    if (this.data.thermocoupleType === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.thermocoupleType;
	  }
	  /**
	   * The `thermocoupleType` must correspond to the thermocouple type you are using in your application.
	   *
	   * *   If you are unsure which `thermocoupleType` to use, visit the [Thermocouple Primer](https://www.phidgets.com/docs/Thermocouple_Primer) for more information.
	   * @throws {@link PhidgetError}
	   * @param thermocoupleType - The thermocouple type
	   */


	  async setThermocoupleType(thermocoupleType) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedThermocoupleType(this._ch, thermocoupleType)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified ThermocoupleType is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: thermocoupleType
	    });
	    await bp.send(this._ch, 84);
	  }

	}

	/** @public */

	class TemperatureSensor extends TemperatureSensorBase {
	  /** @internal */
	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 10:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.getNumber(1);else this.data.dataInterval = bp.getNumber(0);

	        this._FIREPropertyChange('DataInterval');

	        this._FIREPropertyChange('DataRate');

	        break;

	      case 76:
	        this.data.temperature = 1e+300;

	        super._bridgeInput(bp);

	        break;

	      case 84:
	        this.data.temperature = 1e+300;

	        switch (bp.getNumber(0)) {
	          case exports.ThermocoupleType.J:
	            this.data.minTemperature = 0;
	            this.data.maxTemperature = 750;
	            break;

	          case exports.ThermocoupleType.K:
	            this.data.minTemperature = -200;
	            this.data.maxTemperature = 1250;
	            break;

	          case exports.ThermocoupleType.E:
	            this.data.minTemperature = -200;
	            this.data.maxTemperature = 900;
	            break;

	          case exports.ThermocoupleType.T:
	            this.data.minTemperature = -200;
	            this.data.maxTemperature = 350;
	            break;
	        }

	        this._FIREPropertyChange('MinTemperature', bp);

	        this._FIREPropertyChange('MaxTemperature', bp);

	        super._bridgeInput(bp);

	        break;

	      default:
	        super._bridgeInput(bp);

	        break;
	    }
	  }
	  /** @internal */


	  _errorHandler(code) {
	    switch (code) {
	      case exports.ErrorEventCode.SATURATION:
	      case exports.ErrorEventCode.OUT_OF_RANGE:
	        this.data.temperature = 1e+300;
	        this._gotTemperatureChangeErrorEvent = true;
	        break;
	    }
	  }

	}

	class EncoderBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onPositionChange = null;
	    this._class = exports.ChannelClass.ENCODER;
	    this.name = "Encoder";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 56:
	        this.data.enabled = bp.entries[0].v;

	        this._FIREPropertyChange('Enabled', bp);

	        break;

	      case 54:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.entries[1].v;else this.data.dataInterval = bp.entries[0].v;

	        this._FIREPropertyChange('DataInterval', bp);

	        this._FIREPropertyChange('DataRate', bp);

	        break;

	      case 65:
	        this.data.IOMode = bp.entries[0].v;

	        this._FIREPropertyChange('IOMode', bp);

	        break;

	      case 46:
	        this.data.positionChangeTrigger = bp.entries[0].v;

	        this._FIREPropertyChange('PositionChangeTrigger', bp);

	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      dataInterval: 1e+300,
	      minDataInterval: 4294967295,
	      maxDataInterval: 4294967295,
	      minDataRate: 1e+300,
	      maxDataRate: 1e+300,
	      maxPositionChangeTrigger: 4294967295,
	      minPositionChangeTrigger: 4294967295,
	      position: 9223372036854776000,
	      indexPosition: 9223372036854776000,
	      positionChangeTrigger: 4294967295,
	      enabled: 2,
	      IOMode: 2147483647
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 100:
	        this.data.dataInterval = 256;
	        this.data.minDataInterval = 8;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 125;
	        this.data.maxPositionChangeTrigger = 10000;
	        this.data.minPositionChangeTrigger = 0;
	        this.data.position = 0;
	        this.data.indexPosition = 0;
	        this.data.positionChangeTrigger = 0;
	        this.data.enabled = 1;
	        break;

	      case 140:
	        this.data.dataInterval = 256;
	        this.data.minDataInterval = 8;
	        this.data.maxDataInterval = 1000;
	        this.data.minDataRate = 1;
	        this.data.maxDataRate = 125;
	        this.data.maxPositionChangeTrigger = 10000;
	        this.data.minPositionChangeTrigger = 0;
	        this.data.position = 0;
	        this.data.indexPosition = 0;
	        this.data.positionChangeTrigger = 0;
	        this.data.enabled = 1;
	        this.data.IOMode = exports.EncoderIOMode.PUSH_PULL;
	        break;

	      case 243:
	      case 248:
	      case 254:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 100;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.maxPositionChangeTrigger = 60000000;
	        this.data.minPositionChangeTrigger = 0;
	        this.data.position = 0;
	        this.data.indexPosition = 0;
	        this.data.positionChangeTrigger = 0;
	        this.data.enabled = 1;
	        this.data.IOMode = exports.EncoderIOMode.PUSH_PULL;
	        break;

	      case 270:
	      case 273:
	      case 276:
	      case 279:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 50;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 20;
	        this.data.maxPositionChangeTrigger = 60000000;
	        this.data.minPositionChangeTrigger = 0;
	        this.data.position = 0;
	        this.data.indexPosition = 0;
	        this.data.positionChangeTrigger = 0;
	        this.data.enabled = 1;
	        break;

	      case 293:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 20;
	        this.data.maxDataInterval = 1000;
	        this.data.minDataRate = 1;
	        this.data.maxDataRate = 50;
	        this.data.maxPositionChangeTrigger = 60000000;
	        this.data.minPositionChangeTrigger = 0;
	        this.data.position = 0;
	        this.data.indexPosition = 0;
	        this.data.positionChangeTrigger = 0;
	        this.data.enabled = 1;
	        this.data.IOMode = exports.EncoderIOMode.PUSH_PULL;
	        break;

	      case 294:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 20;
	        this.data.maxDataInterval = 1000;
	        this.data.minDataRate = 1;
	        this.data.maxDataRate = 50;
	        this.data.maxPositionChangeTrigger = 60000000;
	        this.data.minPositionChangeTrigger = 0;
	        this.data.position = 0;
	        this.data.positionChangeTrigger = 0;
	        this.data.enabled = 1;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    let bp;

	    switch (this._ch.chDef.uid) {
	      case 100:
	      case 294:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: this.data.positionChangeTrigger
	        });
	        await bp.send(this._ch, 46);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.enabled
	        });
	        await bp.send(this._ch, 56);
	        break;

	      case 140:
	      case 293:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: this.data.positionChangeTrigger
	        });
	        await bp.send(this._ch, 46);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.enabled
	        });
	        await bp.send(this._ch, 56);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.IOMode
	        });
	        await bp.send(this._ch, 65);
	        break;

	      case 243:
	      case 248:
	      case 254:
	        break;

	      case 270:
	      case 273:
	      case 276:
	      case 279:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: this.data.positionChangeTrigger
	        });
	        await bp.send(this._ch, 46);
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {}
	  /**
	   * The enabled state of the encoder.
	   * @throws {@link PhidgetError}
	   */


	  get enabled() {
	    return this.getEnabled();
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `PositionChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `PositionChange` events can also be affected by the `positionChangeTrigger`.
	   * @throws {@link PhidgetError}
	   */


	  get dataInterval() {
	    return this.getDataInterval();
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataInterval() {
	    return this.getMinDataInterval();
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataInterval() {
	    return this.getMaxDataInterval();
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   */


	  get dataRate() {
	    return this.getDataRate();
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataRate() {
	    return this.getMinDataRate();
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataRate() {
	    return this.getMaxDataRate();
	  }
	  /**
	   * The most recent position of the index channel calculated by the Phidgets library.
	   *
	   * *   The index channel will usually pulse once per rotation.
	   * *   Setting the encoder position will move the index position the same amount so their relative position stays the same.
	   * *   Index position is tracked locally as the last position at which the index was triggered. Setting position will only affect the local copy of the index position value. This means that index positions seen by multiple network applications may not agree.
	   * @throws {@link PhidgetError}
	   */


	  get indexPosition() {
	    return this.getIndexPosition();
	  }
	  /**
	   * The encoder interface mode. Match the mode to the type of encoder you have attached.
	   *
	   * *   It is recommended to only change this when the encoder disabled in order to avoid unexpected results.
	   * @throws {@link PhidgetError}
	   */


	  get IOMode() {
	    return this.getIOMode();
	  }
	  /**
	   * The most recent position value calculated by the Phidgets library.
	   *
	   * *   Position counts quadrature edges within a quadrature cycle. This means there are four counts per full quadrature cycle.
	   * *   Position is tracked locally as the total position change from the time the channel is opened. Setting position will only affect the local copy of the position value. This means that positions seen by multiple network applications may not agree.
	   * @throws {@link PhidgetError}
	   */


	  get position() {
	    return this.getPosition();
	  }

	  set position(position) {
	    this.setPosition(position);
	  }
	  /**
	   * The channel will not issue a `PositionChange` event until the position value has changed by the amount specified by the `positionChangeTrigger`.
	   *
	   * *   Setting the `positionChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   */


	  get positionChangeTrigger() {
	    return this.getPositionChangeTrigger();
	  }
	  /**
	   * The minimum value that `positionChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minPositionChangeTrigger() {
	    return this.getMinPositionChangeTrigger();
	  }
	  /**
	   * The maximum value that `positionChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxPositionChangeTrigger() {
	    return this.getMaxPositionChangeTrigger();
	  }
	  /**
	   * The enabled state of the encoder.
	   * @throws {@link PhidgetError}
	   * @param enabled - The enabled value
	   */


	  async setEnabled(enabled) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (enabled !== false && enabled !== true) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be a boolean.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: enabled ? 1 : 0
	    });
	    await bp.send(this._ch, 56);
	  }
	  /**
	   * The enabled state of the encoder.
	   * @returns The enabled value
	   * @throws {@link PhidgetError}
	   */


	  getEnabled() {
	    this._assertOpen();

	    if (this.data.enabled === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.enabled;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `PositionChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `PositionChange` events can also be affected by the `positionChangeTrigger`.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getDataInterval() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dataInterval;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `PositionChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `PositionChange` events can also be affected by the `positionChangeTrigger`.
	   * @throws {@link PhidgetError}
	   * @param dataInterval - The data interval value
	   */


	  async setDataInterval(dataInterval) {
	    this._assertOpen();

	    if (dataInterval < this.data.minDataInterval || dataInterval > this.data.maxDataInterval) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataInterval + " - " + this.data.maxDataInterval + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: dataInterval
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataInterval() {
	    this._assertOpen();

	    if (this.data.minDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataInterval;
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataInterval() {
	    this._assertOpen();

	    if (this.data.maxDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @returns The data rate for the channel
	   * @throws {@link PhidgetError}
	   */


	  getDataRate() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return 1000.0 / this.data.dataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   * @param dataRate - The data rate for the channel
	   */


	  async setDataRate(dataRate) {
	    this._assertOpen();

	    if (dataRate < this.data.minDataRate || dataRate > this.data.maxDataRate) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataRate + " - " + this.data.maxDataRate + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: Math.round(1000.0 / dataRate)
	    });
	    bp.set({
	      name: "1",
	      type: "g",
	      value: 1000.0 / dataRate
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataRate() {
	    this._assertOpen();

	    if (this.data.minDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataRate;
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataRate() {
	    this._assertOpen();

	    if (this.data.maxDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataRate;
	  }
	  /**
	   * The most recent position of the index channel calculated by the Phidgets library.
	   *
	   * *   The index channel will usually pulse once per rotation.
	   * *   Setting the encoder position will move the index position the same amount so their relative position stays the same.
	   * *   Index position is tracked locally as the last position at which the index was triggered. Setting position will only affect the local copy of the index position value. This means that index positions seen by multiple network applications may not agree.
	   * @returns The index position value
	   * @throws {@link PhidgetError}
	   */


	  getIndexPosition() {
	    this._assertOpen();

	    if (this.data.indexPosition === 9223372036854776000) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.indexPosition;
	  }
	  /**
	   * The encoder interface mode. Match the mode to the type of encoder you have attached.
	   *
	   * *   It is recommended to only change this when the encoder disabled in order to avoid unexpected results.
	   * @returns The IO mode value.
	   * @throws {@link PhidgetError}
	   */


	  getIOMode() {
	    this._assertOpen();

	    if (this.data.IOMode === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.IOMode;
	  }
	  /**
	   * The encoder interface mode. Match the mode to the type of encoder you have attached.
	   *
	   * *   It is recommended to only change this when the encoder disabled in order to avoid unexpected results.
	   * @throws {@link PhidgetError}
	   * @param IOMode - The IO mode value.
	   */


	  async setIOMode(IOMode) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedEncoderIOMode(this._ch, IOMode)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified EncoderIOMode is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: IOMode
	    });
	    await bp.send(this._ch, 65);
	  }
	  /**
	   * The most recent position value calculated by the Phidgets library.
	   *
	   * *   Position counts quadrature edges within a quadrature cycle. This means there are four counts per full quadrature cycle.
	   * *   Position is tracked locally as the total position change from the time the channel is opened. Setting position will only affect the local copy of the position value. This means that positions seen by multiple network applications may not agree.
	   * @returns The position value
	   * @throws {@link PhidgetError}
	   */


	  getPosition() {
	    this._assertOpen();

	    if (this.data.position === 9223372036854776000) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.position;
	  }
	  /**
	   * The channel will not issue a `PositionChange` event until the position value has changed by the amount specified by the `positionChangeTrigger`.
	   *
	   * *   Setting the `positionChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getPositionChangeTrigger() {
	    this._assertOpen();

	    if (this.data.positionChangeTrigger === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.positionChangeTrigger;
	  }
	  /**
	   * The channel will not issue a `PositionChange` event until the position value has changed by the amount specified by the `positionChangeTrigger`.
	   *
	   * *   Setting the `positionChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   * @param positionChangeTrigger - The change trigger value
	   */


	  async setPositionChangeTrigger(positionChangeTrigger) {
	    this._assertOpen();

	    if (positionChangeTrigger < this.data.minPositionChangeTrigger || positionChangeTrigger > this.data.maxPositionChangeTrigger) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minPositionChangeTrigger + " - " + this.data.maxPositionChangeTrigger + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: positionChangeTrigger
	    });
	    await bp.send(this._ch, 46);
	  }
	  /**
	   * The minimum value that `positionChangeTrigger` can be set to.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMinPositionChangeTrigger() {
	    this._assertOpen();

	    if (this.data.minPositionChangeTrigger === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minPositionChangeTrigger;
	  }
	  /**
	   * The maximum value that `positionChangeTrigger` can be set to.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMaxPositionChangeTrigger() {
	    this._assertOpen();

	    if (this.data.maxPositionChangeTrigger === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxPositionChangeTrigger;
	  }

	}

	/** @public */

	class Encoder extends EncoderBase {
	  /** @internal */
	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 29:
	        {
	          const positionChange = bp.getNumber(0);
	          const timeChange = bp.getNumber(1);
	          const indexTriggered = bp.getBoolean(2);
	          let indexPosition = 0;

	          if (indexTriggered) {
	            indexPosition = bp.getNumber(3);
	            this.data.indexPosition = this.data.position + indexPosition;
	          }

	          this.data.position += positionChange;

	          if (this._isAttachedDone && this.onPositionChange) {
	            try {
	              this.onPositionChange(positionChange, timeChange, indexTriggered);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        super._bridgeInput(bp);

	        break;
	    }
	  }

	  setPosition(position) {
	    this._assertOpen();

	    if (this.data.indexPosition != 9223372036854776000) this.data.indexPosition += position - this.data.position;
	    this.data.position = position;
	  }

	}

	class FrequencyCounterBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onFrequencyChange = null;
	    this.onCountChange = null;
	    this._class = exports.ChannelClass.FREQUENCY_COUNTER;
	    this.name = "FrequencyCounter";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 56:
	        this.data.enabled = bp.entries[0].v;

	        this._FIREPropertyChange('Enabled', bp);

	        break;

	      case 54:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.entries[1].v;else this.data.dataInterval = bp.entries[0].v;

	        this._FIREPropertyChange('DataInterval', bp);

	        this._FIREPropertyChange('DataRate', bp);

	        break;

	      case 59:
	        this.data.filterType = bp.entries[0].v;

	        this._FIREPropertyChange('FilterType', bp);

	        break;

	      case 64:
	        this.data.inputMode = bp.entries[0].v;

	        this._FIREPropertyChange('InputMode', bp);

	        break;

	      case 74:
	        this.data.powerSupply = bp.entries[0].v;

	        this._FIREPropertyChange('PowerSupply', bp);

	        break;

	      case 7:
	        {
	          if (this._isAttachedDone && this.onCountChange) {
	            try {
	              this.onCountChange(bp.entries[0].v, bp.entries[1].v);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      case 20:
	        {
	          this.data.frequency = bp.entries[0].v;

	          if (this._isAttachedDone && this.onFrequencyChange) {
	            try {
	              this.onFrequencyChange(this.data.frequency);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      totalTicksSinceLastCount: 0,
	      frequencyPrecision: 0,
	      dataInterval: 1e+300,
	      minDataInterval: 4294967295,
	      maxDataInterval: 4294967295,
	      minDataRate: 1e+300,
	      maxDataRate: 1e+300,
	      maxFrequency: 1e+300,
	      maxFrequencyCutoff: 1e+300,
	      minFrequencyCutoff: 1e+300,
	      count: 18446744073709552000,
	      timeElapsed: 1e+300,
	      frequencyCutoff: 1e+300,
	      frequency: 1e+300,
	      filterType: 2147483647,
	      powerSupply: 2147483647,
	      inputMode: 2147483647,
	      enabled: 2
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 235:
	      case 239:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 20;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 50;
	        this.data.maxFrequency = 1000000;
	        this.data.maxFrequencyCutoff = 10;
	        this.data.minFrequencyCutoff = 0.01;
	        this.data.count = 0;
	        this.data.timeElapsed = 0;
	        this.data.frequencyCutoff = 1;
	        this.data.frequency = 0;
	        this.data.filterType = exports.FrequencyFilterType.LOGIC_LEVEL;
	        this.data.powerSupply = exports.PowerSupply.VOLTS_12;
	        this.data.inputMode = exports.InputMode.NPN;
	        this.data.enabled = 1;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    let bp;

	    switch (this._ch.chDef.uid) {
	      case 235:
	      case 239:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.powerSupply
	        });
	        await bp.send(this._ch, 74);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.inputMode
	        });
	        await bp.send(this._ch, 64);
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    if (this.data.frequency == 1e+300 && !this._gotFrequencyChangeErrorEvent) return false;
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {
	    if (this.data.frequency != 1e+300) if (this.onFrequencyChange) try {
	      this.onFrequencyChange(this.data.frequency);
	    } catch (err) {
	      logEventException(err);
	    }
	  }
	  /**
	   * The most recent count value the channel has reported.
	   *
	   * *   The count represents the total number of pulses since the the channel was opened, or last reset.
	   * @throws {@link PhidgetError}
	   */


	  get count() {
	    return this.getCount();
	  }
	  /**
	   * Enables or disables the channel.
	   *
	   * *   When a channel is disabled, it will not longer register counts, therefore the `timeElapsed` and `count` will not be updated until the channel is re-enabled.
	   * @throws {@link PhidgetError}
	   */


	  get enabled() {
	    return this.getEnabled();
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `CountChange` / `FrequencyChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * @throws {@link PhidgetError}
	   */


	  get dataInterval() {
	    return this.getDataInterval();
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataInterval() {
	    return this.getMinDataInterval();
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataInterval() {
	    return this.getMaxDataInterval();
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   */


	  get dataRate() {
	    return this.getDataRate();
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataRate() {
	    return this.getMinDataRate();
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataRate() {
	    return this.getMaxDataRate();
	  }
	  /**
	   * Determines the signal type that the channel responds to.
	   *
	   * *   The filter type is chosen based on the type of input signal. See the `phidget22.FrequencyFilterType` entry under Enumerations for more information.
	   * @throws {@link PhidgetError}
	   */


	  get filterType() {
	    return this.getFilterType();
	  }
	  /**
	   * The most recent frequency value that the channel has reported.
	   *
	   * *   This value will always be between 0 Hz and `maxFrequency`.
	   * @throws {@link PhidgetError}
	   */


	  get frequency() {
	    return this.getFrequency();
	  }
	  /**
	   * The maximum value the `FrequencyChange` event will report.
	   * @throws {@link PhidgetError}
	   */


	  get maxFrequency() {
	    return this.getMaxFrequency();
	  }
	  /**
	   * The frequency at which zero hertz is assumed.
	   *
	   * *   This means any frequency at or below the `frequencyCutoff` value will be reported as 0 Hz.
	   *
	   * *   This property is stored locally, so other users who have this Phidget open over a network connection won't see the effects of your selected cutoff.
	   * @throws {@link PhidgetError}
	   */


	  get frequencyCutoff() {
	    return this.getFrequencyCutoff();
	  }

	  set frequencyCutoff(frequencyCutoff) {
	    this.setFrequencyCutoff(frequencyCutoff);
	  }
	  /**
	   * The minimum value that `frequencyCutoff` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minFrequencyCutoff() {
	    return this.getMinFrequencyCutoff();
	  }
	  /**
	   * The maximum value that `frequencyCutoff` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxFrequencyCutoff() {
	    return this.getMaxFrequencyCutoff();
	  }
	  /**
	   * The input polarity mode for your channel.
	   *
	   * *   See your device's User Guide for more information about what value to chooose for the `inputMode`
	   * @throws {@link PhidgetError}
	   */


	  get inputMode() {
	    return this.getInputMode();
	  }
	  /**
	   * Choose the power supply voltage.
	   *
	   * *   Set this to the voltage specified in the attached sensor's data sheet to power it.
	   *
	   * *   Set to `phidget22.PowerSupply.OFF` to turn off the supply to save power.
	   * @throws {@link PhidgetError}
	   */


	  get powerSupply() {
	    return this.getPowerSupply();
	  }
	  /**
	   * The amount of time the frequency counter has been enabled for.
	   *
	   * *   This property complements `count`, the total number of pulses detected since the channel was opened, or last reset.
	   * @throws {@link PhidgetError}
	   */


	  get timeElapsed() {
	    return this.getTimeElapsed();
	  }
	  /**
	   * The most recent count value the channel has reported.
	   *
	   * *   The count represents the total number of pulses since the the channel was opened, or last reset.
	   * @returns The count value
	   * @throws {@link PhidgetError}
	   */


	  getCount() {
	    this._assertOpen();

	    if (this.data.count === 18446744073709552000) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.count;
	  }
	  /**
	   * Enables or disables the channel.
	   *
	   * *   When a channel is disabled, it will not longer register counts, therefore the `timeElapsed` and `count` will not be updated until the channel is re-enabled.
	   * @throws {@link PhidgetError}
	   * @param enabled - The enabled value
	   */


	  async setEnabled(enabled) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (enabled !== false && enabled !== true) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be a boolean.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: enabled ? 1 : 0
	    });
	    await bp.send(this._ch, 56);
	  }
	  /**
	   * Enables or disables the channel.
	   *
	   * *   When a channel is disabled, it will not longer register counts, therefore the `timeElapsed` and `count` will not be updated until the channel is re-enabled.
	   * @returns The enabled value
	   * @throws {@link PhidgetError}
	   */


	  getEnabled() {
	    this._assertOpen();

	    if (this.data.enabled === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.enabled;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `CountChange` / `FrequencyChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getDataInterval() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dataInterval;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `CountChange` / `FrequencyChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * @throws {@link PhidgetError}
	   * @param dataInterval - The data interval value
	   */


	  async setDataInterval(dataInterval) {
	    this._assertOpen();

	    if (dataInterval < this.data.minDataInterval || dataInterval > this.data.maxDataInterval) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataInterval + " - " + this.data.maxDataInterval + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: dataInterval
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataInterval() {
	    this._assertOpen();

	    if (this.data.minDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataInterval;
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataInterval() {
	    this._assertOpen();

	    if (this.data.maxDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @returns The data rate for the channel
	   * @throws {@link PhidgetError}
	   */


	  getDataRate() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return 1000.0 / this.data.dataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   * @param dataRate - The data rate for the channel
	   */


	  async setDataRate(dataRate) {
	    this._assertOpen();

	    if (dataRate < this.data.minDataRate || dataRate > this.data.maxDataRate) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataRate + " - " + this.data.maxDataRate + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: Math.round(1000.0 / dataRate)
	    });
	    bp.set({
	      name: "1",
	      type: "g",
	      value: 1000.0 / dataRate
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataRate() {
	    this._assertOpen();

	    if (this.data.minDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataRate;
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataRate() {
	    this._assertOpen();

	    if (this.data.maxDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataRate;
	  }
	  /**
	   * Determines the signal type that the channel responds to.
	   *
	   * *   The filter type is chosen based on the type of input signal. See the `phidget22.FrequencyFilterType` entry under Enumerations for more information.
	   * @returns The filter value
	   * @throws {@link PhidgetError}
	   */


	  getFilterType() {
	    this._assertOpen();

	    if (this.data.filterType === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.filterType;
	  }
	  /**
	   * Determines the signal type that the channel responds to.
	   *
	   * *   The filter type is chosen based on the type of input signal. See the `phidget22.FrequencyFilterType` entry under Enumerations for more information.
	   * @throws {@link PhidgetError}
	   * @param filterType - The filter value
	   */


	  async setFilterType(filterType) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedFrequencyFilterType(this._ch, filterType)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified FrequencyFilterType is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: filterType
	    });
	    await bp.send(this._ch, 59);
	  }
	  /**
	   * The most recent frequency value that the channel has reported.
	   *
	   * *   This value will always be between 0 Hz and `maxFrequency`.
	   * @returns The frequency value
	   * @throws {@link PhidgetError}
	   */


	  getFrequency() {
	    this._assertOpen();

	    if (this.data.frequency === 1e+300 || Number.isNaN(this.data.frequency)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    if (this.data.frequency > this.data.maxFrequency) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE_HIGH);
	    return this.data.frequency;
	  }
	  /**
	   * The maximum value the `FrequencyChange` event will report.
	   * @returns The frequency value
	   * @throws {@link PhidgetError}
	   */


	  getMaxFrequency() {
	    this._assertOpen();

	    if (this.data.maxFrequency === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxFrequency;
	  }
	  /**
	   * The frequency at which zero hertz is assumed.
	   *
	   * *   This means any frequency at or below the `frequencyCutoff` value will be reported as 0 Hz.
	   *
	   * *   This property is stored locally, so other users who have this Phidget open over a network connection won't see the effects of your selected cutoff.
	   * @returns The frequency cutoff value
	   * @throws {@link PhidgetError}
	   */


	  getFrequencyCutoff() {
	    this._assertOpen();

	    if (this.data.frequencyCutoff === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.frequencyCutoff;
	  }
	  /**
	   * The minimum value that `frequencyCutoff` can be set to.
	   * @returns The frequency value
	   * @throws {@link PhidgetError}
	   */


	  getMinFrequencyCutoff() {
	    this._assertOpen();

	    if (this.data.minFrequencyCutoff === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minFrequencyCutoff;
	  }
	  /**
	   * The maximum value that `frequencyCutoff` can be set to.
	   * @returns The frequency value
	   * @throws {@link PhidgetError}
	   */


	  getMaxFrequencyCutoff() {
	    this._assertOpen();

	    if (this.data.maxFrequencyCutoff === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxFrequencyCutoff;
	  }
	  /**
	   * The input polarity mode for your channel.
	   *
	   * *   See your device's User Guide for more information about what value to chooose for the `inputMode`
	   * @returns The input mode value
	   * @throws {@link PhidgetError}
	   */


	  getInputMode() {
	    this._assertOpen();

	    if (this.data.inputMode === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.inputMode;
	  }
	  /**
	   * The input polarity mode for your channel.
	   *
	   * *   See your device's User Guide for more information about what value to chooose for the `inputMode`
	   * @throws {@link PhidgetError}
	   * @param inputMode - The input mode value
	   */


	  async setInputMode(inputMode) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedInputMode(this._ch, inputMode)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified InputMode is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: inputMode
	    });
	    await bp.send(this._ch, 64);
	  }
	  /**
	   * Choose the power supply voltage.
	   *
	   * *   Set this to the voltage specified in the attached sensor's data sheet to power it.
	   *
	   * *   Set to `phidget22.PowerSupply.OFF` to turn off the supply to save power.
	   * @returns The power supply value
	   * @throws {@link PhidgetError}
	   */


	  getPowerSupply() {
	    this._assertOpen();

	    if (this.data.powerSupply === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.powerSupply;
	  }
	  /**
	   * Choose the power supply voltage.
	   *
	   * *   Set this to the voltage specified in the attached sensor's data sheet to power it.
	   *
	   * *   Set to `phidget22.PowerSupply.OFF` to turn off the supply to save power.
	   * @throws {@link PhidgetError}
	   * @param powerSupply - The power supply value
	   */


	  async setPowerSupply(powerSupply) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedPowerSupply(this._ch, powerSupply)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified PowerSupply is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: powerSupply
	    });
	    await bp.send(this._ch, 74);
	  }
	  /**
	   * The amount of time the frequency counter has been enabled for.
	   *
	   * *   This property complements `count`, the total number of pulses detected since the channel was opened, or last reset.
	   * @returns The time value
	   * @throws {@link PhidgetError}
	   */


	  getTimeElapsed() {
	    this._assertOpen();

	    if (this.data.timeElapsed === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.timeElapsed;
	  }

	}

	/** @public */

	class FrequencyCounter extends FrequencyCounterBase {
	  /** @internal */
	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 21:
	        {
	          const ticks = bp.getNumber(0);
	          const counts = bp.getNumber(1);
	          const ticksAtLastCount = bp.getNumber(2);
	          let cutoffTime;
	          let precision;
	          let d;
	          this.data.timeElapsed += ticks;
	          this.data.count += counts;

	          if (counts == 0) {
	            if (Number.isNaN(this.data.totalTicksSinceLastCount)) return;
	            this.data.totalTicksSinceLastCount += ticks;
	            cutoffTime = Math.round(1000 / this.data.frequencyCutoff);

	            if (this.data.totalTicksSinceLastCount > cutoffTime) {
	              this.data.frequency = 0;

	              if (this._isAttachedDone && this.onCountChange) {
	                try {
	                  this.onCountChange(0, this.data.totalTicksSinceLastCount);
	                } catch (err) {
	                  logEventException(err);
	                }
	              }

	              if (this._isAttachedDone && this.onFrequencyChange) {
	                try {
	                  this.onFrequencyChange(this.data.frequency);
	                } catch (err) {
	                  logEventException(err);
	                }
	              }

	              this.data.totalTicksSinceLastCount = Number.NaN;
	            }

	            return;
	          }

	          if (Number.isNaN(this.data.totalTicksSinceLastCount)) {
	            this.data.totalTicksSinceLastCount = ticks - ticksAtLastCount;
	            return;
	          }

	          const countTimeSpan = this.data.totalTicksSinceLastCount + ticksAtLastCount;
	          this.data.totalTicksSinceLastCount = ticks - ticksAtLastCount;
	          d = this.data.frequencyCutoff;
	          precision = 2;

	          while (d < 1) {
	            precision++;
	            d *= 10;
	          }

	          this.data.frequency = RoundDouble(counts / (countTimeSpan / 1000.0), precision);

	          if (this._isAttachedDone && this.onCountChange) {
	            try {
	              this.onCountChange(counts, countTimeSpan);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          if (this._isAttachedDone && this.onFrequencyChange) {
	            try {
	              this.onFrequencyChange(this.data.frequency);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      case 56:
	        if (!bp.getBoolean(0)) this.data.frequency = 1e+300;

	        super._bridgeInput(bp);

	        break;

	      default:
	        super._bridgeInput(bp);

	        break;
	    }
	  }

	  setFrequencyCutoff(frequencyCutoff) {
	    this._assertOpen();

	    if (frequencyCutoff < this.data.minFrequencyCutoff || frequencyCutoff > this.data.maxFrequencyCutoff) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minFrequencyCutoff + " - " + this.data.maxFrequencyCutoff + ".");
	    this.data.frequencyCutoff = frequencyCutoff;
	  }

	  reset() {
	    this._assertOpen();

	    this.data.count = 0;
	    this.data.timeElapsed = 0;
	    this.data.frequency = 1e+300;
	  }

	}

	class IRBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onCode = null;
	    this.onLearn = null;
	    this.onRawData = null;
	    this._class = exports.ChannelClass.IR;
	    this.name = "IR";
	    this.data = this._initData();
	  }

	  static get RAW_DATA_LONG_SPACE() {
	    return 4294967295;
	  }

	  static get MAX_CODE_BIT_COUNT() {
	    return 128;
	  }

	  static get MAX_CODE_STRING_LENGTH() {
	    return 33;
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 97:
	        break;

	      case 98:
	        break;

	      case 99:
	        break;

	      case 32:
	        {
	          if (this._isAttachedDone && this.onRawData) {
	            try {
	              this.onRawData(bp.entries[0].v);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      lastCodeInfo: null,
	      lastLearnedCodeInfo: null,
	      lastCodeStr: null,
	      lastCodeBitCount: 0,
	      lastLearnedCodeStr: null
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 130:
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    switch (this._ch.chDef.uid) {
	      case 130:
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {}
	  /**
	   * Transmits a repeat of the last transmited code.
	   *
	   * *   Depending on the CodeInfo structure, this may be a retransmission of the code itself, or there may be a special repeat code.
	   * @throws {@link PhidgetError}
	   */


	  async transmitRepeat() {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    await bp.send(this._ch, 99);
	  }

	}

	/** @public */

	class IR extends IRBase {
	  /** @internal */
	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 33:
	        if (this._isAttachedDone && this.onCode) {
	          try {
	            this.onCode(this.data.lastCodeStr, this.data.lastCodeBitCount, true);
	          } catch (err) {
	            logEventException(err);
	          }
	        }

	        break;

	      case 5:
	        this.data.lastCodeStr = bp.getString(0);
	        this.data.lastCodeBitCount = bp.getNumber(1);

	        if (this._isAttachedDone && this.onCode) {
	          try {
	            this.onCode(this.data.lastCodeStr, this.data.lastCodeBitCount, bp.getBoolean(2));
	          } catch (err) {
	            logEventException(err);
	          }
	        }

	        break;

	      case 25:
	        {
	          const toggleString = String.fromCharCode(...bp.getArray("CodeInfo.toggleMask")).replace(/\u0000/g, '');
	          const repeatArr = bp.getArray("CodeInfo.repeat");

	          while (repeatArr[repeatArr.length - 1] === 0) repeatArr.pop();

	          this.data.lastLearnedCodeStr = bp.getString("0");
	          this.data.lastLearnedCodeInfo = {
	            bitCount: bp.getNumber("CodeInfo.bitCount"),
	            encoding: bp.getNumber("CodeInfo.encoding"),
	            length: bp.getNumber("CodeInfo.length"),
	            gap: bp.getNumber("CodeInfo.gap"),
	            trail: bp.getNumber("CodeInfo.trail"),
	            header: bp.getArray("CodeInfo.header"),
	            one: bp.getArray("CodeInfo.one"),
	            zero: bp.getArray("CodeInfo.zero"),
	            repeat: repeatArr,
	            minRepeat: bp.getNumber("CodeInfo.minRepeat"),
	            dutyCycle: bp.getNumber("CodeInfo.dutyCycle"),
	            carrierFrequency: bp.getNumber("CodeInfo.carrierFrequency"),
	            toggleMask: toggleString
	          };

	          if (this._isAttachedDone && this.onLearn) {
	            try {
	              this.onLearn(this.data.lastLearnedCodeStr, this.data.lastLearnedCodeInfo);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        super._bridgeInput(bp);

	        break;
	    }
	  }

	  async transmit(code, ci) {
	    this._assertOpen();

	    const codeInfo = {
	      bitCount: 0,
	      encoding: exports.IRCodeEncoding.SPACE,
	      length: exports.IRCodeLength.CONSTANT,
	      gap: 0,
	      trail: 0,
	      minRepeat: 0,
	      dutyCycle: 0,
	      carrierFrequency: 0,
	      header: [0, 0],
	      one: [0, 0],
	      zero: [0, 0],
	      repeat: [],
	      toggleMask: ''
	    };
	    if (ci.bitCount !== undefined) codeInfo.bitCount = ci.bitCount;
	    if (ci.encoding !== undefined) codeInfo.encoding = ci.encoding;
	    if (ci.length !== undefined) codeInfo.length = ci.length;
	    if (ci.gap !== undefined) codeInfo.gap = ci.gap;
	    if (ci.trail !== undefined) codeInfo.trail = ci.trail;
	    if (ci.minRepeat !== undefined) codeInfo.minRepeat = ci.minRepeat;
	    if (ci.dutyCycle !== undefined) codeInfo.dutyCycle = ci.dutyCycle;
	    if (ci.carrierFrequency !== undefined) codeInfo.carrierFrequency = ci.carrierFrequency;

	    if (ci.header !== undefined) {
	      if (!Array.isArray(ci.header)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, 'invalid value - header must be Array');
	      if (ci.header.length != 2) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, 'invalid value - header must have length 2');
	      codeInfo.header = ci.header;
	    }

	    if (ci.one !== undefined) {
	      if (!Array.isArray(ci.one)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, 'invalid value - one must be Array');
	      if (ci.one.length != 2) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, 'invalid value - one must have length 2');
	      codeInfo.one = ci.one;
	    }

	    if (ci.zero !== undefined) {
	      if (!Array.isArray(ci.zero)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, 'invalid value - zero must be Array');
	      if (ci.zero.length != 2) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, 'invalid value - zero must have length 2');
	      codeInfo.zero = ci.zero;
	    }

	    const repeatArr = new Array(26).fill(0);

	    if (ci.repeat !== undefined) {
	      if (!Array.isArray(ci.repeat)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, 'invalid value - repeat must be Array');
	      if (ci.repeat.length > 26) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, 'invalid value - repeat must have length <= 26');

	      for (let i = 0; i < ci.repeat.length; i++) repeatArr[i] = ci.repeat[i];
	    }

	    const toggleMaskArr = new Array(33).fill(0);

	    if (ci.toggleMask !== undefined) {
	      if (typeof ci.toggleMask !== 'string') throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, 'invalid value - toggleMask must be a string');
	      if (ci.toggleMask.length > 33) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, 'invalid value - toggleMask must have length <= 33');

	      for (let i = 0; i < ci.toggleMask.length; i++) toggleMaskArr[i] = ci.toggleMask.charCodeAt(i);
	    }

	    const bp = new BridgePacket();
	    bp.set({
	      name: 'code',
	      type: 's',
	      value: code
	    });
	    bp.set({
	      name: 'CodeInfo.bitCount',
	      type: 'u',
	      value: codeInfo.bitCount
	    });
	    bp.set({
	      name: 'CodeInfo.encoding',
	      type: 'd',
	      value: codeInfo.encoding
	    });
	    bp.set({
	      name: 'CodeInfo.length',
	      type: 'd',
	      value: codeInfo.length
	    });
	    bp.set({
	      name: 'CodeInfo.gap',
	      type: 'u',
	      value: codeInfo.gap
	    });
	    bp.set({
	      name: 'CodeInfo.trail',
	      type: 'u',
	      value: codeInfo.trail
	    });
	    bp.set({
	      name: 'CodeInfo.header',
	      type: 'U',
	      value: codeInfo.header
	    });
	    bp.set({
	      name: 'CodeInfo.one',
	      type: 'U',
	      value: codeInfo.one
	    });
	    bp.set({
	      name: 'CodeInfo.zero',
	      type: 'U',
	      value: codeInfo.zero
	    });
	    bp.set({
	      name: 'CodeInfo.repeat',
	      type: 'U',
	      value: repeatArr
	    });
	    bp.set({
	      name: 'CodeInfo.minRepeat',
	      type: 'u',
	      value: codeInfo.minRepeat
	    });
	    bp.set({
	      name: 'CodeInfo.dutyCycle',
	      type: 'g',
	      value: codeInfo.dutyCycle
	    });
	    bp.set({
	      name: 'CodeInfo.carrierFrequency',
	      type: 'u',
	      value: codeInfo.carrierFrequency
	    });
	    bp.set({
	      name: 'CodeInfo.toggleMask',
	      type: 'R',
	      value: toggleMaskArr
	    });
	    await bp.send(this._ch, 97);
	  }

	  async transmitRaw(data) {
	    let carrierFrequency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    let dutyCycle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	    let gap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: 'data',
	      type: 'U',
	      value: data
	    });
	    bp.set({
	      name: 'carrierFrequency',
	      type: 'u',
	      value: carrierFrequency
	    });
	    bp.set({
	      name: 'dutyCycle',
	      type: 'g',
	      value: dutyCycle
	    });
	    bp.set({
	      name: 'gap',
	      type: 'u',
	      value: gap
	    });
	    await bp.send(this._ch, 98);
	  }

	  getLastCode() {
	    this._assertOpen();

	    if (this.data.lastCodeStr == undefined) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return {
	      code: this.data.lastCodeStr,
	      bitCount: this.data.lastCodeBitCount
	    };
	  }

	  getLastLearnedCode() {
	    this._assertOpen();

	    if (this.data.lastLearnedCodeStr == undefined || this.data.lastLearnedCodeInfo == undefined) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return {
	      code: this.data.lastLearnedCodeStr,
	      codeInfo: this.data.lastLearnedCodeInfo
	    };
	  }

	}

	class PHSensorBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onPHChange = null;
	    this._class = exports.ChannelClass.PH_SENSOR;
	    this.name = "PHSensor";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 134:
	        this.data.correctionTemperature = bp.entries[0].v;

	        this._FIREPropertyChange('CorrectionTemperature', bp);

	        break;

	      case 54:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.entries[1].v;else this.data.dataInterval = bp.entries[0].v;

	        this._FIREPropertyChange('DataInterval', bp);

	        this._FIREPropertyChange('DataRate', bp);

	        break;

	      case 46:
	        this.data.PHChangeTrigger = bp.entries[0].v;

	        this._FIREPropertyChange('PHChangeTrigger', bp);

	        break;

	      case 133:
	        {
	          this.data.PH = bp.entries[0].v;

	          if (this._isAttachedDone && this.onPHChange) {
	            try {
	              this.onPHChange(this.data.PH);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      dataInterval: 1e+300,
	      maxDataInterval: 4294967295,
	      minDataRate: 1e+300,
	      maxDataRate: 1e+300,
	      maxPH: 1e+300,
	      maxPHChangeTrigger: 1e+300,
	      minDataInterval: 4294967295,
	      minPH: 1e+300,
	      minPHChangeTrigger: 1e+300,
	      PH: 1e+300,
	      PHChangeTrigger: 1e+300,
	      correctionTemperature: 1e+300,
	      minCorrectionTemperature: 1e+300,
	      maxCorrectionTemperature: 1e+300
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 195:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 20;
	        this.data.maxPH = 14;
	        this.data.maxPHChangeTrigger = 14;
	        this.data.minDataInterval = 50;
	        this.data.minPH = 0;
	        this.data.minPHChangeTrigger = 0;
	        this.data.PHChangeTrigger = 0;
	        this.data.correctionTemperature = 25;
	        this.data.minCorrectionTemperature = 0;
	        this.data.maxCorrectionTemperature = 100;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    let bp;

	    switch (this._ch.chDef.uid) {
	      case 195:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.PHChangeTrigger
	        });
	        await bp.send(this._ch, 46);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.correctionTemperature
	        });
	        await bp.send(this._ch, 134);
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    if (this.data.PH == 1e+300 && !this._gotPHChangeErrorEvent) return false;
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {
	    if (this.data.PH != 1e+300) if (this.onPHChange) try {
	      this.onPHChange(this.data.PH);
	    } catch (err) {
	      logEventException(err);
	    }
	  }
	  /**
	   * Set this property to the measured temperature of the solution to correct the slope of the pH conversion for temperature.
	   * @throws {@link PhidgetError}
	   */


	  get correctionTemperature() {
	    return this.getCorrectionTemperature();
	  }
	  /**
	   * The minimum value that `correctionTemperature` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minCorrectionTemperature() {
	    return this.getMinCorrectionTemperature();
	  }
	  /**
	   * The maximum value that `correctionTemperature` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxCorrectionTemperature() {
	    return this.getMaxCorrectionTemperature();
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `PHChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `PHChange` events can also be affected by the `PHChangeTrigger`.
	   * @throws {@link PhidgetError}
	   */


	  get dataInterval() {
	    return this.getDataInterval();
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataInterval() {
	    return this.getMinDataInterval();
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataInterval() {
	    return this.getMaxDataInterval();
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   */


	  get dataRate() {
	    return this.getDataRate();
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataRate() {
	    return this.getMinDataRate();
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataRate() {
	    return this.getMaxDataRate();
	  }
	  /**
	   * The most recent pH value that the channel has reported.
	   *
	   * *   This value will always be between `minPH` and `maxPH`.
	   * @throws {@link PhidgetError}
	   */


	  get PH() {
	    return this.getPH();
	  }
	  /**
	   * The minimum value the `PHChange` event will report.
	   * @throws {@link PhidgetError}
	   */


	  get minPH() {
	    return this.getMinPH();
	  }
	  /**
	   * The maximum value the `PHChange` event will report.
	   * @throws {@link PhidgetError}
	   */


	  get maxPH() {
	    return this.getMaxPH();
	  }
	  /**
	   * The channel will not issue a `PHChange` event until the pH value has changed by the amount specified by the `PHChangeTrigger`.
	   *
	   * *   Setting the `PHChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   */


	  get PHChangeTrigger() {
	    return this.getPHChangeTrigger();
	  }
	  /**
	   * The minimum value that `PHChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minPHChangeTrigger() {
	    return this.getMinPHChangeTrigger();
	  }
	  /**
	   * The maximum value that `PHChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxPHChangeTrigger() {
	    return this.getMaxPHChangeTrigger();
	  }
	  /**
	   * Set this property to the measured temperature of the solution to correct the slope of the pH conversion for temperature.
	   * @returns The temperature of the solution to correct the pH measurement.
	   * @throws {@link PhidgetError}
	   */


	  getCorrectionTemperature() {
	    this._assertOpen();

	    if (this.data.correctionTemperature === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.correctionTemperature;
	  }
	  /**
	   * Set this property to the measured temperature of the solution to correct the slope of the pH conversion for temperature.
	   * @throws {@link PhidgetError}
	   * @param correctionTemperature - The temperature of the solution to correct the pH measurement.
	   */


	  async setCorrectionTemperature(correctionTemperature) {
	    this._assertOpen();

	    if (correctionTemperature < this.data.minCorrectionTemperature || correctionTemperature > this.data.maxCorrectionTemperature) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minCorrectionTemperature + " - " + this.data.maxCorrectionTemperature + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: correctionTemperature
	    });
	    await bp.send(this._ch, 134);
	  }
	  /**
	   * The minimum value that `correctionTemperature` can be set to.
	   * @returns The minimum temperature that can be corrected for.
	   * @throws {@link PhidgetError}
	   */


	  getMinCorrectionTemperature() {
	    this._assertOpen();

	    if (this.data.minCorrectionTemperature === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minCorrectionTemperature;
	  }
	  /**
	   * The maximum value that `correctionTemperature` can be set to.
	   * @returns The maximum temperature that can be corrected for.
	   * @throws {@link PhidgetError}
	   */


	  getMaxCorrectionTemperature() {
	    this._assertOpen();

	    if (this.data.maxCorrectionTemperature === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxCorrectionTemperature;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `PHChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `PHChange` events can also be affected by the `PHChangeTrigger`.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getDataInterval() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dataInterval;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `PHChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `PHChange` events can also be affected by the `PHChangeTrigger`.
	   * @throws {@link PhidgetError}
	   * @param dataInterval - The data interval value
	   */


	  async setDataInterval(dataInterval) {
	    this._assertOpen();

	    if (dataInterval < this.data.minDataInterval || dataInterval > this.data.maxDataInterval) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataInterval + " - " + this.data.maxDataInterval + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: dataInterval
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataInterval() {
	    this._assertOpen();

	    if (this.data.minDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataInterval;
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataInterval() {
	    this._assertOpen();

	    if (this.data.maxDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @returns The data rate for the channel
	   * @throws {@link PhidgetError}
	   */


	  getDataRate() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return 1000.0 / this.data.dataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   * @param dataRate - The data rate for the channel
	   */


	  async setDataRate(dataRate) {
	    this._assertOpen();

	    if (dataRate < this.data.minDataRate || dataRate > this.data.maxDataRate) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataRate + " - " + this.data.maxDataRate + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: Math.round(1000.0 / dataRate)
	    });
	    bp.set({
	      name: "1",
	      type: "g",
	      value: 1000.0 / dataRate
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataRate() {
	    this._assertOpen();

	    if (this.data.minDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataRate;
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataRate() {
	    this._assertOpen();

	    if (this.data.maxDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataRate;
	  }
	  /**
	   * The most recent pH value that the channel has reported.
	   *
	   * *   This value will always be between `minPH` and `maxPH`.
	   * @returns The pH value
	   * @throws {@link PhidgetError}
	   */


	  getPH() {
	    this._assertOpen();

	    if (this.data.PH === 1e+300 || Number.isNaN(this.data.PH)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    if (this.data.PH > this.data.maxPH) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE_HIGH);
	    if (this.data.PH < this.data.minPH) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE_LOW);
	    return this.data.PH;
	  }
	  /**
	   * The minimum value the `PHChange` event will report.
	   * @returns The pH value
	   * @throws {@link PhidgetError}
	   */


	  getMinPH() {
	    this._assertOpen();

	    if (this.data.minPH === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minPH;
	  }
	  /**
	   * The maximum value the `PHChange` event will report.
	   * @returns The pH value
	   * @throws {@link PhidgetError}
	   */


	  getMaxPH() {
	    this._assertOpen();

	    if (this.data.maxPH === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxPH;
	  }
	  /**
	   * The channel will not issue a `PHChange` event until the pH value has changed by the amount specified by the `PHChangeTrigger`.
	   *
	   * *   Setting the `PHChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getPHChangeTrigger() {
	    this._assertOpen();

	    if (this.data.PHChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.PHChangeTrigger;
	  }
	  /**
	   * The channel will not issue a `PHChange` event until the pH value has changed by the amount specified by the `PHChangeTrigger`.
	   *
	   * *   Setting the `PHChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   * @param PHChangeTrigger - The change trigger value
	   */


	  async setPHChangeTrigger(PHChangeTrigger) {
	    this._assertOpen();

	    if (PHChangeTrigger < this.data.minPHChangeTrigger || PHChangeTrigger > this.data.maxPHChangeTrigger) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minPHChangeTrigger + " - " + this.data.maxPHChangeTrigger + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: PHChangeTrigger
	    });
	    await bp.send(this._ch, 46);
	  }
	  /**
	   * The minimum value that `PHChangeTrigger` can be set to.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMinPHChangeTrigger() {
	    this._assertOpen();

	    if (this.data.minPHChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minPHChangeTrigger;
	  }
	  /**
	   * The maximum value that `PHChangeTrigger` can be set to.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMaxPHChangeTrigger() {
	    this._assertOpen();

	    if (this.data.maxPHChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxPHChangeTrigger;
	  }

	}

	/** @public */

	class PHSensor extends PHSensorBase {}

	class DCMotorBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onBrakingStrengthChange = null;
	    this.onVelocityUpdate = null;
	    this.onBackEMFChange = null;
	    this._class = exports.ChannelClass.DC_MOTOR;
	    this.name = "DCMotor";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 40:
	        this.data.acceleration = bp.entries[0].v;

	        this._FIREPropertyChange('Acceleration', bp);

	        break;

	      case 42:
	        this.data.backEMFSensingState = bp.entries[0].v;

	        this._FIREPropertyChange('BackEMFSensingState', bp);

	        break;

	      case 51:
	        this.data.currentLimit = bp.entries[0].v;

	        this._FIREPropertyChange('CurrentLimit', bp);

	        break;

	      case 119:
	        this.data.currentRegulatorGain = bp.entries[0].v;

	        this._FIREPropertyChange('CurrentRegulatorGain', bp);

	        break;

	      case 54:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.entries[1].v;else this.data.dataInterval = bp.entries[0].v;

	        this._FIREPropertyChange('DataInterval', bp);

	        this._FIREPropertyChange('DataRate', bp);

	        break;

	      case 146:
	        break;

	      case 58:
	        this.data.fanMode = bp.entries[0].v;

	        this._FIREPropertyChange('FanMode', bp);

	        break;

	      case 147:
	        break;

	      case 44:
	        this.data.targetBrakingStrength = bp.entries[0].v;

	        this._FIREPropertyChange('TargetBrakingStrength', bp);

	        break;

	      case 55:
	        this.data.targetVelocity = bp.entries[0].v;

	        this._FIREPropertyChange('TargetVelocity', bp);

	        break;

	      case 3:
	        {
	          this.data.backEMF = bp.entries[0].v;

	          if (this._isAttachedDone && this.onBackEMFChange) {
	            try {
	              this.onBackEMFChange(this.data.backEMF);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      case 121:
	        {
	          this.data.brakingStrength = bp.entries[0].v;

	          if (this._isAttachedDone && this.onBrakingStrengthChange) {
	            try {
	              this.onBrakingStrengthChange(this.data.brakingStrength);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      case 16:
	        {
	          this.data.velocity = bp.entries[0].v;

	          if (this._isAttachedDone && this.onVelocityUpdate) {
	            try {
	              this.onVelocityUpdate(this.data.velocity);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      dataInterval: 1e+300,
	      minDataInterval: 4294967295,
	      maxDataInterval: 4294967295,
	      minDataRate: 1e+300,
	      maxDataRate: 1e+300,
	      currentLimit: 1e+300,
	      maxCurrentLimit: 1e+300,
	      minCurrentLimit: 1e+300,
	      currentRegulatorGain: 1e+300,
	      maxCurrentRegulatorGain: 1e+300,
	      minCurrentRegulatorGain: 1e+300,
	      targetVelocity: 1e+300,
	      maxVelocity: 1e+300,
	      minVelocity: 1e+300,
	      maxAcceleration: 1e+300,
	      minAcceleration: 1e+300,
	      acceleration: 1e+300,
	      targetBrakingStrength: 1e+300,
	      maxBrakingStrength: 1e+300,
	      minBrakingStrength: 1e+300,
	      backEMFSensingState: 2,
	      backEMF: 1e+300,
	      fanMode: 2147483647,
	      velocity: 1e+300,
	      brakingStrength: 1e+300,
	      maxFailsafeTime: 4294967295,
	      minFailsafeTime: 4294967295
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 242:
	      case 247:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 100;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.currentLimit = 2;
	        this.data.maxCurrentLimit = 25;
	        this.data.minCurrentLimit = 2;
	        this.data.currentRegulatorGain = 10;
	        this.data.maxCurrentRegulatorGain = 100;
	        this.data.minCurrentRegulatorGain = 1;
	        this.data.maxVelocity = 1;
	        this.data.minVelocity = 0;
	        this.data.maxAcceleration = 100;
	        this.data.minAcceleration = 0.1;
	        this.data.acceleration = 1;
	        this.data.targetBrakingStrength = 0;
	        this.data.maxBrakingStrength = 1;
	        this.data.minBrakingStrength = 0;
	        this.data.fanMode = exports.FanMode.AUTO;
	        this.data.velocity = 0;
	        break;

	      case 253:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 100;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.currentLimit = 2;
	        this.data.maxCurrentLimit = 25;
	        this.data.minCurrentLimit = 2;
	        this.data.currentRegulatorGain = 10;
	        this.data.maxCurrentRegulatorGain = 100;
	        this.data.minCurrentRegulatorGain = 1;
	        this.data.maxVelocity = 1;
	        this.data.minVelocity = 0;
	        this.data.maxAcceleration = 100;
	        this.data.minAcceleration = 0.1;
	        this.data.acceleration = 1;
	        this.data.targetBrakingStrength = 0;
	        this.data.maxBrakingStrength = 1;
	        this.data.minBrakingStrength = 0;
	        this.data.fanMode = exports.FanMode.AUTO;
	        this.data.velocity = 0;
	        this.data.maxFailsafeTime = 30000;
	        this.data.minFailsafeTime = 500;
	        break;

	      case 269:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 100;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.currentLimit = 2;
	        this.data.maxCurrentLimit = 2;
	        this.data.minCurrentLimit = 0;
	        this.data.maxVelocity = 1;
	        this.data.minVelocity = 0;
	        this.data.maxAcceleration = 100;
	        this.data.minAcceleration = 0.1;
	        this.data.acceleration = 1;
	        this.data.targetBrakingStrength = 0;
	        this.data.maxBrakingStrength = 1;
	        this.data.minBrakingStrength = 0;
	        this.data.velocity = 0;
	        break;

	      case 272:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 100;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.currentLimit = 2;
	        this.data.maxCurrentLimit = 2;
	        this.data.minCurrentLimit = 0;
	        this.data.maxVelocity = 1;
	        this.data.minVelocity = 0;
	        this.data.maxAcceleration = 100;
	        this.data.minAcceleration = 0.1;
	        this.data.acceleration = 1;
	        this.data.targetBrakingStrength = 0;
	        this.data.maxBrakingStrength = 1;
	        this.data.minBrakingStrength = 0;
	        this.data.velocity = 0;
	        this.data.maxFailsafeTime = 30000;
	        this.data.minFailsafeTime = 500;
	        break;

	      case 275:
	      case 281:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 100;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.currentLimit = 2;
	        this.data.maxCurrentLimit = 4;
	        this.data.minCurrentLimit = 0;
	        this.data.maxVelocity = 1;
	        this.data.minVelocity = 0;
	        this.data.maxAcceleration = 100;
	        this.data.minAcceleration = 0.1;
	        this.data.acceleration = 1;
	        this.data.targetBrakingStrength = 0;
	        this.data.maxBrakingStrength = 1;
	        this.data.minBrakingStrength = 0;
	        this.data.velocity = 0;
	        break;

	      case 278:
	      case 282:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 100;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.currentLimit = 2;
	        this.data.maxCurrentLimit = 4;
	        this.data.minCurrentLimit = 0;
	        this.data.maxVelocity = 1;
	        this.data.minVelocity = 0;
	        this.data.maxAcceleration = 100;
	        this.data.minAcceleration = 0.1;
	        this.data.acceleration = 1;
	        this.data.targetBrakingStrength = 0;
	        this.data.maxBrakingStrength = 1;
	        this.data.minBrakingStrength = 0;
	        this.data.velocity = 0;
	        this.data.maxFailsafeTime = 30000;
	        this.data.minFailsafeTime = 500;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    let bp;

	    switch (this._ch.chDef.uid) {
	      case 242:
	      case 247:
	      case 253:
	        break;

	      case 269:
	      case 272:
	      case 275:
	      case 278:
	      case 281:
	      case 282:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.currentLimit
	        });
	        await bp.send(this._ch, 51);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.acceleration
	        });
	        await bp.send(this._ch, 40);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.targetBrakingStrength
	        });
	        await bp.send(this._ch, 44);
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    if (this.data.backEMF == 1e+300 && !this._gotBackEMFChangeErrorEvent) return false;
	    if (this.data.brakingStrength == 1e+300 && !this._gotBrakingStrengthChangeErrorEvent) return false;
	    if (this.data.velocity == 1e+300 && !this._gotVelocityUpdateErrorEvent) return false;
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {
	    if (this.data.backEMF != 1e+300) if (this.onBackEMFChange) try {
	      this.onBackEMFChange(this.data.backEMF);
	    } catch (err) {
	      logEventException(err);
	    }
	    if (this.data.brakingStrength != 1e+300) if (this.onBrakingStrengthChange) try {
	      this.onBrakingStrengthChange(this.data.brakingStrength);
	    } catch (err) {
	      logEventException(err);
	    }
	    if (this.data.velocity != 1e+300) if (this.onVelocityUpdate) try {
	      this.onVelocityUpdate(this.data.velocity);
	    } catch (err) {
	      logEventException(err);
	    }
	  }
	  /**
	   * The rate at which the controller can change the motor's `velocity`.
	   *
	   * *   The acceleration is bounded by `minAcceleration` and `maxAcceleration`
	   * @throws {@link PhidgetError}
	   */


	  get acceleration() {
	    return this.getAcceleration();
	  }
	  /**
	   * The minimum value that `acceleration` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minAcceleration() {
	    return this.getMinAcceleration();
	  }
	  /**
	   * The maximum value that `acceleration` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxAcceleration() {
	    return this.getMaxAcceleration();
	  }
	  /**
	   * The most recent `backEMF` value that the controller has reported.
	   * @throws {@link PhidgetError}
	   */


	  get backEMF() {
	    return this.getBackEMF();
	  }
	  /**
	   * When `backEMFSensingState` is enabled, the controller will measure and report the `backEMF`.
	   *
	   * *   The motor will coast (freewheel) 5% of the time while the back EMF is being measured (800Î¼s every 16ms). Therefore, at a `velocity` of 100%, the motor will only be driven for 95% of the time.
	   * @throws {@link PhidgetError}
	   */


	  get backEMFSensingState() {
	    return this.getBackEMFSensingState();
	  }
	  /**
	   * The most recent braking strength value that the controller has reported. See `targetBrakingStrength` for details.
	   * @throws {@link PhidgetError}
	   */


	  get brakingStrength() {
	    return this.getBrakingStrength();
	  }
	  /**
	   * The minimum value that `targetBrakingStrength` can be set to. See `targetBrakingStrength` for details.
	   * @throws {@link PhidgetError}
	   */


	  get minBrakingStrength() {
	    return this.getMinBrakingStrength();
	  }
	  /**
	   * The maximum value that `targetBrakingStrength` can be set to. See `targetBrakingStrength` for details.
	   * @throws {@link PhidgetError}
	   */


	  get maxBrakingStrength() {
	    return this.getMaxBrakingStrength();
	  }
	  /**
	   * The controller will limit the current through the motor to the `currentLimit` value.
	   * @throws {@link PhidgetError}
	   */


	  get currentLimit() {
	    return this.getCurrentLimit();
	  }
	  /**
	   * The minimum value that `currentLimit` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minCurrentLimit() {
	    return this.getMinCurrentLimit();
	  }
	  /**
	   * The maximum value that `currentLimit` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxCurrentLimit() {
	    return this.getMaxCurrentLimit();
	  }
	  /**
	   * Depending on power supply voltage and motor coil inductance, current through the motor can change relatively slowly or extremely rapidly. A physically larger DC Motor will typically have a lower inductance, requiring a higher current regulator gain. A higher power supply voltage will result in motor current changing more rapidly, requiring a higher current regulator gain. If the current regulator gain is too small, spikes in current will occur, causing large variations in torque, and possibly damaging the motor controller. If the current regulator gain is too high, the current will jitter, causing the motor to sound 'rough', especially when changing directions.
	   *
	   * As a rule of thumb, we recommend setting this value as follows:
	   *
	   * CurrentRegulatorGain = CurrentLimit \* (Voltage / 12)
	   * @throws {@link PhidgetError}
	   */


	  get currentRegulatorGain() {
	    return this.getCurrentRegulatorGain();
	  }
	  /**
	   * The minimum value that `currentRegulatorGain` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minCurrentRegulatorGain() {
	    return this.getMinCurrentRegulatorGain();
	  }
	  /**
	   * The maximum value that `currentRegulatorGain` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxCurrentRegulatorGain() {
	    return this.getMaxCurrentRegulatorGain();
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `VelocityUpdate` / `BrakingStrengthChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   *
	   * *   Note: `BrakingStrengthChange` events will only fire if a change in braking has occurred.
	   * @throws {@link PhidgetError}
	   */


	  get dataInterval() {
	    return this.getDataInterval();
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataInterval() {
	    return this.getMinDataInterval();
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataInterval() {
	    return this.getMaxDataInterval();
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   */


	  get dataRate() {
	    return this.getDataRate();
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataRate() {
	    return this.getMinDataRate();
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataRate() {
	    return this.getMaxDataRate();
	  }
	  /**
	   * The minimum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @throws {@link PhidgetError}
	   */


	  get minFailsafeTime() {
	    return this.getMinFailsafeTime();
	  }
	  /**
	   * The maximum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @throws {@link PhidgetError}
	   */


	  get maxFailsafeTime() {
	    return this.getMaxFailsafeTime();
	  }
	  /**
	   * The `fanMode` dictates the operating condition of the fan.
	   *
	   * *   Choose between on, off, or automatic (based on temperature).
	   * *   If the `fanMode` is set to automatic, the fan will turn on when the temperature reaches 70Â°C and it will remain on until the temperature falls below 55Â°C.
	   * *   If the `fanMode` is off, the controller will still turn on the fan if the temperature reaches 85Â°C and it will remain on until it falls below 70Â°C.
	   * @throws {@link PhidgetError}
	   */


	  get fanMode() {
	    return this.getFanMode();
	  }
	  /**
	   * This setting allows you to choose how hard the motor will resist being turned when it is not being driven forward or reverse (`velocity` = 0). The `targetBrakingStrength` sets the relative amount of electrical braking to be applied to the DC motor, with `minBrakingStrength` corresponding to no braking (free-wheeling), and `maxBrakingStrength` indicating full braking.
	   *
	   * *   A low `targetBrakingStrength` value corresponds to free-wheeling. This means:
	   *     *   The motor will continue to rotate after the controller is no longer driving the motor (`velocity` = 0), due to its momentum.
	   *     *   The motor shaft will provide little resistance to being turned when it is stopped.
	   * *   As `targetBrakingStrength` increases, this will engage electrical braking of the DC motor. This means:
	   *     *   The motor will stop more quickly if it is in motion when braking is requested.
	   *     *   The motor shaft will resist rotation by oustide forces.
	   * *   Braking will be added gradually, according to the `acceleration` setting, once the motor controller's `velocity` reaches 0.0
	   * *   Braking will be immediately stopped when a new (non-zero) `targetVelocity` is set, and the motor will accelerate to the requested velocity.
	   * *   Braking mode is enabled by setting the `velocity` to 0.0
	   * @throws {@link PhidgetError}
	   */


	  get targetBrakingStrength() {
	    return this.getTargetBrakingStrength();
	  }
	  /**
	   * The average voltage across the motor is based on the `targetVelocity` value.
	   *
	   * *   At a constant load, increasing the target velocity will increase the speed of the motor.
	   * *   `targetVelocity` is bounded by -`maxVelocity` and +`maxVelocity`, where a sign change (Â±) is indicitave of a direction change.
	   * *   Setting `targetVelocity` to `minVelocity` will stop the motor. See `targetBrakingStrength` for more information on stopping the motor.
	   * *   The units of `targetVelocity` and `acceleration` refer to 'duty cycle'. This is because the controller controls velocity by rapidly switching the power on/off (i.e. changing the duty cycle) in order to manipulate the voltage across the motor.
	   * @throws {@link PhidgetError}
	   */


	  get targetVelocity() {
	    return this.getTargetVelocity();
	  }
	  /**
	   * The most recent velocity value that the controller has reported.
	   * @throws {@link PhidgetError}
	   */


	  get velocity() {
	    return this.getVelocity();
	  }
	  /**
	   * The minimum value that `targetVelocity` can be set to.
	   *
	   * *   Set the `targetVelocity` to `minVelocity` to stop the motor. See `targetBrakingStrength` for more information on stopping the motor.
	   * *   `targetVelocity` is bounded by -`maxVelocity` and +`maxVelocity`, where a sign change (Â±) is indicitave of a direction change.
	   * @throws {@link PhidgetError}
	   */


	  get minVelocity() {
	    return this.getMinVelocity();
	  }
	  /**
	   * The maximum value that `targetVelocity` can be set to.
	   *
	   * *   `targetVelocity` is bounded by -`maxVelocity` and +`maxVelocity`, where a sign change (Â±) is indicitave of a direction change.
	   * @throws {@link PhidgetError}
	   */


	  get maxVelocity() {
	    return this.getMaxVelocity();
	  }
	  /**
	   * The rate at which the controller can change the motor's `velocity`.
	   *
	   * *   The acceleration is bounded by `minAcceleration` and `maxAcceleration`
	   * @returns The acceleration value
	   * @throws {@link PhidgetError}
	   */


	  getAcceleration() {
	    this._assertOpen();

	    if (this.data.acceleration === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.acceleration;
	  }
	  /**
	   * The rate at which the controller can change the motor's `velocity`.
	   *
	   * *   The acceleration is bounded by `minAcceleration` and `maxAcceleration`
	   * @throws {@link PhidgetError}
	   * @param acceleration - The acceleration value
	   */


	  async setAcceleration(acceleration) {
	    this._assertOpen();

	    if (acceleration < this.data.minAcceleration || acceleration > this.data.maxAcceleration) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minAcceleration + " - " + this.data.maxAcceleration + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: acceleration
	    });
	    await bp.send(this._ch, 40);
	  }
	  /**
	   * The minimum value that `acceleration` can be set to.
	   * @returns The acceleration value.
	   * @throws {@link PhidgetError}
	   */


	  getMinAcceleration() {
	    this._assertOpen();

	    if (this.data.minAcceleration === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minAcceleration;
	  }
	  /**
	   * The maximum value that `acceleration` can be set to.
	   * @returns The acceleration value.
	   * @throws {@link PhidgetError}
	   */


	  getMaxAcceleration() {
	    this._assertOpen();

	    if (this.data.maxAcceleration === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxAcceleration;
	  }
	  /**
	   * The most recent `backEMF` value that the controller has reported.
	   * @returns The back EMF value
	   * @throws {@link PhidgetError}
	   */


	  getBackEMF() {
	    this._assertOpen();

	    if (this.data.backEMF === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.backEMF;
	  }
	  /**
	   * When `backEMFSensingState` is enabled, the controller will measure and report the `backEMF`.
	   *
	   * *   The motor will coast (freewheel) 5% of the time while the back EMF is being measured (800Î¼s every 16ms). Therefore, at a `velocity` of 100%, the motor will only be driven for 95% of the time.
	   * @returns The back EMF state
	   * @throws {@link PhidgetError}
	   */


	  getBackEMFSensingState() {
	    this._assertOpen();

	    if (this.data.backEMFSensingState === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.backEMFSensingState;
	  }
	  /**
	   * When `backEMFSensingState` is enabled, the controller will measure and report the `backEMF`.
	   *
	   * *   The motor will coast (freewheel) 5% of the time while the back EMF is being measured (800Î¼s every 16ms). Therefore, at a `velocity` of 100%, the motor will only be driven for 95% of the time.
	   * @throws {@link PhidgetError}
	   * @param backEMFSensingState - The back EMF state
	   */


	  async setBackEMFSensingState(backEMFSensingState) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (backEMFSensingState !== false && backEMFSensingState !== true) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be a boolean.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: backEMFSensingState ? 1 : 0
	    });
	    await bp.send(this._ch, 42);
	  }
	  /**
	   * The most recent braking strength value that the controller has reported. See `targetBrakingStrength` for details.
	   * @returns The braking strength value
	   * @throws {@link PhidgetError}
	   */


	  getBrakingStrength() {
	    this._assertOpen();

	    if (this.data.brakingStrength === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.brakingStrength;
	  }
	  /**
	   * The minimum value that `targetBrakingStrength` can be set to. See `targetBrakingStrength` for details.
	   * @returns The braking strength value
	   * @throws {@link PhidgetError}
	   */


	  getMinBrakingStrength() {
	    this._assertOpen();

	    if (this.data.minBrakingStrength === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minBrakingStrength;
	  }
	  /**
	   * The maximum value that `targetBrakingStrength` can be set to. See `targetBrakingStrength` for details.
	   * @returns The braking strength value
	   * @throws {@link PhidgetError}
	   */


	  getMaxBrakingStrength() {
	    this._assertOpen();

	    if (this.data.maxBrakingStrength === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxBrakingStrength;
	  }
	  /**
	   * The controller will limit the current through the motor to the `currentLimit` value.
	   * @returns The current value
	   * @throws {@link PhidgetError}
	   */


	  getCurrentLimit() {
	    this._assertOpen();

	    if (this.data.currentLimit === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.currentLimit;
	  }
	  /**
	   * The controller will limit the current through the motor to the `currentLimit` value.
	   * @throws {@link PhidgetError}
	   * @param currentLimit - The current value
	   */


	  async setCurrentLimit(currentLimit) {
	    this._assertOpen();

	    if (currentLimit < this.data.minCurrentLimit || currentLimit > this.data.maxCurrentLimit) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minCurrentLimit + " - " + this.data.maxCurrentLimit + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: currentLimit
	    });
	    await bp.send(this._ch, 51);
	  }
	  /**
	   * The minimum value that `currentLimit` can be set to.
	   * @returns The current value
	   * @throws {@link PhidgetError}
	   */


	  getMinCurrentLimit() {
	    this._assertOpen();

	    if (this.data.minCurrentLimit === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minCurrentLimit;
	  }
	  /**
	   * The maximum value that `currentLimit` can be set to.
	   * @returns The current value
	   * @throws {@link PhidgetError}
	   */


	  getMaxCurrentLimit() {
	    this._assertOpen();

	    if (this.data.maxCurrentLimit === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxCurrentLimit;
	  }
	  /**
	   * Depending on power supply voltage and motor coil inductance, current through the motor can change relatively slowly or extremely rapidly. A physically larger DC Motor will typically have a lower inductance, requiring a higher current regulator gain. A higher power supply voltage will result in motor current changing more rapidly, requiring a higher current regulator gain. If the current regulator gain is too small, spikes in current will occur, causing large variations in torque, and possibly damaging the motor controller. If the current regulator gain is too high, the current will jitter, causing the motor to sound 'rough', especially when changing directions.
	   *
	   * As a rule of thumb, we recommend setting this value as follows:
	   *
	   * CurrentRegulatorGain = CurrentLimit \* (Voltage / 12)
	   * @returns The current regulator gain value
	   * @throws {@link PhidgetError}
	   */


	  getCurrentRegulatorGain() {
	    this._assertOpen();

	    if (this.data.currentRegulatorGain === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.currentRegulatorGain;
	  }
	  /**
	   * Depending on power supply voltage and motor coil inductance, current through the motor can change relatively slowly or extremely rapidly. A physically larger DC Motor will typically have a lower inductance, requiring a higher current regulator gain. A higher power supply voltage will result in motor current changing more rapidly, requiring a higher current regulator gain. If the current regulator gain is too small, spikes in current will occur, causing large variations in torque, and possibly damaging the motor controller. If the current regulator gain is too high, the current will jitter, causing the motor to sound 'rough', especially when changing directions.
	   *
	   * As a rule of thumb, we recommend setting this value as follows:
	   *
	   * CurrentRegulatorGain = CurrentLimit \* (Voltage / 12)
	   * @throws {@link PhidgetError}
	   * @param currentRegulatorGain - The current regulator gain value
	   */


	  async setCurrentRegulatorGain(currentRegulatorGain) {
	    this._assertOpen();

	    if (currentRegulatorGain < this.data.minCurrentRegulatorGain || currentRegulatorGain > this.data.maxCurrentRegulatorGain) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minCurrentRegulatorGain + " - " + this.data.maxCurrentRegulatorGain + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: currentRegulatorGain
	    });
	    await bp.send(this._ch, 119);
	  }
	  /**
	   * The minimum value that `currentRegulatorGain` can be set to.
	   * @returns The current regulator gain value
	   * @throws {@link PhidgetError}
	   */


	  getMinCurrentRegulatorGain() {
	    this._assertOpen();

	    if (this.data.minCurrentRegulatorGain === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minCurrentRegulatorGain;
	  }
	  /**
	   * The maximum value that `currentRegulatorGain` can be set to.
	   * @returns The current regulator gain value
	   * @throws {@link PhidgetError}
	   */


	  getMaxCurrentRegulatorGain() {
	    this._assertOpen();

	    if (this.data.maxCurrentRegulatorGain === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxCurrentRegulatorGain;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `VelocityUpdate` / `BrakingStrengthChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   *
	   * *   Note: `BrakingStrengthChange` events will only fire if a change in braking has occurred.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getDataInterval() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dataInterval;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `VelocityUpdate` / `BrakingStrengthChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   *
	   * *   Note: `BrakingStrengthChange` events will only fire if a change in braking has occurred.
	   * @throws {@link PhidgetError}
	   * @param dataInterval - The data interval value
	   */


	  async setDataInterval(dataInterval) {
	    this._assertOpen();

	    if (dataInterval < this.data.minDataInterval || dataInterval > this.data.maxDataInterval) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataInterval + " - " + this.data.maxDataInterval + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: dataInterval
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataInterval() {
	    this._assertOpen();

	    if (this.data.minDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataInterval;
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataInterval() {
	    this._assertOpen();

	    if (this.data.maxDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @returns The data rate for the channel
	   * @throws {@link PhidgetError}
	   */


	  getDataRate() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return 1000.0 / this.data.dataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   * @param dataRate - The data rate for the channel
	   */


	  async setDataRate(dataRate) {
	    this._assertOpen();

	    if (dataRate < this.data.minDataRate || dataRate > this.data.maxDataRate) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataRate + " - " + this.data.maxDataRate + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: Math.round(1000.0 / dataRate)
	    });
	    bp.set({
	      name: "1",
	      type: "g",
	      value: 1000.0 / dataRate
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataRate() {
	    this._assertOpen();

	    if (this.data.minDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataRate;
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataRate() {
	    this._assertOpen();

	    if (this.data.maxDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataRate;
	  }
	  /**
	   * Enables the **failsafe** feature for the channel, with a given **failsafe time**.
	   *
	   * The **failsafe** feature is intended for use in applications where it is important for the channel to enter a known _safe state_ if the program controlling it locks up or crashes. If you do not enable the failsafe feature, the channel will carry out whatever instructions it was last given until it is explicitly told to stop.
	   *
	   * Enabling the failsafe feature starts a recurring **failsafe timer** for the channel. Once the failsafe timer is enabled, it must be reset within the specified time or the channel will enter a **failsafe state**. The failsafe timer may be reset by sending any valid command to the device\*. Resetting the failsafe timer will reload the timer with the specified _failsafe time_, starting when the message to reset the timer is received by the Phidget.
	   *
	   * _\*(**get** requests do not typically send commands and won't reset the failsafe timer)_
	   *
	   * For example: if the failsafe is enabled with a **failsafe time** of 1000ms, you will have 1000ms to reset the failsafe timer. Every time the failsafe timer is reset, you will have 1000ms from that time to reset the failsafe again.
	   *
	   * If the failsafe timer is not reset before it runs out, the channel will enter a **failsafe state**. For DC Motor channels, this will disengage the motor. Once the channel enters the **failsafe state**, it will reject any further input until the channel is reopened.
	   *
	   * To prevent the channel from falsely entering the failsafe state, we recommend resetting the failsafe timer as frequently as is practical for your application. A good rule of thumb is to not let more than a third of the failsafe time pass before resetting the timer.
	   *
	   * Once the failsafe timer has been set, it cannot be disabled by any means other than closing and reopening the channel.
	   * @throws {@link PhidgetError}
	   * @param failsafeTime - Failsafe timeout in milliseconds
	   */


	  async enableFailsafe(failsafeTime) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: failsafeTime
	    });
	    await bp.send(this._ch, 146);
	  }
	  /**
	   * The minimum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @returns The failsafe time
	   * @throws {@link PhidgetError}
	   */


	  getMinFailsafeTime() {
	    this._assertOpen();

	    if (this.data.minFailsafeTime === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minFailsafeTime;
	  }
	  /**
	   * The maximum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @returns The failsafe time
	   * @throws {@link PhidgetError}
	   */


	  getMaxFailsafeTime() {
	    this._assertOpen();

	    if (this.data.maxFailsafeTime === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxFailsafeTime;
	  }
	  /**
	   * The `fanMode` dictates the operating condition of the fan.
	   *
	   * *   Choose between on, off, or automatic (based on temperature).
	   * *   If the `fanMode` is set to automatic, the fan will turn on when the temperature reaches 70Â°C and it will remain on until the temperature falls below 55Â°C.
	   * *   If the `fanMode` is off, the controller will still turn on the fan if the temperature reaches 85Â°C and it will remain on until it falls below 70Â°C.
	   * @returns The fan mode
	   * @throws {@link PhidgetError}
	   */


	  getFanMode() {
	    this._assertOpen();

	    if (this.data.fanMode === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.fanMode;
	  }
	  /**
	   * The `fanMode` dictates the operating condition of the fan.
	   *
	   * *   Choose between on, off, or automatic (based on temperature).
	   * *   If the `fanMode` is set to automatic, the fan will turn on when the temperature reaches 70Â°C and it will remain on until the temperature falls below 55Â°C.
	   * *   If the `fanMode` is off, the controller will still turn on the fan if the temperature reaches 85Â°C and it will remain on until it falls below 70Â°C.
	   * @throws {@link PhidgetError}
	   * @param fanMode - The fan mode
	   */


	  async setFanMode(fanMode) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedFanMode(this._ch, fanMode)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified FanMode is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: fanMode
	    });
	    await bp.send(this._ch, 58);
	  }
	  /**
	   * Resets the failsafe timer, if one has been set. See `enableFailsafe()` for details.
	   *
	   * This function will fail if no failsafe timer has been set for the channel.
	   * @throws {@link PhidgetError}
	   */


	  async resetFailsafe() {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    await bp.send(this._ch, 147);
	  }
	  /**
	   * This setting allows you to choose how hard the motor will resist being turned when it is not being driven forward or reverse (`velocity` = 0). The `targetBrakingStrength` sets the relative amount of electrical braking to be applied to the DC motor, with `minBrakingStrength` corresponding to no braking (free-wheeling), and `maxBrakingStrength` indicating full braking.
	   *
	   * *   A low `targetBrakingStrength` value corresponds to free-wheeling. This means:
	   *     *   The motor will continue to rotate after the controller is no longer driving the motor (`velocity` = 0), due to its momentum.
	   *     *   The motor shaft will provide little resistance to being turned when it is stopped.
	   * *   As `targetBrakingStrength` increases, this will engage electrical braking of the DC motor. This means:
	   *     *   The motor will stop more quickly if it is in motion when braking is requested.
	   *     *   The motor shaft will resist rotation by oustide forces.
	   * *   Braking will be added gradually, according to the `acceleration` setting, once the motor controller's `velocity` reaches 0.0
	   * *   Braking will be immediately stopped when a new (non-zero) `targetVelocity` is set, and the motor will accelerate to the requested velocity.
	   * *   Braking mode is enabled by setting the `velocity` to 0.0
	   * @returns The braking strength value
	   * @throws {@link PhidgetError}
	   */


	  getTargetBrakingStrength() {
	    this._assertOpen();

	    if (this.data.targetBrakingStrength === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.targetBrakingStrength;
	  }
	  /**
	   * This setting allows you to choose how hard the motor will resist being turned when it is not being driven forward or reverse (`velocity` = 0). The `targetBrakingStrength` sets the relative amount of electrical braking to be applied to the DC motor, with `minBrakingStrength` corresponding to no braking (free-wheeling), and `maxBrakingStrength` indicating full braking.
	   *
	   * *   A low `targetBrakingStrength` value corresponds to free-wheeling. This means:
	   *     *   The motor will continue to rotate after the controller is no longer driving the motor (`velocity` = 0), due to its momentum.
	   *     *   The motor shaft will provide little resistance to being turned when it is stopped.
	   * *   As `targetBrakingStrength` increases, this will engage electrical braking of the DC motor. This means:
	   *     *   The motor will stop more quickly if it is in motion when braking is requested.
	   *     *   The motor shaft will resist rotation by oustide forces.
	   * *   Braking will be added gradually, according to the `acceleration` setting, once the motor controller's `velocity` reaches 0.0
	   * *   Braking will be immediately stopped when a new (non-zero) `targetVelocity` is set, and the motor will accelerate to the requested velocity.
	   * *   Braking mode is enabled by setting the `velocity` to 0.0
	   * @throws {@link PhidgetError}
	   * @param targetBrakingStrength - The braking strength value
	   */


	  async setTargetBrakingStrength(targetBrakingStrength) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: targetBrakingStrength
	    });
	    await bp.send(this._ch, 44);
	  }
	  /**
	   * The average voltage across the motor is based on the `targetVelocity` value.
	   *
	   * *   At a constant load, increasing the target velocity will increase the speed of the motor.
	   * *   `targetVelocity` is bounded by -`maxVelocity` and +`maxVelocity`, where a sign change (Â±) is indicitave of a direction change.
	   * *   Setting `targetVelocity` to `minVelocity` will stop the motor. See `targetBrakingStrength` for more information on stopping the motor.
	   * *   The units of `targetVelocity` and `acceleration` refer to 'duty cycle'. This is because the controller controls velocity by rapidly switching the power on/off (i.e. changing the duty cycle) in order to manipulate the voltage across the motor.
	   * @returns The velocity value
	   * @throws {@link PhidgetError}
	   */


	  getTargetVelocity() {
	    this._assertOpen();

	    if (this.data.targetVelocity === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.targetVelocity;
	  }
	  /**
	   * The average voltage across the motor is based on the `targetVelocity` value.
	   *
	   * *   At a constant load, increasing the target velocity will increase the speed of the motor.
	   * *   `targetVelocity` is bounded by -`maxVelocity` and +`maxVelocity`, where a sign change (Â±) is indicitave of a direction change.
	   * *   Setting `targetVelocity` to `minVelocity` will stop the motor. See `targetBrakingStrength` for more information on stopping the motor.
	   * *   The units of `targetVelocity` and `acceleration` refer to 'duty cycle'. This is because the controller controls velocity by rapidly switching the power on/off (i.e. changing the duty cycle) in order to manipulate the voltage across the motor.
	   * @throws {@link PhidgetError}
	   * @param targetVelocity - The velocity value
	   */


	  async setTargetVelocity(targetVelocity) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: targetVelocity
	    });
	    await bp.send(this._ch, 55);
	  }
	  /**
	   * The most recent velocity value that the controller has reported.
	   * @returns The velocity value
	   * @throws {@link PhidgetError}
	   */


	  getVelocity() {
	    this._assertOpen();

	    if (this.data.velocity === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.velocity;
	  }
	  /**
	   * The minimum value that `targetVelocity` can be set to.
	   *
	   * *   Set the `targetVelocity` to `minVelocity` to stop the motor. See `targetBrakingStrength` for more information on stopping the motor.
	   * *   `targetVelocity` is bounded by -`maxVelocity` and +`maxVelocity`, where a sign change (Â±) is indicitave of a direction change.
	   * @returns The velocity value
	   * @throws {@link PhidgetError}
	   */


	  getMinVelocity() {
	    this._assertOpen();

	    if (this.data.minVelocity === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minVelocity;
	  }
	  /**
	   * The maximum value that `targetVelocity` can be set to.
	   *
	   * *   `targetVelocity` is bounded by -`maxVelocity` and +`maxVelocity`, where a sign change (Â±) is indicitave of a direction change.
	   * @returns The velocity value
	   * @throws {@link PhidgetError}
	   */


	  getMaxVelocity() {
	    this._assertOpen();

	    if (this.data.maxVelocity === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxVelocity;
	  }

	}

	/** @public */

	class DCMotor extends DCMotorBase {}

	class CurrentInputBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onCurrentChange = null;
	    this._class = exports.ChannelClass.CURRENT_INPUT;
	    this.name = "CurrentInput";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 46:
	        this.data.currentChangeTrigger = bp.entries[0].v;

	        this._FIREPropertyChange('CurrentChangeTrigger', bp);

	        break;

	      case 54:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.entries[1].v;else this.data.dataInterval = bp.entries[0].v;

	        this._FIREPropertyChange('DataInterval', bp);

	        this._FIREPropertyChange('DataRate', bp);

	        break;

	      case 74:
	        this.data.powerSupply = bp.entries[0].v;

	        this._FIREPropertyChange('PowerSupply', bp);

	        break;

	      case 8:
	        {
	          this.data.current = bp.entries[0].v;

	          if (this._isAttachedDone && this.onCurrentChange) {
	            try {
	              this.onCurrentChange(this.data.current);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      dataInterval: 1e+300,
	      minDataInterval: 4294967295,
	      maxDataInterval: 4294967295,
	      minDataRate: 1e+300,
	      maxDataRate: 1e+300,
	      maxCurrent: 1e+300,
	      maxCurrentChangeTrigger: 1e+300,
	      minCurrent: 1e+300,
	      minCurrentChangeTrigger: 1e+300,
	      current: 1e+300,
	      currentChangeTrigger: 1e+300,
	      powerSupply: 2147483647
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 233:
	      case 237:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 20;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 50;
	        this.data.maxCurrent = 0.02;
	        this.data.maxCurrentChangeTrigger = 0.016;
	        this.data.minCurrent = 0.0005;
	        this.data.minCurrentChangeTrigger = 0;
	        this.data.currentChangeTrigger = 0;
	        this.data.powerSupply = exports.PowerSupply.VOLTS_12;
	        break;

	      case 241:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 20;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 50;
	        this.data.maxCurrent = 30;
	        this.data.maxCurrentChangeTrigger = 60;
	        this.data.minCurrent = -30;
	        this.data.minCurrentChangeTrigger = 0;
	        this.data.currentChangeTrigger = 0;
	        break;

	      case 246:
	      case 251:
	      case 257:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 100;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.maxCurrent = 25;
	        this.data.maxCurrentChangeTrigger = 25;
	        this.data.minCurrent = 0;
	        this.data.minCurrentChangeTrigger = 0;
	        this.data.currentChangeTrigger = 0;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    let bp;

	    switch (this._ch.chDef.uid) {
	      case 233:
	      case 237:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.currentChangeTrigger
	        });
	        await bp.send(this._ch, 46);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.powerSupply
	        });
	        await bp.send(this._ch, 74);
	        break;

	      case 241:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.currentChangeTrigger
	        });
	        await bp.send(this._ch, 46);
	        break;

	      case 246:
	      case 251:
	      case 257:
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    if (this.data.current == 1e+300 && !this._gotCurrentChangeErrorEvent) return false;
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {
	    if (this.data.current != 1e+300) if (this.onCurrentChange) try {
	      this.onCurrentChange(this.data.current);
	    } catch (err) {
	      logEventException(err);
	    }
	  }
	  /**
	   * The most recent current value that the channel has reported.
	   *
	   * *   This value will always be between `minCurrent` and `maxCurrent`.
	   * @throws {@link PhidgetError}
	   */


	  get current() {
	    return this.getCurrent();
	  }
	  /**
	   * The minimum value the `CurrentChange` event will report.
	   * @throws {@link PhidgetError}
	   */


	  get minCurrent() {
	    return this.getMinCurrent();
	  }
	  /**
	   * The maximum value the `CurrentChange` event will report.
	   * @throws {@link PhidgetError}
	   */


	  get maxCurrent() {
	    return this.getMaxCurrent();
	  }
	  /**
	   * The channel will not issue a `CurrentChange` event until the current value has changed by the amount specified by the `currentChangeTrigger`.
	   *
	   * *   Setting the `currentChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   */


	  get currentChangeTrigger() {
	    return this.getCurrentChangeTrigger();
	  }
	  /**
	   * The minimum value that `currentChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minCurrentChangeTrigger() {
	    return this.getMinCurrentChangeTrigger();
	  }
	  /**
	   * The maximum value that `currentChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxCurrentChangeTrigger() {
	    return this.getMaxCurrentChangeTrigger();
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `CurrentChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `CurrentChange` events can also be affected by the `currentChangeTrigger`.
	   * @throws {@link PhidgetError}
	   */


	  get dataInterval() {
	    return this.getDataInterval();
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataInterval() {
	    return this.getMinDataInterval();
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataInterval() {
	    return this.getMaxDataInterval();
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   */


	  get dataRate() {
	    return this.getDataRate();
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataRate() {
	    return this.getMinDataRate();
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataRate() {
	    return this.getMaxDataRate();
	  }
	  /**
	   * Choose the power supply voltage.
	   *
	   * *   Set this to the voltage specified in the attached sensor's data sheet to power it.
	   *
	   * *   Set to `phidget22.PowerSupply.OFF` to turn off the supply to save power.
	   * @throws {@link PhidgetError}
	   */


	  get powerSupply() {
	    return this.getPowerSupply();
	  }
	  /**
	   * The most recent current value that the channel has reported.
	   *
	   * *   This value will always be between `minCurrent` and `maxCurrent`.
	   * @returns The current value
	   * @throws {@link PhidgetError}
	   */


	  getCurrent() {
	    this._assertOpen();

	    if (this.data.current === 1e+300 || Number.isNaN(this.data.current)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    if (this.data.current > this.data.maxCurrent) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE_HIGH);
	    if (this.data.current < this.data.minCurrent) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE_LOW);
	    return this.data.current;
	  }
	  /**
	   * The minimum value the `CurrentChange` event will report.
	   * @returns The current value
	   * @throws {@link PhidgetError}
	   */


	  getMinCurrent() {
	    this._assertOpen();

	    if (this.data.minCurrent === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minCurrent;
	  }
	  /**
	   * The maximum value the `CurrentChange` event will report.
	   * @returns The current value
	   * @throws {@link PhidgetError}
	   */


	  getMaxCurrent() {
	    this._assertOpen();

	    if (this.data.maxCurrent === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxCurrent;
	  }
	  /**
	   * The channel will not issue a `CurrentChange` event until the current value has changed by the amount specified by the `currentChangeTrigger`.
	   *
	   * *   Setting the `currentChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getCurrentChangeTrigger() {
	    this._assertOpen();

	    if (this.data.currentChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.currentChangeTrigger;
	  }
	  /**
	   * The channel will not issue a `CurrentChange` event until the current value has changed by the amount specified by the `currentChangeTrigger`.
	   *
	   * *   Setting the `currentChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   * @param currentChangeTrigger - The change trigger value
	   */


	  async setCurrentChangeTrigger(currentChangeTrigger) {
	    this._assertOpen();

	    if (currentChangeTrigger < this.data.minCurrentChangeTrigger || currentChangeTrigger > this.data.maxCurrentChangeTrigger) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minCurrentChangeTrigger + " - " + this.data.maxCurrentChangeTrigger + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: currentChangeTrigger
	    });
	    await bp.send(this._ch, 46);
	  }
	  /**
	   * The minimum value that `currentChangeTrigger` can be set to.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMinCurrentChangeTrigger() {
	    this._assertOpen();

	    if (this.data.minCurrentChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minCurrentChangeTrigger;
	  }
	  /**
	   * The maximum value that `currentChangeTrigger` can be set to.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMaxCurrentChangeTrigger() {
	    this._assertOpen();

	    if (this.data.maxCurrentChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxCurrentChangeTrigger;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `CurrentChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `CurrentChange` events can also be affected by the `currentChangeTrigger`.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getDataInterval() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dataInterval;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `CurrentChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `CurrentChange` events can also be affected by the `currentChangeTrigger`.
	   * @throws {@link PhidgetError}
	   * @param dataInterval - The data interval value
	   */


	  async setDataInterval(dataInterval) {
	    this._assertOpen();

	    if (dataInterval < this.data.minDataInterval || dataInterval > this.data.maxDataInterval) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataInterval + " - " + this.data.maxDataInterval + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: dataInterval
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataInterval() {
	    this._assertOpen();

	    if (this.data.minDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataInterval;
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataInterval() {
	    this._assertOpen();

	    if (this.data.maxDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @returns The data rate for the channel
	   * @throws {@link PhidgetError}
	   */


	  getDataRate() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return 1000.0 / this.data.dataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   * @param dataRate - The data rate for the channel
	   */


	  async setDataRate(dataRate) {
	    this._assertOpen();

	    if (dataRate < this.data.minDataRate || dataRate > this.data.maxDataRate) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataRate + " - " + this.data.maxDataRate + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: Math.round(1000.0 / dataRate)
	    });
	    bp.set({
	      name: "1",
	      type: "g",
	      value: 1000.0 / dataRate
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataRate() {
	    this._assertOpen();

	    if (this.data.minDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataRate;
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataRate() {
	    this._assertOpen();

	    if (this.data.maxDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataRate;
	  }
	  /**
	   * Choose the power supply voltage.
	   *
	   * *   Set this to the voltage specified in the attached sensor's data sheet to power it.
	   *
	   * *   Set to `phidget22.PowerSupply.OFF` to turn off the supply to save power.
	   * @returns The power supply value
	   * @throws {@link PhidgetError}
	   */


	  getPowerSupply() {
	    this._assertOpen();

	    if (this.data.powerSupply === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.powerSupply;
	  }
	  /**
	   * Choose the power supply voltage.
	   *
	   * *   Set this to the voltage specified in the attached sensor's data sheet to power it.
	   *
	   * *   Set to `phidget22.PowerSupply.OFF` to turn off the supply to save power.
	   * @throws {@link PhidgetError}
	   * @param powerSupply - The power supply value
	   */


	  async setPowerSupply(powerSupply) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedPowerSupply(this._ch, powerSupply)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified PowerSupply is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: powerSupply
	    });
	    await bp.send(this._ch, 74);
	  }

	}

	/** @public */

	class CurrentInput extends CurrentInputBase {
	  /** @internal */
	  _errorHandler(code) {
	    switch (code) {
	      case exports.ErrorEventCode.SATURATION:
	        this.data.current = 1e+300;
	        this._gotCurrentChangeErrorEvent = true;
	        break;
	    }
	  }

	}

	class StepperBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onPositionChange = null;
	    this.onVelocityChange = null;
	    this.onStopped = null;
	    this._class = exports.ChannelClass.STEPPER;
	    this.name = "Stepper";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 40:
	        this.data.acceleration = bp.entries[0].v;

	        this._FIREPropertyChange('Acceleration', bp);

	        break;

	      case 49:
	        this.data.controlMode = bp.entries[0].v;

	        this._FIREPropertyChange('ControlMode', bp);

	        break;

	      case 51:
	        this.data.currentLimit = bp.entries[0].v;

	        this._FIREPropertyChange('CurrentLimit', bp);

	        break;

	      case 54:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.entries[1].v;else this.data.dataInterval = bp.entries[0].v;

	        this._FIREPropertyChange('DataInterval', bp);

	        this._FIREPropertyChange('DataRate', bp);

	        break;

	      case 57:
	        this.data.engaged = bp.entries[0].v;

	        this._FIREPropertyChange('Engaged', bp);

	        break;

	      case 146:
	        break;

	      case 63:
	        this.data.holdingCurrentLimit = bp.entries[0].v;

	        this._FIREPropertyChange('HoldingCurrentLimit', bp);

	        break;

	      case 147:
	        break;

	      case 83:
	        this.data.targetPosition = bp.entries[0].v;

	        this._FIREPropertyChange('TargetPosition', bp);

	        break;

	      case 85:
	        this.data.velocityLimit = bp.entries[0].v;

	        this._FIREPropertyChange('VelocityLimit', bp);

	        break;

	      case 91:
	        {
	          if (this._isAttachedDone && this.onStopped) {
	            try {
	              this.onStopped();
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      positionOffset: 0,
	      dataInterval: 1e+300,
	      minDataRate: 1e+300,
	      maxDataRate: 1e+300,
	      holdingCurrentLimit: 1e+300,
	      minDataInterval: 4294967295,
	      maxDataInterval: 4294967295,
	      maxPosition: 9223372036854776000,
	      maxVelocityLimit: 1e+300,
	      maxAcceleration: 1e+300,
	      maxCurrentLimit: 1e+300,
	      minPosition: 9223372036854776000,
	      minVelocityLimit: 1e+300,
	      minAcceleration: 1e+300,
	      minCurrentLimit: 1e+300,
	      controlMode: 2147483647,
	      position: 9223372036854776000,
	      targetPosition: 9223372036854776000,
	      velocityLimit: 1e+300,
	      velocity: 1e+300,
	      acceleration: 1e+300,
	      currentLimit: 1e+300,
	      isMoving: 2,
	      engaged: 2,
	      rescaleFactor: 1e+300,
	      maxFailsafeTime: 4294967295,
	      minFailsafeTime: 4294967295
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 367:
	      case 373:
	        this.data.dataInterval = 250;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.minDataInterval = 100;
	        this.data.maxDataInterval = 60000;
	        this.data.maxPosition = 1000000000000000;
	        this.data.maxVelocityLimit = 115000;
	        this.data.maxAcceleration = 10000000;
	        this.data.maxCurrentLimit = 4;
	        this.data.minPosition = -1000000000000000;
	        this.data.minVelocityLimit = 0;
	        this.data.minAcceleration = 2;
	        this.data.minCurrentLimit = 0;
	        this.data.controlMode = exports.StepperControlMode.STEP;
	        this.data.velocityLimit = 10000;
	        this.data.acceleration = 10000;
	        this.data.currentLimit = 1;
	        this.data.engaged = 0;
	        this.data.rescaleFactor = 1;
	        break;

	      case 368:
	      case 374:
	      case 375:
	        this.data.dataInterval = 250;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.minDataInterval = 100;
	        this.data.maxDataInterval = 60000;
	        this.data.maxPosition = 1000000000000000;
	        this.data.maxVelocityLimit = 115000;
	        this.data.maxAcceleration = 10000000;
	        this.data.maxCurrentLimit = 4;
	        this.data.minPosition = -1000000000000000;
	        this.data.minVelocityLimit = 0;
	        this.data.minAcceleration = 2;
	        this.data.minCurrentLimit = 0;
	        this.data.controlMode = exports.StepperControlMode.STEP;
	        this.data.velocityLimit = 10000;
	        this.data.acceleration = 10000;
	        this.data.currentLimit = 1;
	        this.data.engaged = 0;
	        this.data.rescaleFactor = 1;
	        this.data.maxFailsafeTime = 30000;
	        this.data.minFailsafeTime = 500;
	        break;

	      case 369:
	        this.data.dataInterval = 250;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.minDataInterval = 100;
	        this.data.maxDataInterval = 60000;
	        this.data.maxPosition = 1000000000000000;
	        this.data.maxVelocityLimit = 115000;
	        this.data.maxAcceleration = 10000000;
	        this.data.maxCurrentLimit = 2.5;
	        this.data.minPosition = -1000000000000000;
	        this.data.minVelocityLimit = 0;
	        this.data.minAcceleration = 2;
	        this.data.minCurrentLimit = 0;
	        this.data.controlMode = exports.StepperControlMode.STEP;
	        this.data.velocityLimit = 10000;
	        this.data.acceleration = 10000;
	        this.data.currentLimit = 1;
	        this.data.engaged = 0;
	        this.data.rescaleFactor = 1;
	        break;

	      case 370:
	        this.data.dataInterval = 250;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.minDataInterval = 100;
	        this.data.maxDataInterval = 60000;
	        this.data.maxPosition = 1000000000000000;
	        this.data.maxVelocityLimit = 115000;
	        this.data.maxAcceleration = 10000000;
	        this.data.maxCurrentLimit = 2.5;
	        this.data.minPosition = -1000000000000000;
	        this.data.minVelocityLimit = 0;
	        this.data.minAcceleration = 2;
	        this.data.minCurrentLimit = 0;
	        this.data.controlMode = exports.StepperControlMode.STEP;
	        this.data.velocityLimit = 10000;
	        this.data.acceleration = 10000;
	        this.data.currentLimit = 1;
	        this.data.engaged = 0;
	        this.data.rescaleFactor = 1;
	        this.data.maxFailsafeTime = 30000;
	        this.data.minFailsafeTime = 500;
	        break;

	      case 371:
	        this.data.dataInterval = 250;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.minDataInterval = 100;
	        this.data.maxDataInterval = 60000;
	        this.data.maxPosition = 1000000000000000;
	        this.data.maxVelocityLimit = 115000;
	        this.data.maxAcceleration = 10000000;
	        this.data.maxCurrentLimit = 8;
	        this.data.minPosition = -1000000000000000;
	        this.data.minVelocityLimit = 0;
	        this.data.minAcceleration = 2;
	        this.data.minCurrentLimit = 0;
	        this.data.controlMode = exports.StepperControlMode.STEP;
	        this.data.velocityLimit = 10000;
	        this.data.acceleration = 10000;
	        this.data.currentLimit = 1;
	        this.data.engaged = 0;
	        this.data.rescaleFactor = 1;
	        break;

	      case 372:
	        this.data.dataInterval = 250;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.minDataInterval = 100;
	        this.data.maxDataInterval = 60000;
	        this.data.maxPosition = 1000000000000000;
	        this.data.maxVelocityLimit = 115000;
	        this.data.maxAcceleration = 10000000;
	        this.data.maxCurrentLimit = 8;
	        this.data.minPosition = -1000000000000000;
	        this.data.minVelocityLimit = 0;
	        this.data.minAcceleration = 2;
	        this.data.minCurrentLimit = 0;
	        this.data.controlMode = exports.StepperControlMode.STEP;
	        this.data.velocityLimit = 10000;
	        this.data.acceleration = 10000;
	        this.data.currentLimit = 1;
	        this.data.engaged = 0;
	        this.data.rescaleFactor = 1;
	        this.data.maxFailsafeTime = 30000;
	        this.data.minFailsafeTime = 500;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    let bp;

	    switch (this._ch.chDef.uid) {
	      case 367:
	      case 368:
	      case 369:
	      case 370:
	      case 371:
	      case 372:
	      case 373:
	      case 374:
	      case 375:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.controlMode
	        });
	        await bp.send(this._ch, 49);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.velocityLimit
	        });
	        await bp.send(this._ch, 85);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.acceleration
	        });
	        await bp.send(this._ch, 40);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.currentLimit
	        });
	        await bp.send(this._ch, 51);
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {}
	  /**
	   * The rate at which the controller can change the motor's `velocity`.
	   *
	   * *   Units for `position`, `velocity`, and `acceleration` can be set by the user through the `rescaleFactor`.The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees.
	   * *   The default units for this motor controller are **1/16steps per count**.
	   * *   Changing the acceleration value while the stepper is in motion (especially at speeds higher than 1000 1/16th steps/s) can cause unpredictable results due to the inability of the processor tocalculate a new acceleration curve quickly enough. Generally you should wait until the motor is stationary until calling this function.
	   * @throws {@link PhidgetError}
	   */


	  get acceleration() {
	    return this.getAcceleration();
	  }
	  /**
	   * The minimum value that `acceleration` can be set to.
	   *
	   * *   Units for `position`, `velocity`, and `acceleration` can be set by the user through the `rescaleFactor`.The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees.
	   * *   The default units for this motor controller are **1/16steps per count**.
	   * @throws {@link PhidgetError}
	   */


	  get minAcceleration() {
	    return this.getMinAcceleration();
	  }
	  /**
	   * The maximum value that `acceleration` can be set to.
	   *
	   * *   Units for `position`, `velocity`, and `acceleration` can be set by the user through the `rescaleFactor`.The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees.
	   * *   The default units for this motor controller are **1/16steps per count**.
	   * @throws {@link PhidgetError}
	   */


	  get maxAcceleration() {
	    return this.getMaxAcceleration();
	  }
	  /**
	   * Use `phidget22.StepperControlMode.STEP` mode when you want to set a `targetPosition` for the Stepper motor. Use `phidget22.StepperControlMode.RUN` mode when you simply want the Stepper motor to rotate continuously in a specific direction.
	   *
	   * Changing the control mode while the motor is running will not have an effect on the motor's movements until a new `targetPosition` or `velocityLimit` is set.
	   *
	   * In `phidget22.StepperControlMode.RUN` mode, setting a `velocityLimit` will also set the target position of the controller to `minPosition` or `maxPosition`, corresponding to the direction of movement.
	   * @throws {@link PhidgetError}
	   */


	  get controlMode() {
	    return this.getControlMode();
	  }
	  /**
	   * The current through the motor will be limited by the `currentLimit`.
	   *
	   * *   See your Stepper motor's data sheet for more information about what value the `currentLimit` should be.
	   * @throws {@link PhidgetError}
	   */


	  get currentLimit() {
	    return this.getCurrentLimit();
	  }
	  /**
	   * The minimum value that `currentLimit` and `holdingCurrentLimit` can be set to.
	   *
	   * *   Reference your controller's User Guide for more information about how the `holdingCurrentLimit` and `currentLimit` can be used in your application.
	   * @throws {@link PhidgetError}
	   */


	  get minCurrentLimit() {
	    return this.getMinCurrentLimit();
	  }
	  /**
	   * The maximum value that `currentLimit` and `holdingCurrentLimit` can be set to.
	   *
	   * *   Reference your controller's User Guide for more information about how the `holdingCurrentLimit` and `currentLimit` can be used in your application.
	   * @throws {@link PhidgetError}
	   */


	  get maxCurrentLimit() {
	    return this.getMaxCurrentLimit();
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `PositionChange` / `VelocityChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * @throws {@link PhidgetError}
	   */


	  get dataInterval() {
	    return this.getDataInterval();
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataInterval() {
	    return this.getMinDataInterval();
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataInterval() {
	    return this.getMaxDataInterval();
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   */


	  get dataRate() {
	    return this.getDataRate();
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataRate() {
	    return this.getMinDataRate();
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataRate() {
	    return this.getMaxDataRate();
	  }
	  /**
	   * When this property is true, the controller will supply power to the motor coils.
	   *
	   * *   The controller must be `engaged` in order to move the Stepper motor, or have it hold position.
	   * @throws {@link PhidgetError}
	   */


	  get engaged() {
	    return this.getEngaged();
	  }
	  /**
	   * The minimum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @throws {@link PhidgetError}
	   */


	  get minFailsafeTime() {
	    return this.getMinFailsafeTime();
	  }
	  /**
	   * The maximum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @throws {@link PhidgetError}
	   */


	  get maxFailsafeTime() {
	    return this.getMaxFailsafeTime();
	  }
	  /**
	   * The `holdingCurrentLimit` will activate when the `targetPosition` has been reached. It will limit current through the motor.
	   *
	   * *   When the motor is not stopped, the current through the motor is limited by the `currentLimit`.
	   * *   If no `holdingCurrentLimit` is specified, the `currentLimit` value will persist when the motor is stopped.
	   * *   Reference your controller's User Guide for more information about how the `holdingCurrentLimit` and `currentLimit` can be used in your application.
	   * @throws {@link PhidgetError}
	   */


	  get holdingCurrentLimit() {
	    return this.getHoldingCurrentLimit();
	  }
	  /**
	   * `isMoving` returns true while the controller is sending commands to the motor. Note: there is no feedback to the controller, so it does not know whether the motor shaft is actually moving or not.
	   * @throws {@link PhidgetError}
	   */


	  get isMoving() {
	    return this.getIsMoving();
	  }
	  /**
	   * The most recent position value that the controller has reported.
	   *
	   * *   This value will always be between `minPosition` and `maxPosition`.
	   * *   Units for `position`, `velocity`, and `acceleration` can be set by the user through the `rescaleFactor`.The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees.
	   * *   The default units for this motor controller are **1/16steps per count**.
	   * @throws {@link PhidgetError}
	   */


	  get position() {
	    return this.getPosition();
	  }
	  /**
	   * The minimum value that `targetPosition` can be set to.
	   *
	   * *   Units for `position`, `velocity`, and `acceleration` can be set by the user through the `rescaleFactor`.The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees.
	   * *   The default units for this motor controller are **1/16steps per count**.
	   * @throws {@link PhidgetError}
	   */


	  get minPosition() {
	    return this.getMinPosition();
	  }
	  /**
	   * The maximum value that `targetPosition` can be set to.
	   *
	   * *   Units for `position`, `velocity`, and `acceleration` can be set by the user through the `rescaleFactor`.The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees.
	   * *   The default units for this motor controller are **1/16steps per count**.
	   * @throws {@link PhidgetError}
	   */


	  get maxPosition() {
	    return this.getMaxPosition();
	  }
	  /**
	   * Applies a factor to the \[user units\] per step to all movement parameters to make the units in your application is more intuitive.
	   *
	   * *   For example, starting from position 0 and setting a new position with a rescale factor, the stepper will move `position` / `rescaleFactor` steps.
	   * *   In this way, units for `position`, `velocity`, and `acceleration` can be set by the user through the `rescaleFactor`. The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees.
	   * *   The default units for this motor controller are **1/16steps per count**.
	   *
	   *
	   * RescaleFactor = (1/16) \* (MotorStepAngle/Degrees Per UserUnit)
	   * @throws {@link PhidgetError}
	   */


	  get rescaleFactor() {
	    return this.getRescaleFactor();
	  }

	  set rescaleFactor(rescaleFactor) {
	    this.setRescaleFactor(rescaleFactor);
	  }
	  /**
	   * If the controller is configured and the `targetPosition` is set, the Stepper motor will move towards the `targetPosition` at the specified `acceleration` and `velocity`.
	   *
	   * *   `targetPosition` is only used when the `controlMode` is set to step mode.
	   * *   Units for `position`, `velocity`, and `acceleration` can be set by the user through the `rescaleFactor`.The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees.
	   * *   The default units for this motor controller are **1/16steps per count**.
	   * @throws {@link PhidgetError}
	   */


	  get targetPosition() {
	    return this.getTargetPosition();
	  }
	  /**
	   * The most recent velocity value that the controller has reported.
	   *
	   * *   This value is bounded by `minVelocityLimit` and `maxVelocityLimit`.
	   * *   Units for `position`, `velocity`, and `acceleration` can be set by the user through the `rescaleFactor`.The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees.
	   * *   The default units for this motor controller are **1/16steps per count**.
	   * @throws {@link PhidgetError}
	   */


	  get velocity() {
	    return this.getVelocity();
	  }
	  /**
	   * When moving, the Stepper motor velocity will be limited by this value.
	   *
	   * *   The `velocityLimit` is bounded by `minVelocityLimit` and `maxVelocityLimit`.
	   * *   When in step mode, the `minVelocityLimit` has a value of 0. This is because the sign (Â±) of the `targetPosition` will indicate the direction.
	   * *   When in run mode, the `minVelocityLimit` has a value of -`maxVelocityLimit`. This is because there is no target position, so the direction is defined by the sign (Â±) of the `velocityLimit`.
	   * *   Units for `position`, `velocity`, and `acceleration` can be set by the user through the `rescaleFactor`.The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees.
	   * *   The default units for this motor controller are **1/16steps per count**.
	   * @throws {@link PhidgetError}
	   */


	  get velocityLimit() {
	    return this.getVelocityLimit();
	  }
	  /**
	   * The minimum value that `velocityLimit` can be set to.
	   *
	   * *   Units for `position`, `velocity`, and `acceleration` can be set by the user through the `rescaleFactor`.The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees.
	   * *   The default units for this motor controller are **1/16steps per count**.
	   * @throws {@link PhidgetError}
	   */


	  get minVelocityLimit() {
	    return this.getMinVelocityLimit();
	  }
	  /**
	   * The maximum value that `velocityLimit` can be set to.
	   *
	   * *   Units for `position`, `velocity`, and `acceleration` can be set by the user through the `rescaleFactor`.The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees.
	   * *   The default units for this motor controller are **1/16steps per count**.
	   * @throws {@link PhidgetError}
	   */


	  get maxVelocityLimit() {
	    return this.getMaxVelocityLimit();
	  }
	  /**
	   * Use `phidget22.StepperControlMode.STEP` mode when you want to set a `targetPosition` for the Stepper motor. Use `phidget22.StepperControlMode.RUN` mode when you simply want the Stepper motor to rotate continuously in a specific direction.
	   *
	   * Changing the control mode while the motor is running will not have an effect on the motor's movements until a new `targetPosition` or `velocityLimit` is set.
	   *
	   * In `phidget22.StepperControlMode.RUN` mode, setting a `velocityLimit` will also set the target position of the controller to `minPosition` or `maxPosition`, corresponding to the direction of movement.
	   * @returns The control mode value
	   * @throws {@link PhidgetError}
	   */


	  getControlMode() {
	    this._assertOpen();

	    if (this.data.controlMode === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.controlMode;
	  }
	  /**
	   * Use `phidget22.StepperControlMode.STEP` mode when you want to set a `targetPosition` for the Stepper motor. Use `phidget22.StepperControlMode.RUN` mode when you simply want the Stepper motor to rotate continuously in a specific direction.
	   *
	   * Changing the control mode while the motor is running will not have an effect on the motor's movements until a new `targetPosition` or `velocityLimit` is set.
	   *
	   * In `phidget22.StepperControlMode.RUN` mode, setting a `velocityLimit` will also set the target position of the controller to `minPosition` or `maxPosition`, corresponding to the direction of movement.
	   * @throws {@link PhidgetError}
	   * @param controlMode - The control mode value
	   */


	  async setControlMode(controlMode) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedStepperControlMode(this._ch, controlMode)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified StepperControlMode is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: controlMode
	    });
	    await bp.send(this._ch, 49);
	  }
	  /**
	   * The current through the motor will be limited by the `currentLimit`.
	   *
	   * *   See your Stepper motor's data sheet for more information about what value the `currentLimit` should be.
	   * @returns The current limit value
	   * @throws {@link PhidgetError}
	   */


	  getCurrentLimit() {
	    this._assertOpen();

	    if (this.data.currentLimit === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.currentLimit;
	  }
	  /**
	   * The current through the motor will be limited by the `currentLimit`.
	   *
	   * *   See your Stepper motor's data sheet for more information about what value the `currentLimit` should be.
	   * @throws {@link PhidgetError}
	   * @param currentLimit - The current limit value
	   */


	  async setCurrentLimit(currentLimit) {
	    this._assertOpen();

	    if (currentLimit < this.data.minCurrentLimit || currentLimit > this.data.maxCurrentLimit) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minCurrentLimit + " - " + this.data.maxCurrentLimit + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: currentLimit
	    });
	    await bp.send(this._ch, 51);
	  }
	  /**
	   * The minimum value that `currentLimit` and `holdingCurrentLimit` can be set to.
	   *
	   * *   Reference your controller's User Guide for more information about how the `holdingCurrentLimit` and `currentLimit` can be used in your application.
	   * @returns The current limit
	   * @throws {@link PhidgetError}
	   */


	  getMinCurrentLimit() {
	    this._assertOpen();

	    if (this.data.minCurrentLimit === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minCurrentLimit;
	  }
	  /**
	   * The maximum value that `currentLimit` and `holdingCurrentLimit` can be set to.
	   *
	   * *   Reference your controller's User Guide for more information about how the `holdingCurrentLimit` and `currentLimit` can be used in your application.
	   * @returns The current limit
	   * @throws {@link PhidgetError}
	   */


	  getMaxCurrentLimit() {
	    this._assertOpen();

	    if (this.data.maxCurrentLimit === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxCurrentLimit;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `PositionChange` / `VelocityChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getDataInterval() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dataInterval;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `PositionChange` / `VelocityChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * @throws {@link PhidgetError}
	   * @param dataInterval - The data interval value
	   */


	  async setDataInterval(dataInterval) {
	    this._assertOpen();

	    if (dataInterval < this.data.minDataInterval || dataInterval > this.data.maxDataInterval) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataInterval + " - " + this.data.maxDataInterval + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: dataInterval
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataInterval() {
	    this._assertOpen();

	    if (this.data.minDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataInterval;
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataInterval() {
	    this._assertOpen();

	    if (this.data.maxDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @returns The data rate for the channel
	   * @throws {@link PhidgetError}
	   */


	  getDataRate() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return 1000.0 / this.data.dataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   * @param dataRate - The data rate for the channel
	   */


	  async setDataRate(dataRate) {
	    this._assertOpen();

	    if (dataRate < this.data.minDataRate || dataRate > this.data.maxDataRate) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataRate + " - " + this.data.maxDataRate + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: Math.round(1000.0 / dataRate)
	    });
	    bp.set({
	      name: "1",
	      type: "g",
	      value: 1000.0 / dataRate
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataRate() {
	    this._assertOpen();

	    if (this.data.minDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataRate;
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataRate() {
	    this._assertOpen();

	    if (this.data.maxDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataRate;
	  }
	  /**
	   * When this property is true, the controller will supply power to the motor coils.
	   *
	   * *   The controller must be `engaged` in order to move the Stepper motor, or have it hold position.
	   * @returns The engaged state
	   * @throws {@link PhidgetError}
	   */


	  getEngaged() {
	    this._assertOpen();

	    if (this.data.engaged === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.engaged;
	  }
	  /**
	   * When this property is true, the controller will supply power to the motor coils.
	   *
	   * *   The controller must be `engaged` in order to move the Stepper motor, or have it hold position.
	   * @throws {@link PhidgetError}
	   * @param engaged - The engaged state
	   */


	  async setEngaged(engaged) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (engaged !== false && engaged !== true) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be a boolean.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: engaged ? 1 : 0
	    });
	    await bp.send(this._ch, 57);
	  }
	  /**
	   * Enables the **failsafe** feature for the channel, with a given **failsafe time**.
	   *
	   * The **failsafe** feature is intended for use in applications where it is important for the channel to enter a known _safe state_ if the program controlling it locks up or crashes. If you do not enable the failsafe feature, the channel will carry out whatever instructions it was last given until it is explicitly told to stop.
	   *
	   * Enabling the failsafe feature starts a recurring **failsafe timer** for the channel. Once the failsafe timer is enabled, it must be reset within the specified time or the channel will enter a **failsafe state**. The failsafe timer may be reset by sending any valid command to the device\*. Resetting the failsafe timer will reload the timer with the specified _failsafe time_, starting when the message to reset the timer is received by the Phidget.
	   *
	   * _\*(**get** requests do not typically send commands and won't reset the failsafe timer)_
	   *
	   * For example: if the failsafe is enabled with a **failsafe time** of 1000ms, you will have 1000ms to reset the failsafe timer. Every time the failsafe timer is reset, you will have 1000ms from that time to reset the failsafe again.
	   *
	   * If the failsafe timer is not reset before it runs out, the channel will enter a **failsafe state**. For Stepper Motor channels, this will disengage the motor. Once the channel enters the **failsafe state**, it will reject any further input until the channel is reopened.
	   *
	   * To prevent the channel from falsely entering the failsafe state, we recommend resetting the failsafe timer as frequently as is practical for your application. A good rule of thumb is to not let more than a third of the failsafe time pass before resetting the timer.
	   *
	   * Once the failsafe timer has been set, it cannot be disabled by any means other than closing and reopening the channel.
	   * @throws {@link PhidgetError}
	   * @param failsafeTime - Failsafe timeout in milliseconds
	   */


	  async enableFailsafe(failsafeTime) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: failsafeTime
	    });
	    await bp.send(this._ch, 146);
	  }
	  /**
	   * The minimum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @returns The failsafe time
	   * @throws {@link PhidgetError}
	   */


	  getMinFailsafeTime() {
	    this._assertOpen();

	    if (this.data.minFailsafeTime === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minFailsafeTime;
	  }
	  /**
	   * The maximum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @returns The failsafe time
	   * @throws {@link PhidgetError}
	   */


	  getMaxFailsafeTime() {
	    this._assertOpen();

	    if (this.data.maxFailsafeTime === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxFailsafeTime;
	  }
	  /**
	   * The `holdingCurrentLimit` will activate when the `targetPosition` has been reached. It will limit current through the motor.
	   *
	   * *   When the motor is not stopped, the current through the motor is limited by the `currentLimit`.
	   * *   If no `holdingCurrentLimit` is specified, the `currentLimit` value will persist when the motor is stopped.
	   * *   Reference your controller's User Guide for more information about how the `holdingCurrentLimit` and `currentLimit` can be used in your application.
	   * @returns The current value
	   * @throws {@link PhidgetError}
	   */


	  getHoldingCurrentLimit() {
	    this._assertOpen();

	    if (this.data.holdingCurrentLimit === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.holdingCurrentLimit;
	  }
	  /**
	   * The `holdingCurrentLimit` will activate when the `targetPosition` has been reached. It will limit current through the motor.
	   *
	   * *   When the motor is not stopped, the current through the motor is limited by the `currentLimit`.
	   * *   If no `holdingCurrentLimit` is specified, the `currentLimit` value will persist when the motor is stopped.
	   * *   Reference your controller's User Guide for more information about how the `holdingCurrentLimit` and `currentLimit` can be used in your application.
	   * @throws {@link PhidgetError}
	   * @param holdingCurrentLimit - The current value
	   */


	  async setHoldingCurrentLimit(holdingCurrentLimit) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: holdingCurrentLimit
	    });
	    await bp.send(this._ch, 63);
	  }
	  /**
	   * `isMoving` returns true while the controller is sending commands to the motor. Note: there is no feedback to the controller, so it does not know whether the motor shaft is actually moving or not.
	   * @returns The moving state
	   * @throws {@link PhidgetError}
	   */


	  getIsMoving() {
	    this._assertOpen();

	    if (this.data.isMoving === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.isMoving;
	  }
	  /**
	   * Applies a factor to the \[user units\] per step to all movement parameters to make the units in your application is more intuitive.
	   *
	   * *   For example, starting from position 0 and setting a new position with a rescale factor, the stepper will move `position` / `rescaleFactor` steps.
	   * *   In this way, units for `position`, `velocity`, and `acceleration` can be set by the user through the `rescaleFactor`. The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees.
	   * *   The default units for this motor controller are **1/16steps per count**.
	   *
	   *
	   * RescaleFactor = (1/16) \* (MotorStepAngle/Degrees Per UserUnit)
	   * @returns The rescale factor value
	   * @throws {@link PhidgetError}
	   */


	  getRescaleFactor() {
	    this._assertOpen();

	    if (this.data.rescaleFactor === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.rescaleFactor;
	  }
	  /**
	   * Resets the failsafe timer, if one has been set. See `enableFailsafe()` for details.
	   *
	   * This function will fail if no failsafe timer has been set for the channel.
	   * @throws {@link PhidgetError}
	   */


	  async resetFailsafe() {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    await bp.send(this._ch, 147);
	  }

	}

	/** @public */

	class Stepper extends StepperBase {
	  /** @internal */
	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 29:
	        this.data.position = bp.getNumber(0);

	        if (this._isAttachedDone && this.onPositionChange) {
	          try {
	            this.onPositionChange((this.data.position + this.data.positionOffset) * this.data.rescaleFactor);
	          } catch (err) {
	            logEventException(err);
	          }
	        }

	        break;

	      case 100:
	        this.data.velocity = bp.getNumber(0);

	        if (this._isAttachedDone && this.onVelocityChange) {
	          try {
	            this.onVelocityChange(this.data.velocity * this.data.rescaleFactor);
	          } catch (err) {
	            logEventException(err);
	          }
	        }

	        break;

	      case 49:
	        switch (bp.getNumber(0)) {
	          case exports.StepperControlMode.STEP:
	            this.data.minVelocityLimit = 0;
	            break;

	          case exports.StepperControlMode.RUN:
	            this.data.minVelocityLimit = -this.data.maxVelocityLimit;
	            break;
	        }

	        super._bridgeInput(bp);

	        break;

	      case 91:
	        this.data.isMoving = 0;

	        super._bridgeInput(bp);

	        break;

	      case 57:
	        if (bp.getBoolean(0) == true && this.data.velocityLimit !== 0 && this.data.position !== this.data.targetPosition) this.data.isMoving = 1;

	        super._bridgeInput(bp);

	        break;

	      case 85:
	        if (this.data.engaged && bp.getNumber(0) !== 0 && this.data.position !== this.data.targetPosition) this.data.isMoving = 1;

	        super._bridgeInput(bp);

	        break;

	      case 83:
	        if (this.data.engaged && this.data.velocityLimit !== 0 && this.data.position !== bp.getNumber(0)) this.data.isMoving = 1;

	        super._bridgeInput(bp);

	        break;

	      default:
	        super._bridgeInput(bp);

	        break;
	    }
	  }
	  /** @internal */


	  _initAfterOpen() {
	    super._initAfterOpen();

	    if (this.data.position == 9223372036854776000) this.data.position = 0;
	    if (this.data.velocity == 1e+300) this.data.velocity = 0;
	    if (this.data.isMoving == 2) this.data.isMoving = 0;
	  }

	  getAcceleration() {
	    this._assertOpen();

	    if (this.data.acceleration === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.acceleration * this.data.rescaleFactor;
	  }

	  async setAcceleration(acceleration) {
	    this._assertOpen();

	    const calcAccel = acceleration / this.data.rescaleFactor;
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: calcAccel
	    });
	    await bp.send(this._ch, 40);
	  }

	  getMinAcceleration() {
	    this._assertOpen();

	    if (this.data.minAcceleration === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minAcceleration * this.data.rescaleFactor;
	  }

	  getMaxAcceleration() {
	    this._assertOpen();

	    if (this.data.maxAcceleration === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxAcceleration * this.data.rescaleFactor;
	  }

	  getPosition() {
	    this._assertOpen();

	    if (this.data.position === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return (this.data.position + this.data.positionOffset) * this.data.rescaleFactor;
	  }

	  getMinPosition() {
	    this._assertOpen();

	    if (this.data.minPosition === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return (this.data.minPosition + this.data.positionOffset) * this.data.rescaleFactor;
	  }

	  getMaxPosition() {
	    this._assertOpen();

	    if (this.data.maxPosition === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return (this.data.maxPosition + this.data.positionOffset) * this.data.rescaleFactor;
	  }

	  setRescaleFactor(rescaleFactor) {
	    this._assertOpen();

	    this.data.rescaleFactor = rescaleFactor;
	  }

	  getTargetPosition() {
	    this._assertOpen();

	    if (this.data.targetPosition === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return (this.data.targetPosition + this.data.positionOffset) * this.data.rescaleFactor;
	  }

	  async setTargetPosition(targetPosition) {
	    this._assertOpen();

	    const calcPosition = targetPosition / this.data.rescaleFactor - this.data.positionOffset;
	    if (calcPosition < this.data.minPosition || calcPosition > this.data.maxPosition) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.minPosition + " - " + this.maxPosition + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "l",
	      value: calcPosition
	    });
	    await bp.send(this._ch, 83);
	  }

	  getVelocity() {
	    this._assertOpen();

	    if (this.data.velocity === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.velocity * this.data.rescaleFactor;
	  }

	  getVelocityLimit() {
	    this._assertOpen();

	    if (this.data.velocityLimit === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.velocityLimit * this.data.rescaleFactor;
	  }

	  async setVelocityLimit(velocityLimit) {
	    this._assertOpen();

	    const calcLimit = velocityLimit / this.data.rescaleFactor;
	    if (calcLimit < this.data.minVelocityLimit || calcLimit > this.data.maxVelocityLimit) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.minVelocityLimit + " - " + this.maxVelocityLimit + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: calcLimit
	    });
	    await bp.send(this._ch, 85);
	  }

	  getMaxVelocityLimit() {
	    this._assertOpen();

	    if (this.data.maxVelocityLimit === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxVelocityLimit * this.data.rescaleFactor;
	  }

	  getMinVelocityLimit() {
	    this._assertOpen();

	    if (this.data.minVelocityLimit === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minVelocityLimit * this.data.rescaleFactor;
	  }

	  addPositionOffset(positionOffset) {
	    this._assertOpen();

	    this.data.positionOffset += positionOffset / this.data.rescaleFactor;
	  }

	}

	class LCDBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this._class = exports.ChannelClass.LCD;
	    this.name = "LCD";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 43:
	        this.data.backlight = bp.entries[0].v;

	        this._FIREPropertyChange('Backlight', bp);

	        break;

	      case 47:
	        break;

	      case 4:
	        break;

	      case 48:
	        this.data.contrast = bp.entries[0].v;

	        this._FIREPropertyChange('Contrast', bp);

	        break;

	      case 6:
	        break;

	      case 52:
	        this.data.cursorBlink = bp.entries[0].v;

	        this._FIREPropertyChange('CursorBlink', bp);

	        break;

	      case 53:
	        this.data.cursorOn = bp.entries[0].v;

	        this._FIREPropertyChange('CursorOn', bp);

	        break;

	      case 13:
	        break;

	      case 14:
	        break;

	      case 15:
	        break;

	      case 19:
	        break;

	      case 62:
	        this.data.frameBuffer = bp.entries[0].v;

	        this._FIREPropertyChange('FrameBuffer', bp);

	        break;

	      case 24:
	        break;

	      case 38:
	        break;

	      case 78:
	        this.data.screenSize = bp.entries[0].v;

	        this._FIREPropertyChange('ScreenSize', bp);

	        break;

	      case 80:
	        this.data.sleeping = bp.entries[0].v;

	        this._FIREPropertyChange('Sleeping', bp);

	        break;

	      case 104:
	        break;

	      case 105:
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      fontWidth: [255, 255, 255],
	      fontHeight: [255, 255, 255],
	      backlight: 1e+300,
	      minBacklight: 1e+300,
	      maxBacklight: 1e+300,
	      contrast: 1e+300,
	      minContrast: 1e+300,
	      maxContrast: 1e+300,
	      cursorBlink: 2,
	      cursorOn: 2,
	      frameBuffer: 2147483647,
	      height: 2147483647,
	      width: 2147483647,
	      screenSize: 2147483647,
	      sleeping: 2,
	      autoFlush: 2
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 305:
	        this.data.backlight = 0;
	        this.data.minBacklight = 0;
	        this.data.maxBacklight = 1;
	        this.data.contrast = 0.25;
	        this.data.minContrast = 0;
	        this.data.maxContrast = 1;
	        this.data.frameBuffer = 0;
	        this.data.height = 64;
	        this.data.width = 128;
	        this.data.screenSize = exports.LCDScreenSize.DIMENSIONS_64X128;
	        this.data.sleeping = 1;
	        this.data.autoFlush = 0;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    let bp;

	    switch (this._ch.chDef.uid) {
	      case 305:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.contrast
	        });
	        await bp.send(this._ch, 48);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.frameBuffer
	        });
	        await bp.send(this._ch, 62);
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {}
	  /**
	   * Set to true to automatically flush the LCD screen after every message that writes to the LCD.
	   * @throws {@link PhidgetError}
	   */


	  get autoFlush() {
	    return this.getAutoFlush();
	  }

	  set autoFlush(autoFlush) {
	    this.setAutoFlush(autoFlush);
	  }
	  /**
	   * The `backlight` affects the brightness of the LCD screen.
	   *
	   * *   `backlight` is bounded by `minBacklight` and `maxBacklight`.
	   * @throws {@link PhidgetError}
	   */


	  get backlight() {
	    return this.getBacklight();
	  }
	  /**
	   * The minimum value that `backlight` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minBacklight() {
	    return this.getMinBacklight();
	  }
	  /**
	   * The maximum value that `backlight` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxBacklight() {
	    return this.getMaxBacklight();
	  }
	  /**
	   * Contrast level of the text or graphic pixels.
	   *
	   * *   A higher contrast will make the image darker.
	   * *   `contrast` is bounded by `minContrast` and `maxContrast`.
	   * @throws {@link PhidgetError}
	   */


	  get contrast() {
	    return this.getContrast();
	  }
	  /**
	   * The minimum value that `contrast` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minContrast() {
	    return this.getMinContrast();
	  }
	  /**
	   * The maximum value that `contrast` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxContrast() {
	    return this.getMaxContrast();
	  }
	  /**
	   * When `cursorBlink` is true, the device will cause the cursor to periodically blink.
	   * @throws {@link PhidgetError}
	   */


	  get cursorBlink() {
	    return this.getCursorBlink();
	  }
	  /**
	   * When `cursorOn` is true, the device will underline to the cursor position.
	   * @throws {@link PhidgetError}
	   */


	  get cursorOn() {
	    return this.getCursorOn();
	  }
	  /**
	   * The frame buffer that is currently being used.
	   *
	   * *   Commands sent to the device are performed on this buffer.
	   * @throws {@link PhidgetError}
	   */


	  get frameBuffer() {
	    return this.getFrameBuffer();
	  }
	  /**
	   * The height of the LCD screen attached to the channel.
	   * @throws {@link PhidgetError}
	   */


	  get height() {
	    return this.getHeight();
	  }
	  /**
	   * The size of the LCD screen attached to the channel.
	   * @throws {@link PhidgetError}
	   */


	  get screenSize() {
	    return this.getScreenSize();
	  }
	  /**
	   * The on/off state of `sleeping`. Putting the device to sleep turns off the display and backlight in order to save power.
	   *
	   * *   The device will still take commands while asleep, and will wake up if the screen is flushed, or if the contrast or backlight are changed.
	   * *   When the device wakes up, it will return to its last known state, taking into account any changes that happened while asleep.
	   * @throws {@link PhidgetError}
	   */


	  get sleeping() {
	    return this.getSleeping();
	  }
	  /**
	   * The width of the LCD screen attached to the channel.
	   * @throws {@link PhidgetError}
	   */


	  get width() {
	    return this.getWidth();
	  }
	  /**
	   * Set to true to automatically flush the LCD screen after every message that writes to the LCD.
	   * @returns Allows setting the LCD to flush the screen automatically
	   * @throws {@link PhidgetError}
	   */


	  getAutoFlush() {
	    this._assertOpen();

	    if (this.data.autoFlush === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.autoFlush;
	  }
	  /**
	   * The `backlight` affects the brightness of the LCD screen.
	   *
	   * *   `backlight` is bounded by `minBacklight` and `maxBacklight`.
	   * @returns The backlight value
	   * @throws {@link PhidgetError}
	   */


	  getBacklight() {
	    this._assertOpen();

	    if (this.data.backlight === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.backlight;
	  }
	  /**
	   * The `backlight` affects the brightness of the LCD screen.
	   *
	   * *   `backlight` is bounded by `minBacklight` and `maxBacklight`.
	   * @throws {@link PhidgetError}
	   * @param backlight - The backlight value
	   */


	  async setBacklight(backlight) {
	    this._assertOpen();

	    if (backlight < this.data.minBacklight || backlight > this.data.maxBacklight) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minBacklight + " - " + this.data.maxBacklight + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: backlight
	    });
	    await bp.send(this._ch, 43);
	  }
	  /**
	   * The minimum value that `backlight` can be set to.
	   * @returns The backlight value
	   * @throws {@link PhidgetError}
	   */


	  getMinBacklight() {
	    this._assertOpen();

	    if (this.data.minBacklight === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minBacklight;
	  }
	  /**
	   * The maximum value that `backlight` can be set to.
	   * @returns The backlight value
	   * @throws {@link PhidgetError}
	   */


	  getMaxBacklight() {
	    this._assertOpen();

	    if (this.data.maxBacklight === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxBacklight;
	  }
	  /**
	   * Clears all pixels in the current frame buffer.
	   *
	   * *   Changes made to the frame buffer must be flushed to the LCD screen using `flush()`.
	   * @throws {@link PhidgetError}
	   */


	  async clear() {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    await bp.send(this._ch, 4);
	  }
	  /**
	   * Contrast level of the text or graphic pixels.
	   *
	   * *   A higher contrast will make the image darker.
	   * *   `contrast` is bounded by `minContrast` and `maxContrast`.
	   * @returns The contrast value
	   * @throws {@link PhidgetError}
	   */


	  getContrast() {
	    this._assertOpen();

	    if (this.data.contrast === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.contrast;
	  }
	  /**
	   * Contrast level of the text or graphic pixels.
	   *
	   * *   A higher contrast will make the image darker.
	   * *   `contrast` is bounded by `minContrast` and `maxContrast`.
	   * @throws {@link PhidgetError}
	   * @param contrast - The contrast value
	   */


	  async setContrast(contrast) {
	    this._assertOpen();

	    if (contrast < this.data.minContrast || contrast > this.data.maxContrast) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minContrast + " - " + this.data.maxContrast + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: contrast
	    });
	    await bp.send(this._ch, 48);
	  }
	  /**
	   * The minimum value that `contrast` can be set to.
	   * @returns The contrast value.
	   * @throws {@link PhidgetError}
	   */


	  getMinContrast() {
	    this._assertOpen();

	    if (this.data.minContrast === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minContrast;
	  }
	  /**
	   * The maximum value that `contrast` can be set to.
	   * @returns The contrast value.
	   * @throws {@link PhidgetError}
	   */


	  getMaxContrast() {
	    this._assertOpen();

	    if (this.data.maxContrast === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxContrast;
	  }
	  /**
	   * Copies all pixels from a specified rectangular region to another.
	   * @throws {@link PhidgetError}
	   * @param sourceFramebuffer - Index number of the frame buffer containing the source rectangle
	   * @param destFramebuffer - Index number of the frame buffer containing the destination rectangle
	   * @param sourceX1 - X coordinate of upper left corner of source rectangle
	   * @param sourceY1 - Y coordinate of upper left corner of source rectangle
	   * @param sourceX2 - X coordinate of bottom right corner of source rectangle
	   * @param sourceY2 - Y coordinate of bottom right corner of source rectangle
	   * @param destX - X coordinate of upper left corner of destination rectangle
	   * @param destY - Y coordinate of upper left corner of destination rectangle
	   * @param inverted - If true, copied pixels are inverted
	   */


	  async copy(sourceFramebuffer, destFramebuffer, sourceX1, sourceY1, sourceX2, sourceY2, destX, destY, inverted) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "d",
	      value: sourceFramebuffer
	    });
	    bp.set({
	      name: "1",
	      type: "d",
	      value: destFramebuffer
	    });
	    bp.set({
	      name: "2",
	      type: "d",
	      value: sourceX1
	    });
	    bp.set({
	      name: "3",
	      type: "d",
	      value: sourceY1
	    });
	    bp.set({
	      name: "4",
	      type: "d",
	      value: sourceX2
	    });
	    bp.set({
	      name: "5",
	      type: "d",
	      value: sourceY2
	    });
	    bp.set({
	      name: "6",
	      type: "d",
	      value: destX
	    });
	    bp.set({
	      name: "7",
	      type: "d",
	      value: destY
	    });
	    if (inverted !== false && inverted !== true) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be a boolean.");
	    bp.set({
	      name: "8",
	      type: "d",
	      value: inverted ? 1 : 0
	    });
	    await bp.send(this._ch, 6);
	  }
	  /**
	   * When `cursorBlink` is true, the device will cause the cursor to periodically blink.
	   * @returns The cursor blink mode
	   * @throws {@link PhidgetError}
	   */


	  getCursorBlink() {
	    this._assertOpen();

	    if (this.data.cursorBlink === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.cursorBlink;
	  }
	  /**
	   * When `cursorBlink` is true, the device will cause the cursor to periodically blink.
	   * @throws {@link PhidgetError}
	   * @param cursorBlink - The cursor blink mode
	   */


	  async setCursorBlink(cursorBlink) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (cursorBlink !== false && cursorBlink !== true) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be a boolean.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: cursorBlink ? 1 : 0
	    });
	    await bp.send(this._ch, 52);
	  }
	  /**
	   * When `cursorOn` is true, the device will underline to the cursor position.
	   * @returns The cursor on value
	   * @throws {@link PhidgetError}
	   */


	  getCursorOn() {
	    this._assertOpen();

	    if (this.data.cursorOn === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.cursorOn;
	  }
	  /**
	   * When `cursorOn` is true, the device will underline to the cursor position.
	   * @throws {@link PhidgetError}
	   * @param cursorOn - The cursor on value
	   */


	  async setCursorOn(cursorOn) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (cursorOn !== false && cursorOn !== true) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be a boolean.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: cursorOn ? 1 : 0
	    });
	    await bp.send(this._ch, 53);
	  }
	  /**
	   * Draws a straight line in the current frame buffer between two specified points
	   *
	   * *   Changes made to the frame buffer must be flushed to the LCD screen using `flush()`.
	   * @throws {@link PhidgetError}
	   * @param x1 - X coordinate of the first point
	   * @param y1 - Y coordinate of the first point
	   * @param x2 - X coordinate of the second point
	   * @param y2 - Y coordinate of the second point
	   */


	  async drawLine(x1, y1, x2, y2) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "d",
	      value: x1
	    });
	    bp.set({
	      name: "1",
	      type: "d",
	      value: y1
	    });
	    bp.set({
	      name: "2",
	      type: "d",
	      value: x2
	    });
	    bp.set({
	      name: "3",
	      type: "d",
	      value: y2
	    });
	    await bp.send(this._ch, 13);
	  }
	  /**
	   * Draws, erases, or inverts a single specified pixel.
	   *
	   * *   Changes made to the frame buffer must be flushed to the LCD screen using `flush()`.
	   * @throws {@link PhidgetError}
	   * @param x - The X coordinate of the pixel
	   * @param y - The Y coordinate of the pixel
	   * @param pixelState - The new state of the pixel.
	   */


	  async drawPixel(x, y, pixelState) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "d",
	      value: x
	    });
	    bp.set({
	      name: "1",
	      type: "d",
	      value: y
	    });
	    if (!supportedLCDPixelState(this._ch, pixelState)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified LCDPixelState is unsupported by this device.");
	    bp.set({
	      name: "2",
	      type: "d",
	      value: pixelState
	    });
	    await bp.send(this._ch, 14);
	  }
	  /**
	   * Draws a rectangle in the current frame buffer using the specified points
	   *
	   * *   Changes made to the frame buffer must be flushed to the LCD screen using `flush()`.
	   * @throws {@link PhidgetError}
	   * @param x1 - The X coordinate of the top-left corner of the rectangle
	   * @param y1 - The Y coordinate of the top-left corner of the rectangle
	   * @param x2 - The X coordinate of the bottom-right corner of the rectangle
	   * @param y2 - The Y coordinate of the bottom-right corner of the rectangle
	   * @param filled - If true, the rectangle will be solid. If false, just a single pixel outline.
	   * @param inverted - If true, clears the region instead of drawing
	   */


	  async drawRect(x1, y1, x2, y2, filled, inverted) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "d",
	      value: x1
	    });
	    bp.set({
	      name: "1",
	      type: "d",
	      value: y1
	    });
	    bp.set({
	      name: "2",
	      type: "d",
	      value: x2
	    });
	    bp.set({
	      name: "3",
	      type: "d",
	      value: y2
	    });
	    if (filled !== false && filled !== true) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be a boolean.");
	    bp.set({
	      name: "4",
	      type: "d",
	      value: filled ? 1 : 0
	    });
	    if (inverted !== false && inverted !== true) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be a boolean.");
	    bp.set({
	      name: "5",
	      type: "d",
	      value: inverted ? 1 : 0
	    });
	    await bp.send(this._ch, 15);
	  }
	  /**
	   * Flushes the buffered LCD contents to the LCD screen.
	   * @throws {@link PhidgetError}
	   */


	  async flush() {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    await bp.send(this._ch, 19);
	  }
	  /**
	   * Sets the size of the specified font.
	   * @throws {@link PhidgetError}
	   * @param font - The specified font
	   * @param width - The width of the font
	   * @param height - The height of the font
	   */


	  async setFontSize(font, width, height) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedLCDFont(this._ch, font)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified LCDFont is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: font
	    });
	    bp.set({
	      name: "1",
	      type: "d",
	      value: width
	    });
	    bp.set({
	      name: "2",
	      type: "d",
	      value: height
	    });
	    await bp.send(this._ch, 61);
	  }
	  /**
	   * The frame buffer that is currently being used.
	   *
	   * *   Commands sent to the device are performed on this buffer.
	   * @returns The current frame buffer
	   * @throws {@link PhidgetError}
	   */


	  getFrameBuffer() {
	    this._assertOpen();

	    if (this.data.frameBuffer === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.frameBuffer;
	  }
	  /**
	   * The frame buffer that is currently being used.
	   *
	   * *   Commands sent to the device are performed on this buffer.
	   * @throws {@link PhidgetError}
	   * @param frameBuffer - The current frame buffer
	   */


	  async setFrameBuffer(frameBuffer) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "d",
	      value: frameBuffer
	    });
	    await bp.send(this._ch, 62);
	  }
	  /**
	   * The height of the LCD screen attached to the channel.
	   * @returns The height value
	   * @throws {@link PhidgetError}
	   */


	  getHeight() {
	    this._assertOpen();

	    if (this.data.height === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.height;
	  }
	  /**
	   * Initializes the Text LCD display
	   * @throws {@link PhidgetError}
	   */


	  async initialize() {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    await bp.send(this._ch, 24);
	  }
	  /**
	   * Writes the specified frame buffer to flash memory
	   *
	   * *   Use sparingly. The flash memory is only designed to be written to 10,000 times before it may become unusable. This method can only be called one time each time the channel is opened.
	   * @throws {@link PhidgetError}
	   * @param frameBuffer - The frame buffer to be saved
	   */


	  async saveFrameBuffer(frameBuffer) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "d",
	      value: frameBuffer
	    });
	    await bp.send(this._ch, 38);
	  }
	  /**
	   * The size of the LCD screen attached to the channel.
	   * @returns The screen size
	   * @throws {@link PhidgetError}
	   */


	  getScreenSize() {
	    this._assertOpen();

	    if (this.data.screenSize === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.screenSize;
	  }
	  /**
	   * The size of the LCD screen attached to the channel.
	   * @throws {@link PhidgetError}
	   * @param screenSize - The screen size
	   */


	  async setScreenSize(screenSize) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedLCDScreenSize(this._ch, screenSize)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified LCDScreenSize is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: screenSize
	    });
	    await bp.send(this._ch, 78);
	  }
	  /**
	   * The on/off state of `sleeping`. Putting the device to sleep turns off the display and backlight in order to save power.
	   *
	   * *   The device will still take commands while asleep, and will wake up if the screen is flushed, or if the contrast or backlight are changed.
	   * *   When the device wakes up, it will return to its last known state, taking into account any changes that happened while asleep.
	   * @returns The sleep status
	   * @throws {@link PhidgetError}
	   */


	  getSleeping() {
	    this._assertOpen();

	    if (this.data.sleeping === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.sleeping;
	  }
	  /**
	   * The on/off state of `sleeping`. Putting the device to sleep turns off the display and backlight in order to save power.
	   *
	   * *   The device will still take commands while asleep, and will wake up if the screen is flushed, or if the contrast or backlight are changed.
	   * *   When the device wakes up, it will return to its last known state, taking into account any changes that happened while asleep.
	   * @throws {@link PhidgetError}
	   * @param sleeping - The sleep status
	   */


	  async setSleeping(sleeping) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (sleeping !== false && sleeping !== true) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be a boolean.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: sleeping ? 1 : 0
	    });
	    await bp.send(this._ch, 80);
	  }
	  /**
	   * The width of the LCD screen attached to the channel.
	   * @returns The width value
	   * @throws {@link PhidgetError}
	   */


	  getWidth() {
	    this._assertOpen();

	    if (this.data.width === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.width;
	  }
	  /**
	   * Writes text to the current frame buffer at the specified location
	   *
	   * *   Changes made to the frame buffer must be flushed to the LCD screen using `flush()`.
	   * @throws {@link PhidgetError}
	   * @param font - The font of the text
	   * @param xPosition - The X position of the start of the text string
	   * @param yPosition - The Y position of the start of the text string
	   * @param text - The text to be written
	   */


	  async writeText(font, xPosition, yPosition, text) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedLCDFont(this._ch, font)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified LCDFont is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: font
	    });
	    bp.set({
	      name: "1",
	      type: "d",
	      value: xPosition
	    });
	    bp.set({
	      name: "2",
	      type: "d",
	      value: yPosition
	    });
	    bp.set({
	      name: "3",
	      type: "s",
	      value: text
	    });
	    await bp.send(this._ch, 105);
	  }

	}

	/** @public */

	class LCD extends LCDBase {
	  constructor(ch) {
	    super(ch);
	    this._transactionLock = new PhidgetLock();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 61:
	        {
	          const font = bp.getNumber(0);
	          const width = bp.getNumber(1);
	          const height = bp.getNumber(2);
	          this.data.fontWidth[font] = width;
	          this.data.fontHeight[font] = height;

	          this._FIREPropertyChange('FontSize', bp);

	          break;
	        }

	      case 78:
	        this._setWidthHeightFromScreenSize(bp.getNumber(0));

	        super._bridgeInput(bp);

	        break;

	      case 43:
	      case 48:
	      case 19:
	        if (this.deviceID === exports.DeviceID.PN_LCD1100) this.data.sleeping = 0;

	        super._bridgeInput(bp);

	        break;

	      default:
	        super._bridgeInput(bp);

	        break;
	    }
	  }
	  /** @internal */


	  _setWidthHeightFromScreenSize(size) {
	    switch (size) {
	      case exports.LCDScreenSize.NO_SCREEN:
	        this.data.height = 0;
	        this.data.width = 0;
	        break;

	      case exports.LCDScreenSize.DIMENSIONS_1X8:
	        this.data.height = 1;
	        this.data.width = 8;
	        break;

	      case exports.LCDScreenSize.DIMENSIONS_2X8:
	        this.data.height = 2;
	        this.data.width = 8;
	        break;

	      case exports.LCDScreenSize.DIMENSIONS_1X16:
	        this.data.height = 1;
	        this.data.width = 16;
	        break;

	      case exports.LCDScreenSize.DIMENSIONS_2X16:
	        this.data.height = 2;
	        this.data.width = 16;
	        break;

	      case exports.LCDScreenSize.DIMENSIONS_4X16:
	        this.data.height = 4;
	        this.data.width = 16;
	        break;

	      case exports.LCDScreenSize.DIMENSIONS_2X20:
	        this.data.height = 2;
	        this.data.width = 20;
	        break;

	      case exports.LCDScreenSize.DIMENSIONS_4X20:
	        this.data.height = 4;
	        this.data.width = 20;
	        break;

	      case exports.LCDScreenSize.DIMENSIONS_2X24:
	        this.data.height = 2;
	        this.data.width = 24;
	        break;

	      case exports.LCDScreenSize.DIMENSIONS_1X40:
	        this.data.height = 1;
	        this.data.width = 40;
	        break;

	      case exports.LCDScreenSize.DIMENSIONS_2X40:
	        this.data.height = 2;
	        this.data.width = 40;
	        break;

	      case exports.LCDScreenSize.DIMENSIONS_4X40:
	        this.data.height = 4;
	        this.data.width = 40;
	        break;
	    }
	  }

	  setAutoFlush(autoFlush) {
	    this._assertOpen();

	    this.data.autoFlush = autoFlush ? 1 : 0;
	  }

	  async setCharacterBitmap(font, character, bitmap) {
	    this._assertOpen();

	    const fontSize = this.getFontSize(font);
	    const bp = new BridgePacket();
	    if (fontSize.width <= 0) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "invalid arg (getFontSize): " + font);
	    if (fontSize.height <= 0) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "invalid arg (getFontSize): " + font);
	    bp.set({
	      name: "0",
	      type: "d",
	      value: font
	    });
	    bp.set({
	      name: "1",
	      type: "s",
	      value: character
	    });
	    bp.set({
	      name: "2",
	      type: "R",
	      value: bitmap
	    });
	    await bp.send(this._ch, 47);
	  }

	  getMaxCharacters(font) {
	    this._assertOpen();

	    let maxChars;
	    let fontSize;

	    switch (this.deviceID) {
	      case exports.DeviceID.PN_LCD1100:
	        fontSize = this.getFontSize(font);
	        if (fontSize.width <= 0) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Font width is <= 0.");
	        if (fontSize.height <= 0) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Font height is <= 0.");
	        maxChars = Math.floor(Math.min(255, this.data.width / fontSize.width * (this.data.height / fontSize.height)));
	        break;

	      case exports.DeviceID.PN_1202_1203:
	      case exports.DeviceID.PN_1204:
	      case exports.DeviceID.PN_1215__1218:
	      case exports.DeviceID.PN_1219__1222:
	        maxChars = 0xff;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	    }

	    return maxChars;
	  }

	  getFontSize(font) {
	    this._assertOpen();

	    const fontSize = {
	      width: 0,
	      height: 0
	    };

	    switch (font) {
	      case exports.LCDFont.DIMENSIONS_6X10:
	        fontSize.width = 6;
	        fontSize.height = 10;
	        break;

	      case exports.LCDFont.DIMENSIONS_5X8:
	        fontSize.width = 5;
	        fontSize.height = 8;
	        break;

	      case exports.LCDFont.DIMENSIONS_6X12:
	        fontSize.width = 6;
	        fontSize.height = 12;
	        break;

	      case exports.LCDFont.USER1:
	      case exports.LCDFont.USER2:
	        fontSize.width = this.data.fontWidth[font];
	        fontSize.height = this.data.fontHeight[font];
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Invalid font.");
	    }

	    return fontSize;
	  }

	  async writeBitmap(xpos, ypos, xsize, ysize, bitmap) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (xsize <= 0 || ysize <= 0) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "invalid arg (size cannot be <=0) " + (xsize <= 0 ? xsize : ysize));
	    bp.set({
	      name: "0",
	      type: "d",
	      value: xpos
	    });
	    bp.set({
	      name: "1",
	      type: "d",
	      value: ypos
	    });
	    bp.set({
	      name: "2",
	      type: "d",
	      value: xsize
	    });
	    bp.set({
	      name: "3",
	      type: "d",
	      value: ysize
	    });
	    bp.set({
	      name: "4",
	      type: "R",
	      value: bitmap
	    });
	    await bp.send(this._ch, 104);
	  }

	}

	class MotorPositionControllerBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onPositionChange = null;
	    this.onDutyCycleUpdate = null;
	    this._class = exports.ChannelClass.MOTOR_POSITION_CONTROLLER;
	    this.name = "MotorPositionController";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 40:
	        this.data.acceleration = bp.entries[0].v;

	        this._FIREPropertyChange('Acceleration', bp);

	        break;

	      case 51:
	        this.data.currentLimit = bp.entries[0].v;

	        this._FIREPropertyChange('CurrentLimit', bp);

	        break;

	      case 119:
	        this.data.currentRegulatorGain = bp.entries[0].v;

	        this._FIREPropertyChange('CurrentRegulatorGain', bp);

	        break;

	      case 54:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.entries[1].v;else this.data.dataInterval = bp.entries[0].v;

	        this._FIREPropertyChange('DataInterval', bp);

	        this._FIREPropertyChange('DataRate', bp);

	        break;

	      case 120:
	        this.data.deadBand = bp.entries[0].v;

	        this._FIREPropertyChange('DeadBand', bp);

	        break;

	      case 57:
	        this.data.engaged = bp.entries[0].v;

	        this._FIREPropertyChange('Engaged', bp);

	        break;

	      case 146:
	        break;

	      case 58:
	        this.data.fanMode = bp.entries[0].v;

	        this._FIREPropertyChange('FanMode', bp);

	        break;

	      case 65:
	        this.data.IOMode = bp.entries[0].v;

	        this._FIREPropertyChange('IOMode', bp);

	        break;

	      case 136:
	        this.data.kd = bp.entries[0].v;

	        this._FIREPropertyChange('Kd', bp);

	        break;

	      case 142:
	        this.data.ki = bp.entries[0].v;

	        this._FIREPropertyChange('Ki', bp);

	        break;

	      case 135:
	        this.data.kp = bp.entries[0].v;

	        this._FIREPropertyChange('Kp', bp);

	        break;

	      case 147:
	        break;

	      case 141:
	        this.data.stallVelocity = bp.entries[0].v;

	        this._FIREPropertyChange('StallVelocity', bp);

	        break;

	      case 83:
	        this.data.targetPosition = bp.entries[0].v;

	        this._FIREPropertyChange('TargetPosition', bp);

	        break;

	      case 55:
	        this.data.velocityLimit = bp.entries[0].v;

	        this._FIREPropertyChange('VelocityLimit', bp);

	        break;

	      case 16:
	        {
	          this.data.dutyCycle = bp.entries[0].v;

	          if (this._isAttachedDone && this.onDutyCycleUpdate) {
	            try {
	              this.onDutyCycleUpdate(this.data.dutyCycle);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      positionOffset: 0,
	      dataInterval: 1e+300,
	      minDataInterval: 4294967295,
	      maxDataInterval: 4294967295,
	      minDataRate: 1e+300,
	      maxDataRate: 1e+300,
	      currentLimit: 1e+300,
	      maxCurrentLimit: 1e+300,
	      minCurrentLimit: 1e+300,
	      currentRegulatorGain: 1e+300,
	      dutyCycle: 1e+300,
	      engaged: 2,
	      maxCurrentRegulatorGain: 1e+300,
	      minCurrentRegulatorGain: 1e+300,
	      velocityLimit: 1e+300,
	      minVelocityLimit: 1e+300,
	      maxVelocityLimit: 1e+300,
	      maxAcceleration: 1e+300,
	      minAcceleration: 1e+300,
	      acceleration: 1e+300,
	      targetPosition: 9223372036854776000,
	      position: 9223372036854776000,
	      maxPosition: 9223372036854776000,
	      minPosition: 9223372036854776000,
	      rescaleFactor: 1e+300,
	      fanMode: 2147483647,
	      deadBand: 4294967295,
	      kp: 1e+300,
	      kd: 1e+300,
	      ki: 1e+300,
	      IOMode: 2147483647,
	      stallVelocity: 1e+300,
	      minStallVelocity: 1e+300,
	      maxStallVelocity: 1e+300,
	      maxFailsafeTime: 4294967295,
	      minFailsafeTime: 4294967295
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 252:
	        this.data.dataInterval = 100;
	        this.data.minDataInterval = 20;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 50;
	        this.data.currentLimit = 2;
	        this.data.maxCurrentLimit = 25;
	        this.data.minCurrentLimit = 2;
	        this.data.currentRegulatorGain = 10;
	        this.data.engaged = 0;
	        this.data.maxCurrentRegulatorGain = 100;
	        this.data.minCurrentRegulatorGain = 1;
	        this.data.velocityLimit = 20000;
	        this.data.minVelocityLimit = 0;
	        this.data.maxVelocityLimit = 250000;
	        this.data.maxAcceleration = 10000000;
	        this.data.minAcceleration = 0.1;
	        this.data.acceleration = 10000;
	        this.data.targetPosition = 0;
	        this.data.maxPosition = 1000000000000000;
	        this.data.minPosition = -1000000000000000;
	        this.data.rescaleFactor = 1;
	        this.data.fanMode = exports.FanMode.AUTO;
	        this.data.deadBand = 0;
	        this.data.kp = 2000;
	        this.data.kd = 25000;
	        this.data.ki = 5;
	        this.data.IOMode = exports.EncoderIOMode.PUSH_PULL;
	        break;

	      case 258:
	        this.data.dataInterval = 100;
	        this.data.minDataInterval = 20;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 50;
	        this.data.currentLimit = 2;
	        this.data.maxCurrentLimit = 25;
	        this.data.minCurrentLimit = 2;
	        this.data.currentRegulatorGain = 10;
	        this.data.engaged = 0;
	        this.data.maxCurrentRegulatorGain = 100;
	        this.data.minCurrentRegulatorGain = 1;
	        this.data.velocityLimit = 20000;
	        this.data.minVelocityLimit = 0;
	        this.data.maxVelocityLimit = 250000;
	        this.data.maxAcceleration = 10000000;
	        this.data.minAcceleration = 0.1;
	        this.data.acceleration = 10000;
	        this.data.targetPosition = 0;
	        this.data.maxPosition = 1000000000000000;
	        this.data.minPosition = -1000000000000000;
	        this.data.rescaleFactor = 1;
	        this.data.fanMode = exports.FanMode.AUTO;
	        this.data.deadBand = 0;
	        this.data.kp = 2000;
	        this.data.kd = 25000;
	        this.data.ki = 5;
	        this.data.IOMode = exports.EncoderIOMode.PUSH_PULL;
	        this.data.maxFailsafeTime = 30000;
	        this.data.minFailsafeTime = 500;
	        break;

	      case 271:
	        this.data.dataInterval = 100;
	        this.data.minDataInterval = 20;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 50;
	        this.data.currentLimit = 1;
	        this.data.maxCurrentLimit = 2;
	        this.data.minCurrentLimit = 0;
	        this.data.engaged = 0;
	        this.data.velocityLimit = 20000;
	        this.data.minVelocityLimit = 0;
	        this.data.maxVelocityLimit = 250000;
	        this.data.maxAcceleration = 10000000;
	        this.data.minAcceleration = 0.1;
	        this.data.acceleration = 10000;
	        this.data.targetPosition = 0;
	        this.data.maxPosition = 1000000000000000;
	        this.data.minPosition = -1000000000000000;
	        this.data.rescaleFactor = 1;
	        this.data.deadBand = 0;
	        this.data.kp = 2000;
	        this.data.kd = 25000;
	        this.data.ki = 5;
	        break;

	      case 274:
	        this.data.dataInterval = 100;
	        this.data.minDataInterval = 20;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 50;
	        this.data.currentLimit = 1;
	        this.data.maxCurrentLimit = 2;
	        this.data.minCurrentLimit = 0;
	        this.data.engaged = 0;
	        this.data.velocityLimit = 20000;
	        this.data.minVelocityLimit = 0;
	        this.data.maxVelocityLimit = 250000;
	        this.data.maxAcceleration = 10000000;
	        this.data.minAcceleration = 0.1;
	        this.data.acceleration = 10000;
	        this.data.targetPosition = 0;
	        this.data.maxPosition = 1000000000000000;
	        this.data.minPosition = -1000000000000000;
	        this.data.rescaleFactor = 1;
	        this.data.deadBand = 0;
	        this.data.kp = 2000;
	        this.data.kd = 25000;
	        this.data.ki = 5;
	        this.data.maxFailsafeTime = 30000;
	        this.data.minFailsafeTime = 500;
	        break;

	      case 277:
	        this.data.dataInterval = 100;
	        this.data.minDataInterval = 20;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 50;
	        this.data.currentLimit = 1;
	        this.data.maxCurrentLimit = 3.5;
	        this.data.minCurrentLimit = 0;
	        this.data.engaged = 0;
	        this.data.velocityLimit = 20000;
	        this.data.minVelocityLimit = 0;
	        this.data.maxVelocityLimit = 250000;
	        this.data.maxAcceleration = 10000000;
	        this.data.minAcceleration = 0.1;
	        this.data.acceleration = 10000;
	        this.data.targetPosition = 0;
	        this.data.maxPosition = 1000000000000000;
	        this.data.minPosition = -1000000000000000;
	        this.data.rescaleFactor = 1;
	        this.data.deadBand = 0;
	        this.data.kp = 2000;
	        this.data.kd = 25000;
	        this.data.ki = 5;
	        break;

	      case 280:
	        this.data.dataInterval = 100;
	        this.data.minDataInterval = 20;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 50;
	        this.data.currentLimit = 1;
	        this.data.maxCurrentLimit = 4;
	        this.data.minCurrentLimit = 0;
	        this.data.engaged = 0;
	        this.data.velocityLimit = 20000;
	        this.data.minVelocityLimit = 0;
	        this.data.maxVelocityLimit = 250000;
	        this.data.maxAcceleration = 10000000;
	        this.data.minAcceleration = 0.1;
	        this.data.acceleration = 10000;
	        this.data.targetPosition = 0;
	        this.data.maxPosition = 1000000000000000;
	        this.data.minPosition = -1000000000000000;
	        this.data.rescaleFactor = 1;
	        this.data.deadBand = 0;
	        this.data.kp = 2000;
	        this.data.kd = 25000;
	        this.data.ki = 5;
	        this.data.maxFailsafeTime = 30000;
	        this.data.minFailsafeTime = 500;
	        break;

	      case 285:
	        this.data.dataInterval = 100;
	        this.data.minDataInterval = 20;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 50;
	        this.data.engaged = 0;
	        this.data.velocityLimit = 1000;
	        this.data.minVelocityLimit = 0;
	        this.data.maxVelocityLimit = 10000;
	        this.data.maxAcceleration = 100000;
	        this.data.minAcceleration = 0.1;
	        this.data.acceleration = 100;
	        this.data.targetPosition = 0;
	        this.data.maxPosition = 1000000000000000;
	        this.data.minPosition = -1000000000000000;
	        this.data.rescaleFactor = 1;
	        this.data.deadBand = 0;
	        this.data.kp = 20000;
	        this.data.kd = 40000;
	        this.data.ki = 2;
	        this.data.stallVelocity = 400;
	        this.data.minStallVelocity = 0;
	        this.data.maxStallVelocity = 2000;
	        break;

	      case 288:
	        this.data.dataInterval = 100;
	        this.data.minDataInterval = 20;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 50;
	        this.data.engaged = 0;
	        this.data.velocityLimit = 1000;
	        this.data.minVelocityLimit = 0;
	        this.data.maxVelocityLimit = 10000;
	        this.data.maxAcceleration = 100000;
	        this.data.minAcceleration = 0.1;
	        this.data.acceleration = 100;
	        this.data.targetPosition = 0;
	        this.data.maxPosition = 1000000000000000;
	        this.data.minPosition = -1000000000000000;
	        this.data.rescaleFactor = 1;
	        this.data.deadBand = 0;
	        this.data.kp = 20000;
	        this.data.kd = 40000;
	        this.data.ki = 2;
	        this.data.stallVelocity = 400;
	        this.data.minStallVelocity = 0;
	        this.data.maxStallVelocity = 2000;
	        this.data.maxFailsafeTime = 30000;
	        this.data.minFailsafeTime = 500;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    let bp;

	    switch (this._ch.chDef.uid) {
	      case 252:
	      case 258:
	        break;

	      case 271:
	      case 274:
	      case 277:
	      case 280:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.currentLimit
	        });
	        await bp.send(this._ch, 51);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.engaged
	        });
	        await bp.send(this._ch, 57);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.velocityLimit
	        });
	        await bp.send(this._ch, 55);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.acceleration
	        });
	        await bp.send(this._ch, 40);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "l",
	          value: this.data.targetPosition
	        });
	        await bp.send(this._ch, 83);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: this.data.deadBand
	        });
	        await bp.send(this._ch, 120);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.kp
	        });
	        await bp.send(this._ch, 135);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.kd
	        });
	        await bp.send(this._ch, 136);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.ki
	        });
	        await bp.send(this._ch, 142);
	        break;

	      case 285:
	      case 288:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.engaged
	        });
	        await bp.send(this._ch, 57);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.velocityLimit
	        });
	        await bp.send(this._ch, 55);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.acceleration
	        });
	        await bp.send(this._ch, 40);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "l",
	          value: this.data.targetPosition
	        });
	        await bp.send(this._ch, 83);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: this.data.deadBand
	        });
	        await bp.send(this._ch, 120);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.kp
	        });
	        await bp.send(this._ch, 135);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.kd
	        });
	        await bp.send(this._ch, 136);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.ki
	        });
	        await bp.send(this._ch, 142);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.stallVelocity
	        });
	        await bp.send(this._ch, 141);
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    if (this.data.dutyCycle == 1e+300 && !this._gotDutyCycleUpdateErrorEvent) return false;
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {
	    if (this.data.dutyCycle != 1e+300) if (this.onDutyCycleUpdate) try {
	      this.onDutyCycleUpdate(this.data.dutyCycle);
	    } catch (err) {
	      logEventException(err);
	    }
	  }
	  /**
	   * The rate at which the controller can change the motor's velocity.
	   *
	   * *   Units for `position`, `velocityLimit`, `acceleration`, and `deadBand` can be set by the user through the `rescaleFactor`. The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees.
	   * @throws {@link PhidgetError}
	   */


	  get acceleration() {
	    return this.getAcceleration();
	  }
	  /**
	   * The minimum value that `acceleration` can be set to.
	   *
	   * *   Units for `position`, `velocityLimit`, `acceleration`, and `deadBand` can be set by the user through the `rescaleFactor`. The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees.
	   * @throws {@link PhidgetError}
	   */


	  get minAcceleration() {
	    return this.getMinAcceleration();
	  }
	  /**
	   * The maximum value that `acceleration` can be set to.
	   *
	   * *   Units for `position`, `velocityLimit`, `acceleration`, and `deadBand` can be set by the user through the `rescaleFactor`. The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees.
	   * @throws {@link PhidgetError}
	   */


	  get maxAcceleration() {
	    return this.getMaxAcceleration();
	  }
	  /**
	   * The controller will limit the current through the motor to this value.
	   * @throws {@link PhidgetError}
	   */


	  get currentLimit() {
	    return this.getCurrentLimit();
	  }
	  /**
	   * The minimum current limit that can be set for the device.
	   * @throws {@link PhidgetError}
	   */


	  get minCurrentLimit() {
	    return this.getMinCurrentLimit();
	  }
	  /**
	   * The maximum current limit that can be set for the device.
	   * @throws {@link PhidgetError}
	   */


	  get maxCurrentLimit() {
	    return this.getMaxCurrentLimit();
	  }
	  /**
	   * Depending on power supply voltage and motor coil inductance, current through the motor can change relatively slowly or extremely rapidly. A physically larger DC Motor will typically have a lower inductance, requiring a higher current regulator gain. A higher power supply voltage will result in motor current changing more rapidly, requiring a higher current regulator gain. If the current regulator gain is too small, spikes in current will occur, causing large variations in torque, and possibly damaging the motor controller. If the current regulator gain is too high, the current will jitter, causing the motor to sound 'rough', especially when changing directions. Each DC Motor we sell specifies a suitable current regulator gain.
	   * @throws {@link PhidgetError}
	   */


	  get currentRegulatorGain() {
	    return this.getCurrentRegulatorGain();
	  }
	  /**
	   * The minimum current regulator gain for the device.
	   * @throws {@link PhidgetError}
	   */


	  get minCurrentRegulatorGain() {
	    return this.getMinCurrentRegulatorGain();
	  }
	  /**
	   * The maximum current regulator gain for the device.
	   * @throws {@link PhidgetError}
	   */


	  get maxCurrentRegulatorGain() {
	    return this.getMaxCurrentRegulatorGain();
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `PositionChange` / `DutyCycleUpdate` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * @throws {@link PhidgetError}
	   */


	  get dataInterval() {
	    return this.getDataInterval();
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataInterval() {
	    return this.getMinDataInterval();
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataInterval() {
	    return this.getMaxDataInterval();
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   */


	  get dataRate() {
	    return this.getDataRate();
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataRate() {
	    return this.getMinDataRate();
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataRate() {
	    return this.getMaxDataRate();
	  }
	  /**
	   * Depending on your system, it may not be possible to bring the position error (`targetPosition` - `position`) to zero. A small error can lead to the motor continually 'hunting' for a target position, which can cause unwanted effects. By setting a non-zero `deadBand`, the position controller will relax control of the motor within the deadband, preventing the 'hunting' behavior.
	   *
	   * *   Units for `position`, `velocityLimit`, `acceleration`, and `deadBand` can be set by the user through the `rescaleFactor`. The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees.
	   * @throws {@link PhidgetError}
	   */


	  get deadBand() {
	    return this.getDeadBand();
	  }
	  /**
	   * The most recent duty cycle value that the controller has reported.
	   *
	   * *   This value will be between -1 and 1 where a sign change (Â±) is indicitave of a direction change.
	   * *   Note that `dutyCycle` is merely an indication of the average voltage across the motor. At a constant load, an increase in `dutyCycle` indicates an increase in motor speed.
	   * *   The units of `dutyCycle` refer to 'duty cycle'. This is because the controller must rapidly switch the power on/off (i.e. change the duty cycle) in order to manipulate the voltage across the motor.
	   * @throws {@link PhidgetError}
	   */


	  get dutyCycle() {
	    return this.getDutyCycle();
	  }
	  /**
	   * When engaged, a motor has the ability to be positioned. When disengaged, no commands are sent to the motor.
	   *
	   * *   This function is useful for completely relaxing a motor once it has reached the target position.
	   * @throws {@link PhidgetError}
	   */


	  get engaged() {
	    return this.getEngaged();
	  }
	  /**
	   * The minimum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @throws {@link PhidgetError}
	   */


	  get minFailsafeTime() {
	    return this.getMinFailsafeTime();
	  }
	  /**
	   * The maximum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @throws {@link PhidgetError}
	   */


	  get maxFailsafeTime() {
	    return this.getMaxFailsafeTime();
	  }
	  /**
	   * The `fanMode` dictates the operating condition of the fan.
	   *
	   * *   Choose between on, off, or automatic (based on temperature).
	   * *   If the `fanMode` is set to automatic, the fan will turn on when the temperature reaches 70Â°C and it will remain on until the temperature falls below 55Â°C.
	   * *   If the `fanMode` is off, the controller will still turn on the fan if the temperature reaches 85Â°C and it will remain on until it falls below 70Â°C.
	   * @throws {@link PhidgetError}
	   */


	  get fanMode() {
	    return this.getFanMode();
	  }
	  /**
	   * The encoder interface mode. Match the mode to the type of encoder you have attached.
	   *
	   * *   It is recommended to only change this when the encoder disabled in order to avoid unexpected results.
	   * @throws {@link PhidgetError}
	   */


	  get IOMode() {
	    return this.getIOMode();
	  }
	  /**
	   * Derivative gain constant. A higher `kd` will help reduce oscillations.
	   * @throws {@link PhidgetError}
	   */


	  get kd() {
	    return this.getKd();
	  }
	  /**
	   * Integral gain constant. The integral term will help eliminate steady-state error.
	   * @throws {@link PhidgetError}
	   */


	  get ki() {
	    return this.getKi();
	  }
	  /**
	   * Proportional gain constant. A small `kp` value will result in a less responsive controller, however, if `kp` is too high, the system can become unstable.
	   * @throws {@link PhidgetError}
	   */


	  get kp() {
	    return this.getKp();
	  }
	  /**
	   * The most recent position value that the controller has reported.
	   *
	   * *   This value will always be between `minPosition` and `maxPosition`.
	   * *   Units for `position`, `velocityLimit`, `acceleration`, and `deadBand` can be set by the user through the `rescaleFactor`. The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees.
	   * @throws {@link PhidgetError}
	   */


	  get position() {
	    return this.getPosition();
	  }
	  /**
	   * The minimum value that `targetPosition` can be set to.
	   *
	   * *   Units for `position`, `velocityLimit`, `acceleration`, and `deadBand` can be set by the user through the `rescaleFactor`. The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees.
	   * @throws {@link PhidgetError}
	   */


	  get minPosition() {
	    return this.getMinPosition();
	  }
	  /**
	   * The maximum value that `targetPosition` can be set to.
	   *
	   * *   Units for `position`, `velocityLimit`, `acceleration`, and `deadBand` can be set by the user through the `rescaleFactor`. The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees.
	   * @throws {@link PhidgetError}
	   */


	  get maxPosition() {
	    return this.getMaxPosition();
	  }
	  /**
	   * Change the units of your parameters so that your application is more intuitive.
	   *
	   * *   Units for `position`, `velocityLimit`, `acceleration`, and `deadBand` can be set by the user through the `rescaleFactor`. The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees.
	   * @throws {@link PhidgetError}
	   */


	  get rescaleFactor() {
	    return this.getRescaleFactor();
	  }

	  set rescaleFactor(rescaleFactor) {
	    this.setRescaleFactor(rescaleFactor);
	  }
	  /**
	   * Before reading this description, it is important to note the difference between the units of `stallVelocity` and `dutyCycle`.
	   *
	   * *   `dutyCycle` is a number between -1 and 1 with units of 'duty cycle'. It simply represents the average voltage across the motor.
	   * *   `stallVelocity` represents a real velocity (e.g. m/s, RPM, etc.) and the units are determined by the `rescaleFactor`. With a `rescaleFactor` of 1, the default units would be in commutations per second.
	   *
	   * If the load on your motor is large, your motor may begin rotating more slowly, or even fully stall. Depending on the voltage across your motor, this may result in a large amount of current through both the controller and the motor. In order to prevent damage in these situations, you can use the `stallVelocity` property.
	   *
	   * The `stallVelocity` should be set to the lowest velocity you would expect from your motor. The controller will then monitor the motor's velocity, as well as the `dutyCycle`, and prevent a 'dangerous stall' from occuring. If the controller detects a dangerous stall, it will immediately disengage the motor (i.e. `engaged` will be set to false) and an error will be reported to your program.
	   *
	   * *   A 'dangerous stall' will occur faster when the `dutyCycle` is higher (i.e. when the average voltage across the motor is higher)
	   * *   A 'dangerous stall' will occur faster as (`stallVelocity` - motor velocity) becomes larger .
	   *
	   * Setting `stallVelocity` to 0 will turn off stall protection functionality.
	   * @throws {@link PhidgetError}
	   */


	  get stallVelocity() {
	    return this.getStallVelocity();
	  }
	  /**
	   * The lower bound of `stallVelocity`.
	   * @throws {@link PhidgetError}
	   */


	  get minStallVelocity() {
	    return this.getMinStallVelocity();
	  }
	  /**
	   * The upper bound of `stallVelocity`.
	   * @throws {@link PhidgetError}
	   */


	  get maxStallVelocity() {
	    return this.getMaxStallVelocity();
	  }
	  /**
	   * If the controller is configured and the `targetPosition` is set, the motor will try to reach the `targetPosition`.
	   *
	   * *   If the `deadBand` is non-zero, the final position of the motor may not match the `targetPosition`
	   * *   Units for `position`, `velocityLimit`, `acceleration`, and `deadBand` can be set by the user through the `rescaleFactor`. The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees.
	   * @throws {@link PhidgetError}
	   */


	  get targetPosition() {
	    return this.getTargetPosition();
	  }
	  /**
	   * When moving, the motor velocity will be limited by this value.
	   *
	   * *   `velocityLimit` is bounded by `minVelocityLimit` and `maxVelocityLimit`.
	   * *   Units for `position`, `velocityLimit`, `acceleration`, and `deadBand` can be set by the user through the `rescaleFactor`. The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees.
	   * @throws {@link PhidgetError}
	   */


	  get velocityLimit() {
	    return this.getVelocityLimit();
	  }
	  /**
	   * The minimum value that `velocityLimit` can be set to.
	   *
	   * *   Units for `position`, `velocityLimit`, `acceleration`, and `deadBand` can be set by the user through the `rescaleFactor`. The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees.
	   * @throws {@link PhidgetError}
	   */


	  get minVelocityLimit() {
	    return this.getMinVelocityLimit();
	  }
	  /**
	   * The maximum value that `velocityLimit` can be set to.
	   *
	   * *   Units for `position`, `velocityLimit`, `acceleration`, and `deadBand` can be set by the user through the `rescaleFactor`. The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees.
	   * @throws {@link PhidgetError}
	   */


	  get maxVelocityLimit() {
	    return this.getMaxVelocityLimit();
	  }
	  /**
	   * The controller will limit the current through the motor to this value.
	   * @returns Motor current limit
	   * @throws {@link PhidgetError}
	   */


	  getCurrentLimit() {
	    this._assertOpen();

	    if (this.data.currentLimit === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.currentLimit;
	  }
	  /**
	   * The controller will limit the current through the motor to this value.
	   * @throws {@link PhidgetError}
	   * @param currentLimit - Motor current limit
	   */


	  async setCurrentLimit(currentLimit) {
	    this._assertOpen();

	    if (currentLimit < this.data.minCurrentLimit || currentLimit > this.data.maxCurrentLimit) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minCurrentLimit + " - " + this.data.maxCurrentLimit + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: currentLimit
	    });
	    await bp.send(this._ch, 51);
	  }
	  /**
	   * The minimum current limit that can be set for the device.
	   * @returns Minimum current limit
	   * @throws {@link PhidgetError}
	   */


	  getMinCurrentLimit() {
	    this._assertOpen();

	    if (this.data.minCurrentLimit === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minCurrentLimit;
	  }
	  /**
	   * The maximum current limit that can be set for the device.
	   * @returns Maximum current limit
	   * @throws {@link PhidgetError}
	   */


	  getMaxCurrentLimit() {
	    this._assertOpen();

	    if (this.data.maxCurrentLimit === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxCurrentLimit;
	  }
	  /**
	   * Depending on power supply voltage and motor coil inductance, current through the motor can change relatively slowly or extremely rapidly. A physically larger DC Motor will typically have a lower inductance, requiring a higher current regulator gain. A higher power supply voltage will result in motor current changing more rapidly, requiring a higher current regulator gain. If the current regulator gain is too small, spikes in current will occur, causing large variations in torque, and possibly damaging the motor controller. If the current regulator gain is too high, the current will jitter, causing the motor to sound 'rough', especially when changing directions. Each DC Motor we sell specifies a suitable current regulator gain.
	   * @returns Current Regulator Gain
	   * @throws {@link PhidgetError}
	   */


	  getCurrentRegulatorGain() {
	    this._assertOpen();

	    if (this.data.currentRegulatorGain === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.currentRegulatorGain;
	  }
	  /**
	   * Depending on power supply voltage and motor coil inductance, current through the motor can change relatively slowly or extremely rapidly. A physically larger DC Motor will typically have a lower inductance, requiring a higher current regulator gain. A higher power supply voltage will result in motor current changing more rapidly, requiring a higher current regulator gain. If the current regulator gain is too small, spikes in current will occur, causing large variations in torque, and possibly damaging the motor controller. If the current regulator gain is too high, the current will jitter, causing the motor to sound 'rough', especially when changing directions. Each DC Motor we sell specifies a suitable current regulator gain.
	   * @throws {@link PhidgetError}
	   * @param currentRegulatorGain - Current Regulator Gain
	   */


	  async setCurrentRegulatorGain(currentRegulatorGain) {
	    this._assertOpen();

	    if (currentRegulatorGain < this.data.minCurrentRegulatorGain || currentRegulatorGain > this.data.maxCurrentRegulatorGain) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minCurrentRegulatorGain + " - " + this.data.maxCurrentRegulatorGain + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: currentRegulatorGain
	    });
	    await bp.send(this._ch, 119);
	  }
	  /**
	   * The minimum current regulator gain for the device.
	   * @returns Minimum current regulator gain
	   * @throws {@link PhidgetError}
	   */


	  getMinCurrentRegulatorGain() {
	    this._assertOpen();

	    if (this.data.minCurrentRegulatorGain === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minCurrentRegulatorGain;
	  }
	  /**
	   * The maximum current regulator gain for the device.
	   * @returns Maximum current regulator gain
	   * @throws {@link PhidgetError}
	   */


	  getMaxCurrentRegulatorGain() {
	    this._assertOpen();

	    if (this.data.maxCurrentRegulatorGain === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxCurrentRegulatorGain;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `PositionChange` / `DutyCycleUpdate` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getDataInterval() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dataInterval;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `PositionChange` / `DutyCycleUpdate` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * @throws {@link PhidgetError}
	   * @param dataInterval - The data interval value
	   */


	  async setDataInterval(dataInterval) {
	    this._assertOpen();

	    if (dataInterval < this.data.minDataInterval || dataInterval > this.data.maxDataInterval) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataInterval + " - " + this.data.maxDataInterval + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: dataInterval
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataInterval() {
	    this._assertOpen();

	    if (this.data.minDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataInterval;
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataInterval() {
	    this._assertOpen();

	    if (this.data.maxDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @returns The data rate for the channel
	   * @throws {@link PhidgetError}
	   */


	  getDataRate() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return 1000.0 / this.data.dataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   * @param dataRate - The data rate for the channel
	   */


	  async setDataRate(dataRate) {
	    this._assertOpen();

	    if (dataRate < this.data.minDataRate || dataRate > this.data.maxDataRate) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataRate + " - " + this.data.maxDataRate + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: Math.round(1000.0 / dataRate)
	    });
	    bp.set({
	      name: "1",
	      type: "g",
	      value: 1000.0 / dataRate
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataRate() {
	    this._assertOpen();

	    if (this.data.minDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataRate;
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataRate() {
	    this._assertOpen();

	    if (this.data.maxDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataRate;
	  }
	  /**
	   * The most recent duty cycle value that the controller has reported.
	   *
	   * *   This value will be between -1 and 1 where a sign change (Â±) is indicitave of a direction change.
	   * *   Note that `dutyCycle` is merely an indication of the average voltage across the motor. At a constant load, an increase in `dutyCycle` indicates an increase in motor speed.
	   * *   The units of `dutyCycle` refer to 'duty cycle'. This is because the controller must rapidly switch the power on/off (i.e. change the duty cycle) in order to manipulate the voltage across the motor.
	   * @returns The duty cycle value.
	   * @throws {@link PhidgetError}
	   */


	  getDutyCycle() {
	    this._assertOpen();

	    if (this.data.dutyCycle === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dutyCycle;
	  }
	  /**
	   * When engaged, a motor has the ability to be positioned. When disengaged, no commands are sent to the motor.
	   *
	   * *   This function is useful for completely relaxing a motor once it has reached the target position.
	   * @returns The engaged value.
	   * @throws {@link PhidgetError}
	   */


	  getEngaged() {
	    this._assertOpen();

	    if (this.data.engaged === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.engaged;
	  }
	  /**
	   * When engaged, a motor has the ability to be positioned. When disengaged, no commands are sent to the motor.
	   *
	   * *   This function is useful for completely relaxing a motor once it has reached the target position.
	   * @throws {@link PhidgetError}
	   * @param engaged - The engaged value.
	   */


	  async setEngaged(engaged) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (engaged !== false && engaged !== true) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be a boolean.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: engaged ? 1 : 0
	    });
	    await bp.send(this._ch, 57);
	  }
	  /**
	   * Enables the **failsafe** feature for the channel, with a given **failsafe time**.
	   *
	   * The **failsafe** feature is intended for use in applications where it is important for the channel to enter a known _safe state_ if the program controlling it locks up or crashes. If you do not enable the failsafe feature, the channel will carry out whatever instructions it was last given until it is explicitly told to stop.
	   *
	   * Enabling the failsafe feature starts a recurring **failsafe timer** for the channel. Once the failsafe timer is enabled, it must be reset within the specified time or the channel will enter a **failsafe state**. The failsafe timer may be reset by sending any valid command to the device\*. Resetting the failsafe timer will reload the timer with the specified _failsafe time_, starting when the message to reset the timer is received by the Phidget.
	   *
	   * _\*(**get** requests do not typically send commands and won't reset the failsafe timer)_
	   *
	   * For example: if the failsafe is enabled with a **failsafe time** of 1000ms, you will have 1000ms to reset the failsafe timer. Every time the failsafe timer is reset, you will have 1000ms from that time to reset the failsafe again.
	   *
	   * If the failsafe timer is not reset before it runs out, the channel will enter a **failsafe state**. For Motor Position Controller channels, this will disengage the motor. Once the channel enters the **failsafe state**, it will reject any further input until the channel is reopened.
	   *
	   * To prevent the channel from falsely entering the failsafe state, we recommend resetting the failsafe timer as frequently as is practical for your application. A good rule of thumb is to not let more than a third of the failsafe time pass before resetting the timer.
	   *
	   * Once the failsafe timer has been set, it cannot be disabled by any means other than closing and reopening the channel.
	   * @throws {@link PhidgetError}
	   * @param failsafeTime - Failsafe timeout in milliseconds
	   */


	  async enableFailsafe(failsafeTime) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: failsafeTime
	    });
	    await bp.send(this._ch, 146);
	  }
	  /**
	   * The minimum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @returns The failsafe time
	   * @throws {@link PhidgetError}
	   */


	  getMinFailsafeTime() {
	    this._assertOpen();

	    if (this.data.minFailsafeTime === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minFailsafeTime;
	  }
	  /**
	   * The maximum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @returns The failsafe time
	   * @throws {@link PhidgetError}
	   */


	  getMaxFailsafeTime() {
	    this._assertOpen();

	    if (this.data.maxFailsafeTime === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxFailsafeTime;
	  }
	  /**
	   * The `fanMode` dictates the operating condition of the fan.
	   *
	   * *   Choose between on, off, or automatic (based on temperature).
	   * *   If the `fanMode` is set to automatic, the fan will turn on when the temperature reaches 70Â°C and it will remain on until the temperature falls below 55Â°C.
	   * *   If the `fanMode` is off, the controller will still turn on the fan if the temperature reaches 85Â°C and it will remain on until it falls below 70Â°C.
	   * @returns The fan mode
	   * @throws {@link PhidgetError}
	   */


	  getFanMode() {
	    this._assertOpen();

	    if (this.data.fanMode === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.fanMode;
	  }
	  /**
	   * The `fanMode` dictates the operating condition of the fan.
	   *
	   * *   Choose between on, off, or automatic (based on temperature).
	   * *   If the `fanMode` is set to automatic, the fan will turn on when the temperature reaches 70Â°C and it will remain on until the temperature falls below 55Â°C.
	   * *   If the `fanMode` is off, the controller will still turn on the fan if the temperature reaches 85Â°C and it will remain on until it falls below 70Â°C.
	   * @throws {@link PhidgetError}
	   * @param fanMode - The fan mode
	   */


	  async setFanMode(fanMode) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedFanMode(this._ch, fanMode)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified FanMode is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: fanMode
	    });
	    await bp.send(this._ch, 58);
	  }
	  /**
	   * The encoder interface mode. Match the mode to the type of encoder you have attached.
	   *
	   * *   It is recommended to only change this when the encoder disabled in order to avoid unexpected results.
	   * @returns The IO mode value.
	   * @throws {@link PhidgetError}
	   */


	  getIOMode() {
	    this._assertOpen();

	    if (this.data.IOMode === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.IOMode;
	  }
	  /**
	   * The encoder interface mode. Match the mode to the type of encoder you have attached.
	   *
	   * *   It is recommended to only change this when the encoder disabled in order to avoid unexpected results.
	   * @throws {@link PhidgetError}
	   * @param IOMode - The IO mode value.
	   */


	  async setIOMode(IOMode) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedEncoderIOMode(this._ch, IOMode)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified EncoderIOMode is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: IOMode
	    });
	    await bp.send(this._ch, 65);
	  }
	  /**
	   * Derivative gain constant. A higher `kd` will help reduce oscillations.
	   * @returns The Kd value.
	   * @throws {@link PhidgetError}
	   */


	  getKd() {
	    this._assertOpen();

	    if (this.data.kd === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.kd;
	  }
	  /**
	   * Derivative gain constant. A higher `kd` will help reduce oscillations.
	   * @throws {@link PhidgetError}
	   * @param kd - The Kd value.
	   */


	  async setKd(kd) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: kd
	    });
	    await bp.send(this._ch, 136);
	  }
	  /**
	   * Integral gain constant. The integral term will help eliminate steady-state error.
	   * @returns The Ki value.
	   * @throws {@link PhidgetError}
	   */


	  getKi() {
	    this._assertOpen();

	    if (this.data.ki === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.ki;
	  }
	  /**
	   * Integral gain constant. The integral term will help eliminate steady-state error.
	   * @throws {@link PhidgetError}
	   * @param ki - The Ki value.
	   */


	  async setKi(ki) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: ki
	    });
	    await bp.send(this._ch, 142);
	  }
	  /**
	   * Proportional gain constant. A small `kp` value will result in a less responsive controller, however, if `kp` is too high, the system can become unstable.
	   * @returns The Kp value.
	   * @throws {@link PhidgetError}
	   */


	  getKp() {
	    this._assertOpen();

	    if (this.data.kp === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.kp;
	  }
	  /**
	   * Proportional gain constant. A small `kp` value will result in a less responsive controller, however, if `kp` is too high, the system can become unstable.
	   * @throws {@link PhidgetError}
	   * @param kp - The Kp value.
	   */


	  async setKp(kp) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: kp
	    });
	    await bp.send(this._ch, 135);
	  }
	  /**
	   * Change the units of your parameters so that your application is more intuitive.
	   *
	   * *   Units for `position`, `velocityLimit`, `acceleration`, and `deadBand` can be set by the user through the `rescaleFactor`. The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees.
	   * @returns The rescale factor value
	   * @throws {@link PhidgetError}
	   */


	  getRescaleFactor() {
	    this._assertOpen();

	    if (this.data.rescaleFactor === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.rescaleFactor;
	  }
	  /**
	   * Resets the failsafe timer, if one has been set. See `enableFailsafe()` for details.
	   *
	   * This function will fail if no failsafe timer has been set for the channel.
	   * @throws {@link PhidgetError}
	   */


	  async resetFailsafe() {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    await bp.send(this._ch, 147);
	  }

	}

	/** @public */

	class MotorPositionController extends MotorPositionControllerBase {
	  /** @internal */
	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 29:
	        this.data.position = bp.getNumber(0);

	        if (this._isAttachedDone && this.onPositionChange) {
	          try {
	            this.onPositionChange((this.data.position + this.data.positionOffset) * this.data.rescaleFactor);
	          } catch (err) {
	            logEventException(err);
	          }
	        }

	        break;

	      default:
	        super._bridgeInput(bp);

	        break;
	    }
	  }
	  /** @internal */


	  _errorHandler(code) {
	    switch (code) {
	      case exports.ErrorEventCode.MOTOR_STALL_CONDITION:
	        this.data.engaged = 0;
	        break;
	    }
	  }

	  getAcceleration() {
	    this._assertOpen();

	    if (this.data.acceleration === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.acceleration * this.data.rescaleFactor;
	  }

	  async setAcceleration(acceleration) {
	    this._assertOpen();

	    const calcAccel = acceleration / this.data.rescaleFactor;
	    if (calcAccel < this.data.minAcceleration || calcAccel > this.data.maxAcceleration) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.minAcceleration + " - " + this.maxAcceleration + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: calcAccel
	    });
	    await bp.send(this._ch, 40);
	  }

	  getMinAcceleration() {
	    this._assertOpen();

	    if (this.data.minAcceleration === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minAcceleration * this.data.rescaleFactor;
	  }

	  getMaxAcceleration() {
	    this._assertOpen();

	    if (this.data.maxAcceleration === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxAcceleration * this.data.rescaleFactor;
	  }

	  addPositionOffset(positionOffset) {
	    this._assertOpen();

	    this.data.positionOffset += positionOffset / this.data.rescaleFactor;
	  }

	  getDeadBand() {
	    this._assertOpen();

	    if (this.data.deadBand === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.deadBand * this.data.rescaleFactor;
	  }

	  async setDeadBand(deadBand) {
	    this._assertOpen();

	    const calcDeadband = deadBand / this.data.rescaleFactor;
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: calcDeadband
	    });
	    await bp.send(this._ch, 120);
	  }

	  getPosition() {
	    this._assertOpen();

	    if (this.data.position === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return (this.data.position + this.data.positionOffset) * this.data.rescaleFactor;
	  }

	  getMinPosition() {
	    this._assertOpen();

	    if (this.data.minPosition === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return (this.data.minPosition + this.data.positionOffset) * this.data.rescaleFactor;
	  }

	  getMaxPosition() {
	    this._assertOpen();

	    if (this.data.maxPosition === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return (this.data.maxPosition + this.data.positionOffset) * this.data.rescaleFactor;
	  }

	  setRescaleFactor(rescaleFactor) {
	    this._assertOpen();

	    this.data.rescaleFactor = rescaleFactor;
	  }

	  getTargetPosition() {
	    this._assertOpen();

	    if (this.data.targetPosition === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return (this.data.targetPosition + this.data.positionOffset) * this.data.rescaleFactor;
	  }

	  async setTargetPosition(targetPosition) {
	    this._assertOpen();

	    const calcPosition = targetPosition / this.data.rescaleFactor - this.data.positionOffset;
	    if (calcPosition < this.data.minPosition || calcPosition > this.data.maxPosition) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.minPosition + " - " + this.maxPosition + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "l",
	      value: calcPosition
	    });
	    await bp.send(this._ch, 83);
	  }

	  getVelocityLimit() {
	    this._assertOpen();

	    if (this.data.velocityLimit === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.velocityLimit * this.data.rescaleFactor;
	  }

	  getStallVelocity() {
	    this._assertOpen();

	    if (this.data.stallVelocity === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.stallVelocity * this.data.rescaleFactor;
	  }

	  async setStallVelocity(stallVelocity) {
	    this._assertOpen();

	    const calcVelocity = stallVelocity / this.data.rescaleFactor;
	    if (calcVelocity < this.data.minStallVelocity || calcVelocity > this.data.maxStallVelocity) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.minStallVelocity + " - " + this.maxStallVelocity + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: calcVelocity
	    });
	    await bp.send(this._ch, 141);
	  }

	  async setVelocityLimit(velocityLimit) {
	    this._assertOpen();

	    const calcLimit = velocityLimit / this.data.rescaleFactor;
	    if (calcLimit < this.data.minVelocityLimit || calcLimit > this.data.maxVelocityLimit) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.minVelocityLimit + " - " + this.maxVelocityLimit + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: calcLimit
	    });
	    await bp.send(this._ch, 55);
	  }

	  getMinStallVelocity() {
	    this._assertOpen();

	    if (this.data.minStallVelocity === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minStallVelocity * this.data.rescaleFactor;
	  }

	  getMaxStallVelocity() {
	    this._assertOpen();

	    if (this.data.maxStallVelocity === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxStallVelocity * this.data.rescaleFactor;
	  }

	  getMinVelocityLimit() {
	    this._assertOpen();

	    if (this.data.minVelocityLimit === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minVelocityLimit * this.data.rescaleFactor;
	  }

	  getMaxVelocityLimit() {
	    this._assertOpen();

	    if (this.data.maxVelocityLimit === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxVelocityLimit * this.data.rescaleFactor;
	  }

	}

	class BLDCMotorBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onBrakingStrengthChange = null;
	    this.onPositionChange = null;
	    this.onVelocityUpdate = null;
	    this._class = exports.ChannelClass.BLDC_MOTOR;
	    this.name = "BLDCMotor";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 40:
	        this.data.acceleration = bp.entries[0].v;

	        this._FIREPropertyChange('Acceleration', bp);

	        break;

	      case 54:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.entries[1].v;else this.data.dataInterval = bp.entries[0].v;

	        this._FIREPropertyChange('DataInterval', bp);

	        this._FIREPropertyChange('DataRate', bp);

	        break;

	      case 146:
	        break;

	      case 147:
	        break;

	      case 141:
	        this.data.stallVelocity = bp.entries[0].v;

	        this._FIREPropertyChange('StallVelocity', bp);

	        break;

	      case 44:
	        this.data.targetBrakingStrength = bp.entries[0].v;

	        this._FIREPropertyChange('TargetBrakingStrength', bp);

	        break;

	      case 55:
	        this.data.targetVelocity = bp.entries[0].v;

	        this._FIREPropertyChange('TargetVelocity', bp);

	        break;

	      case 121:
	        {
	          this.data.brakingStrength = bp.entries[0].v;

	          if (this._isAttachedDone && this.onBrakingStrengthChange) {
	            try {
	              this.onBrakingStrengthChange(this.data.brakingStrength);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      case 16:
	        {
	          this.data.velocity = bp.entries[0].v;

	          if (this._isAttachedDone && this.onVelocityUpdate) {
	            try {
	              this.onVelocityUpdate(this.data.velocity);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      positionOffset: 0,
	      dataInterval: 1e+300,
	      minDataInterval: 4294967295,
	      maxDataInterval: 4294967295,
	      minDataRate: 1e+300,
	      maxDataRate: 1e+300,
	      acceleration: 1e+300,
	      targetBrakingStrength: 1e+300,
	      maxAcceleration: 1e+300,
	      maxBrakingStrength: 1e+300,
	      maxVelocity: 1e+300,
	      maxPosition: 9223372036854776000,
	      minVelocity: 1e+300,
	      minAcceleration: 1e+300,
	      minBrakingStrength: 1e+300,
	      minPosition: 9223372036854776000,
	      position: 9223372036854776000,
	      rescaleFactor: 1e+300,
	      targetVelocity: 1e+300,
	      velocity: 1e+300,
	      brakingStrength: 1e+300,
	      stallVelocity: 1e+300,
	      minStallVelocity: 1e+300,
	      maxStallVelocity: 1e+300,
	      maxFailsafeTime: 4294967295,
	      minFailsafeTime: 4294967295
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 283:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 100;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.acceleration = 1;
	        this.data.targetBrakingStrength = 0;
	        this.data.maxAcceleration = 100;
	        this.data.maxBrakingStrength = 1;
	        this.data.maxVelocity = 1;
	        this.data.maxPosition = 1000000000000000;
	        this.data.minVelocity = 0;
	        this.data.minAcceleration = 0.1;
	        this.data.minBrakingStrength = 0;
	        this.data.minPosition = -1000000000000000;
	        this.data.position = 0;
	        this.data.rescaleFactor = 1;
	        this.data.stallVelocity = 400;
	        this.data.minStallVelocity = 0;
	        this.data.maxStallVelocity = 2000;
	        break;

	      case 286:
	        this.data.dataInterval = 250;
	        this.data.minDataInterval = 100;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.acceleration = 1;
	        this.data.targetBrakingStrength = 0;
	        this.data.maxAcceleration = 100;
	        this.data.maxBrakingStrength = 1;
	        this.data.maxVelocity = 1;
	        this.data.maxPosition = 1000000000000000;
	        this.data.minVelocity = 0;
	        this.data.minAcceleration = 0.1;
	        this.data.minBrakingStrength = 0;
	        this.data.minPosition = -1000000000000000;
	        this.data.position = 0;
	        this.data.rescaleFactor = 1;
	        this.data.stallVelocity = 400;
	        this.data.minStallVelocity = 0;
	        this.data.maxStallVelocity = 2000;
	        this.data.maxFailsafeTime = 30000;
	        this.data.minFailsafeTime = 500;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    let bp;

	    switch (this._ch.chDef.uid) {
	      case 283:
	      case 286:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.acceleration
	        });
	        await bp.send(this._ch, 40);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.targetBrakingStrength
	        });
	        await bp.send(this._ch, 44);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.stallVelocity
	        });
	        await bp.send(this._ch, 141);
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    if (this.data.brakingStrength == 1e+300 && !this._gotBrakingStrengthChangeErrorEvent) return false;
	    if (this.data.velocity == 1e+300 && !this._gotVelocityUpdateErrorEvent) return false;
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {
	    if (this.data.brakingStrength != 1e+300) if (this.onBrakingStrengthChange) try {
	      this.onBrakingStrengthChange(this.data.brakingStrength);
	    } catch (err) {
	      logEventException(err);
	    }
	    if (this.data.velocity != 1e+300) if (this.onVelocityUpdate) try {
	      this.onVelocityUpdate(this.data.velocity);
	    } catch (err) {
	      logEventException(err);
	    }
	  }
	  /**
	   * The rate at which the controller can change the motor's `velocity`.
	   *
	   * *   The acceleration is bounded by `minAcceleration` and `maxAcceleration`
	   * @throws {@link PhidgetError}
	   */


	  get acceleration() {
	    return this.getAcceleration();
	  }
	  /**
	   * The minimum value that `acceleration` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minAcceleration() {
	    return this.getMinAcceleration();
	  }
	  /**
	   * The maximum value that `acceleration` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxAcceleration() {
	    return this.getMaxAcceleration();
	  }
	  /**
	   * The most recent braking strength value that the controller has reported.
	   * @throws {@link PhidgetError}
	   */


	  get brakingStrength() {
	    return this.getBrakingStrength();
	  }
	  /**
	   * The minimum value that `targetBrakingStrength` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minBrakingStrength() {
	    return this.getMinBrakingStrength();
	  }
	  /**
	   * The maximum value that `targetBrakingStrength` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxBrakingStrength() {
	    return this.getMaxBrakingStrength();
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `VelocityUpdate` / `PositionChange` / `BrakingStrengthChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * @throws {@link PhidgetError}
	   */


	  get dataInterval() {
	    return this.getDataInterval();
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataInterval() {
	    return this.getMinDataInterval();
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataInterval() {
	    return this.getMaxDataInterval();
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   */


	  get dataRate() {
	    return this.getDataRate();
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataRate() {
	    return this.getMinDataRate();
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataRate() {
	    return this.getMaxDataRate();
	  }
	  /**
	   * The minimum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @throws {@link PhidgetError}
	   */


	  get minFailsafeTime() {
	    return this.getMinFailsafeTime();
	  }
	  /**
	   * The maximum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @throws {@link PhidgetError}
	   */


	  get maxFailsafeTime() {
	    return this.getMaxFailsafeTime();
	  }
	  /**
	   * The most recent position value that the controller has reported.
	   *
	   * *   Position values are calculated using Hall Effect sensors mounted on the motor, therefore, the resolution of position depends on the motor you are using.
	   * *   Units for `position` can be set by the user through the `rescaleFactor`. The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees. For more information on how to apply the `rescaleFactor` to your application, see your controller's User Guide.
	   * @throws {@link PhidgetError}
	   */


	  get position() {
	    return this.getPosition();
	  }
	  /**
	   * The lower bound of `position`.
	   * @throws {@link PhidgetError}
	   */


	  get minPosition() {
	    return this.getMinPosition();
	  }
	  /**
	   * The upper bound of `position`.
	   * @throws {@link PhidgetError}
	   */


	  get maxPosition() {
	    return this.getMaxPosition();
	  }
	  /**
	   * Change the units of your parameters so that your application is more intuitive.
	   *
	   * *   Units for `position` can be set by the user through the `rescaleFactor`. The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees. For more information on how to apply the `rescaleFactor` to your application, see your controller's User Guide.
	   * @throws {@link PhidgetError}
	   */


	  get rescaleFactor() {
	    return this.getRescaleFactor();
	  }

	  set rescaleFactor(rescaleFactor) {
	    this.setRescaleFactor(rescaleFactor);
	  }
	  /**
	   * Before reading this description, it is important to note the difference between the units of `stallVelocity` and `velocity`.
	   *
	   * *   `velocity` is a number between -1 and 1 with units of 'duty cycle'. It simply represents the average voltage across the motor.
	   * *   `stallVelocity` represents a real velocity (e.g. m/s, RPM, etc.) and the units are determined by the `rescaleFactor`. With a `rescaleFactor` of 1, the default units would be in commutations per second.
	   *
	   * If the load on your motor is large, your motor may begin rotating more slowly, or even fully stall. Depending on the voltage across your motor, this may result in a large amount of current through both the controller and the motor. In order to prevent damage in these situations, you can use the `stallVelocity` property.
	   *
	   * The `stallVelocity` should be set to the lowest velocity you would expect from your motor. The controller will then monitor the motor's velocity, as well as the `velocity`, and prevent a 'dangerous stall' from occuring. If the controller detects a dangerous stall, it will immediately reduce the `velocity` (i.e. average voltage) to 0 and an error will be reported to your program.
	   *
	   * *   A 'dangerous stall' will occur faster when the `velocity` is higher (i.e. when the average voltage across the motor is higher)
	   * *   A 'dangerous stall' will occur faster as (`stallVelocity` - motor velocity) becomes larger .
	   *
	   * Setting `stallVelocity` to 0 will turn off stall protection functionality.
	   * @throws {@link PhidgetError}
	   */


	  get stallVelocity() {
	    return this.getStallVelocity();
	  }
	  /**
	   * The lower bound of `stallVelocity`.
	   * @throws {@link PhidgetError}
	   */


	  get minStallVelocity() {
	    return this.getMinStallVelocity();
	  }
	  /**
	   * The upper bound of `stallVelocity`.
	   * @throws {@link PhidgetError}
	   */


	  get maxStallVelocity() {
	    return this.getMaxStallVelocity();
	  }
	  /**
	   * When a motor is not being actively driven forward or reverse, you can choose if the motor will be allowed to freely turn, or will resist being turned.
	   *
	   * *   A low `targetBrakingStrength` value corresponds to free wheeling, this will have the following effects:
	   *     *   The motor will continue to rotate after the controller is no longer driving the motor (i.e. `velocity` is 0), due to inertia.
	   *     *   The motor shaft will provide little resistance to being turned when it is stopped.
	   * *   A higher `targetBrakingStrength` value will resist being turned, this will have the following effects:
	   *     *   The motor will more stop more quickly if it is in motion and braking has been requested. It will fight against the rotation of the shaft.
	   * *   Braking mode is enabled by setting the `velocity` to `minVelocity`
	   * @throws {@link PhidgetError}
	   */


	  get targetBrakingStrength() {
	    return this.getTargetBrakingStrength();
	  }
	  /**
	   * The average voltage across the motor is based on the `targetVelocity` value.
	   *
	   * *   At a constant load, increasing the target velocity will increase the speed of the motor.
	   * *   `targetVelocity` is bounded by -`maxVelocity` and +`maxVelocity`, where a sign change (Â±) is indicitave of a direction change.
	   * *   Setting `targetVelocity` to `minVelocity` will stop the motor. See `targetBrakingStrength` for more information on stopping the motor.
	   * *   The units of `targetVelocity` and `acceleration` refer to 'duty cycle'. This is because the controller must rapidly switch the power on/off (i.e. change the duty cycle) in order to manipulate the voltage across the motor.
	   * @throws {@link PhidgetError}
	   */


	  get targetVelocity() {
	    return this.getTargetVelocity();
	  }
	  /**
	   * The most recent velocity value that the controller has reported.
	   * @throws {@link PhidgetError}
	   */


	  get velocity() {
	    return this.getVelocity();
	  }
	  /**
	   * The minimum value that `targetVelocity` can be set to.
	   *
	   * *   Set the `targetVelocity` to `minVelocity` to stop the motor. See `targetBrakingStrength` for more information on stopping the motor.
	   * *   `targetVelocity` is bounded by -`maxVelocity` and +`maxVelocity`, where a sign change (Â±) is indicitave of a direction change.
	   * @throws {@link PhidgetError}
	   */


	  get minVelocity() {
	    return this.getMinVelocity();
	  }
	  /**
	   * The maximum value that `targetVelocity` can be set to.
	   *
	   * *   `targetVelocity` is bounded by -`maxVelocity` and +`maxVelocity`, where a sign change (Â±) is indicitave of a direction change.
	   * @throws {@link PhidgetError}
	   */


	  get maxVelocity() {
	    return this.getMaxVelocity();
	  }
	  /**
	   * The rate at which the controller can change the motor's `velocity`.
	   *
	   * *   The acceleration is bounded by `minAcceleration` and `maxAcceleration`
	   * @returns The acceleration value
	   * @throws {@link PhidgetError}
	   */


	  getAcceleration() {
	    this._assertOpen();

	    if (this.data.acceleration === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.acceleration;
	  }
	  /**
	   * The rate at which the controller can change the motor's `velocity`.
	   *
	   * *   The acceleration is bounded by `minAcceleration` and `maxAcceleration`
	   * @throws {@link PhidgetError}
	   * @param acceleration - The acceleration value
	   */


	  async setAcceleration(acceleration) {
	    this._assertOpen();

	    if (acceleration < this.data.minAcceleration || acceleration > this.data.maxAcceleration) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minAcceleration + " - " + this.data.maxAcceleration + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: acceleration
	    });
	    await bp.send(this._ch, 40);
	  }
	  /**
	   * The minimum value that `acceleration` can be set to.
	   * @returns The acceleration value.
	   * @throws {@link PhidgetError}
	   */


	  getMinAcceleration() {
	    this._assertOpen();

	    if (this.data.minAcceleration === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minAcceleration;
	  }
	  /**
	   * The maximum value that `acceleration` can be set to.
	   * @returns The acceleration value.
	   * @throws {@link PhidgetError}
	   */


	  getMaxAcceleration() {
	    this._assertOpen();

	    if (this.data.maxAcceleration === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxAcceleration;
	  }
	  /**
	   * The most recent braking strength value that the controller has reported.
	   * @returns The braking strength value
	   * @throws {@link PhidgetError}
	   */


	  getBrakingStrength() {
	    this._assertOpen();

	    if (this.data.brakingStrength === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.brakingStrength;
	  }
	  /**
	   * The minimum value that `targetBrakingStrength` can be set to.
	   * @returns The braking value
	   * @throws {@link PhidgetError}
	   */


	  getMinBrakingStrength() {
	    this._assertOpen();

	    if (this.data.minBrakingStrength === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minBrakingStrength;
	  }
	  /**
	   * The maximum value that `targetBrakingStrength` can be set to.
	   * @returns The braking value
	   * @throws {@link PhidgetError}
	   */


	  getMaxBrakingStrength() {
	    this._assertOpen();

	    if (this.data.maxBrakingStrength === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxBrakingStrength;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `VelocityUpdate` / `PositionChange` / `BrakingStrengthChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getDataInterval() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dataInterval;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `VelocityUpdate` / `PositionChange` / `BrakingStrengthChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * @throws {@link PhidgetError}
	   * @param dataInterval - The data interval value
	   */


	  async setDataInterval(dataInterval) {
	    this._assertOpen();

	    if (dataInterval < this.data.minDataInterval || dataInterval > this.data.maxDataInterval) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataInterval + " - " + this.data.maxDataInterval + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: dataInterval
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataInterval() {
	    this._assertOpen();

	    if (this.data.minDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataInterval;
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataInterval() {
	    this._assertOpen();

	    if (this.data.maxDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @returns The data rate for the channel
	   * @throws {@link PhidgetError}
	   */


	  getDataRate() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return 1000.0 / this.data.dataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   * @param dataRate - The data rate for the channel
	   */


	  async setDataRate(dataRate) {
	    this._assertOpen();

	    if (dataRate < this.data.minDataRate || dataRate > this.data.maxDataRate) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataRate + " - " + this.data.maxDataRate + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: Math.round(1000.0 / dataRate)
	    });
	    bp.set({
	      name: "1",
	      type: "g",
	      value: 1000.0 / dataRate
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataRate() {
	    this._assertOpen();

	    if (this.data.minDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataRate;
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataRate() {
	    this._assertOpen();

	    if (this.data.maxDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataRate;
	  }
	  /**
	   * Enables the **failsafe** feature for the channel, with a given **failsafe time**.
	   *
	   * The **failsafe** feature is intended for use in applications where it is important for the channel to enter a known _safe state_ if the program controlling it locks up or crashes. If you do not enable the failsafe feature, the channel will carry out whatever instructions it was last given until it is explicitly told to stop.
	   *
	   * Enabling the failsafe feature starts a recurring **failsafe timer** for the channel. Once the failsafe timer is enabled, it must be reset within the specified time or the channel will enter a **failsafe state**. The failsafe timer may be reset by sending any valid command to the device\*. Resetting the failsafe timer will reload the timer with the specified _failsafe time_, starting when the message to reset the timer is received by the Phidget.
	   *
	   * _\*(**get** requests do not typically send commands and won't reset the failsafe timer)_
	   *
	   * For example: if the failsafe is enabled with a **failsafe time** of 1000ms, you will have 1000ms to reset the failsafe timer. Every time the failsafe timer is reset, you will have 1000ms from that time to reset the failsafe again.
	   *
	   * If the failsafe timer is not reset before it runs out, the channel will enter a **failsafe state**. For BLDC Motor channels, this will disengage the motor. Once the channel enters the **failsafe state**, it will reject any further input until the channel is reopened.
	   *
	   * To prevent the channel from falsely entering the failsafe state, we recommend resetting the failsafe timer as frequently as is practical for your application. A good rule of thumb is to not let more than a third of the failsafe time pass before resetting the timer.
	   *
	   * Once the failsafe timer has been set, it cannot be disabled by any means other than closing and reopening the channel.
	   * @throws {@link PhidgetError}
	   * @param failsafeTime - Failsafe timeout in milliseconds
	   */


	  async enableFailsafe(failsafeTime) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: failsafeTime
	    });
	    await bp.send(this._ch, 146);
	  }
	  /**
	   * The minimum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @returns The failsafe time
	   * @throws {@link PhidgetError}
	   */


	  getMinFailsafeTime() {
	    this._assertOpen();

	    if (this.data.minFailsafeTime === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minFailsafeTime;
	  }
	  /**
	   * The maximum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @returns The failsafe time
	   * @throws {@link PhidgetError}
	   */


	  getMaxFailsafeTime() {
	    this._assertOpen();

	    if (this.data.maxFailsafeTime === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxFailsafeTime;
	  }
	  /**
	   * Change the units of your parameters so that your application is more intuitive.
	   *
	   * *   Units for `position` can be set by the user through the `rescaleFactor`. The `rescaleFactor` allows you to use more intuitive units such as rotations, or degrees. For more information on how to apply the `rescaleFactor` to your application, see your controller's User Guide.
	   * @returns The rescale factor value
	   * @throws {@link PhidgetError}
	   */


	  getRescaleFactor() {
	    this._assertOpen();

	    if (this.data.rescaleFactor === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.rescaleFactor;
	  }
	  /**
	   * Resets the failsafe timer, if one has been set. See `enableFailsafe()` for details.
	   *
	   * This function will fail if no failsafe timer has been set for the channel.
	   * @throws {@link PhidgetError}
	   */


	  async resetFailsafe() {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    await bp.send(this._ch, 147);
	  }
	  /**
	   * When a motor is not being actively driven forward or reverse, you can choose if the motor will be allowed to freely turn, or will resist being turned.
	   *
	   * *   A low `targetBrakingStrength` value corresponds to free wheeling, this will have the following effects:
	   *     *   The motor will continue to rotate after the controller is no longer driving the motor (i.e. `velocity` is 0), due to inertia.
	   *     *   The motor shaft will provide little resistance to being turned when it is stopped.
	   * *   A higher `targetBrakingStrength` value will resist being turned, this will have the following effects:
	   *     *   The motor will more stop more quickly if it is in motion and braking has been requested. It will fight against the rotation of the shaft.
	   * *   Braking mode is enabled by setting the `velocity` to `minVelocity`
	   * @returns The braking value
	   * @throws {@link PhidgetError}
	   */


	  getTargetBrakingStrength() {
	    this._assertOpen();

	    if (this.data.targetBrakingStrength === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.targetBrakingStrength;
	  }
	  /**
	   * When a motor is not being actively driven forward or reverse, you can choose if the motor will be allowed to freely turn, or will resist being turned.
	   *
	   * *   A low `targetBrakingStrength` value corresponds to free wheeling, this will have the following effects:
	   *     *   The motor will continue to rotate after the controller is no longer driving the motor (i.e. `velocity` is 0), due to inertia.
	   *     *   The motor shaft will provide little resistance to being turned when it is stopped.
	   * *   A higher `targetBrakingStrength` value will resist being turned, this will have the following effects:
	   *     *   The motor will more stop more quickly if it is in motion and braking has been requested. It will fight against the rotation of the shaft.
	   * *   Braking mode is enabled by setting the `velocity` to `minVelocity`
	   * @throws {@link PhidgetError}
	   * @param targetBrakingStrength - The braking value
	   */


	  async setTargetBrakingStrength(targetBrakingStrength) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: targetBrakingStrength
	    });
	    await bp.send(this._ch, 44);
	  }
	  /**
	   * The average voltage across the motor is based on the `targetVelocity` value.
	   *
	   * *   At a constant load, increasing the target velocity will increase the speed of the motor.
	   * *   `targetVelocity` is bounded by -`maxVelocity` and +`maxVelocity`, where a sign change (Â±) is indicitave of a direction change.
	   * *   Setting `targetVelocity` to `minVelocity` will stop the motor. See `targetBrakingStrength` for more information on stopping the motor.
	   * *   The units of `targetVelocity` and `acceleration` refer to 'duty cycle'. This is because the controller must rapidly switch the power on/off (i.e. change the duty cycle) in order to manipulate the voltage across the motor.
	   * @returns The velocity value
	   * @throws {@link PhidgetError}
	   */


	  getTargetVelocity() {
	    this._assertOpen();

	    if (this.data.targetVelocity === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.targetVelocity;
	  }
	  /**
	   * The average voltage across the motor is based on the `targetVelocity` value.
	   *
	   * *   At a constant load, increasing the target velocity will increase the speed of the motor.
	   * *   `targetVelocity` is bounded by -`maxVelocity` and +`maxVelocity`, where a sign change (Â±) is indicitave of a direction change.
	   * *   Setting `targetVelocity` to `minVelocity` will stop the motor. See `targetBrakingStrength` for more information on stopping the motor.
	   * *   The units of `targetVelocity` and `acceleration` refer to 'duty cycle'. This is because the controller must rapidly switch the power on/off (i.e. change the duty cycle) in order to manipulate the voltage across the motor.
	   * @throws {@link PhidgetError}
	   * @param targetVelocity - The velocity value
	   */


	  async setTargetVelocity(targetVelocity) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: targetVelocity
	    });
	    await bp.send(this._ch, 55);
	  }
	  /**
	   * The most recent velocity value that the controller has reported.
	   * @returns The velocity value
	   * @throws {@link PhidgetError}
	   */


	  getVelocity() {
	    this._assertOpen();

	    if (this.data.velocity === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.velocity;
	  }
	  /**
	   * The minimum value that `targetVelocity` can be set to.
	   *
	   * *   Set the `targetVelocity` to `minVelocity` to stop the motor. See `targetBrakingStrength` for more information on stopping the motor.
	   * *   `targetVelocity` is bounded by -`maxVelocity` and +`maxVelocity`, where a sign change (Â±) is indicitave of a direction change.
	   * @returns The velocity value
	   * @throws {@link PhidgetError}
	   */


	  getMinVelocity() {
	    this._assertOpen();

	    if (this.data.minVelocity === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minVelocity;
	  }
	  /**
	   * The maximum value that `targetVelocity` can be set to.
	   *
	   * *   `targetVelocity` is bounded by -`maxVelocity` and +`maxVelocity`, where a sign change (Â±) is indicitave of a direction change.
	   * @returns The velocity value
	   * @throws {@link PhidgetError}
	   */


	  getMaxVelocity() {
	    this._assertOpen();

	    if (this.data.maxVelocity === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxVelocity;
	  }

	}

	/** @public */

	class BLDCMotor extends BLDCMotorBase {
	  /** @internal */
	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 29:
	        this.data.position = bp.getNumber(0);

	        if (this._isAttachedDone && this.onPositionChange) {
	          try {
	            this.onPositionChange((this.data.position + this.data.positionOffset) * this.data.rescaleFactor);
	          } catch (err) {
	            logEventException(err);
	          }
	        }

	        break;

	      default:
	        super._bridgeInput(bp);

	        break;
	    }
	  }

	  setRescaleFactor(rescaleFactor) {
	    this._assertOpen();

	    this.data.rescaleFactor = rescaleFactor;
	  }

	  getPosition() {
	    this._assertOpen();

	    if (this.data.position === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.position * this.data.rescaleFactor;
	  }

	  getMinPosition() {
	    this._assertOpen();

	    if (this.data.minPosition === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return (this.data.minPosition + this.data.positionOffset) * this.data.rescaleFactor;
	  }

	  getMaxPosition() {
	    this._assertOpen();

	    if (this.data.maxPosition === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return (this.data.maxPosition + this.data.positionOffset) * this.data.rescaleFactor;
	  }

	  addPositionOffset(positionOffset) {
	    this._assertOpen();

	    this.data.positionOffset += positionOffset / this.data.rescaleFactor;
	  }

	  async setStallVelocity(stallVelocity) {
	    this._assertOpen();

	    const calcVelocity = stallVelocity / this.data.rescaleFactor;
	    if (calcVelocity < this.data.minStallVelocity || calcVelocity > this.data.maxStallVelocity) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.minStallVelocity + " - " + this.maxStallVelocity + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: calcVelocity
	    });
	    await bp.send(this._ch, 141);
	  }

	  getStallVelocity() {
	    this._assertOpen();

	    if (this.data.stallVelocity === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.stallVelocity * this.data.rescaleFactor;
	  }

	  getMinStallVelocity() {
	    this._assertOpen();

	    if (this.data.minStallVelocity === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minStallVelocity * this.data.rescaleFactor;
	  }

	  getMaxStallVelocity() {
	    this._assertOpen();

	    if (this.data.maxStallVelocity === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxStallVelocity * this.data.rescaleFactor;
	  }

	}

	class DistanceSensorBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onDistanceChange = null;
	    this.onSonarReflectionsUpdate = null;
	    this._class = exports.ChannelClass.DISTANCE_SENSOR;
	    this.name = "DistanceSensor";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 54:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.entries[1].v;else this.data.dataInterval = bp.entries[0].v;

	        this._FIREPropertyChange('DataInterval', bp);

	        this._FIREPropertyChange('DataRate', bp);

	        break;

	      case 46:
	        this.data.distanceChangeTrigger = bp.entries[0].v;

	        this._FIREPropertyChange('DistanceChangeTrigger', bp);

	        break;

	      case 75:
	        this.data.sonarQuietMode = bp.entries[0].v;

	        this._FIREPropertyChange('SonarQuietMode', bp);

	        break;

	      case 12:
	        {
	          this.data.distance = bp.entries[0].v;

	          if (this._isAttachedDone && this.onDistanceChange) {
	            try {
	              this.onDistanceChange(this.data.distance);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      case 88:
	        {
	          if (this._isAttachedDone && this.onSonarReflectionsUpdate) {
	            try {
	              this.onSonarReflectionsUpdate(bp.entries[0].v, bp.entries[1].v, bp.entries[2].v);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      amplitudes: [4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295],
	      distances: [4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295],
	      count: 0,
	      dataInterval: 1e+300,
	      maxDataInterval: 4294967295,
	      minDataRate: 1e+300,
	      maxDataRate: 1e+300,
	      maxDistance: 4294967295,
	      maxDistanceChangeTrigger: 4294967295,
	      minDataInterval: 4294967295,
	      minDistance: 4294967295,
	      minDistanceChangeTrigger: 4294967295,
	      distance: 4294967295,
	      distanceChangeTrigger: 4294967295,
	      sonarQuietMode: 2
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 289:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.maxDistance = 200;
	        this.data.maxDistanceChangeTrigger = 200;
	        this.data.minDataInterval = 100;
	        this.data.minDistance = 0;
	        this.data.minDistanceChangeTrigger = 0;
	        this.data.distanceChangeTrigger = 0;
	        break;

	      case 290:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 33.333333333333336;
	        this.data.maxDistance = 650;
	        this.data.maxDistanceChangeTrigger = 650;
	        this.data.minDataInterval = 30;
	        this.data.minDistance = 0;
	        this.data.minDistanceChangeTrigger = 0;
	        this.data.distanceChangeTrigger = 0;
	        break;

	      case 291:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 33.333333333333336;
	        this.data.maxDistance = 1300;
	        this.data.maxDistanceChangeTrigger = 1300;
	        this.data.minDataInterval = 30;
	        this.data.minDistance = 0;
	        this.data.minDistanceChangeTrigger = 0;
	        this.data.distanceChangeTrigger = 0;
	        break;

	      case 292:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.maxDistance = 10000;
	        this.data.maxDistanceChangeTrigger = 10000;
	        this.data.minDataInterval = 100;
	        this.data.minDistance = 40;
	        this.data.minDistanceChangeTrigger = 0;
	        this.data.distanceChangeTrigger = 0;
	        this.data.sonarQuietMode = 1;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    let bp;

	    switch (this._ch.chDef.uid) {
	      case 289:
	      case 290:
	      case 291:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: this.data.distanceChangeTrigger
	        });
	        await bp.send(this._ch, 46);
	        break;

	      case 292:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: this.data.distanceChangeTrigger
	        });
	        await bp.send(this._ch, 46);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.sonarQuietMode
	        });
	        await bp.send(this._ch, 75);
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    if (this.data.distance == 4294967295 && !this._gotDistanceChangeErrorEvent) return false;
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {
	    if (this.data.distance != 4294967295) if (this.onDistanceChange) try {
	      this.onDistanceChange(this.data.distance);
	    } catch (err) {
	      logEventException(err);
	    }
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between events can also be affected by the `distanceChangeTrigger`.
	   * @throws {@link PhidgetError}
	   */


	  get dataInterval() {
	    return this.getDataInterval();
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataInterval() {
	    return this.getMinDataInterval();
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataInterval() {
	    return this.getMaxDataInterval();
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   */


	  get dataRate() {
	    return this.getDataRate();
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataRate() {
	    return this.getMinDataRate();
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataRate() {
	    return this.getMaxDataRate();
	  }
	  /**
	   * The most recent distance value that the channel has reported.
	   *
	   * *   This value will always be between `minDistance` and `maxDistance`.
	   * @throws {@link PhidgetError}
	   */


	  get distance() {
	    return this.getDistance();
	  }
	  /**
	   * The minimum distance that a event will report.
	   * @throws {@link PhidgetError}
	   */


	  get minDistance() {
	    return this.getMinDistance();
	  }
	  /**
	   * The maximum distance that a event will report.
	   * @throws {@link PhidgetError}
	   */


	  get maxDistance() {
	    return this.getMaxDistance();
	  }
	  /**
	   * The channel will not issue an event until the distance value has changed by the amount specified by the `distanceChangeTrigger`.
	   *
	   * *   Setting the `distanceChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering,
	   * @throws {@link PhidgetError}
	   */


	  get distanceChangeTrigger() {
	    return this.getDistanceChangeTrigger();
	  }
	  /**
	   * The minimum value that `distanceChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDistanceChangeTrigger() {
	    return this.getMinDistanceChangeTrigger();
	  }
	  /**
	   * The maximum value that `distanceChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDistanceChangeTrigger() {
	    return this.getMaxDistanceChangeTrigger();
	  }
	  /**
	   * When set to true, the device will operate more quietly.
	   *
	   * *   The measurable range is reduced when operating in quiet mode.
	   * @throws {@link PhidgetError}
	   */


	  get sonarQuietMode() {
	    return this.getSonarQuietMode();
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between events can also be affected by the `distanceChangeTrigger`.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getDataInterval() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dataInterval;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between events can also be affected by the `distanceChangeTrigger`.
	   * @throws {@link PhidgetError}
	   * @param dataInterval - The data interval value
	   */


	  async setDataInterval(dataInterval) {
	    this._assertOpen();

	    if (dataInterval < this.data.minDataInterval || dataInterval > this.data.maxDataInterval) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataInterval + " - " + this.data.maxDataInterval + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: dataInterval
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataInterval() {
	    this._assertOpen();

	    if (this.data.minDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataInterval;
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataInterval() {
	    this._assertOpen();

	    if (this.data.maxDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @returns The data rate for the channel
	   * @throws {@link PhidgetError}
	   */


	  getDataRate() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return 1000.0 / this.data.dataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   * @param dataRate - The data rate for the channel
	   */


	  async setDataRate(dataRate) {
	    this._assertOpen();

	    if (dataRate < this.data.minDataRate || dataRate > this.data.maxDataRate) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataRate + " - " + this.data.maxDataRate + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: Math.round(1000.0 / dataRate)
	    });
	    bp.set({
	      name: "1",
	      type: "g",
	      value: 1000.0 / dataRate
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataRate() {
	    this._assertOpen();

	    if (this.data.minDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataRate;
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataRate() {
	    this._assertOpen();

	    if (this.data.maxDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataRate;
	  }
	  /**
	   * The most recent distance value that the channel has reported.
	   *
	   * *   This value will always be between `minDistance` and `maxDistance`.
	   * @returns The distance value
	   * @throws {@link PhidgetError}
	   */


	  getDistance() {
	    this._assertOpen();

	    if (this.data.distance === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    if (this.data.distance > this.data.maxDistance) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE_HIGH);
	    if (this.data.distance < this.data.minDistance) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE_LOW);
	    return this.data.distance;
	  }
	  /**
	   * The minimum distance that a event will report.
	   * @returns The distance value
	   * @throws {@link PhidgetError}
	   */


	  getMinDistance() {
	    this._assertOpen();

	    if (this.data.minDistance === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDistance;
	  }
	  /**
	   * The maximum distance that a event will report.
	   * @returns The distance value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDistance() {
	    this._assertOpen();

	    if (this.data.maxDistance === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDistance;
	  }
	  /**
	   * The channel will not issue an event until the distance value has changed by the amount specified by the `distanceChangeTrigger`.
	   *
	   * *   Setting the `distanceChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering,
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getDistanceChangeTrigger() {
	    this._assertOpen();

	    if (this.data.distanceChangeTrigger === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.distanceChangeTrigger;
	  }
	  /**
	   * The channel will not issue an event until the distance value has changed by the amount specified by the `distanceChangeTrigger`.
	   *
	   * *   Setting the `distanceChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering,
	   * @throws {@link PhidgetError}
	   * @param distanceChangeTrigger - The change trigger value
	   */


	  async setDistanceChangeTrigger(distanceChangeTrigger) {
	    this._assertOpen();

	    if (distanceChangeTrigger < this.data.minDistanceChangeTrigger || distanceChangeTrigger > this.data.maxDistanceChangeTrigger) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDistanceChangeTrigger + " - " + this.data.maxDistanceChangeTrigger + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: distanceChangeTrigger
	    });
	    await bp.send(this._ch, 46);
	  }
	  /**
	   * The minimum value that `distanceChangeTrigger` can be set to.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMinDistanceChangeTrigger() {
	    this._assertOpen();

	    if (this.data.minDistanceChangeTrigger === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDistanceChangeTrigger;
	  }
	  /**
	   * The maximum value that `distanceChangeTrigger` can be set to.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDistanceChangeTrigger() {
	    this._assertOpen();

	    if (this.data.maxDistanceChangeTrigger === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDistanceChangeTrigger;
	  }
	  /**
	   * When set to true, the device will operate more quietly.
	   *
	   * *   The measurable range is reduced when operating in quiet mode.
	   * @returns The quiet mode value
	   * @throws {@link PhidgetError}
	   */


	  getSonarQuietMode() {
	    this._assertOpen();

	    if (this.data.sonarQuietMode === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.sonarQuietMode;
	  }
	  /**
	   * When set to true, the device will operate more quietly.
	   *
	   * *   The measurable range is reduced when operating in quiet mode.
	   * @throws {@link PhidgetError}
	   * @param sonarQuietMode - The quiet mode value
	   */


	  async setSonarQuietMode(sonarQuietMode) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (sonarQuietMode !== false && sonarQuietMode !== true) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be a boolean.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: sonarQuietMode ? 1 : 0
	    });
	    await bp.send(this._ch, 75);
	  }

	}

	/** @public */

	class DistanceSensor extends DistanceSensorBase {
	  /** @internal */
	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 88:
	        this.data.distances = bp.getArray(0);
	        this.data.amplitudes = bp.getArray(1);
	        this.data.count = bp.getNumber(2);

	        super._bridgeInput(bp);

	        break;

	      default:
	        super._bridgeInput(bp);

	        break;
	    }
	  }
	  /** @internal */


	  _errorHandler(code) {
	    switch (code) {
	      case exports.ErrorEventCode.SATURATION:
	      case exports.ErrorEventCode.OUT_OF_RANGE:
	        this.data.distance = 4294967295;
	        this._gotDistanceChangeErrorEvent = true;
	        break;
	    }
	  }

	  getSonarReflections() {
	    this._assertOpen();

	    return {
	      distances: this.data.distances,
	      amplitudes: this.data.amplitudes,
	      count: this.data.count
	    };
	  }

	}

	class HumiditySensorBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onHumidityChange = null;
	    this._class = exports.ChannelClass.HUMIDITY_SENSOR;
	    this.name = "HumiditySensor";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 54:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.entries[1].v;else this.data.dataInterval = bp.entries[0].v;

	        this._FIREPropertyChange('DataInterval', bp);

	        this._FIREPropertyChange('DataRate', bp);

	        break;

	      case 46:
	        this.data.humidityChangeTrigger = bp.entries[0].v;

	        this._FIREPropertyChange('HumidityChangeTrigger', bp);

	        break;

	      case 22:
	        {
	          this.data.humidity = bp.entries[0].v;

	          if (this._isAttachedDone && this.onHumidityChange) {
	            try {
	              this.onHumidityChange(this.data.humidity);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      dataInterval: 1e+300,
	      maxDataInterval: 4294967295,
	      minDataRate: 1e+300,
	      maxDataRate: 1e+300,
	      maxHumidity: 1e+300,
	      maxHumidityChangeTrigger: 1e+300,
	      minDataInterval: 4294967295,
	      minHumidity: 1e+300,
	      minHumidityChangeTrigger: 1e+300,
	      humidity: 1e+300,
	      humidityChangeTrigger: 1e+300
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 301:
	        this.data.dataInterval = 500;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 2;
	        this.data.maxHumidity = 100;
	        this.data.maxHumidityChangeTrigger = 100;
	        this.data.minDataInterval = 500;
	        this.data.minHumidity = 0;
	        this.data.minHumidityChangeTrigger = 0;
	        this.data.humidityChangeTrigger = 0;
	        break;

	      case 303:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 20;
	        this.data.maxHumidity = 100;
	        this.data.maxHumidityChangeTrigger = 100;
	        this.data.minDataInterval = 50;
	        this.data.minHumidity = 0;
	        this.data.minHumidityChangeTrigger = 0;
	        this.data.humidityChangeTrigger = 0;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    let bp;

	    switch (this._ch.chDef.uid) {
	      case 301:
	      case 303:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.humidityChangeTrigger
	        });
	        await bp.send(this._ch, 46);
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    if (this.data.humidity == 1e+300 && !this._gotHumidityChangeErrorEvent) return false;
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {
	    if (this.data.humidity != 1e+300) if (this.onHumidityChange) try {
	      this.onHumidityChange(this.data.humidity);
	    } catch (err) {
	      logEventException(err);
	    }
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `HumidityChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `HumidityChange` events can also be affected by the `humidityChangeTrigger`.
	   * @throws {@link PhidgetError}
	   */


	  get dataInterval() {
	    return this.getDataInterval();
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataInterval() {
	    return this.getMinDataInterval();
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataInterval() {
	    return this.getMaxDataInterval();
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   */


	  get dataRate() {
	    return this.getDataRate();
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataRate() {
	    return this.getMinDataRate();
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataRate() {
	    return this.getMaxDataRate();
	  }
	  /**
	   * The most recent humidity value that the channel has reported.
	   *
	   * *   This value will always be between `minHumidity` and `maxHumidity`.
	   * @throws {@link PhidgetError}
	   */


	  get humidity() {
	    return this.getHumidity();
	  }
	  /**
	   * The minimum value that the `HumidityChange` event will report.
	   * @throws {@link PhidgetError}
	   */


	  get minHumidity() {
	    return this.getMinHumidity();
	  }
	  /**
	   * The maximum value that the `HumidityChange` event will report.
	   * @throws {@link PhidgetError}
	   */


	  get maxHumidity() {
	    return this.getMaxHumidity();
	  }
	  /**
	   * The channel will not issue a `HumidityChange` event until the humidity value has changed by the amount specified by the `humidityChangeTrigger`.
	   *
	   * *   Setting the `humidityChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering.
	   * @throws {@link PhidgetError}
	   */


	  get humidityChangeTrigger() {
	    return this.getHumidityChangeTrigger();
	  }
	  /**
	   * The minimum value that `humidityChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minHumidityChangeTrigger() {
	    return this.getMinHumidityChangeTrigger();
	  }
	  /**
	   * The maximum value that `humidityChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxHumidityChangeTrigger() {
	    return this.getMaxHumidityChangeTrigger();
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `HumidityChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `HumidityChange` events can also be affected by the `humidityChangeTrigger`.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getDataInterval() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dataInterval;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `HumidityChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `HumidityChange` events can also be affected by the `humidityChangeTrigger`.
	   * @throws {@link PhidgetError}
	   * @param dataInterval - The data interval value
	   */


	  async setDataInterval(dataInterval) {
	    this._assertOpen();

	    if (dataInterval < this.data.minDataInterval || dataInterval > this.data.maxDataInterval) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataInterval + " - " + this.data.maxDataInterval + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: dataInterval
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataInterval() {
	    this._assertOpen();

	    if (this.data.minDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataInterval;
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataInterval() {
	    this._assertOpen();

	    if (this.data.maxDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @returns The data rate for the channel
	   * @throws {@link PhidgetError}
	   */


	  getDataRate() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return 1000.0 / this.data.dataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   * @param dataRate - The data rate for the channel
	   */


	  async setDataRate(dataRate) {
	    this._assertOpen();

	    if (dataRate < this.data.minDataRate || dataRate > this.data.maxDataRate) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataRate + " - " + this.data.maxDataRate + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: Math.round(1000.0 / dataRate)
	    });
	    bp.set({
	      name: "1",
	      type: "g",
	      value: 1000.0 / dataRate
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataRate() {
	    this._assertOpen();

	    if (this.data.minDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataRate;
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataRate() {
	    this._assertOpen();

	    if (this.data.maxDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataRate;
	  }
	  /**
	   * The most recent humidity value that the channel has reported.
	   *
	   * *   This value will always be between `minHumidity` and `maxHumidity`.
	   * @returns The humidity value
	   * @throws {@link PhidgetError}
	   */


	  getHumidity() {
	    this._assertOpen();

	    if (this.data.humidity === 1e+300 || Number.isNaN(this.data.humidity)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    if (this.data.humidity > this.data.maxHumidity) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE_HIGH);
	    if (this.data.humidity < this.data.minHumidity) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE_LOW);
	    return this.data.humidity;
	  }
	  /**
	   * The minimum value that the `HumidityChange` event will report.
	   * @returns The humidity value
	   * @throws {@link PhidgetError}
	   */


	  getMinHumidity() {
	    this._assertOpen();

	    if (this.data.minHumidity === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minHumidity;
	  }
	  /**
	   * The maximum value that the `HumidityChange` event will report.
	   * @returns The humidity value
	   * @throws {@link PhidgetError}
	   */


	  getMaxHumidity() {
	    this._assertOpen();

	    if (this.data.maxHumidity === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxHumidity;
	  }
	  /**
	   * The channel will not issue a `HumidityChange` event until the humidity value has changed by the amount specified by the `humidityChangeTrigger`.
	   *
	   * *   Setting the `humidityChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getHumidityChangeTrigger() {
	    this._assertOpen();

	    if (this.data.humidityChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.humidityChangeTrigger;
	  }
	  /**
	   * The channel will not issue a `HumidityChange` event until the humidity value has changed by the amount specified by the `humidityChangeTrigger`.
	   *
	   * *   Setting the `humidityChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering.
	   * @throws {@link PhidgetError}
	   * @param humidityChangeTrigger - The change trigger value
	   */


	  async setHumidityChangeTrigger(humidityChangeTrigger) {
	    this._assertOpen();

	    if (humidityChangeTrigger < this.data.minHumidityChangeTrigger || humidityChangeTrigger > this.data.maxHumidityChangeTrigger) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minHumidityChangeTrigger + " - " + this.data.maxHumidityChangeTrigger + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: humidityChangeTrigger
	    });
	    await bp.send(this._ch, 46);
	  }
	  /**
	   * The minimum value that `humidityChangeTrigger` can be set to.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMinHumidityChangeTrigger() {
	    this._assertOpen();

	    if (this.data.minHumidityChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minHumidityChangeTrigger;
	  }
	  /**
	   * The maximum value that `humidityChangeTrigger` can be set to.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMaxHumidityChangeTrigger() {
	    this._assertOpen();

	    if (this.data.maxHumidityChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxHumidityChangeTrigger;
	  }

	}

	/** @public */

	class HumiditySensor extends HumiditySensorBase {
	  /** @internal */
	  _errorHandler(code) {
	    switch (code) {
	      case exports.ErrorEventCode.SATURATION:
	        this.data.humidity = 1e+300;
	        this._gotHumidityChangeErrorEvent = true;
	        break;
	    }
	  }

	}

	class LightSensorBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onIlluminanceChange = null;
	    this._class = exports.ChannelClass.LIGHT_SENSOR;
	    this.name = "LightSensor";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 54:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.entries[1].v;else this.data.dataInterval = bp.entries[0].v;

	        this._FIREPropertyChange('DataInterval', bp);

	        this._FIREPropertyChange('DataRate', bp);

	        break;

	      case 46:
	        this.data.illuminanceChangeTrigger = bp.entries[0].v;

	        this._FIREPropertyChange('IlluminanceChangeTrigger', bp);

	        break;

	      case 23:
	        {
	          this.data.illuminance = bp.entries[0].v;

	          if (this._isAttachedDone && this.onIlluminanceChange) {
	            try {
	              this.onIlluminanceChange(this.data.illuminance);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      dataInterval: 1e+300,
	      maxDataInterval: 4294967295,
	      minDataRate: 1e+300,
	      maxDataRate: 1e+300,
	      maxIlluminance: 1e+300,
	      maxIlluminanceChangeTrigger: 1e+300,
	      minDataInterval: 4294967295,
	      minIlluminance: 1e+300,
	      minIlluminanceChangeTrigger: 1e+300,
	      illuminance: 1e+300,
	      illuminanceChangeTrigger: 1e+300
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 307:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 8;
	        this.data.maxIlluminance = 131072;
	        this.data.maxIlluminanceChangeTrigger = 131072;
	        this.data.minDataInterval = 125;
	        this.data.minIlluminance = 0;
	        this.data.minIlluminanceChangeTrigger = 0;
	        this.data.illuminanceChangeTrigger = 0;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    let bp;

	    switch (this._ch.chDef.uid) {
	      case 307:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.illuminanceChangeTrigger
	        });
	        await bp.send(this._ch, 46);
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    if (this.data.illuminance == 1e+300 && !this._gotIlluminanceChangeErrorEvent) return false;
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {
	    if (this.data.illuminance != 1e+300) if (this.onIlluminanceChange) try {
	      this.onIlluminanceChange(this.data.illuminance);
	    } catch (err) {
	      logEventException(err);
	    }
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `IlluminanceChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `IlluminanceChange` events can also be affected by the `illuminanceChangeTrigger`.
	   * @throws {@link PhidgetError}
	   */


	  get dataInterval() {
	    return this.getDataInterval();
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataInterval() {
	    return this.getMinDataInterval();
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataInterval() {
	    return this.getMaxDataInterval();
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   */


	  get dataRate() {
	    return this.getDataRate();
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataRate() {
	    return this.getMinDataRate();
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataRate() {
	    return this.getMaxDataRate();
	  }
	  /**
	   * The most recent illuminance value that the channel has reported.
	   *
	   * *   This value will always be between `minIlluminance` and `maxIlluminance`.
	   * @throws {@link PhidgetError}
	   */


	  get illuminance() {
	    return this.getIlluminance();
	  }
	  /**
	   * The minimum value the `IlluminanceChange` event will report.
	   * @throws {@link PhidgetError}
	   */


	  get minIlluminance() {
	    return this.getMinIlluminance();
	  }
	  /**
	   * The maximum value the `IlluminanceChange` event will report.
	   * @throws {@link PhidgetError}
	   */


	  get maxIlluminance() {
	    return this.getMaxIlluminance();
	  }
	  /**
	   * The channel will not issue a `IlluminanceChange` event until the illuminance value has changed by the amount specified by the `illuminanceChangeTrigger`.
	   *
	   * *   Setting the `illuminanceChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   */


	  get illuminanceChangeTrigger() {
	    return this.getIlluminanceChangeTrigger();
	  }
	  /**
	   * The minimum value that `illuminanceChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minIlluminanceChangeTrigger() {
	    return this.getMinIlluminanceChangeTrigger();
	  }
	  /**
	   * The maximum value that `illuminanceChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxIlluminanceChangeTrigger() {
	    return this.getMaxIlluminanceChangeTrigger();
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `IlluminanceChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `IlluminanceChange` events can also be affected by the `illuminanceChangeTrigger`.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getDataInterval() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dataInterval;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `IlluminanceChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `IlluminanceChange` events can also be affected by the `illuminanceChangeTrigger`.
	   * @throws {@link PhidgetError}
	   * @param dataInterval - The data interval value
	   */


	  async setDataInterval(dataInterval) {
	    this._assertOpen();

	    if (dataInterval < this.data.minDataInterval || dataInterval > this.data.maxDataInterval) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataInterval + " - " + this.data.maxDataInterval + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: dataInterval
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataInterval() {
	    this._assertOpen();

	    if (this.data.minDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataInterval;
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataInterval() {
	    this._assertOpen();

	    if (this.data.maxDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @returns The data rate for the channel
	   * @throws {@link PhidgetError}
	   */


	  getDataRate() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return 1000.0 / this.data.dataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   * @param dataRate - The data rate for the channel
	   */


	  async setDataRate(dataRate) {
	    this._assertOpen();

	    if (dataRate < this.data.minDataRate || dataRate > this.data.maxDataRate) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataRate + " - " + this.data.maxDataRate + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: Math.round(1000.0 / dataRate)
	    });
	    bp.set({
	      name: "1",
	      type: "g",
	      value: 1000.0 / dataRate
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataRate() {
	    this._assertOpen();

	    if (this.data.minDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataRate;
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataRate() {
	    this._assertOpen();

	    if (this.data.maxDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataRate;
	  }
	  /**
	   * The most recent illuminance value that the channel has reported.
	   *
	   * *   This value will always be between `minIlluminance` and `maxIlluminance`.
	   * @returns The illuminance value
	   * @throws {@link PhidgetError}
	   */


	  getIlluminance() {
	    this._assertOpen();

	    if (this.data.illuminance === 1e+300 || Number.isNaN(this.data.illuminance)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    if (this.data.illuminance > this.data.maxIlluminance) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE_HIGH);
	    if (this.data.illuminance < this.data.minIlluminance) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE_LOW);
	    return this.data.illuminance;
	  }
	  /**
	   * The minimum value the `IlluminanceChange` event will report.
	   * @returns The illuminance value
	   * @throws {@link PhidgetError}
	   */


	  getMinIlluminance() {
	    this._assertOpen();

	    if (this.data.minIlluminance === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minIlluminance;
	  }
	  /**
	   * The maximum value the `IlluminanceChange` event will report.
	   * @returns The illuminance value
	   * @throws {@link PhidgetError}
	   */


	  getMaxIlluminance() {
	    this._assertOpen();

	    if (this.data.maxIlluminance === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxIlluminance;
	  }
	  /**
	   * The channel will not issue a `IlluminanceChange` event until the illuminance value has changed by the amount specified by the `illuminanceChangeTrigger`.
	   *
	   * *   Setting the `illuminanceChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getIlluminanceChangeTrigger() {
	    this._assertOpen();

	    if (this.data.illuminanceChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.illuminanceChangeTrigger;
	  }
	  /**
	   * The channel will not issue a `IlluminanceChange` event until the illuminance value has changed by the amount specified by the `illuminanceChangeTrigger`.
	   *
	   * *   Setting the `illuminanceChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   * @param illuminanceChangeTrigger - The change trigger value
	   */


	  async setIlluminanceChangeTrigger(illuminanceChangeTrigger) {
	    this._assertOpen();

	    if (illuminanceChangeTrigger < this.data.minIlluminanceChangeTrigger || illuminanceChangeTrigger > this.data.maxIlluminanceChangeTrigger) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minIlluminanceChangeTrigger + " - " + this.data.maxIlluminanceChangeTrigger + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: illuminanceChangeTrigger
	    });
	    await bp.send(this._ch, 46);
	  }
	  /**
	   * The minimum value that `illuminanceChangeTrigger` can be set to.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMinIlluminanceChangeTrigger() {
	    this._assertOpen();

	    if (this.data.minIlluminanceChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minIlluminanceChangeTrigger;
	  }
	  /**
	   * The maximum value that `illuminanceChangeTrigger` can be set to.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMaxIlluminanceChangeTrigger() {
	    this._assertOpen();

	    if (this.data.maxIlluminanceChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxIlluminanceChangeTrigger;
	  }

	}

	/** @public */

	class LightSensor extends LightSensorBase {
	  /** @internal */
	  _errorHandler(code) {
	    switch (code) {
	      case exports.ErrorEventCode.SATURATION:
	        this.data.illuminance = 1e+300;
	        this._gotIlluminanceChangeErrorEvent = true;
	        break;
	    }
	  }

	}

	class PressureSensorBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onPressureChange = null;
	    this._class = exports.ChannelClass.PRESSURE_SENSOR;
	    this.name = "PressureSensor";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 54:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.entries[1].v;else this.data.dataInterval = bp.entries[0].v;

	        this._FIREPropertyChange('DataInterval', bp);

	        this._FIREPropertyChange('DataRate', bp);

	        break;

	      case 46:
	        this.data.pressureChangeTrigger = bp.entries[0].v;

	        this._FIREPropertyChange('PressureChangeTrigger', bp);

	        break;

	      case 31:
	        {
	          this.data.pressure = bp.entries[0].v;

	          if (this._isAttachedDone && this.onPressureChange) {
	            try {
	              this.onPressureChange(this.data.pressure);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      dataInterval: 1e+300,
	      maxDataInterval: 4294967295,
	      minDataRate: 1e+300,
	      maxDataRate: 1e+300,
	      maxPressure: 1e+300,
	      maxPressureChangeTrigger: 1e+300,
	      minDataInterval: 4294967295,
	      minPressure: 1e+300,
	      minPressureChangeTrigger: 1e+300,
	      pressure: 1e+300,
	      pressureChangeTrigger: 1e+300
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 346:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.maxPressure = 110;
	        this.data.maxPressureChangeTrigger = 60;
	        this.data.minDataInterval = 100;
	        this.data.minPressure = 50;
	        this.data.minPressureChangeTrigger = 0;
	        this.data.pressureChangeTrigger = 0;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    let bp;

	    switch (this._ch.chDef.uid) {
	      case 346:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.pressureChangeTrigger
	        });
	        await bp.send(this._ch, 46);
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    if (this.data.pressure == 1e+300 && !this._gotPressureChangeErrorEvent) return false;
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {
	    if (this.data.pressure != 1e+300) if (this.onPressureChange) try {
	      this.onPressureChange(this.data.pressure);
	    } catch (err) {
	      logEventException(err);
	    }
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `PressureChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `PressureChange` events can also be affected by the `pressureChangeTrigger`.
	   * @throws {@link PhidgetError}
	   */


	  get dataInterval() {
	    return this.getDataInterval();
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataInterval() {
	    return this.getMinDataInterval();
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataInterval() {
	    return this.getMaxDataInterval();
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   */


	  get dataRate() {
	    return this.getDataRate();
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataRate() {
	    return this.getMinDataRate();
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataRate() {
	    return this.getMaxDataRate();
	  }
	  /**
	   * The most recent pressure value that the channel has reported.
	   *
	   * *   This value will always be between `minPressure` and `maxPressure`.
	   * @throws {@link PhidgetError}
	   */


	  get pressure() {
	    return this.getPressure();
	  }
	  /**
	   * The minimum value the `PressureChange` event will report.
	   * @throws {@link PhidgetError}
	   */


	  get minPressure() {
	    return this.getMinPressure();
	  }
	  /**
	   * The maximum value the `PressureChange` event will report.
	   * @throws {@link PhidgetError}
	   */


	  get maxPressure() {
	    return this.getMaxPressure();
	  }
	  /**
	   * The channel will not issue a `PressureChange` event until the pressure value has changed by the amount specified by the `pressureChangeTrigger`.
	   *
	   * *   Setting the `pressureChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   */


	  get pressureChangeTrigger() {
	    return this.getPressureChangeTrigger();
	  }
	  /**
	   * The minimum value that `pressureChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minPressureChangeTrigger() {
	    return this.getMinPressureChangeTrigger();
	  }
	  /**
	   * The maximum value that `pressureChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxPressureChangeTrigger() {
	    return this.getMaxPressureChangeTrigger();
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `PressureChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `PressureChange` events can also be affected by the `pressureChangeTrigger`.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getDataInterval() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dataInterval;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `PressureChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `PressureChange` events can also be affected by the `pressureChangeTrigger`.
	   * @throws {@link PhidgetError}
	   * @param dataInterval - The data interval value
	   */


	  async setDataInterval(dataInterval) {
	    this._assertOpen();

	    if (dataInterval < this.data.minDataInterval || dataInterval > this.data.maxDataInterval) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataInterval + " - " + this.data.maxDataInterval + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: dataInterval
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataInterval() {
	    this._assertOpen();

	    if (this.data.minDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataInterval;
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataInterval() {
	    this._assertOpen();

	    if (this.data.maxDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @returns The data rate for the channel
	   * @throws {@link PhidgetError}
	   */


	  getDataRate() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return 1000.0 / this.data.dataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   * @param dataRate - The data rate for the channel
	   */


	  async setDataRate(dataRate) {
	    this._assertOpen();

	    if (dataRate < this.data.minDataRate || dataRate > this.data.maxDataRate) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataRate + " - " + this.data.maxDataRate + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: Math.round(1000.0 / dataRate)
	    });
	    bp.set({
	      name: "1",
	      type: "g",
	      value: 1000.0 / dataRate
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataRate() {
	    this._assertOpen();

	    if (this.data.minDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataRate;
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataRate() {
	    this._assertOpen();

	    if (this.data.maxDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataRate;
	  }
	  /**
	   * The most recent pressure value that the channel has reported.
	   *
	   * *   This value will always be between `minPressure` and `maxPressure`.
	   * @returns The pressure value
	   * @throws {@link PhidgetError}
	   */


	  getPressure() {
	    this._assertOpen();

	    if (this.data.pressure === 1e+300 || Number.isNaN(this.data.pressure)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    if (this.data.pressure > this.data.maxPressure) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE_HIGH);
	    if (this.data.pressure < this.data.minPressure) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE_LOW);
	    return this.data.pressure;
	  }
	  /**
	   * The minimum value the `PressureChange` event will report.
	   * @returns The pressure value
	   * @throws {@link PhidgetError}
	   */


	  getMinPressure() {
	    this._assertOpen();

	    if (this.data.minPressure === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minPressure;
	  }
	  /**
	   * The maximum value the `PressureChange` event will report.
	   * @returns The pressure value
	   * @throws {@link PhidgetError}
	   */


	  getMaxPressure() {
	    this._assertOpen();

	    if (this.data.maxPressure === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxPressure;
	  }
	  /**
	   * The channel will not issue a `PressureChange` event until the pressure value has changed by the amount specified by the `pressureChangeTrigger`.
	   *
	   * *   Setting the `pressureChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getPressureChangeTrigger() {
	    this._assertOpen();

	    if (this.data.pressureChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.pressureChangeTrigger;
	  }
	  /**
	   * The channel will not issue a `PressureChange` event until the pressure value has changed by the amount specified by the `pressureChangeTrigger`.
	   *
	   * *   Setting the `pressureChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   * @param pressureChangeTrigger - The change trigger value
	   */


	  async setPressureChangeTrigger(pressureChangeTrigger) {
	    this._assertOpen();

	    if (pressureChangeTrigger < this.data.minPressureChangeTrigger || pressureChangeTrigger > this.data.maxPressureChangeTrigger) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minPressureChangeTrigger + " - " + this.data.maxPressureChangeTrigger + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: pressureChangeTrigger
	    });
	    await bp.send(this._ch, 46);
	  }
	  /**
	   * The minimum value that `pressureChangeTrigger` can be set to.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMinPressureChangeTrigger() {
	    this._assertOpen();

	    if (this.data.minPressureChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minPressureChangeTrigger;
	  }
	  /**
	   * The maximum value that `pressureChangeTrigger` can be set to.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMaxPressureChangeTrigger() {
	    this._assertOpen();

	    if (this.data.maxPressureChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxPressureChangeTrigger;
	  }

	}

	/** @public */

	class PressureSensor extends PressureSensorBase {
	  /** @internal */
	  _errorHandler(code) {
	    switch (code) {
	      case exports.ErrorEventCode.SATURATION:
	        this.data.pressure = 1e+300;
	        this._gotPressureChangeErrorEvent = true;
	        break;
	    }
	  }

	}

	class ResistanceInputBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onResistanceChange = null;
	    this._class = exports.ChannelClass.RESISTANCE_INPUT;
	    this.name = "ResistanceInput";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 54:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.entries[1].v;else this.data.dataInterval = bp.entries[0].v;

	        this._FIREPropertyChange('DataInterval', bp);

	        this._FIREPropertyChange('DataRate', bp);

	        break;

	      case 46:
	        this.data.resistanceChangeTrigger = bp.entries[0].v;

	        this._FIREPropertyChange('ResistanceChangeTrigger', bp);

	        break;

	      case 77:
	        this.data.RTDWireSetup = bp.entries[0].v;

	        this._FIREPropertyChange('RTDWireSetup', bp);

	        break;

	      case 36:
	        {
	          this.data.resistance = bp.entries[0].v;

	          if (this._isAttachedDone && this.onResistanceChange) {
	            try {
	              this.onResistanceChange(this.data.resistance);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      dataInterval: 1e+300,
	      maxDataInterval: 4294967295,
	      minDataRate: 1e+300,
	      maxDataRate: 1e+300,
	      maxResistance: 1e+300,
	      maxResistanceChangeTrigger: 1e+300,
	      minDataInterval: 4294967295,
	      minResistance: 1e+300,
	      minResistanceChangeTrigger: 1e+300,
	      resistance: 1e+300,
	      resistanceChangeTrigger: 1e+300,
	      RTDWireSetup: 2147483647
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 391:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 4;
	        this.data.maxResistance = 50000;
	        this.data.maxResistanceChangeTrigger = 19000;
	        this.data.minDataInterval = 250;
	        this.data.minResistance = 0;
	        this.data.minResistanceChangeTrigger = 0;
	        this.data.resistanceChangeTrigger = 0;
	        this.data.RTDWireSetup = exports.RTDWireSetup.WIRES_4;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    let bp;

	    switch (this._ch.chDef.uid) {
	      case 391:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "g",
	          value: this.data.resistanceChangeTrigger
	        });
	        await bp.send(this._ch, 46);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.RTDWireSetup
	        });
	        await bp.send(this._ch, 77);
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    if (this.data.resistance == 1e+300 && !this._gotResistanceChangeErrorEvent) return false;
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {
	    if (this.data.resistance != 1e+300) if (this.onResistanceChange) try {
	      this.onResistanceChange(this.data.resistance);
	    } catch (err) {
	      logEventException(err);
	    }
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `ResistanceChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `ResistanceChange` events can also be affected by the `resistanceChangeTrigger`.
	   * @throws {@link PhidgetError}
	   */


	  get dataInterval() {
	    return this.getDataInterval();
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataInterval() {
	    return this.getMinDataInterval();
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataInterval() {
	    return this.getMaxDataInterval();
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   */


	  get dataRate() {
	    return this.getDataRate();
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataRate() {
	    return this.getMinDataRate();
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataRate() {
	    return this.getMaxDataRate();
	  }
	  /**
	   * The most recent resistance value that the channel has reported.
	   *
	   * *   This value will always be between `minResistance` and `maxResistance`.
	   * *   The `resistance` value will change when the device is also being used as a temperature sensor. This is a side effect of increasing accuracy on the temperature channel.
	   * @throws {@link PhidgetError}
	   */


	  get resistance() {
	    return this.getResistance();
	  }
	  /**
	   * The minimum value the `ResistanceChange` event will report.
	   *
	   * *   When the device is also being used as a TemperatureSensor the `minResistance` and `maxResistance` will not represent the true input range. This is a side effect of increasing accuracy on the temperature channel.
	   * @throws {@link PhidgetError}
	   */


	  get minResistance() {
	    return this.getMinResistance();
	  }
	  /**
	   * The maximum value the `ResistanceChange` event will report.
	   * @throws {@link PhidgetError}
	   */


	  get maxResistance() {
	    return this.getMaxResistance();
	  }
	  /**
	   * The channel will not issue a `ResistanceChange` event until the resistance value has changed by the amount specified by the `resistanceChangeTrigger`.
	   *
	   * *   Setting the `resistanceChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   */


	  get resistanceChangeTrigger() {
	    return this.getResistanceChangeTrigger();
	  }
	  /**
	   * The minimum value that the `resistanceChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minResistanceChangeTrigger() {
	    return this.getMinResistanceChangeTrigger();
	  }
	  /**
	   * The maximum value that `resistanceChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxResistanceChangeTrigger() {
	    return this.getMaxResistanceChangeTrigger();
	  }
	  /**
	   * Select the RTD wiring configuration.
	   *
	   * *   More information about RTD wiring can be found in the user guide.
	   * @throws {@link PhidgetError}
	   */


	  get RTDWireSetup() {
	    return this.getRTDWireSetup();
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `ResistanceChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `ResistanceChange` events can also be affected by the `resistanceChangeTrigger`.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getDataInterval() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dataInterval;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `ResistanceChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `ResistanceChange` events can also be affected by the `resistanceChangeTrigger`.
	   * @throws {@link PhidgetError}
	   * @param dataInterval - The data interval value
	   */


	  async setDataInterval(dataInterval) {
	    this._assertOpen();

	    if (dataInterval < this.data.minDataInterval || dataInterval > this.data.maxDataInterval) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataInterval + " - " + this.data.maxDataInterval + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: dataInterval
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataInterval() {
	    this._assertOpen();

	    if (this.data.minDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataInterval;
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataInterval() {
	    this._assertOpen();

	    if (this.data.maxDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @returns The data rate for the channel
	   * @throws {@link PhidgetError}
	   */


	  getDataRate() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return 1000.0 / this.data.dataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   * @param dataRate - The data rate for the channel
	   */


	  async setDataRate(dataRate) {
	    this._assertOpen();

	    if (dataRate < this.data.minDataRate || dataRate > this.data.maxDataRate) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataRate + " - " + this.data.maxDataRate + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: Math.round(1000.0 / dataRate)
	    });
	    bp.set({
	      name: "1",
	      type: "g",
	      value: 1000.0 / dataRate
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataRate() {
	    this._assertOpen();

	    if (this.data.minDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataRate;
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataRate() {
	    this._assertOpen();

	    if (this.data.maxDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataRate;
	  }
	  /**
	   * The most recent resistance value that the channel has reported.
	   *
	   * *   This value will always be between `minResistance` and `maxResistance`.
	   * *   The `resistance` value will change when the device is also being used as a temperature sensor. This is a side effect of increasing accuracy on the temperature channel.
	   * @returns The resistance value
	   * @throws {@link PhidgetError}
	   */


	  getResistance() {
	    this._assertOpen();

	    if (this.data.resistance === 1e+300 || Number.isNaN(this.data.resistance)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    if (this.data.resistance > this.data.maxResistance) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE_HIGH);
	    if (this.data.resistance < this.data.minResistance) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE_LOW);
	    return this.data.resistance;
	  }
	  /**
	   * The minimum value the `ResistanceChange` event will report.
	   *
	   * *   When the device is also being used as a TemperatureSensor the `minResistance` and `maxResistance` will not represent the true input range. This is a side effect of increasing accuracy on the temperature channel.
	   * @returns The minimum resistance
	   * @throws {@link PhidgetError}
	   */


	  getMinResistance() {
	    this._assertOpen();

	    if (this.data.minResistance === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minResistance;
	  }
	  /**
	   * The maximum value the `ResistanceChange` event will report.
	   * @returns The resistance value
	   * @throws {@link PhidgetError}
	   */


	  getMaxResistance() {
	    this._assertOpen();

	    if (this.data.maxResistance === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxResistance;
	  }
	  /**
	   * The channel will not issue a `ResistanceChange` event until the resistance value has changed by the amount specified by the `resistanceChangeTrigger`.
	   *
	   * *   Setting the `resistanceChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getResistanceChangeTrigger() {
	    this._assertOpen();

	    if (this.data.resistanceChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.resistanceChangeTrigger;
	  }
	  /**
	   * The channel will not issue a `ResistanceChange` event until the resistance value has changed by the amount specified by the `resistanceChangeTrigger`.
	   *
	   * *   Setting the `resistanceChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   * @param resistanceChangeTrigger - The change trigger value
	   */


	  async setResistanceChangeTrigger(resistanceChangeTrigger) {
	    this._assertOpen();

	    if (resistanceChangeTrigger < this.data.minResistanceChangeTrigger || resistanceChangeTrigger > this.data.maxResistanceChangeTrigger) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minResistanceChangeTrigger + " - " + this.data.maxResistanceChangeTrigger + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: resistanceChangeTrigger
	    });
	    await bp.send(this._ch, 46);
	  }
	  /**
	   * The minimum value that the `resistanceChangeTrigger` can be set to.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMinResistanceChangeTrigger() {
	    this._assertOpen();

	    if (this.data.minResistanceChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minResistanceChangeTrigger;
	  }
	  /**
	   * The maximum value that `resistanceChangeTrigger` can be set to.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMaxResistanceChangeTrigger() {
	    this._assertOpen();

	    if (this.data.maxResistanceChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxResistanceChangeTrigger;
	  }
	  /**
	   * Select the RTD wiring configuration.
	   *
	   * *   More information about RTD wiring can be found in the user guide.
	   * @returns Wire setup value
	   * @throws {@link PhidgetError}
	   */


	  getRTDWireSetup() {
	    this._assertOpen();

	    if (this.data.RTDWireSetup === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.RTDWireSetup;
	  }
	  /**
	   * Select the RTD wiring configuration.
	   *
	   * *   More information about RTD wiring can be found in the user guide.
	   * @throws {@link PhidgetError}
	   * @param RTDWireSetup - Wire setup value
	   */


	  async setRTDWireSetup(RTDWireSetup) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedRTDWireSetup(this._ch, RTDWireSetup)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified RTDWireSetup is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: RTDWireSetup
	    });
	    await bp.send(this._ch, 77);
	  }

	}

	/** @public */

	class ResistanceInput extends ResistanceInputBase {
	  /** @internal */
	  _errorHandler(code) {
	    switch (code) {
	      case exports.ErrorEventCode.SATURATION:
	        this.data.resistance = 1e+300;
	        this._gotResistanceChangeErrorEvent = true;
	        break;
	    }
	  }

	}

	class PowerGuardBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this._class = exports.ChannelClass.POWER_GUARD;
	    this.name = "PowerGuard";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 146:
	        break;

	      case 58:
	        this.data.fanMode = bp.entries[0].v;

	        this._FIREPropertyChange('FanMode', bp);

	        break;

	      case 71:
	        this.data.overVoltage = bp.entries[0].v;

	        this._FIREPropertyChange('OverVoltage', bp);

	        break;

	      case 56:
	        this.data.powerEnabled = bp.entries[0].v;

	        this._FIREPropertyChange('PowerEnabled', bp);

	        break;

	      case 147:
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      powerEnabled: 2,
	      overVoltage: 1e+300,
	      maxOverVoltage: 1e+300,
	      minOverVoltage: 1e+300,
	      fanMode: 2147483647,
	      maxFailsafeTime: 4294967295,
	      minFailsafeTime: 4294967295
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 360:
	        this.data.powerEnabled = 0;
	        this.data.maxOverVoltage = 33;
	        this.data.minOverVoltage = 8;
	        this.data.fanMode = exports.FanMode.AUTO;
	        break;

	      case 363:
	        this.data.powerEnabled = 0;
	        this.data.maxOverVoltage = 33;
	        this.data.minOverVoltage = 8;
	        this.data.fanMode = exports.FanMode.AUTO;
	        this.data.maxFailsafeTime = 30000;
	        this.data.minFailsafeTime = 500;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    let bp;

	    switch (this._ch.chDef.uid) {
	      case 360:
	      case 363:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.powerEnabled
	        });
	        await bp.send(this._ch, 56);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.fanMode
	        });
	        await bp.send(this._ch, 58);
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {}
	  /**
	   * The minimum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @throws {@link PhidgetError}
	   */


	  get minFailsafeTime() {
	    return this.getMinFailsafeTime();
	  }
	  /**
	   * The maximum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @throws {@link PhidgetError}
	   */


	  get maxFailsafeTime() {
	    return this.getMaxFailsafeTime();
	  }
	  /**
	   * The `fanMode` dictates the operating condition of the fan.
	   *
	   * *   Choose between on, off, or automatic (based on temperature).
	   * *   If the `fanMode` is set to automatic, the fan will turn on when the temperature reaches 70Â°C and it will remain on until the temperature falls below 55Â°C.
	   * *   If the `fanMode` is off, the device will still turn on the fan if the temperature reaches 85Â°C and it will remain on until it falls below 70Â°C.
	   * @throws {@link PhidgetError}
	   */


	  get fanMode() {
	    return this.getFanMode();
	  }
	  /**
	   * The device constantly monitors the output voltage, and if it exceeds the `overVoltage` value, it will disconnect the input from the output.
	   *
	   * *   This functionality is critical for protecting power supplies from regenerated voltage coming from motors. Many power supplies assume that a higher than output expected voltage is related to an internal failure to the power supply, and will permanently disable themselves to protect the system. A typical safe value is to set OverVoltage to 1-2 volts higher than the output voltage of the supply. For instance, a 12V supply would be protected by setting OverVoltage to 13V.
	   * *   The device will connect the input to the output again when the voltage drops to (`overVoltage` - 1V)
	   * @throws {@link PhidgetError}
	   */


	  get overVoltage() {
	    return this.getOverVoltage();
	  }
	  /**
	   * The minimum value that `overVoltage` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minOverVoltage() {
	    return this.getMinOverVoltage();
	  }
	  /**
	   * The maximum value that `overVoltage` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxOverVoltage() {
	    return this.getMaxOverVoltage();
	  }
	  /**
	   * When `powerEnabled` is true, the device will connect the input to the output and begin monitoring.
	   *
	   * *   The output voltage is constantly monitored and will be automatically disconnected from the input when the output exceeds the `overVoltage` value.
	   * *   `powerEnabled` allows the device to operate as a Solid State Relay, powering on or off all devices connected to the output.
	   * @throws {@link PhidgetError}
	   */


	  get powerEnabled() {
	    return this.getPowerEnabled();
	  }
	  /**
	   * Enables the **failsafe** feature for the channel, with a given **failsafe time**.
	   *
	   * The **failsafe** feature is intended for use in applications where it is important for the channel to enter a known _safe state_ if the program controlling it locks up or crashes. If you do not enable the failsafe feature, the channel will carry out whatever instructions it was last given until it is explicitly told to stop.
	   *
	   * Enabling the failsafe feature starts a recurring **failsafe timer** for the channel. Once the failsafe timer is enabled, it must be reset within the specified time or the channel will enter a **failsafe state**. The failsafe timer may be reset by sending any valid command to the device\*. Resetting the failsafe timer will reload the timer with the specified _failsafe time_, starting when the message to reset the timer is received by the Phidget.
	   *
	   * _\*(**get** requests do not typically send commands and won't reset the failsafe timer)_
	   *
	   * For example: if the failsafe is enabled with a **failsafe time** of 1000ms, you will have 1000ms to reset the failsafe timer. Every time the failsafe timer is reset, you will have 1000ms from that time to reset the failsafe again.
	   *
	   * If the failsafe timer is not reset before it runs out, the channel will enter a **failsafe state**. For Power Guard channels, this will turn off the output. Once the channel enters the **failsafe state**, it will reject any further input until the channel is reopened.
	   *
	   * To prevent the channel from falsely entering the failsafe state, we recommend resetting the failsafe timer as frequently as is practical for your application. A good rule of thumb is to not let more than a third of the failsafe time pass before resetting the timer.
	   *
	   * Once the failsafe timer has been set, it cannot be disabled by any means other than closing and reopening the channel.
	   * @throws {@link PhidgetError}
	   * @param failsafeTime - Failsafe timeout in milliseconds
	   */


	  async enableFailsafe(failsafeTime) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: failsafeTime
	    });
	    await bp.send(this._ch, 146);
	  }
	  /**
	   * The minimum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @returns The failsafe time
	   * @throws {@link PhidgetError}
	   */


	  getMinFailsafeTime() {
	    this._assertOpen();

	    if (this.data.minFailsafeTime === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minFailsafeTime;
	  }
	  /**
	   * The maximum value that `failsafeTime` can be set to when calling `enableFailsafe()`.
	   * @returns The failsafe time
	   * @throws {@link PhidgetError}
	   */


	  getMaxFailsafeTime() {
	    this._assertOpen();

	    if (this.data.maxFailsafeTime === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxFailsafeTime;
	  }
	  /**
	   * The `fanMode` dictates the operating condition of the fan.
	   *
	   * *   Choose between on, off, or automatic (based on temperature).
	   * *   If the `fanMode` is set to automatic, the fan will turn on when the temperature reaches 70Â°C and it will remain on until the temperature falls below 55Â°C.
	   * *   If the `fanMode` is off, the device will still turn on the fan if the temperature reaches 85Â°C and it will remain on until it falls below 70Â°C.
	   * @returns The fan mode value
	   * @throws {@link PhidgetError}
	   */


	  getFanMode() {
	    this._assertOpen();

	    if (this.data.fanMode === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.fanMode;
	  }
	  /**
	   * The `fanMode` dictates the operating condition of the fan.
	   *
	   * *   Choose between on, off, or automatic (based on temperature).
	   * *   If the `fanMode` is set to automatic, the fan will turn on when the temperature reaches 70Â°C and it will remain on until the temperature falls below 55Â°C.
	   * *   If the `fanMode` is off, the device will still turn on the fan if the temperature reaches 85Â°C and it will remain on until it falls below 70Â°C.
	   * @throws {@link PhidgetError}
	   * @param fanMode - The fan mode value
	   */


	  async setFanMode(fanMode) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedFanMode(this._ch, fanMode)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified FanMode is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: fanMode
	    });
	    await bp.send(this._ch, 58);
	  }
	  /**
	   * The device constantly monitors the output voltage, and if it exceeds the `overVoltage` value, it will disconnect the input from the output.
	   *
	   * *   This functionality is critical for protecting power supplies from regenerated voltage coming from motors. Many power supplies assume that a higher than output expected voltage is related to an internal failure to the power supply, and will permanently disable themselves to protect the system. A typical safe value is to set OverVoltage to 1-2 volts higher than the output voltage of the supply. For instance, a 12V supply would be protected by setting OverVoltage to 13V.
	   * *   The device will connect the input to the output again when the voltage drops to (`overVoltage` - 1V)
	   * @returns The voltage value
	   * @throws {@link PhidgetError}
	   */


	  getOverVoltage() {
	    this._assertOpen();

	    if (this.data.overVoltage === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.overVoltage;
	  }
	  /**
	   * The device constantly monitors the output voltage, and if it exceeds the `overVoltage` value, it will disconnect the input from the output.
	   *
	   * *   This functionality is critical for protecting power supplies from regenerated voltage coming from motors. Many power supplies assume that a higher than output expected voltage is related to an internal failure to the power supply, and will permanently disable themselves to protect the system. A typical safe value is to set OverVoltage to 1-2 volts higher than the output voltage of the supply. For instance, a 12V supply would be protected by setting OverVoltage to 13V.
	   * *   The device will connect the input to the output again when the voltage drops to (`overVoltage` - 1V)
	   * @throws {@link PhidgetError}
	   * @param overVoltage - The voltage value
	   */


	  async setOverVoltage(overVoltage) {
	    this._assertOpen();

	    if (overVoltage < this.data.minOverVoltage || overVoltage > this.data.maxOverVoltage) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minOverVoltage + " - " + this.data.maxOverVoltage + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: overVoltage
	    });
	    await bp.send(this._ch, 71);
	  }
	  /**
	   * The minimum value that `overVoltage` can be set to.
	   * @returns The voltage value
	   * @throws {@link PhidgetError}
	   */


	  getMinOverVoltage() {
	    this._assertOpen();

	    if (this.data.minOverVoltage === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minOverVoltage;
	  }
	  /**
	   * The maximum value that `overVoltage` can be set to.
	   * @returns The voltage value
	   * @throws {@link PhidgetError}
	   */


	  getMaxOverVoltage() {
	    this._assertOpen();

	    if (this.data.maxOverVoltage === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxOverVoltage;
	  }
	  /**
	   * When `powerEnabled` is true, the device will connect the input to the output and begin monitoring.
	   *
	   * *   The output voltage is constantly monitored and will be automatically disconnected from the input when the output exceeds the `overVoltage` value.
	   * *   `powerEnabled` allows the device to operate as a Solid State Relay, powering on or off all devices connected to the output.
	   * @returns The power enabled value.
	   * @throws {@link PhidgetError}
	   */


	  getPowerEnabled() {
	    this._assertOpen();

	    if (this.data.powerEnabled === 2) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return !!this.data.powerEnabled;
	  }
	  /**
	   * When `powerEnabled` is true, the device will connect the input to the output and begin monitoring.
	   *
	   * *   The output voltage is constantly monitored and will be automatically disconnected from the input when the output exceeds the `overVoltage` value.
	   * *   `powerEnabled` allows the device to operate as a Solid State Relay, powering on or off all devices connected to the output.
	   * @throws {@link PhidgetError}
	   * @param powerEnabled - The power enabled value.
	   */


	  async setPowerEnabled(powerEnabled) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (powerEnabled !== false && powerEnabled !== true) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be a boolean.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: powerEnabled ? 1 : 0
	    });
	    await bp.send(this._ch, 56);
	  }
	  /**
	   * Resets the failsafe timer, if one has been set. See `enableFailsafe()` for details.
	   *
	   * This function will fail if no failsafe timer has been set for the channel.
	   * @throws {@link PhidgetError}
	   */


	  async resetFailsafe() {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    await bp.send(this._ch, 147);
	  }

	}

	/** @public */

	class PowerGuard extends PowerGuardBase {}

	class SoundSensorBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onSPLChange = null;
	    this._class = exports.ChannelClass.SOUND_SENSOR;
	    this.name = "SoundSensor";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 54:
	        if (bp.entryCount > 1) this.data.dataInterval = bp.entries[1].v;else this.data.dataInterval = bp.entries[0].v;

	        this._FIREPropertyChange('DataInterval', bp);

	        this._FIREPropertyChange('DataRate', bp);

	        break;

	      case 46:
	        this.data.SPLChangeTrigger = bp.entries[0].v;

	        this._FIREPropertyChange('SPLChangeTrigger', bp);

	        break;

	      case 116:
	        this.data.SPLRange = bp.entries[0].v;

	        this._FIREPropertyChange('SPLRange', bp);

	        break;

	      case 11:
	        {
	          this.data.dB = bp.entries[0].v;
	          this.data.dBA = bp.entries[1].v;
	          this.data.dBC = bp.entries[2].v;
	          this.data.octaves = bp.entries[3].v;

	          if (this._isAttachedDone && this.onSPLChange) {
	            try {
	              this.onSPLChange(this.data.dB, this.data.dBA, this.data.dBC, this.data.octaves);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      lastdB: 0,
	      dataInterval: 1e+300,
	      maxDataInterval: 4294967295,
	      minDataRate: 1e+300,
	      maxDataRate: 1e+300,
	      maxdB: 1e+300,
	      maxSPLChangeTrigger: 1e+300,
	      minDataInterval: 4294967295,
	      noiseFloor: 1e+300,
	      minSPLChangeTrigger: 1e+300,
	      dB: 1e+300,
	      dBA: 1e+300,
	      dBC: 1e+300,
	      octaves: [1e+300, 1e+300, 1e+300, 1e+300, 1e+300, 1e+300, 1e+300, 1e+300, 1e+300, 1e+300],
	      SPLRange: 2147483647,
	      SPLChangeTrigger: 1e+300
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 366:
	        this.data.dataInterval = 250;
	        this.data.maxDataInterval = 60000;
	        this.data.minDataRate = 0.016666666666666666;
	        this.data.maxDataRate = 10;
	        this.data.maxdB = 102;
	        this.data.maxSPLChangeTrigger = 102;
	        this.data.minDataInterval = 100;
	        this.data.noiseFloor = 34;
	        this.data.minSPLChangeTrigger = 0;
	        this.data.SPLRange = exports.SPLRange.DB_102;
	        this.data.SPLChangeTrigger = 0;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    let bp;

	    switch (this._ch.chDef.uid) {
	      case 366:
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "u",
	          value: Math.round(this.data.dataInterval)
	        });
	        await bp.send(this._ch, 54);
	        bp = new BridgePacket();
	        bp.set({
	          name: "0",
	          type: "d",
	          value: this.data.SPLRange
	        });
	        await bp.send(this._ch, 116);
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {}
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `SPLChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `SPLChange` events can also be affected by the `SPLChangeTrigger`.
	   * @throws {@link PhidgetError}
	   */


	  get dataInterval() {
	    return this.getDataInterval();
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataInterval() {
	    return this.getMinDataInterval();
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataInterval() {
	    return this.getMaxDataInterval();
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   */


	  get dataRate() {
	    return this.getDataRate();
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minDataRate() {
	    return this.getMinDataRate();
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxDataRate() {
	    return this.getMaxDataRate();
	  }
	  /**
	   * The most recent dB SPL value that has been calculated.
	   *
	   * *   This value is bounded by `maxdB`.
	   * @throws {@link PhidgetError}
	   */


	  get dB() {
	    return this.getdB();
	  }
	  /**
	   * The maximum value the `SPLChange` event will report.
	   * @throws {@link PhidgetError}
	   */


	  get maxdB() {
	    return this.getMaxdB();
	  }
	  /**
	   * The most recent dBA SPL value that has been calculated.
	   *
	   * *   The dBA SPL value is calculated by applying a A-weighted filter to the `octaves` data.
	   * @throws {@link PhidgetError}
	   */


	  get dBA() {
	    return this.getdBA();
	  }
	  /**
	   * The most recent dBC SPL value that has been calculated.
	   *
	   * *   The dBC SPL value is calculated by applying a C-weighted filter to the `octaves` data.
	   * @throws {@link PhidgetError}
	   */


	  get dBC() {
	    return this.getdBC();
	  }
	  /**
	   * The minimum SPL value that the channel can accurately measure.
	   *
	   * *   Input SPLs below this level will not produce an output from the microphone.
	   * @throws {@link PhidgetError}
	   */


	  get noiseFloor() {
	    return this.getNoiseFloor();
	  }
	  /**
	   * The unweighted value of each frequency band.
	   *
	   * *   The following frequency bands are represented:
	   *
	   * *   octaves\[0\] = 31.5 Hz
	   * *   octaves\[1\] = 63 Hz
	   * *   octaves\[2\] = 125 Hz
	   * *   octaves\[3\] = 250 Hz
	   * *   octaves\[4\] = 500 Hz
	   * *   octaves\[5\] = 1 kHz
	   * *   octaves\[6\] = 2 kHz
	   * *   octaves\[7\] = 4 kHz
	   * *   octaves\[8\] = 8 kHz
	   * *   octaves\[9\] = 16 kHz
	   * @throws {@link PhidgetError}
	   */


	  get octaves() {
	    return this.getOctaves();
	  }
	  /**
	   * The channel will not issue a `SPLChange` event until the `dB` value has changed by the amount specified by the `SPLChangeTrigger`.
	   *
	   * *   Setting the `SPLChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   */


	  get SPLChangeTrigger() {
	    return this.getSPLChangeTrigger();
	  }
	  /**
	   * The minimum value that `SPLChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get minSPLChangeTrigger() {
	    return this.getMinSPLChangeTrigger();
	  }
	  /**
	   * The maximum value that `SPLChangeTrigger` can be set to.
	   * @throws {@link PhidgetError}
	   */


	  get maxSPLChangeTrigger() {
	    return this.getMaxSPLChangeTrigger();
	  }
	  /**
	   * When selecting a range, first decide how sensitive you want the microphone to be. Select a smaller range when you want more sensitivity from the microphone.
	   *
	   * *   If a `Saturation` event occurrs, increase the range.
	   * @throws {@link PhidgetError}
	   */


	  get SPLRange() {
	    return this.getSPLRange();
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `SPLChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `SPLChange` events can also be affected by the `SPLChangeTrigger`.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getDataInterval() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dataInterval;
	  }
	  /**
	   * The `dataInterval` is the time that must elapse before the channel will fire another `SPLChange` event.
	   *
	   * *   The data interval is bounded by `minDataInterval` and `maxDataInterval`.
	   * *   The timing between `SPLChange` events can also be affected by the `SPLChangeTrigger`.
	   * @throws {@link PhidgetError}
	   * @param dataInterval - The data interval value
	   */


	  async setDataInterval(dataInterval) {
	    this._assertOpen();

	    if (dataInterval < this.data.minDataInterval || dataInterval > this.data.maxDataInterval) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataInterval + " - " + this.data.maxDataInterval + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: dataInterval
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataInterval() {
	    this._assertOpen();

	    if (this.data.minDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataInterval;
	  }
	  /**
	   * The maximum value that `dataInterval` can be set to.
	   * @returns The data interval value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataInterval() {
	    this._assertOpen();

	    if (this.data.maxDataInterval === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @returns The data rate for the channel
	   * @throws {@link PhidgetError}
	   */


	  getDataRate() {
	    this._assertOpen();

	    if (this.data.dataInterval === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return 1000.0 / this.data.dataInterval;
	  }
	  /**
	   * The `dataRate` is the frequency of events from the device.
	   *
	   * *   The data rate is bounded by `minDataRate` and `maxDataRate`.
	   * *   Changing `dataRate` will change the channel's `dataInterval` to a corresponding value, rounded to the nearest integer number of milliseconds.
	   * *   The timing between events can also affected by the change trigger.
	   * @throws {@link PhidgetError}
	   * @param dataRate - The data rate for the channel
	   */


	  async setDataRate(dataRate) {
	    this._assertOpen();

	    if (dataRate < this.data.minDataRate || dataRate > this.data.maxDataRate) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minDataRate + " - " + this.data.maxDataRate + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "u",
	      value: Math.round(1000.0 / dataRate)
	    });
	    bp.set({
	      name: "1",
	      type: "g",
	      value: 1000.0 / dataRate
	    });
	    await bp.send(this._ch, 54);
	  }
	  /**
	   * The minimum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMinDataRate() {
	    this._assertOpen();

	    if (this.data.minDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minDataRate;
	  }
	  /**
	   * The maximum value that `dataRate` can be set to.
	   * @returns The data rate value
	   * @throws {@link PhidgetError}
	   */


	  getMaxDataRate() {
	    this._assertOpen();

	    if (this.data.maxDataRate === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxDataRate;
	  }
	  /**
	   * The most recent dB SPL value that has been calculated.
	   *
	   * *   This value is bounded by `maxdB`.
	   * @returns The dB value
	   * @throws {@link PhidgetError}
	   */


	  getdB() {
	    this._assertOpen();

	    if (this.data.dB === 1e+300 || Number.isNaN(this.data.dB)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    if (this.data.dB > this.data.maxdB) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE_HIGH);
	    return this.data.dB;
	  }
	  /**
	   * The maximum value the `SPLChange` event will report.
	   * @returns The dB value
	   * @throws {@link PhidgetError}
	   */


	  getMaxdB() {
	    this._assertOpen();

	    if (this.data.maxdB === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxdB;
	  }
	  /**
	   * The most recent dBA SPL value that has been calculated.
	   *
	   * *   The dBA SPL value is calculated by applying a A-weighted filter to the `octaves` data.
	   * @returns The dBA value
	   * @throws {@link PhidgetError}
	   */


	  getdBA() {
	    this._assertOpen();

	    if (this.data.dBA === 1e+300 || Number.isNaN(this.data.dBA)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dBA;
	  }
	  /**
	   * The most recent dBC SPL value that has been calculated.
	   *
	   * *   The dBC SPL value is calculated by applying a C-weighted filter to the `octaves` data.
	   * @returns The dBC value
	   * @throws {@link PhidgetError}
	   */


	  getdBC() {
	    this._assertOpen();

	    if (this.data.dBC === 1e+300 || Number.isNaN(this.data.dBC)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.dBC;
	  }
	  /**
	   * The minimum SPL value that the channel can accurately measure.
	   *
	   * *   Input SPLs below this level will not produce an output from the microphone.
	   * @returns The noise floor value.
	   * @throws {@link PhidgetError}
	   */


	  getNoiseFloor() {
	    this._assertOpen();

	    if (this.data.noiseFloor === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.noiseFloor;
	  }
	  /**
	   * The unweighted value of each frequency band.
	   *
	   * *   The following frequency bands are represented:
	   *
	   * *   octaves\[0\] = 31.5 Hz
	   * *   octaves\[1\] = 63 Hz
	   * *   octaves\[2\] = 125 Hz
	   * *   octaves\[3\] = 250 Hz
	   * *   octaves\[4\] = 500 Hz
	   * *   octaves\[5\] = 1 kHz
	   * *   octaves\[6\] = 2 kHz
	   * *   octaves\[7\] = 4 kHz
	   * *   octaves\[8\] = 8 kHz
	   * *   octaves\[9\] = 16 kHz
	   * @returns The octave values
	   * @throws {@link PhidgetError}
	   */


	  getOctaves() {
	    this._assertOpen();

	    if (this.data.octaves.includes(1e+300)) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.octaves;
	  }
	  /**
	   * The channel will not issue a `SPLChange` event until the `dB` value has changed by the amount specified by the `SPLChangeTrigger`.
	   *
	   * *   Setting the `SPLChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getSPLChangeTrigger() {
	    this._assertOpen();

	    if (this.data.SPLChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.SPLChangeTrigger;
	  }
	  /**
	   * The channel will not issue a `SPLChange` event until the `dB` value has changed by the amount specified by the `SPLChangeTrigger`.
	   *
	   * *   Setting the `SPLChangeTrigger` to 0 will result in the channel firing events every `dataInterval`. This is useful for applications that implement their own data filtering
	   * @throws {@link PhidgetError}
	   * @param SPLChangeTrigger - The change trigger value
	   */


	  async setSPLChangeTrigger(SPLChangeTrigger) {
	    this._assertOpen();

	    if (SPLChangeTrigger < this.data.minSPLChangeTrigger || SPLChangeTrigger > this.data.maxSPLChangeTrigger) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be in range: " + this.data.minSPLChangeTrigger + " - " + this.data.maxSPLChangeTrigger + ".");
	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "g",
	      value: SPLChangeTrigger
	    });
	    await bp.send(this._ch, 46);
	  }
	  /**
	   * The minimum value that `SPLChangeTrigger` can be set to.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMinSPLChangeTrigger() {
	    this._assertOpen();

	    if (this.data.minSPLChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.minSPLChangeTrigger;
	  }
	  /**
	   * The maximum value that `SPLChangeTrigger` can be set to.
	   * @returns The change trigger value
	   * @throws {@link PhidgetError}
	   */


	  getMaxSPLChangeTrigger() {
	    this._assertOpen();

	    if (this.data.maxSPLChangeTrigger === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.maxSPLChangeTrigger;
	  }
	  /**
	   * When selecting a range, first decide how sensitive you want the microphone to be. Select a smaller range when you want more sensitivity from the microphone.
	   *
	   * *   If a `Saturation` event occurrs, increase the range.
	   * @returns The range value.
	   * @throws {@link PhidgetError}
	   */


	  getSPLRange() {
	    this._assertOpen();

	    if (this.data.SPLRange === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.SPLRange;
	  }
	  /**
	   * When selecting a range, first decide how sensitive you want the microphone to be. Select a smaller range when you want more sensitivity from the microphone.
	   *
	   * *   If a `Saturation` event occurrs, increase the range.
	   * @throws {@link PhidgetError}
	   * @param SPLRange - The range value.
	   */


	  async setSPLRange(SPLRange) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    if (!supportedSPLRange(this._ch, SPLRange)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified SPLRange is unsupported by this device.");
	    bp.set({
	      name: "0",
	      type: "d",
	      value: SPLRange
	    });
	    await bp.send(this._ch, 116);
	  }

	}

	/** @public */

	class SoundSensor extends SoundSensorBase {
	  /** @internal */
	  _hasInitialState() {
	    if (this.data.dB == 1e+300) return false;
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {
	    if (this.data.dB != 1e+300) {
	      if (this.onSPLChange) {
	        try {
	          this.onSPLChange(this.data.dB, this.data.dBA, this.data.dBC, this.data.octaves);
	        } catch (err) {
	          logEventException(err);
	        }
	      }
	    }
	  }

	}

	class HubBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this._class = exports.ChannelClass.HUB;
	    this.name = "Hub";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 60:
	        break;

	      case 72:
	        break;

	      case 73:
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {};
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 403:
	      case 404:
	      case 405:
	      case 414:
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    switch (this._ch.chDef.uid) {
	      case 403:
	      case 404:
	      case 405:
	      case 414:
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {}
	  /**
	   * Sets a flag on this hub port which forces the next VINT devices plugged in to stay in firmware upgrade mode.
	   * @throws {@link PhidgetError}
	   * @param port - The port the device is plugged into
	   * @param timeout - The time to leave the flag set for
	   * @internal
	   */


	  async setFirmwareUpgradeFlag(port, timeout) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "d",
	      value: port
	    });
	    bp.set({
	      name: "1",
	      type: "u",
	      value: timeout
	    });
	    await bp.send(this._ch, 60);
	  }
	  /**
	   * Sets the mode of the selected port.
	   * @throws {@link PhidgetError}
	   * @param port - The port being set
	   * @param mode - The mode the port is being set to
	   * @internal
	   */


	  async setPortMode(port, mode) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "d",
	      value: port
	    });
	    if (!supportedHubPortMode(this._ch, mode)) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Specified HubPortMode is unsupported by this device.");
	    bp.set({
	      name: "1",
	      type: "d",
	      value: mode
	    });
	    await bp.send(this._ch, 72);
	  }
	  /**
	   * Controls power to the VINT Hub Ports.
	   * @throws {@link PhidgetError}
	   * @param port - The Hub port
	   * @param state - The power state
	   */


	  async setPortPower(port, state) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "d",
	      value: port
	    });
	    if (state !== false && state !== true) throw new PhidgetError(exports.ErrorCode.INVALID_ARGUMENT, "Value must be a boolean.");
	    bp.set({
	      name: "1",
	      type: "d",
	      value: state ? 1 : 0
	    });
	    await bp.send(this._ch, 73);
	  }

	}

	/** @public */

	class Hub extends HubBase {
	  async getPortMode(port) {
	    var _a;

	    this._assertAttached();

	    if (!this._ch.conn._isLocal) throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    await this.hub._device.openAndUpdatePortProperties(port);
	    const mode = (_a = this.hub._device.hubPortProps) === null || _a === void 0 ? void 0 : _a[port].portMode;
	    if (mode == undefined) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return mode;
	  }

	  async getPortPower(port) {
	    var _a;

	    this._assertAttached();

	    if (!this._ch.conn._isLocal) throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    await this.hub._device.openAndUpdatePortProperties(port);
	    const power = (_a = this.hub._device.hubPortProps) === null || _a === void 0 ? void 0 : _a[port].portPowered;
	    if (power == undefined) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return power;
	  }

	}

	class FirmwareUpgradeBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    /**
	     * **ProgressChange** event
	     *  * `progress` - The progress, range is 0-1.
	     * ---
	     * Occurs on firmware upgrade progress.
	     * @internal
	     */

	    this.onProgressChange = null;
	    this._class = exports.ChannelClass.FIRMWARE_UPGRADE;
	    this.name = "FirmwareUpgrade";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 112:
	        break;

	      case 113:
	        {
	          this.data.progress = bp.entries[0].v;

	          if (this._isAttachedDone && this.onProgressChange) {
	            try {
	              this.onProgressChange(this.data.progress);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {
	      actualDeviceID: 2147483647,
	      actualDeviceVINTID: 4294967295,
	      actualDeviceSKU: null,
	      actualDeviceVersion: 2147483647,
	      actualDeviceName: null,
	      progress: 1e+300
	    };
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 417:
	      case 418:
	      case 419:
	      case 420:
	      case 421:
	      case 422:
	        this.data.progress = 0;
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    switch (this._ch.chDef.uid) {
	      case 417:
	      case 418:
	      case 419:
	      case 420:
	      case 421:
	      case 422:
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    if (this.data.progress == 1e+300 && !this._gotProgressChangeErrorEvent) return false;
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {
	    if (this.data.progress != 1e+300) if (this.onProgressChange) try {
	      this.onProgressChange(this.data.progress);
	    } catch (err) {
	      logEventException(err);
	    }
	  }
	  /**
	   * TODO: Text Here
	   * @throws {@link PhidgetError}
	   * @internal
	   */


	  get actualDeviceID() {
	    return this.getActualDeviceID();
	  }
	  /**
	   * TODO: Text Here
	   * @throws {@link PhidgetError}
	   * @internal
	   */


	  get actualDeviceName() {
	    return this.getActualDeviceName();
	  }
	  /**
	   * TODO: Text Here
	   * @throws {@link PhidgetError}
	   * @internal
	   */


	  get actualDeviceSKU() {
	    return this.getActualDeviceSKU();
	  }
	  /**
	   * TODO: Text Here
	   * @throws {@link PhidgetError}
	   * @internal
	   */


	  get actualDeviceVersion() {
	    return this.getActualDeviceVersion();
	  }
	  /**
	   * TODO: Text Here
	   * @throws {@link PhidgetError}
	   * @internal
	   */


	  get actualDeviceVINTID() {
	    return this.getActualDeviceVINTID();
	  }
	  /**
	   * TODO: Text Here
	   * @throws {@link PhidgetError}
	   * @internal
	   */


	  get progress() {
	    return this.getProgress();
	  }
	  /**
	   * TODO: Text Here
	   * @returns Device ID
	   * @throws {@link PhidgetError}
	   * @internal
	   */


	  getActualDeviceID() {
	    this._assertOpen();

	    if (this.data.actualDeviceID === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.actualDeviceID;
	  }
	  /**
	   * TODO: Text Here
	   * @returns Name of the device
	   * @throws {@link PhidgetError}
	   * @internal
	   */


	  getActualDeviceName() {
	    this._assertOpen();

	    if (this.data.actualDeviceName === null) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.actualDeviceName;
	  }
	  /**
	   * TODO: Text Here
	   * @returns Device SKU
	   * @throws {@link PhidgetError}
	   * @internal
	   */


	  getActualDeviceSKU() {
	    this._assertOpen();

	    if (this.data.actualDeviceSKU === null) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.actualDeviceSKU;
	  }
	  /**
	   * TODO: Text Here
	   * @returns Firmware version
	   * @throws {@link PhidgetError}
	   * @internal
	   */


	  getActualDeviceVersion() {
	    this._assertOpen();

	    if (this.data.actualDeviceVersion === 2147483647) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.actualDeviceVersion;
	  }
	  /**
	   * TODO: Text Here
	   * @returns Device VINT ID
	   * @throws {@link PhidgetError}
	   * @internal
	   */


	  getActualDeviceVINTID() {
	    this._assertOpen();

	    if (this.data.actualDeviceVINTID === 4294967295) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.actualDeviceVINTID;
	  }
	  /**
	   * TODO: Text Here
	   * @returns Firmware update progress
	   * @throws {@link PhidgetError}
	   * @internal
	   */


	  getProgress() {
	    this._assertOpen();

	    if (this.data.progress === 1e+300) throw new PhidgetError(exports.ErrorCode.UNKNOWN_VALUE);
	    return this.data.progress;
	  }

	}

	/** @internal */

	class FirmwareUpgrade extends FirmwareUpgradeBase {
	  /** @internal */
	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 114:
	        break;

	      default:
	        super._bridgeInput(bp);

	        break;
	    }
	  }
	  /** @internal */


	  sendFirmware(_data) {
	    throw new Error('Method not implemented.');
	  }

	}

	class GenericBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this._class = exports.ChannelClass.GENERIC;
	    this.name = "Generic";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {};
	  }
	  /** @internal */


	  _initAfterOpen() {
	    this.data = this._initData();

	    switch (this._ch.chDef.uid) {
	      case 437:
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  async _setDefaults() {
	    switch (this._ch.chDef.uid) {
	      case 437:
	        break;

	      default:
	        throw new PhidgetError(exports.ErrorCode.UNSUPPORTED);
	    }
	  }
	  /** @internal */


	  _hasInitialState() {
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {}

	}

	/** @internal */

	class Generic extends GenericBase {
	  /** @internal */
	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      default:
	        super._bridgeInput(bp);

	        break;
	    }
	  }
	  /** @internal */


	  sendChannelPacket(_packetType, _index, _packet) {
	    throw new Error('Method not implemented.');
	  }
	  /** @internal */


	  sendDevicePacket(_packetType, _packet) {
	    throw new Error('Method not implemented.');
	  }
	  /** @internal */


	  sendPacket(_packet) {
	    throw new Error('Method not implemented.');
	  }

	}

	var whitespaces$2 = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
	  '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

	var uncurryThis = functionUncurryThis;
	var requireObjectCoercible = requireObjectCoercible$4;
	var toString = toString$5;
	var whitespaces$1 = whitespaces$2;
	var replace = uncurryThis(''.replace);
	var whitespace = '[' + whitespaces$1 + ']';
	var ltrim = RegExp('^' + whitespace + whitespace + '*');
	var rtrim = RegExp(whitespace + whitespace + '*$');
	var createMethod = function (TYPE) {
	  return function ($this) {
	    var string = toString(requireObjectCoercible($this));
	    if (TYPE & 1) string = replace(string, ltrim, '');
	    if (TYPE & 2) string = replace(string, rtrim, '');
	    return string;
	  };
	};
	var stringTrim = {
	  start: createMethod(1),
	  end: createMethod(2),
	  trim: createMethod(3)
	};

	var PROPER_FUNCTION_NAME = functionName.PROPER;
	var fails = fails$f;
	var whitespaces = whitespaces$2;
	var non = '\u200B\u0085\u180E';
	var stringTrimForced = function (METHOD_NAME) {
	  return fails(function () {
	    return !!whitespaces[METHOD_NAME]()
	      || non[METHOD_NAME]() !== non
	      || (PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME);
	  });
	};

	var $ = _export;
	var $trim = stringTrim.trim;
	var forcedStringTrimMethod = stringTrimForced;
	$({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {
	  trim: function trim() {
	    return $trim(this);
	  }
	});

	var entryVirtual = entryVirtual$4;
	var trim$3 = entryVirtual('String').trim;

	var isPrototypeOf = objectIsPrototypeOf;
	var method = trim$3;
	var StringPrototype = String.prototype;
	var trim$2 = function (it) {
	  var own = it.trim;
	  return typeof it == 'string' || it === StringPrototype
	    || (isPrototypeOf(StringPrototype, it) && own === StringPrototype.trim) ? method : own;
	};

	var parent = trim$2;
	var trim$1 = parent;

	var trim = trim$1;

	class DictionaryBase extends PhidgetChannel {
	  constructor(ch) {
	    super(ch);
	    this.onAdd = null;
	    this.onUpdate = null;
	    this.onRemove = null;
	    this._class = exports.ChannelClass.DICTIONARY;
	    this.name = "Dictionary";
	    this.data = this._initData();
	  }
	  /** @internal */


	  _bridgeInput(bp) {
	    switch (bp.vpkt) {
	      case 123:
	        break;

	      case 131:
	        break;

	      case 129:
	        break;

	      case 127:
	        break;

	      case 132:
	        break;

	      case 130:
	        break;

	      case 125:
	        break;

	      case 124:
	        {
	          if (this._isAttachedDone && this.onAdd) {
	            try {
	              this.onAdd(bp.entries[0].v, bp.entries[1].v);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      case 128:
	        {
	          if (this._isAttachedDone && this.onRemove) {
	            try {
	              this.onRemove(bp.entries[0].v);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      case 126:
	        {
	          if (this._isAttachedDone && this.onUpdate) {
	            try {
	              this.onUpdate(bp.entries[0].v, bp.entries[1].v);
	            } catch (err) {
	              logEventException(err);
	            }
	          }

	          break;
	        }

	      default:
	        throw new PhidgetError(exports.ErrorCode.INVALID_PACKET, "Unsupported bridge packet: 0x" + bp.vpkt.toString(16));
	    }
	  }
	  /** @internal */


	  _initData() {
	    return {};
	  }
	  /** @internal */


	  _initAfterOpen() {
	    throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	  }
	  /** @internal */


	  async _setDefaults() {
	    throw new PhidgetError(exports.ErrorCode.UNEXPECTED);
	  }
	  /** @internal */


	  _hasInitialState() {
	    return true;
	  }
	  /** @internal */


	  _fireInitialEvents() {}
	  /**
	   * Adds a new key value pair to the dictionary. It is an error if the key already exits.
	   * @throws {@link PhidgetError}
	   * @param key - The key to add
	   * @param value - The value to add
	   */


	  async add(key, value) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "s",
	      value: key
	    });
	    bp.set({
	      name: "1",
	      type: "s",
	      value: value
	    });
	    await bp.send(this._ch, 123);
	  }
	  /**
	   * Removes every key from the dictionary
	   * @throws {@link PhidgetError}
	   */


	  async removeAll() {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    await bp.send(this._ch, 131);
	  }
	  /**
	   * Removes the key from the dictionary
	   * @throws {@link PhidgetError}
	   * @param key - The key to remove
	   */


	  async remove(key) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "s",
	      value: key
	    });
	    await bp.send(this._ch, 127);
	  }
	  /**
	   * Sets the value of a key, or creates the key value pair if the key does not already exist.
	   * @throws {@link PhidgetError}
	   * @param key - The key to set
	   * @param value - The value to set
	   */


	  async set(key, value) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "s",
	      value: key
	    });
	    bp.set({
	      name: "1",
	      type: "s",
	      value: value
	    });
	    await bp.send(this._ch, 130);
	  }
	  /**
	   * Updates a key value pair in the dictionary. It is an error if the key does not exist.
	   * @throws {@link PhidgetError}
	   * @param key - The key to update
	   * @param value - The value to set
	   */


	  async update(key, value) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "s",
	      value: key
	    });
	    bp.set({
	      name: "1",
	      type: "s",
	      value: value
	    });
	    await bp.send(this._ch, 125);
	  }

	}

	/** @public */

	class Dictionary extends DictionaryBase {
	  async get(key, def) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "s",
	      value: key
	    });

	    try {
	      const val = await bp.send(this._ch, 129);
	      return val;
	    } catch (err) {
	      if (def !== undefined) return def;
	      if (err instanceof PhidgetError && err.errorCode === exports.ErrorCode.NO_SUCH_ENTITY) return null;
	      throw err;
	    }
	  }

	  async scan(key) {
	    this._assertOpen();

	    const bp = new BridgePacket();
	    bp.set({
	      name: "0",
	      type: "s",
	      value: key !== null && key !== void 0 ? key : ''
	    });
	    const list = await bp.send(this._ch, 132);
	    if (list.length == 0) return [];
	    return trim(list).call(list).split('\n');
	  }

	}

	/** @internal */

	function CreatePhidgetChannel(ch) {
	  switch (ch.class) {
	    case exports.ChannelClass.ACCELEROMETER:
	      return new Accelerometer(ch);

	    case exports.ChannelClass.BLDC_MOTOR:
	      return new BLDCMotor(ch);

	    case exports.ChannelClass.CAPACITIVE_TOUCH:
	      return new CapacitiveTouch(ch);

	    case exports.ChannelClass.CURRENT_INPUT:
	      return new CurrentInput(ch);

	    case exports.ChannelClass.DC_MOTOR:
	      return new DCMotor(ch);

	    case exports.ChannelClass.DICTIONARY:
	      return new Dictionary(ch);

	    case exports.ChannelClass.DIGITAL_INPUT:
	      return new DigitalInput(ch);

	    case exports.ChannelClass.DIGITAL_OUTPUT:
	      return new DigitalOutput(ch);

	    case exports.ChannelClass.DISTANCE_SENSOR:
	      return new DistanceSensor(ch);

	    case exports.ChannelClass.ENCODER:
	      return new Encoder(ch);

	    case exports.ChannelClass.FIRMWARE_UPGRADE:
	      return new FirmwareUpgrade(ch);

	    case exports.ChannelClass.FREQUENCY_COUNTER:
	      return new FrequencyCounter(ch);

	    case exports.ChannelClass.GENERIC:
	      return new Generic(ch);

	    case exports.ChannelClass.GPS:
	      return new GPS(ch);

	    case exports.ChannelClass.GYROSCOPE:
	      return new Gyroscope(ch);

	    case exports.ChannelClass.HUB:
	      return new Hub(ch);

	    case exports.ChannelClass.HUMIDITY_SENSOR:
	      return new HumiditySensor(ch);

	    case exports.ChannelClass.IR:
	      return new IR(ch);

	    case exports.ChannelClass.LCD:
	      return new LCD(ch);

	    case exports.ChannelClass.LIGHT_SENSOR:
	      return new LightSensor(ch);

	    case exports.ChannelClass.MAGNETOMETER:
	      return new Magnetometer(ch);

	    case exports.ChannelClass.MOTOR_POSITION_CONTROLLER:
	      return new MotorPositionController(ch);

	    case exports.ChannelClass.PH_SENSOR:
	      return new PHSensor(ch);

	    case exports.ChannelClass.POWER_GUARD:
	      return new PowerGuard(ch);

	    case exports.ChannelClass.PRESSURE_SENSOR:
	      return new PressureSensor(ch);

	    case exports.ChannelClass.RC_SERVO:
	      return new RCServo(ch);

	    case exports.ChannelClass.RESISTANCE_INPUT:
	      return new ResistanceInput(ch);

	    case exports.ChannelClass.RFID:
	      return new RFID(ch);

	    case exports.ChannelClass.SOUND_SENSOR:
	      return new SoundSensor(ch);

	    case exports.ChannelClass.SPATIAL:
	      return new Spatial(ch);

	    case exports.ChannelClass.STEPPER:
	      return new Stepper(ch);

	    case exports.ChannelClass.TEMPERATURE_SENSOR:
	      return new TemperatureSensor(ch);

	    case exports.ChannelClass.VOLTAGE_INPUT:
	      return new VoltageInput(ch);

	    case exports.ChannelClass.VOLTAGE_OUTPUT:
	      return new VoltageOutput(ch);

	    case exports.ChannelClass.VOLTAGE_RATIO_INPUT:
	      return new VoltageRatioInput(ch);

	    default:
	      throw new Error("Invalid Channel Class");
	  }
	}

	/**
	 * @public
	 */

	class Manager {
	  /**
	   * The Phidget Manager allows tracking of which Phidgets are available to be controlled from the current program.
	   * This is useful for listing all available Phidgets so you can select which ones to use at runtime.
	   *
	   * You do not need to use a Phidget Manager if you know what Phidgets will be required for your application
	   * in advance.
	   *
	   * Phidget channels that become available will each send an Attach event, and Phidgets that are removed
	   * from the system will send corresponding Detach events. If you are using a Phidget Manager, your program
	   * is responsible for keeping track of available Phidgets using these events.
	   *
	   * @param opts - Event callbacks can be specified via this object
	   */
	  constructor(opts) {
	    this.onDeviceAttach = null;
	    this.onDeviceDetach = null;
	    this.onAttach = null;
	    this.onDetach = null;
	    this._isopen = false;

	    if (typeof opts === 'object') {
	      if ('onDeviceAttach' in opts && typeof opts.onDeviceAttach === 'function') this.onDeviceAttach = opts.onDeviceAttach;
	      if ('onDeviceDetach' in opts && typeof opts.onDeviceDetach === 'function') this.onDeviceDetach = opts.onDeviceDetach;
	      if ('onAttach' in opts && typeof opts.onAttach === 'function') this.onAttach = opts.onAttach;
	      if ('onDetach' in opts && typeof opts.onDetach === 'function') this.onDetach = opts.onDetach;
	    }
	  }

	  open() {
	    if (this._isopen) return;
	    Managers.push(this);

	    for (const conn of Connections) {
	      if (this.onDeviceAttach) {
	        for (const d of values(_context = conn._devices).call(_context)) {
	          var _context;

	          const phid = new PhidgetDevice(d);

	          try {
	            this.onDeviceAttach(phid);
	          } catch (err) {
	            logEventException(err);
	          }
	        }
	      }

	      if (this.onAttach) {
	        for (const ch of values(_context2 = conn._channels).call(_context2)) {
	          var _context2;

	          const phid = CreatePhidgetChannel(ch);

	          try {
	            this.onAttach(phid);
	          } catch (err) {
	            logEventException(err);
	          }
	        }
	      }
	    }

	    this._isopen = true;
	  }

	  close() {
	    this._isopen = false;
	    if (Managers.includes(this)) Managers.splice(Managers.indexOf(this), 1);
	  }
	  /** @internal */


	  _deviceAttach(dev) {
	    if (this._isopen && this.onDeviceAttach) {
	      const phdev = new PhidgetDevice(dev);

	      try {
	        this.onDeviceAttach(phdev);
	      } catch (err) {
	        logEventException(err);
	      }
	    }
	  }
	  /** @internal */


	  _deviceDetach(dev) {
	    if (this._isopen && this.onDeviceDetach) {
	      const phdev = new PhidgetDevice(dev);

	      try {
	        this.onDeviceDetach(phdev);
	      } catch (err) {
	        logEventException(err);
	      }
	    }
	  }
	  /** @internal */


	  _channelAttach(ch) {
	    if (this._isopen && this.onAttach) {
	      const phch = CreatePhidgetChannel(ch);

	      try {
	        this.onAttach(phch);
	      } catch (err) {
	        logEventException(err);
	      }
	    }
	  }
	  /** @internal */


	  _channelDetach(ch) {
	    if (this._isopen && this.onDetach) {
	      const phch = CreatePhidgetChannel(ch);

	      try {
	        this.onDetach(phch);
	      } catch (err) {
	        logEventException(err);
	      }
	    }
	  }

	}

	exports.Accelerometer = Accelerometer;
	exports.BLDCMotor = BLDCMotor;
	exports.CapacitiveTouch = CapacitiveTouch;
	exports.Connection = NetworkConnection;
	exports.CurrentInput = CurrentInput;
	exports.DCMotor = DCMotor;
	exports.Dictionary = Dictionary;
	exports.DigitalInput = DigitalInput;
	exports.DigitalOutput = DigitalOutput;
	exports.DistanceSensor = DistanceSensor;
	exports.Encoder = Encoder;
	exports.FirmwareUpgrade = FirmwareUpgrade;
	exports.FrequencyCounter = FrequencyCounter;
	exports.GPS = GPS;
	exports.Generic = Generic;
	exports.Gyroscope = Gyroscope;
	exports.Hub = Hub;
	exports.HumiditySensor = HumiditySensor;
	exports.IR = IR;
	exports.JSLibraryVersion = JSLibraryVersion;
	exports.LCD = LCD;
	exports.LibraryVersion = LibraryVersion;
	exports.LightSensor = LightSensor;
	exports.Log = Log;
	exports.Magnetometer = Magnetometer;
	exports.Manager = Manager;
	exports.MotorPositionController = MotorPositionController;
	exports.NetworkConnection = NetworkConnection;
	exports.PHSensor = PHSensor;
	exports.Phidget = Phidget;
	exports.PhidgetConnection = PhidgetConnection;
	exports.PhidgetError = PhidgetError;
	exports.PowerGuard = PowerGuard;
	exports.PressureSensor = PressureSensor;
	exports.RCServo = RCServo;
	exports.RFID = RFID;
	exports.ResistanceInput = ResistanceInput;
	exports.SoundSensor = SoundSensor;
	exports.Spatial = Spatial;
	exports.Stepper = Stepper;
	exports.TemperatureSensor = TemperatureSensor;
	exports.USBConnection = USBConnection;
	exports.VoltageInput = VoltageInput;
	exports.VoltageOutput = VoltageOutput;
	exports.VoltageRatioInput = VoltageRatioInput;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=phidget22.js.map
